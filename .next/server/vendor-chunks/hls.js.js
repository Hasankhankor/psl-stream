"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/hls.js";
exports.ids = ["vendor-chunks/hls.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/hls.js/dist/hls.mjs":
/*!******************************************!*\
  !*** ./node_modules/hls.js/dist/hls.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbrController: () => (/* binding */ AbrController),\n/* harmony export */   AttrList: () => (/* binding */ AttrList),\n/* harmony export */   AudioStreamController: () => (/* binding */ AudioStreamController),\n/* harmony export */   AudioTrackController: () => (/* binding */ AudioTrackController),\n/* harmony export */   BasePlaylistController: () => (/* binding */ BasePlaylistController),\n/* harmony export */   BaseSegment: () => (/* binding */ BaseSegment),\n/* harmony export */   BaseStreamController: () => (/* binding */ BaseStreamController),\n/* harmony export */   BufferController: () => (/* binding */ BufferController),\n/* harmony export */   CMCDController: () => (/* binding */ CMCDController),\n/* harmony export */   CapLevelController: () => (/* binding */ CapLevelController),\n/* harmony export */   ChunkMetadata: () => (/* binding */ ChunkMetadata),\n/* harmony export */   ContentSteeringController: () => (/* binding */ ContentSteeringController),\n/* harmony export */   DateRange: () => (/* binding */ DateRange),\n/* harmony export */   EMEController: () => (/* binding */ EMEController),\n/* harmony export */   ErrorActionFlags: () => (/* binding */ ErrorActionFlags),\n/* harmony export */   ErrorController: () => (/* binding */ ErrorController),\n/* harmony export */   ErrorDetails: () => (/* binding */ ErrorDetails),\n/* harmony export */   ErrorTypes: () => (/* binding */ ErrorTypes),\n/* harmony export */   Events: () => (/* binding */ Events),\n/* harmony export */   FPSController: () => (/* binding */ FPSController),\n/* harmony export */   Fragment: () => (/* binding */ Fragment),\n/* harmony export */   Hls: () => (/* binding */ Hls),\n/* harmony export */   HlsSkip: () => (/* binding */ HlsSkip),\n/* harmony export */   HlsUrlParameters: () => (/* binding */ HlsUrlParameters),\n/* harmony export */   KeySystemFormats: () => (/* binding */ KeySystemFormats),\n/* harmony export */   KeySystems: () => (/* binding */ KeySystems),\n/* harmony export */   Level: () => (/* binding */ Level),\n/* harmony export */   LevelDetails: () => (/* binding */ LevelDetails),\n/* harmony export */   LevelKey: () => (/* binding */ LevelKey),\n/* harmony export */   LoadStats: () => (/* binding */ LoadStats),\n/* harmony export */   MetadataSchema: () => (/* binding */ MetadataSchema),\n/* harmony export */   NetworkErrorAction: () => (/* binding */ NetworkErrorAction),\n/* harmony export */   Part: () => (/* binding */ Part),\n/* harmony export */   PlaylistLevelType: () => (/* binding */ PlaylistLevelType),\n/* harmony export */   SubtitleStreamController: () => (/* binding */ SubtitleStreamController),\n/* harmony export */   SubtitleTrackController: () => (/* binding */ SubtitleTrackController),\n/* harmony export */   TimelineController: () => (/* binding */ TimelineController),\n/* harmony export */   \"default\": () => (/* binding */ Hls),\n/* harmony export */   getMediaSource: () => (/* binding */ getMediaSource),\n/* harmony export */   isMSESupported: () => (/* binding */ isMSESupported),\n/* harmony export */   isSupported: () => (/* binding */ isSupported)\n/* harmony export */ });\nfunction getDefaultExportFromCjs(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nvar urlToolkit = {\n    exports: {}\n};\n(function(module, exports) {\n    // see https://tools.ietf.org/html/rfc1808\n    (function(root) {\n        var URL_REGEX = /^(?=((?:[a-zA-Z0-9+\\-.]+:)?))\\1(?=((?:\\/\\/[^\\/?#]*)?))\\2(?=((?:(?:[^?#\\/]*\\/)*[^;?#\\/]*)?))\\3((?:;[^?#]*)?)(\\?[^#]*)?(#[^]*)?$/;\n        var FIRST_SEGMENT_REGEX = /^(?=([^\\/?#]*))\\1([^]*)$/;\n        var SLASH_DOT_REGEX = /(?:\\/|^)\\.(?=\\/)/g;\n        var SLASH_DOT_DOT_REGEX = /(?:\\/|^)\\.\\.\\/(?!\\.\\.\\/)[^\\/]*(?=\\/)/g;\n        var URLToolkit = {\n            // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //\n            // E.g\n            // With opts.alwaysNormalize = false (default, spec compliant)\n            // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g\n            // With opts.alwaysNormalize = true (not spec compliant)\n            // http://a.com/b/cd + /e/f/../g => http://a.com/e/g\n            buildAbsoluteURL: function(baseURL, relativeURL, opts) {\n                opts = opts || {};\n                // remove any remaining space and CRLF\n                baseURL = baseURL.trim();\n                relativeURL = relativeURL.trim();\n                if (!relativeURL) {\n                    // 2a) If the embedded URL is entirely empty, it inherits the\n                    // entire base URL (i.e., is set equal to the base URL)\n                    // and we are done.\n                    if (!opts.alwaysNormalize) {\n                        return baseURL;\n                    }\n                    var basePartsForNormalise = URLToolkit.parseURL(baseURL);\n                    if (!basePartsForNormalise) {\n                        throw new Error(\"Error trying to parse base URL.\");\n                    }\n                    basePartsForNormalise.path = URLToolkit.normalizePath(basePartsForNormalise.path);\n                    return URLToolkit.buildURLFromParts(basePartsForNormalise);\n                }\n                var relativeParts = URLToolkit.parseURL(relativeURL);\n                if (!relativeParts) {\n                    throw new Error(\"Error trying to parse relative URL.\");\n                }\n                if (relativeParts.scheme) {\n                    // 2b) If the embedded URL starts with a scheme name, it is\n                    // interpreted as an absolute URL and we are done.\n                    if (!opts.alwaysNormalize) {\n                        return relativeURL;\n                    }\n                    relativeParts.path = URLToolkit.normalizePath(relativeParts.path);\n                    return URLToolkit.buildURLFromParts(relativeParts);\n                }\n                var baseParts = URLToolkit.parseURL(baseURL);\n                if (!baseParts) {\n                    throw new Error(\"Error trying to parse base URL.\");\n                }\n                if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== \"/\") {\n                    // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc\n                    // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'\n                    var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);\n                    baseParts.netLoc = pathParts[1];\n                    baseParts.path = pathParts[2];\n                }\n                if (baseParts.netLoc && !baseParts.path) {\n                    baseParts.path = \"/\";\n                }\n                var builtParts = {\n                    // 2c) Otherwise, the embedded URL inherits the scheme of\n                    // the base URL.\n                    scheme: baseParts.scheme,\n                    netLoc: relativeParts.netLoc,\n                    path: null,\n                    params: relativeParts.params,\n                    query: relativeParts.query,\n                    fragment: relativeParts.fragment\n                };\n                if (!relativeParts.netLoc) {\n                    // 3) If the embedded URL's <net_loc> is non-empty, we skip to\n                    // Step 7.  Otherwise, the embedded URL inherits the <net_loc>\n                    // (if any) of the base URL.\n                    builtParts.netLoc = baseParts.netLoc;\n                    // 4) If the embedded URL path is preceded by a slash \"/\", the\n                    // path is not relative and we skip to Step 7.\n                    if (relativeParts.path[0] !== \"/\") {\n                        if (!relativeParts.path) {\n                            // 5) If the embedded URL path is empty (and not preceded by a\n                            // slash), then the embedded URL inherits the base URL path\n                            builtParts.path = baseParts.path;\n                            // 5a) if the embedded URL's <params> is non-empty, we skip to\n                            // step 7; otherwise, it inherits the <params> of the base\n                            // URL (if any) and\n                            if (!relativeParts.params) {\n                                builtParts.params = baseParts.params;\n                                // 5b) if the embedded URL's <query> is non-empty, we skip to\n                                // step 7; otherwise, it inherits the <query> of the base\n                                // URL (if any) and we skip to step 7.\n                                if (!relativeParts.query) {\n                                    builtParts.query = baseParts.query;\n                                }\n                            }\n                        } else {\n                            // 6) The last segment of the base URL's path (anything\n                            // following the rightmost slash \"/\", or the entire path if no\n                            // slash is present) is removed and the embedded URL's path is\n                            // appended in its place.\n                            var baseURLPath = baseParts.path;\n                            var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf(\"/\") + 1) + relativeParts.path;\n                            builtParts.path = URLToolkit.normalizePath(newPath);\n                        }\n                    }\n                }\n                if (builtParts.path === null) {\n                    builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path;\n                }\n                return URLToolkit.buildURLFromParts(builtParts);\n            },\n            parseURL: function(url) {\n                var parts = URL_REGEX.exec(url);\n                if (!parts) {\n                    return null;\n                }\n                return {\n                    scheme: parts[1] || \"\",\n                    netLoc: parts[2] || \"\",\n                    path: parts[3] || \"\",\n                    params: parts[4] || \"\",\n                    query: parts[5] || \"\",\n                    fragment: parts[6] || \"\"\n                };\n            },\n            normalizePath: function(path) {\n                // The following operations are\n                // then applied, in order, to the new path:\n                // 6a) All occurrences of \"./\", where \".\" is a complete path\n                // segment, are removed.\n                // 6b) If the path ends with \".\" as a complete path segment,\n                // that \".\" is removed.\n                path = path.split(\"\").reverse().join(\"\").replace(SLASH_DOT_REGEX, \"\");\n                // 6c) All occurrences of \"<segment>/../\", where <segment> is a\n                // complete path segment not equal to \"..\", are removed.\n                // Removal of these path segments is performed iteratively,\n                // removing the leftmost matching pattern on each iteration,\n                // until no matching pattern remains.\n                // 6d) If the path ends with \"<segment>/..\", where <segment> is a\n                // complete path segment not equal to \"..\", that\n                // \"<segment>/..\" is removed.\n                while(path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, \"\")).length){}\n                return path.split(\"\").reverse().join(\"\");\n            },\n            buildURLFromParts: function(parts) {\n                return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;\n            }\n        };\n        module.exports = URLToolkit;\n    })();\n})(urlToolkit);\nvar urlToolkitExports = urlToolkit.exports;\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread2(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != typeof t || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != typeof i) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\n// https://caniuse.com/mdn-javascript_builtins_number_isfinite\nconst isFiniteNumber = Number.isFinite || function(value) {\n    return typeof value === \"number\" && isFinite(value);\n};\n// https://caniuse.com/mdn-javascript_builtins_number_issafeinteger\nconst isSafeInteger = Number.isSafeInteger || function(value) {\n    return typeof value === \"number\" && Math.abs(value) <= MAX_SAFE_INTEGER;\n};\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\nlet Events = /*#__PURE__*/ function(Events) {\n    Events[\"MEDIA_ATTACHING\"] = \"hlsMediaAttaching\";\n    Events[\"MEDIA_ATTACHED\"] = \"hlsMediaAttached\";\n    Events[\"MEDIA_DETACHING\"] = \"hlsMediaDetaching\";\n    Events[\"MEDIA_DETACHED\"] = \"hlsMediaDetached\";\n    Events[\"BUFFER_RESET\"] = \"hlsBufferReset\";\n    Events[\"BUFFER_CODECS\"] = \"hlsBufferCodecs\";\n    Events[\"BUFFER_CREATED\"] = \"hlsBufferCreated\";\n    Events[\"BUFFER_APPENDING\"] = \"hlsBufferAppending\";\n    Events[\"BUFFER_APPENDED\"] = \"hlsBufferAppended\";\n    Events[\"BUFFER_EOS\"] = \"hlsBufferEos\";\n    Events[\"BUFFER_FLUSHING\"] = \"hlsBufferFlushing\";\n    Events[\"BUFFER_FLUSHED\"] = \"hlsBufferFlushed\";\n    Events[\"MANIFEST_LOADING\"] = \"hlsManifestLoading\";\n    Events[\"MANIFEST_LOADED\"] = \"hlsManifestLoaded\";\n    Events[\"MANIFEST_PARSED\"] = \"hlsManifestParsed\";\n    Events[\"LEVEL_SWITCHING\"] = \"hlsLevelSwitching\";\n    Events[\"LEVEL_SWITCHED\"] = \"hlsLevelSwitched\";\n    Events[\"LEVEL_LOADING\"] = \"hlsLevelLoading\";\n    Events[\"LEVEL_LOADED\"] = \"hlsLevelLoaded\";\n    Events[\"LEVEL_UPDATED\"] = \"hlsLevelUpdated\";\n    Events[\"LEVEL_PTS_UPDATED\"] = \"hlsLevelPtsUpdated\";\n    Events[\"LEVELS_UPDATED\"] = \"hlsLevelsUpdated\";\n    Events[\"AUDIO_TRACKS_UPDATED\"] = \"hlsAudioTracksUpdated\";\n    Events[\"AUDIO_TRACK_SWITCHING\"] = \"hlsAudioTrackSwitching\";\n    Events[\"AUDIO_TRACK_SWITCHED\"] = \"hlsAudioTrackSwitched\";\n    Events[\"AUDIO_TRACK_LOADING\"] = \"hlsAudioTrackLoading\";\n    Events[\"AUDIO_TRACK_LOADED\"] = \"hlsAudioTrackLoaded\";\n    Events[\"SUBTITLE_TRACKS_UPDATED\"] = \"hlsSubtitleTracksUpdated\";\n    Events[\"SUBTITLE_TRACKS_CLEARED\"] = \"hlsSubtitleTracksCleared\";\n    Events[\"SUBTITLE_TRACK_SWITCH\"] = \"hlsSubtitleTrackSwitch\";\n    Events[\"SUBTITLE_TRACK_LOADING\"] = \"hlsSubtitleTrackLoading\";\n    Events[\"SUBTITLE_TRACK_LOADED\"] = \"hlsSubtitleTrackLoaded\";\n    Events[\"SUBTITLE_FRAG_PROCESSED\"] = \"hlsSubtitleFragProcessed\";\n    Events[\"CUES_PARSED\"] = \"hlsCuesParsed\";\n    Events[\"NON_NATIVE_TEXT_TRACKS_FOUND\"] = \"hlsNonNativeTextTracksFound\";\n    Events[\"INIT_PTS_FOUND\"] = \"hlsInitPtsFound\";\n    Events[\"FRAG_LOADING\"] = \"hlsFragLoading\";\n    Events[\"FRAG_LOAD_EMERGENCY_ABORTED\"] = \"hlsFragLoadEmergencyAborted\";\n    Events[\"FRAG_LOADED\"] = \"hlsFragLoaded\";\n    Events[\"FRAG_DECRYPTED\"] = \"hlsFragDecrypted\";\n    Events[\"FRAG_PARSING_INIT_SEGMENT\"] = \"hlsFragParsingInitSegment\";\n    Events[\"FRAG_PARSING_USERDATA\"] = \"hlsFragParsingUserdata\";\n    Events[\"FRAG_PARSING_METADATA\"] = \"hlsFragParsingMetadata\";\n    Events[\"FRAG_PARSED\"] = \"hlsFragParsed\";\n    Events[\"FRAG_BUFFERED\"] = \"hlsFragBuffered\";\n    Events[\"FRAG_CHANGED\"] = \"hlsFragChanged\";\n    Events[\"FPS_DROP\"] = \"hlsFpsDrop\";\n    Events[\"FPS_DROP_LEVEL_CAPPING\"] = \"hlsFpsDropLevelCapping\";\n    Events[\"MAX_AUTO_LEVEL_UPDATED\"] = \"hlsMaxAutoLevelUpdated\";\n    Events[\"ERROR\"] = \"hlsError\";\n    Events[\"DESTROYING\"] = \"hlsDestroying\";\n    Events[\"KEY_LOADING\"] = \"hlsKeyLoading\";\n    Events[\"KEY_LOADED\"] = \"hlsKeyLoaded\";\n    Events[\"LIVE_BACK_BUFFER_REACHED\"] = \"hlsLiveBackBufferReached\";\n    Events[\"BACK_BUFFER_REACHED\"] = \"hlsBackBufferReached\";\n    Events[\"STEERING_MANIFEST_LOADED\"] = \"hlsSteeringManifestLoaded\";\n    return Events;\n}({});\n/**\n * Defines each Event type and payload by Event name. Used in {@link hls.js#HlsEventEmitter} to strongly type the event listener API.\n */ let ErrorTypes = /*#__PURE__*/ function(ErrorTypes) {\n    ErrorTypes[\"NETWORK_ERROR\"] = \"networkError\";\n    ErrorTypes[\"MEDIA_ERROR\"] = \"mediaError\";\n    ErrorTypes[\"KEY_SYSTEM_ERROR\"] = \"keySystemError\";\n    ErrorTypes[\"MUX_ERROR\"] = \"muxError\";\n    ErrorTypes[\"OTHER_ERROR\"] = \"otherError\";\n    return ErrorTypes;\n}({});\nlet ErrorDetails = /*#__PURE__*/ function(ErrorDetails) {\n    ErrorDetails[\"KEY_SYSTEM_NO_KEYS\"] = \"keySystemNoKeys\";\n    ErrorDetails[\"KEY_SYSTEM_NO_ACCESS\"] = \"keySystemNoAccess\";\n    ErrorDetails[\"KEY_SYSTEM_NO_SESSION\"] = \"keySystemNoSession\";\n    ErrorDetails[\"KEY_SYSTEM_NO_CONFIGURED_LICENSE\"] = \"keySystemNoConfiguredLicense\";\n    ErrorDetails[\"KEY_SYSTEM_LICENSE_REQUEST_FAILED\"] = \"keySystemLicenseRequestFailed\";\n    ErrorDetails[\"KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED\"] = \"keySystemServerCertificateRequestFailed\";\n    ErrorDetails[\"KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED\"] = \"keySystemServerCertificateUpdateFailed\";\n    ErrorDetails[\"KEY_SYSTEM_SESSION_UPDATE_FAILED\"] = \"keySystemSessionUpdateFailed\";\n    ErrorDetails[\"KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED\"] = \"keySystemStatusOutputRestricted\";\n    ErrorDetails[\"KEY_SYSTEM_STATUS_INTERNAL_ERROR\"] = \"keySystemStatusInternalError\";\n    ErrorDetails[\"MANIFEST_LOAD_ERROR\"] = \"manifestLoadError\";\n    ErrorDetails[\"MANIFEST_LOAD_TIMEOUT\"] = \"manifestLoadTimeOut\";\n    ErrorDetails[\"MANIFEST_PARSING_ERROR\"] = \"manifestParsingError\";\n    ErrorDetails[\"MANIFEST_INCOMPATIBLE_CODECS_ERROR\"] = \"manifestIncompatibleCodecsError\";\n    ErrorDetails[\"LEVEL_EMPTY_ERROR\"] = \"levelEmptyError\";\n    ErrorDetails[\"LEVEL_LOAD_ERROR\"] = \"levelLoadError\";\n    ErrorDetails[\"LEVEL_LOAD_TIMEOUT\"] = \"levelLoadTimeOut\";\n    ErrorDetails[\"LEVEL_PARSING_ERROR\"] = \"levelParsingError\";\n    ErrorDetails[\"LEVEL_SWITCH_ERROR\"] = \"levelSwitchError\";\n    ErrorDetails[\"AUDIO_TRACK_LOAD_ERROR\"] = \"audioTrackLoadError\";\n    ErrorDetails[\"AUDIO_TRACK_LOAD_TIMEOUT\"] = \"audioTrackLoadTimeOut\";\n    ErrorDetails[\"SUBTITLE_LOAD_ERROR\"] = \"subtitleTrackLoadError\";\n    ErrorDetails[\"SUBTITLE_TRACK_LOAD_TIMEOUT\"] = \"subtitleTrackLoadTimeOut\";\n    ErrorDetails[\"FRAG_LOAD_ERROR\"] = \"fragLoadError\";\n    ErrorDetails[\"FRAG_LOAD_TIMEOUT\"] = \"fragLoadTimeOut\";\n    ErrorDetails[\"FRAG_DECRYPT_ERROR\"] = \"fragDecryptError\";\n    ErrorDetails[\"FRAG_PARSING_ERROR\"] = \"fragParsingError\";\n    ErrorDetails[\"FRAG_GAP\"] = \"fragGap\";\n    ErrorDetails[\"REMUX_ALLOC_ERROR\"] = \"remuxAllocError\";\n    ErrorDetails[\"KEY_LOAD_ERROR\"] = \"keyLoadError\";\n    ErrorDetails[\"KEY_LOAD_TIMEOUT\"] = \"keyLoadTimeOut\";\n    ErrorDetails[\"BUFFER_ADD_CODEC_ERROR\"] = \"bufferAddCodecError\";\n    ErrorDetails[\"BUFFER_INCOMPATIBLE_CODECS_ERROR\"] = \"bufferIncompatibleCodecsError\";\n    ErrorDetails[\"BUFFER_APPEND_ERROR\"] = \"bufferAppendError\";\n    ErrorDetails[\"BUFFER_APPENDING_ERROR\"] = \"bufferAppendingError\";\n    ErrorDetails[\"BUFFER_STALLED_ERROR\"] = \"bufferStalledError\";\n    ErrorDetails[\"BUFFER_FULL_ERROR\"] = \"bufferFullError\";\n    ErrorDetails[\"BUFFER_SEEK_OVER_HOLE\"] = \"bufferSeekOverHole\";\n    ErrorDetails[\"BUFFER_NUDGE_ON_STALL\"] = \"bufferNudgeOnStall\";\n    ErrorDetails[\"INTERNAL_EXCEPTION\"] = \"internalException\";\n    ErrorDetails[\"INTERNAL_ABORTED\"] = \"aborted\";\n    ErrorDetails[\"UNKNOWN\"] = \"unknown\";\n    return ErrorDetails;\n}({});\nconst noop = function noop() {};\nconst fakeLogger = {\n    trace: noop,\n    debug: noop,\n    log: noop,\n    warn: noop,\n    info: noop,\n    error: noop\n};\nlet exportedLogger = fakeLogger;\n// let lastCallTime;\n// function formatMsgWithTimeInfo(type, msg) {\n//   const now = Date.now();\n//   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';\n//   lastCallTime = now;\n//   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';\n//   return msg;\n// }\nfunction consolePrintFn(type) {\n    const func = self.console[type];\n    if (func) {\n        return func.bind(self.console, `[${type}] >`);\n    }\n    return noop;\n}\nfunction exportLoggerFunctions(debugConfig, ...functions) {\n    functions.forEach(function(type) {\n        exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);\n    });\n}\nfunction enableLogs(debugConfig, id) {\n    // check that console is available\n    if (typeof console === \"object\" && debugConfig === true || typeof debugConfig === \"object\") {\n        exportLoggerFunctions(debugConfig, // Remove out from list here to hard-disable a log-level\n        // 'trace',\n        \"debug\", \"log\", \"info\", \"warn\", \"error\");\n        // Some browsers don't allow to use bind on console object anyway\n        // fallback to default if needed\n        try {\n            exportedLogger.log(`Debug logs enabled for \"${id}\" in hls.js version ${\"1.5.6\"}`);\n        } catch (e) {\n            exportedLogger = fakeLogger;\n        }\n    } else {\n        exportedLogger = fakeLogger;\n    }\n}\nconst logger = exportedLogger;\nconst DECIMAL_RESOLUTION_REGEX = /^(\\d+)x(\\d+)$/;\nconst ATTR_LIST_REGEX = /(.+?)=(\".*?\"|.*?)(?:,|$)/g;\n// adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js\nclass AttrList {\n    constructor(attrs){\n        if (typeof attrs === \"string\") {\n            attrs = AttrList.parseAttrList(attrs);\n        }\n        _extends(this, attrs);\n    }\n    get clientAttrs() {\n        return Object.keys(this).filter((attr)=>attr.substring(0, 2) === \"X-\");\n    }\n    decimalInteger(attrName) {\n        const intValue = parseInt(this[attrName], 10);\n        if (intValue > Number.MAX_SAFE_INTEGER) {\n            return Infinity;\n        }\n        return intValue;\n    }\n    hexadecimalInteger(attrName) {\n        if (this[attrName]) {\n            let stringValue = (this[attrName] || \"0x\").slice(2);\n            stringValue = (stringValue.length & 1 ? \"0\" : \"\") + stringValue;\n            const value = new Uint8Array(stringValue.length / 2);\n            for(let i = 0; i < stringValue.length / 2; i++){\n                value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);\n            }\n            return value;\n        } else {\n            return null;\n        }\n    }\n    hexadecimalIntegerAsNumber(attrName) {\n        const intValue = parseInt(this[attrName], 16);\n        if (intValue > Number.MAX_SAFE_INTEGER) {\n            return Infinity;\n        }\n        return intValue;\n    }\n    decimalFloatingPoint(attrName) {\n        return parseFloat(this[attrName]);\n    }\n    optionalFloat(attrName, defaultValue) {\n        const value = this[attrName];\n        return value ? parseFloat(value) : defaultValue;\n    }\n    enumeratedString(attrName) {\n        return this[attrName];\n    }\n    bool(attrName) {\n        return this[attrName] === \"YES\";\n    }\n    decimalResolution(attrName) {\n        const res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);\n        if (res === null) {\n            return undefined;\n        }\n        return {\n            width: parseInt(res[1], 10),\n            height: parseInt(res[2], 10)\n        };\n    }\n    static parseAttrList(input) {\n        let match;\n        const attrs = {};\n        const quote = '\"';\n        ATTR_LIST_REGEX.lastIndex = 0;\n        while((match = ATTR_LIST_REGEX.exec(input)) !== null){\n            let value = match[2];\n            if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {\n                value = value.slice(1, -1);\n            }\n            const name = match[1].trim();\n            attrs[name] = value;\n        }\n        return attrs;\n    }\n}\n// Avoid exporting const enum so that these values can be inlined\nfunction isDateRangeCueAttribute(attrName) {\n    return attrName !== \"ID\" && attrName !== \"CLASS\" && attrName !== \"START-DATE\" && attrName !== \"DURATION\" && attrName !== \"END-DATE\" && attrName !== \"END-ON-NEXT\";\n}\nfunction isSCTE35Attribute(attrName) {\n    return attrName === \"SCTE35-OUT\" || attrName === \"SCTE35-IN\";\n}\nclass DateRange {\n    constructor(dateRangeAttr, dateRangeWithSameId){\n        this.attr = void 0;\n        this._startDate = void 0;\n        this._endDate = void 0;\n        this._badValueForSameId = void 0;\n        if (dateRangeWithSameId) {\n            const previousAttr = dateRangeWithSameId.attr;\n            for(const key in previousAttr){\n                if (Object.prototype.hasOwnProperty.call(dateRangeAttr, key) && dateRangeAttr[key] !== previousAttr[key]) {\n                    logger.warn(`DATERANGE tag attribute: \"${key}\" does not match for tags with ID: \"${dateRangeAttr.ID}\"`);\n                    this._badValueForSameId = key;\n                    break;\n                }\n            }\n            // Merge DateRange tags with the same ID\n            dateRangeAttr = _extends(new AttrList({}), previousAttr, dateRangeAttr);\n        }\n        this.attr = dateRangeAttr;\n        this._startDate = new Date(dateRangeAttr[\"START-DATE\"]);\n        if (\"END-DATE\" in this.attr) {\n            const endDate = new Date(this.attr[\"END-DATE\"]);\n            if (isFiniteNumber(endDate.getTime())) {\n                this._endDate = endDate;\n            }\n        }\n    }\n    get id() {\n        return this.attr.ID;\n    }\n    get class() {\n        return this.attr.CLASS;\n    }\n    get startDate() {\n        return this._startDate;\n    }\n    get endDate() {\n        if (this._endDate) {\n            return this._endDate;\n        }\n        const duration = this.duration;\n        if (duration !== null) {\n            return new Date(this._startDate.getTime() + duration * 1000);\n        }\n        return null;\n    }\n    get duration() {\n        if (\"DURATION\" in this.attr) {\n            const duration = this.attr.decimalFloatingPoint(\"DURATION\");\n            if (isFiniteNumber(duration)) {\n                return duration;\n            }\n        } else if (this._endDate) {\n            return (this._endDate.getTime() - this._startDate.getTime()) / 1000;\n        }\n        return null;\n    }\n    get plannedDuration() {\n        if (\"PLANNED-DURATION\" in this.attr) {\n            return this.attr.decimalFloatingPoint(\"PLANNED-DURATION\");\n        }\n        return null;\n    }\n    get endOnNext() {\n        return this.attr.bool(\"END-ON-NEXT\");\n    }\n    get isValid() {\n        return !!this.id && !this._badValueForSameId && isFiniteNumber(this.startDate.getTime()) && (this.duration === null || this.duration >= 0) && (!this.endOnNext || !!this.class);\n    }\n}\nclass LoadStats {\n    constructor(){\n        this.aborted = false;\n        this.loaded = 0;\n        this.retry = 0;\n        this.total = 0;\n        this.chunkCount = 0;\n        this.bwEstimate = 0;\n        this.loading = {\n            start: 0,\n            first: 0,\n            end: 0\n        };\n        this.parsing = {\n            start: 0,\n            end: 0\n        };\n        this.buffering = {\n            start: 0,\n            first: 0,\n            end: 0\n        };\n    }\n}\nvar ElementaryStreamTypes = {\n    AUDIO: \"audio\",\n    VIDEO: \"video\",\n    AUDIOVIDEO: \"audiovideo\"\n};\nclass BaseSegment {\n    constructor(baseurl){\n        this._byteRange = null;\n        this._url = null;\n        // baseurl is the URL to the playlist\n        this.baseurl = void 0;\n        // relurl is the portion of the URL that comes from inside the playlist.\n        this.relurl = void 0;\n        // Holds the types of data this fragment supports\n        this.elementaryStreams = {\n            [ElementaryStreamTypes.AUDIO]: null,\n            [ElementaryStreamTypes.VIDEO]: null,\n            [ElementaryStreamTypes.AUDIOVIDEO]: null\n        };\n        this.baseurl = baseurl;\n    }\n    // setByteRange converts a EXT-X-BYTERANGE attribute into a two element array\n    setByteRange(value, previous) {\n        const params = value.split(\"@\", 2);\n        let start;\n        if (params.length === 1) {\n            start = (previous == null ? void 0 : previous.byteRangeEndOffset) || 0;\n        } else {\n            start = parseInt(params[1]);\n        }\n        this._byteRange = [\n            start,\n            parseInt(params[0]) + start\n        ];\n    }\n    get byteRange() {\n        if (!this._byteRange) {\n            return [];\n        }\n        return this._byteRange;\n    }\n    get byteRangeStartOffset() {\n        return this.byteRange[0];\n    }\n    get byteRangeEndOffset() {\n        return this.byteRange[1];\n    }\n    get url() {\n        if (!this._url && this.baseurl && this.relurl) {\n            this._url = urlToolkitExports.buildAbsoluteURL(this.baseurl, this.relurl, {\n                alwaysNormalize: true\n            });\n        }\n        return this._url || \"\";\n    }\n    set url(value) {\n        this._url = value;\n    }\n}\n/**\n * Object representing parsed data from an HLS Segment. Found in {@link hls.js#LevelDetails.fragments}.\n */ class Fragment extends BaseSegment {\n    constructor(type, baseurl){\n        super(baseurl);\n        this._decryptdata = null;\n        this.rawProgramDateTime = null;\n        this.programDateTime = null;\n        this.tagList = [];\n        // EXTINF has to be present for a m3u8 to be considered valid\n        this.duration = 0;\n        // sn notates the sequence number for a segment, and if set to a string can be 'initSegment'\n        this.sn = 0;\n        // levelkeys are the EXT-X-KEY tags that apply to this segment for decryption\n        // core difference from the private field _decryptdata is the lack of the initialized IV\n        // _decryptdata will set the IV for this segment based on the segment number in the fragment\n        this.levelkeys = void 0;\n        // A string representing the fragment type\n        this.type = void 0;\n        // A reference to the loader. Set while the fragment is loading, and removed afterwards. Used to abort fragment loading\n        this.loader = null;\n        // A reference to the key loader. Set while the key is loading, and removed afterwards. Used to abort key loading\n        this.keyLoader = null;\n        // The level/track index to which the fragment belongs\n        this.level = -1;\n        // The continuity counter of the fragment\n        this.cc = 0;\n        // The starting Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.\n        this.startPTS = void 0;\n        // The ending Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.\n        this.endPTS = void 0;\n        // The starting Decode Time Stamp (DTS) of the fragment. Set after transmux complete.\n        this.startDTS = void 0;\n        // The ending Decode Time Stamp (DTS) of the fragment. Set after transmux complete.\n        this.endDTS = void 0;\n        // The start time of the fragment, as listed in the manifest. Updated after transmux complete.\n        this.start = 0;\n        // Set by `updateFragPTSDTS` in level-helper\n        this.deltaPTS = void 0;\n        // The maximum starting Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.\n        this.maxStartPTS = void 0;\n        // The minimum ending Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.\n        this.minEndPTS = void 0;\n        // Load/parse timing information\n        this.stats = new LoadStats();\n        // Init Segment bytes (unset for media segments)\n        this.data = void 0;\n        // A flag indicating whether the segment was downloaded in order to test bitrate, and was not buffered\n        this.bitrateTest = false;\n        // #EXTINF  segment title\n        this.title = null;\n        // The Media Initialization Section for this segment\n        this.initSegment = null;\n        // Fragment is the last fragment in the media playlist\n        this.endList = void 0;\n        // Fragment is marked by an EXT-X-GAP tag indicating that it does not contain media data and should not be loaded\n        this.gap = void 0;\n        // Deprecated\n        this.urlId = 0;\n        this.type = type;\n    }\n    get decryptdata() {\n        const { levelkeys } = this;\n        if (!levelkeys && !this._decryptdata) {\n            return null;\n        }\n        if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {\n            const key = this.levelkeys.identity;\n            if (key) {\n                this._decryptdata = key.getDecryptData(this.sn);\n            } else {\n                const keyFormats = Object.keys(this.levelkeys);\n                if (keyFormats.length === 1) {\n                    return this._decryptdata = this.levelkeys[keyFormats[0]].getDecryptData(this.sn);\n                }\n            }\n        }\n        return this._decryptdata;\n    }\n    get end() {\n        return this.start + this.duration;\n    }\n    get endProgramDateTime() {\n        if (this.programDateTime === null) {\n            return null;\n        }\n        if (!isFiniteNumber(this.programDateTime)) {\n            return null;\n        }\n        const duration = !isFiniteNumber(this.duration) ? 0 : this.duration;\n        return this.programDateTime + duration * 1000;\n    }\n    get encrypted() {\n        var _this$_decryptdata;\n        // At the m3u8-parser level we need to add support for manifest signalled keyformats\n        // when we want the fragment to start reporting that it is encrypted.\n        // Currently, keyFormat will only be set for identity keys\n        if ((_this$_decryptdata = this._decryptdata) != null && _this$_decryptdata.encrypted) {\n            return true;\n        } else if (this.levelkeys) {\n            const keyFormats = Object.keys(this.levelkeys);\n            const len = keyFormats.length;\n            if (len > 1 || len === 1 && this.levelkeys[keyFormats[0]].encrypted) {\n                return true;\n            }\n        }\n        return false;\n    }\n    setKeyFormat(keyFormat) {\n        if (this.levelkeys) {\n            const key = this.levelkeys[keyFormat];\n            if (key && !this._decryptdata) {\n                this._decryptdata = key.getDecryptData(this.sn);\n            }\n        }\n    }\n    abortRequests() {\n        var _this$loader, _this$keyLoader;\n        (_this$loader = this.loader) == null ? void 0 : _this$loader.abort();\n        (_this$keyLoader = this.keyLoader) == null ? void 0 : _this$keyLoader.abort();\n    }\n    setElementaryStreamInfo(type, startPTS, endPTS, startDTS, endDTS, partial = false) {\n        const { elementaryStreams } = this;\n        const info = elementaryStreams[type];\n        if (!info) {\n            elementaryStreams[type] = {\n                startPTS,\n                endPTS,\n                startDTS,\n                endDTS,\n                partial\n            };\n            return;\n        }\n        info.startPTS = Math.min(info.startPTS, startPTS);\n        info.endPTS = Math.max(info.endPTS, endPTS);\n        info.startDTS = Math.min(info.startDTS, startDTS);\n        info.endDTS = Math.max(info.endDTS, endDTS);\n    }\n    clearElementaryStreamInfo() {\n        const { elementaryStreams } = this;\n        elementaryStreams[ElementaryStreamTypes.AUDIO] = null;\n        elementaryStreams[ElementaryStreamTypes.VIDEO] = null;\n        elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO] = null;\n    }\n}\n/**\n * Object representing parsed data from an HLS Partial Segment. Found in {@link hls.js#LevelDetails.partList}.\n */ class Part extends BaseSegment {\n    constructor(partAttrs, frag, baseurl, index, previous){\n        super(baseurl);\n        this.fragOffset = 0;\n        this.duration = 0;\n        this.gap = false;\n        this.independent = false;\n        this.relurl = void 0;\n        this.fragment = void 0;\n        this.index = void 0;\n        this.stats = new LoadStats();\n        this.duration = partAttrs.decimalFloatingPoint(\"DURATION\");\n        this.gap = partAttrs.bool(\"GAP\");\n        this.independent = partAttrs.bool(\"INDEPENDENT\");\n        this.relurl = partAttrs.enumeratedString(\"URI\");\n        this.fragment = frag;\n        this.index = index;\n        const byteRange = partAttrs.enumeratedString(\"BYTERANGE\");\n        if (byteRange) {\n            this.setByteRange(byteRange, previous);\n        }\n        if (previous) {\n            this.fragOffset = previous.fragOffset + previous.duration;\n        }\n    }\n    get start() {\n        return this.fragment.start + this.fragOffset;\n    }\n    get end() {\n        return this.start + this.duration;\n    }\n    get loaded() {\n        const { elementaryStreams } = this;\n        return !!(elementaryStreams.audio || elementaryStreams.video || elementaryStreams.audiovideo);\n    }\n}\nconst DEFAULT_TARGET_DURATION = 10;\n/**\n * Object representing parsed data from an HLS Media Playlist. Found in {@link hls.js#Level.details}.\n */ class LevelDetails {\n    constructor(baseUrl){\n        this.PTSKnown = false;\n        this.alignedSliding = false;\n        this.averagetargetduration = void 0;\n        this.endCC = 0;\n        this.endSN = 0;\n        this.fragments = void 0;\n        this.fragmentHint = void 0;\n        this.partList = null;\n        this.dateRanges = void 0;\n        this.live = true;\n        this.ageHeader = 0;\n        this.advancedDateTime = void 0;\n        this.updated = true;\n        this.advanced = true;\n        this.availabilityDelay = void 0;\n        // Manifest reload synchronization\n        this.misses = 0;\n        this.startCC = 0;\n        this.startSN = 0;\n        this.startTimeOffset = null;\n        this.targetduration = 0;\n        this.totalduration = 0;\n        this.type = null;\n        this.url = void 0;\n        this.m3u8 = \"\";\n        this.version = null;\n        this.canBlockReload = false;\n        this.canSkipUntil = 0;\n        this.canSkipDateRanges = false;\n        this.skippedSegments = 0;\n        this.recentlyRemovedDateranges = void 0;\n        this.partHoldBack = 0;\n        this.holdBack = 0;\n        this.partTarget = 0;\n        this.preloadHint = void 0;\n        this.renditionReports = void 0;\n        this.tuneInGoal = 0;\n        this.deltaUpdateFailed = void 0;\n        this.driftStartTime = 0;\n        this.driftEndTime = 0;\n        this.driftStart = 0;\n        this.driftEnd = 0;\n        this.encryptedFragments = void 0;\n        this.playlistParsingError = null;\n        this.variableList = null;\n        this.hasVariableRefs = false;\n        this.fragments = [];\n        this.encryptedFragments = [];\n        this.dateRanges = {};\n        this.url = baseUrl;\n    }\n    reloaded(previous) {\n        if (!previous) {\n            this.advanced = true;\n            this.updated = true;\n            return;\n        }\n        const partSnDiff = this.lastPartSn - previous.lastPartSn;\n        const partIndexDiff = this.lastPartIndex - previous.lastPartIndex;\n        this.updated = this.endSN !== previous.endSN || !!partIndexDiff || !!partSnDiff || !this.live;\n        this.advanced = this.endSN > previous.endSN || partSnDiff > 0 || partSnDiff === 0 && partIndexDiff > 0;\n        if (this.updated || this.advanced) {\n            this.misses = Math.floor(previous.misses * 0.6);\n        } else {\n            this.misses = previous.misses + 1;\n        }\n        this.availabilityDelay = previous.availabilityDelay;\n    }\n    get hasProgramDateTime() {\n        if (this.fragments.length) {\n            return isFiniteNumber(this.fragments[this.fragments.length - 1].programDateTime);\n        }\n        return false;\n    }\n    get levelTargetDuration() {\n        return this.averagetargetduration || this.targetduration || DEFAULT_TARGET_DURATION;\n    }\n    get drift() {\n        const runTime = this.driftEndTime - this.driftStartTime;\n        if (runTime > 0) {\n            const runDuration = this.driftEnd - this.driftStart;\n            return runDuration * 1000 / runTime;\n        }\n        return 1;\n    }\n    get edge() {\n        return this.partEnd || this.fragmentEnd;\n    }\n    get partEnd() {\n        var _this$partList;\n        if ((_this$partList = this.partList) != null && _this$partList.length) {\n            return this.partList[this.partList.length - 1].end;\n        }\n        return this.fragmentEnd;\n    }\n    get fragmentEnd() {\n        var _this$fragments;\n        if ((_this$fragments = this.fragments) != null && _this$fragments.length) {\n            return this.fragments[this.fragments.length - 1].end;\n        }\n        return 0;\n    }\n    get age() {\n        if (this.advancedDateTime) {\n            return Math.max(Date.now() - this.advancedDateTime, 0) / 1000;\n        }\n        return 0;\n    }\n    get lastPartIndex() {\n        var _this$partList2;\n        if ((_this$partList2 = this.partList) != null && _this$partList2.length) {\n            return this.partList[this.partList.length - 1].index;\n        }\n        return -1;\n    }\n    get lastPartSn() {\n        var _this$partList3;\n        if ((_this$partList3 = this.partList) != null && _this$partList3.length) {\n            return this.partList[this.partList.length - 1].fragment.sn;\n        }\n        return this.endSN;\n    }\n}\nfunction base64Decode(base64encodedStr) {\n    return Uint8Array.from(atob(base64encodedStr), (c)=>c.charCodeAt(0));\n}\nfunction getKeyIdBytes(str) {\n    const keyIdbytes = strToUtf8array(str).subarray(0, 16);\n    const paddedkeyIdbytes = new Uint8Array(16);\n    paddedkeyIdbytes.set(keyIdbytes, 16 - keyIdbytes.length);\n    return paddedkeyIdbytes;\n}\nfunction changeEndianness(keyId) {\n    const swap = function swap(array, from, to) {\n        const cur = array[from];\n        array[from] = array[to];\n        array[to] = cur;\n    };\n    swap(keyId, 0, 3);\n    swap(keyId, 1, 2);\n    swap(keyId, 4, 5);\n    swap(keyId, 6, 7);\n}\nfunction convertDataUriToArrayBytes(uri) {\n    // data:[<media type][;attribute=value][;base64],<data>\n    const colonsplit = uri.split(\":\");\n    let keydata = null;\n    if (colonsplit[0] === \"data\" && colonsplit.length === 2) {\n        const semicolonsplit = colonsplit[1].split(\";\");\n        const commasplit = semicolonsplit[semicolonsplit.length - 1].split(\",\");\n        if (commasplit.length === 2) {\n            const isbase64 = commasplit[0] === \"base64\";\n            const data = commasplit[1];\n            if (isbase64) {\n                semicolonsplit.splice(-1, 1); // remove from processing\n                keydata = base64Decode(data);\n            } else {\n                keydata = getKeyIdBytes(data);\n            }\n        }\n    }\n    return keydata;\n}\nfunction strToUtf8array(str) {\n    return Uint8Array.from(unescape(encodeURIComponent(str)), (c)=>c.charCodeAt(0));\n}\n/** returns `undefined` is `self` is missing, e.g. in node */ const optionalSelf = typeof self !== \"undefined\" ? self : undefined;\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess\n */ var KeySystems = {\n    CLEARKEY: \"org.w3.clearkey\",\n    FAIRPLAY: \"com.apple.fps\",\n    PLAYREADY: \"com.microsoft.playready\",\n    WIDEVINE: \"com.widevine.alpha\"\n};\n// Playlist #EXT-X-KEY KEYFORMAT values\nvar KeySystemFormats = {\n    CLEARKEY: \"org.w3.clearkey\",\n    FAIRPLAY: \"com.apple.streamingkeydelivery\",\n    PLAYREADY: \"com.microsoft.playready\",\n    WIDEVINE: \"urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed\"\n};\nfunction keySystemFormatToKeySystemDomain(format) {\n    switch(format){\n        case KeySystemFormats.FAIRPLAY:\n            return KeySystems.FAIRPLAY;\n        case KeySystemFormats.PLAYREADY:\n            return KeySystems.PLAYREADY;\n        case KeySystemFormats.WIDEVINE:\n            return KeySystems.WIDEVINE;\n        case KeySystemFormats.CLEARKEY:\n            return KeySystems.CLEARKEY;\n    }\n}\n// System IDs for which we can extract a key ID from \"encrypted\" event PSSH\nvar KeySystemIds = {\n    WIDEVINE: \"edef8ba979d64acea3c827dcd51d21ed\"\n};\nfunction keySystemIdToKeySystemDomain(systemId) {\n    if (systemId === KeySystemIds.WIDEVINE) {\n        return KeySystems.WIDEVINE;\n    // } else if (systemId === KeySystemIds.PLAYREADY) {\n    //   return KeySystems.PLAYREADY;\n    // } else if (systemId === KeySystemIds.CENC || systemId === KeySystemIds.CLEARKEY) {\n    //   return KeySystems.CLEARKEY;\n    }\n}\nfunction keySystemDomainToKeySystemFormat(keySystem) {\n    switch(keySystem){\n        case KeySystems.FAIRPLAY:\n            return KeySystemFormats.FAIRPLAY;\n        case KeySystems.PLAYREADY:\n            return KeySystemFormats.PLAYREADY;\n        case KeySystems.WIDEVINE:\n            return KeySystemFormats.WIDEVINE;\n        case KeySystems.CLEARKEY:\n            return KeySystemFormats.CLEARKEY;\n    }\n}\nfunction getKeySystemsForConfig(config) {\n    const { drmSystems, widevineLicenseUrl } = config;\n    const keySystemsToAttempt = drmSystems ? [\n        KeySystems.FAIRPLAY,\n        KeySystems.WIDEVINE,\n        KeySystems.PLAYREADY,\n        KeySystems.CLEARKEY\n    ].filter((keySystem)=>!!drmSystems[keySystem]) : [];\n    if (!keySystemsToAttempt[KeySystems.WIDEVINE] && widevineLicenseUrl) {\n        keySystemsToAttempt.push(KeySystems.WIDEVINE);\n    }\n    return keySystemsToAttempt;\n}\nconst requestMediaKeySystemAccess = function(_optionalSelf$navigat) {\n    if (optionalSelf != null && (_optionalSelf$navigat = optionalSelf.navigator) != null && _optionalSelf$navigat.requestMediaKeySystemAccess) {\n        return self.navigator.requestMediaKeySystemAccess.bind(self.navigator);\n    } else {\n        return null;\n    }\n}();\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/MediaKeySystemConfiguration\n */ function getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, drmSystemOptions) {\n    let initDataTypes;\n    switch(keySystem){\n        case KeySystems.FAIRPLAY:\n            initDataTypes = [\n                \"cenc\",\n                \"sinf\"\n            ];\n            break;\n        case KeySystems.WIDEVINE:\n        case KeySystems.PLAYREADY:\n            initDataTypes = [\n                \"cenc\"\n            ];\n            break;\n        case KeySystems.CLEARKEY:\n            initDataTypes = [\n                \"cenc\",\n                \"keyids\"\n            ];\n            break;\n        default:\n            throw new Error(`Unknown key-system: ${keySystem}`);\n    }\n    return createMediaKeySystemConfigurations(initDataTypes, audioCodecs, videoCodecs, drmSystemOptions);\n}\nfunction createMediaKeySystemConfigurations(initDataTypes, audioCodecs, videoCodecs, drmSystemOptions) {\n    const baseConfig = {\n        initDataTypes: initDataTypes,\n        persistentState: drmSystemOptions.persistentState || \"optional\",\n        distinctiveIdentifier: drmSystemOptions.distinctiveIdentifier || \"optional\",\n        sessionTypes: drmSystemOptions.sessionTypes || [\n            drmSystemOptions.sessionType || \"temporary\"\n        ],\n        audioCapabilities: audioCodecs.map((codec)=>({\n                contentType: `audio/mp4; codecs=\"${codec}\"`,\n                robustness: drmSystemOptions.audioRobustness || \"\",\n                encryptionScheme: drmSystemOptions.audioEncryptionScheme || null\n            })),\n        videoCapabilities: videoCodecs.map((codec)=>({\n                contentType: `video/mp4; codecs=\"${codec}\"`,\n                robustness: drmSystemOptions.videoRobustness || \"\",\n                encryptionScheme: drmSystemOptions.videoEncryptionScheme || null\n            }))\n    };\n    return [\n        baseConfig\n    ];\n}\nfunction sliceUint8(array, start, end) {\n    // @ts-expect-error This polyfills IE11 usage of Uint8Array slice.\n    // It always exists in the TypeScript definition so fails, but it fails at runtime on IE11.\n    return Uint8Array.prototype.slice ? array.slice(start, end) : new Uint8Array(Array.prototype.slice.call(array, start, end));\n}\n// breaking up those two types in order to clarify what is happening in the decoding path.\n/**\n * Returns true if an ID3 header can be found at offset in data\n * @param data - The data to search\n * @param offset - The offset at which to start searching\n */ const isHeader$2 = (data, offset)=>{\n    /*\n   * http://id3.org/id3v2.3.0\n   * [0]     = 'I'\n   * [1]     = 'D'\n   * [2]     = '3'\n   * [3,4]   = {Version}\n   * [5]     = {Flags}\n   * [6-9]   = {ID3 Size}\n   *\n   * An ID3v2 tag can be detected with the following pattern:\n   *  $49 44 33 yy yy xx zz zz zz zz\n   * Where yy is less than $FF, xx is the 'flags' byte and zz is less than $80\n   */ if (offset + 10 <= data.length) {\n        // look for 'ID3' identifier\n        if (data[offset] === 0x49 && data[offset + 1] === 0x44 && data[offset + 2] === 0x33) {\n            // check version is within range\n            if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\n                // check size is within range\n                if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n};\n/**\n * Returns true if an ID3 footer can be found at offset in data\n * @param data - The data to search\n * @param offset - The offset at which to start searching\n */ const isFooter = (data, offset)=>{\n    /*\n   * The footer is a copy of the header, but with a different identifier\n   */ if (offset + 10 <= data.length) {\n        // look for '3DI' identifier\n        if (data[offset] === 0x33 && data[offset + 1] === 0x44 && data[offset + 2] === 0x49) {\n            // check version is within range\n            if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\n                // check size is within range\n                if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n};\n/**\n * Returns any adjacent ID3 tags found in data starting at offset, as one block of data\n * @param data - The data to search in\n * @param offset - The offset at which to start searching\n * @returns the block of data containing any ID3 tags found\n * or *undefined* if no header is found at the starting offset\n */ const getID3Data = (data, offset)=>{\n    const front = offset;\n    let length = 0;\n    while(isHeader$2(data, offset)){\n        // ID3 header is 10 bytes\n        length += 10;\n        const size = readSize(data, offset + 6);\n        length += size;\n        if (isFooter(data, offset + 10)) {\n            // ID3 footer is 10 bytes\n            length += 10;\n        }\n        offset += length;\n    }\n    if (length > 0) {\n        return data.subarray(front, front + length);\n    }\n    return undefined;\n};\nconst readSize = (data, offset)=>{\n    let size = 0;\n    size = (data[offset] & 0x7f) << 21;\n    size |= (data[offset + 1] & 0x7f) << 14;\n    size |= (data[offset + 2] & 0x7f) << 7;\n    size |= data[offset + 3] & 0x7f;\n    return size;\n};\nconst canParse$2 = (data, offset)=>{\n    return isHeader$2(data, offset) && readSize(data, offset + 6) + 10 <= data.length - offset;\n};\n/**\n * Searches for the Elementary Stream timestamp found in the ID3 data chunk\n * @param data - Block of data containing one or more ID3 tags\n */ const getTimeStamp = (data)=>{\n    const frames = getID3Frames(data);\n    for(let i = 0; i < frames.length; i++){\n        const frame = frames[i];\n        if (isTimeStampFrame(frame)) {\n            return readTimeStamp(frame);\n        }\n    }\n    return undefined;\n};\n/**\n * Returns true if the ID3 frame is an Elementary Stream timestamp frame\n */ const isTimeStampFrame = (frame)=>{\n    return frame && frame.key === \"PRIV\" && frame.info === \"com.apple.streaming.transportStreamTimestamp\";\n};\nconst getFrameData = (data)=>{\n    /*\n  Frame ID       $xx xx xx xx (four characters)\n  Size           $xx xx xx xx\n  Flags          $xx xx\n  */ const type = String.fromCharCode(data[0], data[1], data[2], data[3]);\n    const size = readSize(data, 4);\n    // skip frame id, size, and flags\n    const offset = 10;\n    return {\n        type,\n        size,\n        data: data.subarray(offset, offset + size)\n    };\n};\n/**\n * Returns an array of ID3 frames found in all the ID3 tags in the id3Data\n * @param id3Data - The ID3 data containing one or more ID3 tags\n */ const getID3Frames = (id3Data)=>{\n    let offset = 0;\n    const frames = [];\n    while(isHeader$2(id3Data, offset)){\n        const size = readSize(id3Data, offset + 6);\n        // skip past ID3 header\n        offset += 10;\n        const end = offset + size;\n        // loop through frames in the ID3 tag\n        while(offset + 8 < end){\n            const frameData = getFrameData(id3Data.subarray(offset));\n            const frame = decodeFrame(frameData);\n            if (frame) {\n                frames.push(frame);\n            }\n            // skip frame header and frame data\n            offset += frameData.size + 10;\n        }\n        if (isFooter(id3Data, offset)) {\n            offset += 10;\n        }\n    }\n    return frames;\n};\nconst decodeFrame = (frame)=>{\n    if (frame.type === \"PRIV\") {\n        return decodePrivFrame(frame);\n    } else if (frame.type[0] === \"W\") {\n        return decodeURLFrame(frame);\n    }\n    return decodeTextFrame(frame);\n};\nconst decodePrivFrame = (frame)=>{\n    /*\n  Format: <text string>\\0<binary data>\n  */ if (frame.size < 2) {\n        return undefined;\n    }\n    const owner = utf8ArrayToStr(frame.data, true);\n    const privateData = new Uint8Array(frame.data.subarray(owner.length + 1));\n    return {\n        key: frame.type,\n        info: owner,\n        data: privateData.buffer\n    };\n};\nconst decodeTextFrame = (frame)=>{\n    if (frame.size < 2) {\n        return undefined;\n    }\n    if (frame.type === \"TXXX\") {\n        /*\n    Format:\n    [0]   = {Text Encoding}\n    [1-?] = {Description}\\0{Value}\n    */ let index = 1;\n        const description = utf8ArrayToStr(frame.data.subarray(index), true);\n        index += description.length + 1;\n        const value = utf8ArrayToStr(frame.data.subarray(index));\n        return {\n            key: frame.type,\n            info: description,\n            data: value\n        };\n    }\n    /*\n  Format:\n  [0]   = {Text Encoding}\n  [1-?] = {Value}\n  */ const text = utf8ArrayToStr(frame.data.subarray(1));\n    return {\n        key: frame.type,\n        data: text\n    };\n};\nconst decodeURLFrame = (frame)=>{\n    if (frame.type === \"WXXX\") {\n        /*\n    Format:\n    [0]   = {Text Encoding}\n    [1-?] = {Description}\\0{URL}\n    */ if (frame.size < 2) {\n            return undefined;\n        }\n        let index = 1;\n        const description = utf8ArrayToStr(frame.data.subarray(index), true);\n        index += description.length + 1;\n        const value = utf8ArrayToStr(frame.data.subarray(index));\n        return {\n            key: frame.type,\n            info: description,\n            data: value\n        };\n    }\n    /*\n  Format:\n  [0-?] = {URL}\n  */ const url = utf8ArrayToStr(frame.data);\n    return {\n        key: frame.type,\n        data: url\n    };\n};\nconst readTimeStamp = (timeStampFrame)=>{\n    if (timeStampFrame.data.byteLength === 8) {\n        const data = new Uint8Array(timeStampFrame.data);\n        // timestamp is 33 bit expressed as a big-endian eight-octet number,\n        // with the upper 31 bits set to zero.\n        const pts33Bit = data[3] & 0x1;\n        let timestamp = (data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7];\n        timestamp /= 45;\n        if (pts33Bit) {\n            timestamp += 47721858.84;\n        } // 2^32 / 90\n        return Math.round(timestamp);\n    }\n    return undefined;\n};\n// http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197\n// http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt\n/* utf.js - UTF-8 <=> UTF-16 convertion\n *\n * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\n * Version: 1.0\n * LastModified: Dec 25 1999\n * This library is free.  You can redistribute it and/or modify it.\n */ const utf8ArrayToStr = (array, exitOnNull = false)=>{\n    const decoder = getTextDecoder();\n    if (decoder) {\n        const decoded = decoder.decode(array);\n        if (exitOnNull) {\n            // grab up to the first null\n            const idx = decoded.indexOf(\"\\x00\");\n            return idx !== -1 ? decoded.substring(0, idx) : decoded;\n        }\n        // remove any null characters\n        return decoded.replace(/\\0/g, \"\");\n    }\n    const len = array.length;\n    let c;\n    let char2;\n    let char3;\n    let out = \"\";\n    let i = 0;\n    while(i < len){\n        c = array[i++];\n        if (c === 0x00 && exitOnNull) {\n            return out;\n        } else if (c === 0x00 || c === 0x03) {\n            continue;\n        }\n        switch(c >> 4){\n            case 0:\n            case 1:\n            case 2:\n            case 3:\n            case 4:\n            case 5:\n            case 6:\n            case 7:\n                // 0xxxxxxx\n                out += String.fromCharCode(c);\n                break;\n            case 12:\n            case 13:\n                // 110x xxxx   10xx xxxx\n                char2 = array[i++];\n                out += String.fromCharCode((c & 0x1f) << 6 | char2 & 0x3f);\n                break;\n            case 14:\n                // 1110 xxxx  10xx xxxx  10xx xxxx\n                char2 = array[i++];\n                char3 = array[i++];\n                out += String.fromCharCode((c & 0x0f) << 12 | (char2 & 0x3f) << 6 | (char3 & 0x3f) << 0);\n                break;\n        }\n    }\n    return out;\n};\nlet decoder;\nfunction getTextDecoder() {\n    // On Play Station 4, TextDecoder is defined but partially implemented.\n    // Manual decoding option is preferable\n    if (navigator.userAgent.includes(\"PlayStation 4\")) {\n        return;\n    }\n    if (!decoder && typeof self.TextDecoder !== \"undefined\") {\n        decoder = new self.TextDecoder(\"utf-8\");\n    }\n    return decoder;\n}\n/**\n *  hex dump helper class\n */ const Hex = {\n    hexDump: function(array) {\n        let str = \"\";\n        for(let i = 0; i < array.length; i++){\n            let h = array[i].toString(16);\n            if (h.length < 2) {\n                h = \"0\" + h;\n            }\n            str += h;\n        }\n        return str;\n    }\n};\nconst UINT32_MAX$1 = Math.pow(2, 32) - 1;\nconst push = [].push;\n// We are using fixed track IDs for driving the MP4 remuxer\n// instead of following the TS PIDs.\n// There is no reason not to do this and some browsers/SourceBuffer-demuxers\n// may not like if there are TrackID \"switches\"\n// See https://github.com/video-dev/hls.js/issues/1331\n// Here we are mapping our internal track types to constant MP4 track IDs\n// With MSE currently one can only have one track of each, and we are muxing\n// whatever video/audio rendition in them.\nconst RemuxerTrackIdConfig = {\n    video: 1,\n    audio: 2,\n    id3: 3,\n    text: 4\n};\nfunction bin2str(data) {\n    return String.fromCharCode.apply(null, data);\n}\nfunction readUint16(buffer, offset) {\n    const val = buffer[offset] << 8 | buffer[offset + 1];\n    return val < 0 ? 65536 + val : val;\n}\nfunction readUint32(buffer, offset) {\n    const val = readSint32(buffer, offset);\n    return val < 0 ? 4294967296 + val : val;\n}\nfunction readUint64(buffer, offset) {\n    let result = readUint32(buffer, offset);\n    result *= Math.pow(2, 32);\n    result += readUint32(buffer, offset + 4);\n    return result;\n}\nfunction readSint32(buffer, offset) {\n    return buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3];\n}\nfunction writeUint32(buffer, offset, value) {\n    buffer[offset] = value >> 24;\n    buffer[offset + 1] = value >> 16 & 0xff;\n    buffer[offset + 2] = value >> 8 & 0xff;\n    buffer[offset + 3] = value & 0xff;\n}\n// Find \"moof\" box\nfunction hasMoofData(data) {\n    const end = data.byteLength;\n    for(let i = 0; i < end;){\n        const size = readUint32(data, i);\n        if (size > 8 && data[i + 4] === 0x6d && data[i + 5] === 0x6f && data[i + 6] === 0x6f && data[i + 7] === 0x66) {\n            return true;\n        }\n        i = size > 1 ? i + size : end;\n    }\n    return false;\n}\n// Find the data for a box specified by its path\nfunction findBox(data, path) {\n    const results = [];\n    if (!path.length) {\n        // short-circuit the search for empty paths\n        return results;\n    }\n    const end = data.byteLength;\n    for(let i = 0; i < end;){\n        const size = readUint32(data, i);\n        const type = bin2str(data.subarray(i + 4, i + 8));\n        const endbox = size > 1 ? i + size : end;\n        if (type === path[0]) {\n            if (path.length === 1) {\n                // this is the end of the path and we've found the box we were\n                // looking for\n                results.push(data.subarray(i + 8, endbox));\n            } else {\n                // recursively search for the next box along the path\n                const subresults = findBox(data.subarray(i + 8, endbox), path.slice(1));\n                if (subresults.length) {\n                    push.apply(results, subresults);\n                }\n            }\n        }\n        i = endbox;\n    }\n    // we've finished searching all of data\n    return results;\n}\nfunction parseSegmentIndex(sidx) {\n    const references = [];\n    const version = sidx[0];\n    // set initial offset, we skip the reference ID (not needed)\n    let index = 8;\n    const timescale = readUint32(sidx, index);\n    index += 4;\n    let earliestPresentationTime = 0;\n    let firstOffset = 0;\n    if (version === 0) {\n        earliestPresentationTime = readUint32(sidx, index);\n        firstOffset = readUint32(sidx, index + 4);\n        index += 8;\n    } else {\n        earliestPresentationTime = readUint64(sidx, index);\n        firstOffset = readUint64(sidx, index + 8);\n        index += 16;\n    }\n    // skip reserved\n    index += 2;\n    let startByte = sidx.length + firstOffset;\n    const referencesCount = readUint16(sidx, index);\n    index += 2;\n    for(let i = 0; i < referencesCount; i++){\n        let referenceIndex = index;\n        const referenceInfo = readUint32(sidx, referenceIndex);\n        referenceIndex += 4;\n        const referenceSize = referenceInfo & 0x7fffffff;\n        const referenceType = (referenceInfo & 0x80000000) >>> 31;\n        if (referenceType === 1) {\n            logger.warn(\"SIDX has hierarchical references (not supported)\");\n            return null;\n        }\n        const subsegmentDuration = readUint32(sidx, referenceIndex);\n        referenceIndex += 4;\n        references.push({\n            referenceSize,\n            subsegmentDuration,\n            // unscaled\n            info: {\n                duration: subsegmentDuration / timescale,\n                start: startByte,\n                end: startByte + referenceSize - 1\n            }\n        });\n        startByte += referenceSize;\n        // Skipping 1 bit for |startsWithSap|, 3 bits for |sapType|, and 28 bits\n        // for |sapDelta|.\n        referenceIndex += 4;\n        // skip to next ref\n        index = referenceIndex;\n    }\n    return {\n        earliestPresentationTime,\n        timescale,\n        version,\n        referencesCount,\n        references\n    };\n}\n/**\n * Parses an MP4 initialization segment and extracts stream type and\n * timescale values for any declared tracks. Timescale values indicate the\n * number of clock ticks per second to assume for time-based values\n * elsewhere in the MP4.\n *\n * To determine the start time of an MP4, you need two pieces of\n * information: the timescale unit and the earliest base media decode\n * time. Multiple timescales can be specified within an MP4 but the\n * base media decode time is always expressed in the timescale from\n * the media header box for the track:\n * ```\n * moov > trak > mdia > mdhd.timescale\n * moov > trak > mdia > hdlr\n * ```\n * @param initSegment the bytes of the init segment\n * @returns a hash of track type to timescale values or null if\n * the init segment is malformed.\n */ function parseInitSegment(initSegment) {\n    const result = [];\n    const traks = findBox(initSegment, [\n        \"moov\",\n        \"trak\"\n    ]);\n    for(let i = 0; i < traks.length; i++){\n        const trak = traks[i];\n        const tkhd = findBox(trak, [\n            \"tkhd\"\n        ])[0];\n        if (tkhd) {\n            let version = tkhd[0];\n            const trackId = readUint32(tkhd, version === 0 ? 12 : 20);\n            const mdhd = findBox(trak, [\n                \"mdia\",\n                \"mdhd\"\n            ])[0];\n            if (mdhd) {\n                version = mdhd[0];\n                const timescale = readUint32(mdhd, version === 0 ? 12 : 20);\n                const hdlr = findBox(trak, [\n                    \"mdia\",\n                    \"hdlr\"\n                ])[0];\n                if (hdlr) {\n                    const hdlrType = bin2str(hdlr.subarray(8, 12));\n                    const type = {\n                        soun: ElementaryStreamTypes.AUDIO,\n                        vide: ElementaryStreamTypes.VIDEO\n                    }[hdlrType];\n                    if (type) {\n                        // Parse codec details\n                        const stsd = findBox(trak, [\n                            \"mdia\",\n                            \"minf\",\n                            \"stbl\",\n                            \"stsd\"\n                        ])[0];\n                        const stsdData = parseStsd(stsd);\n                        result[trackId] = {\n                            timescale,\n                            type\n                        };\n                        result[type] = _objectSpread2({\n                            timescale,\n                            id: trackId\n                        }, stsdData);\n                    }\n                }\n            }\n        }\n    }\n    const trex = findBox(initSegment, [\n        \"moov\",\n        \"mvex\",\n        \"trex\"\n    ]);\n    trex.forEach((trex)=>{\n        const trackId = readUint32(trex, 4);\n        const track = result[trackId];\n        if (track) {\n            track.default = {\n                duration: readUint32(trex, 12),\n                flags: readUint32(trex, 20)\n            };\n        }\n    });\n    return result;\n}\nfunction parseStsd(stsd) {\n    const sampleEntries = stsd.subarray(8);\n    const sampleEntriesEnd = sampleEntries.subarray(8 + 78);\n    const fourCC = bin2str(sampleEntries.subarray(4, 8));\n    let codec = fourCC;\n    const encrypted = fourCC === \"enca\" || fourCC === \"encv\";\n    if (encrypted) {\n        const encBox = findBox(sampleEntries, [\n            fourCC\n        ])[0];\n        const encBoxChildren = encBox.subarray(fourCC === \"enca\" ? 28 : 78);\n        const sinfs = findBox(encBoxChildren, [\n            \"sinf\"\n        ]);\n        sinfs.forEach((sinf)=>{\n            const schm = findBox(sinf, [\n                \"schm\"\n            ])[0];\n            if (schm) {\n                const scheme = bin2str(schm.subarray(4, 8));\n                if (scheme === \"cbcs\" || scheme === \"cenc\") {\n                    const frma = findBox(sinf, [\n                        \"frma\"\n                    ])[0];\n                    if (frma) {\n                        // for encrypted content codec fourCC will be in frma\n                        codec = bin2str(frma);\n                    }\n                }\n            }\n        });\n    }\n    switch(codec){\n        case \"avc1\":\n        case \"avc2\":\n        case \"avc3\":\n        case \"avc4\":\n            {\n                // extract profile + compatibility + level out of avcC box\n                const avcCBox = findBox(sampleEntriesEnd, [\n                    \"avcC\"\n                ])[0];\n                codec += \".\" + toHex(avcCBox[1]) + toHex(avcCBox[2]) + toHex(avcCBox[3]);\n                break;\n            }\n        case \"mp4a\":\n            {\n                const codecBox = findBox(sampleEntries, [\n                    fourCC\n                ])[0];\n                const esdsBox = findBox(codecBox.subarray(28), [\n                    \"esds\"\n                ])[0];\n                if (esdsBox && esdsBox.length > 12) {\n                    let i = 4;\n                    // ES Descriptor tag\n                    if (esdsBox[i++] !== 0x03) {\n                        break;\n                    }\n                    i = skipBERInteger(esdsBox, i);\n                    i += 2; // skip es_id;\n                    const flags = esdsBox[i++];\n                    if (flags & 0x80) {\n                        i += 2; // skip dependency es_id\n                    }\n                    if (flags & 0x40) {\n                        i += esdsBox[i++]; // skip URL\n                    }\n                    // Decoder config descriptor\n                    if (esdsBox[i++] !== 0x04) {\n                        break;\n                    }\n                    i = skipBERInteger(esdsBox, i);\n                    const objectType = esdsBox[i++];\n                    if (objectType === 0x40) {\n                        codec += \".\" + toHex(objectType);\n                    } else {\n                        break;\n                    }\n                    i += 12;\n                    // Decoder specific info\n                    if (esdsBox[i++] !== 0x05) {\n                        break;\n                    }\n                    i = skipBERInteger(esdsBox, i);\n                    const firstByte = esdsBox[i++];\n                    let audioObjectType = (firstByte & 0xf8) >> 3;\n                    if (audioObjectType === 31) {\n                        audioObjectType += 1 + ((firstByte & 0x7) << 3) + ((esdsBox[i] & 0xe0) >> 5);\n                    }\n                    codec += \".\" + audioObjectType;\n                }\n                break;\n            }\n        case \"hvc1\":\n        case \"hev1\":\n            {\n                const hvcCBox = findBox(sampleEntriesEnd, [\n                    \"hvcC\"\n                ])[0];\n                const profileByte = hvcCBox[1];\n                const profileSpace = [\n                    \"\",\n                    \"A\",\n                    \"B\",\n                    \"C\"\n                ][profileByte >> 6];\n                const generalProfileIdc = profileByte & 0x1f;\n                const profileCompat = readUint32(hvcCBox, 2);\n                const tierFlag = (profileByte & 0x20) >> 5 ? \"H\" : \"L\";\n                const levelIDC = hvcCBox[12];\n                const constraintIndicator = hvcCBox.subarray(6, 12);\n                codec += \".\" + profileSpace + generalProfileIdc;\n                codec += \".\" + profileCompat.toString(16).toUpperCase();\n                codec += \".\" + tierFlag + levelIDC;\n                let constraintString = \"\";\n                for(let i = constraintIndicator.length; i--;){\n                    const byte = constraintIndicator[i];\n                    if (byte || constraintString) {\n                        const encodedByte = byte.toString(16).toUpperCase();\n                        constraintString = \".\" + encodedByte + constraintString;\n                    }\n                }\n                codec += constraintString;\n                break;\n            }\n        case \"dvh1\":\n        case \"dvhe\":\n            {\n                const dvcCBox = findBox(sampleEntriesEnd, [\n                    \"dvcC\"\n                ])[0];\n                const profile = dvcCBox[2] >> 1 & 0x7f;\n                const level = dvcCBox[2] << 5 & 0x20 | dvcCBox[3] >> 3 & 0x1f;\n                codec += \".\" + addLeadingZero(profile) + \".\" + addLeadingZero(level);\n                break;\n            }\n        case \"vp09\":\n            {\n                const vpcCBox = findBox(sampleEntriesEnd, [\n                    \"vpcC\"\n                ])[0];\n                const profile = vpcCBox[4];\n                const level = vpcCBox[5];\n                const bitDepth = vpcCBox[6] >> 4 & 0x0f;\n                codec += \".\" + addLeadingZero(profile) + \".\" + addLeadingZero(level) + \".\" + addLeadingZero(bitDepth);\n                break;\n            }\n        case \"av01\":\n            {\n                const av1CBox = findBox(sampleEntriesEnd, [\n                    \"av1C\"\n                ])[0];\n                const profile = av1CBox[1] >>> 5;\n                const level = av1CBox[1] & 0x1f;\n                const tierFlag = av1CBox[2] >>> 7 ? \"H\" : \"M\";\n                const highBitDepth = (av1CBox[2] & 0x40) >> 6;\n                const twelveBit = (av1CBox[2] & 0x20) >> 5;\n                const bitDepth = profile === 2 && highBitDepth ? twelveBit ? 12 : 10 : highBitDepth ? 10 : 8;\n                const monochrome = (av1CBox[2] & 0x10) >> 4;\n                const chromaSubsamplingX = (av1CBox[2] & 0x08) >> 3;\n                const chromaSubsamplingY = (av1CBox[2] & 0x04) >> 2;\n                const chromaSamplePosition = av1CBox[2] & 0x03;\n                // TODO: parse color_description_present_flag\n                // default it to BT.709/limited range for now\n                // more info https://aomediacodec.github.io/av1-isobmff/#av1codecconfigurationbox-syntax\n                const colorPrimaries = 1;\n                const transferCharacteristics = 1;\n                const matrixCoefficients = 1;\n                const videoFullRangeFlag = 0;\n                codec += \".\" + profile + \".\" + addLeadingZero(level) + tierFlag + \".\" + addLeadingZero(bitDepth) + \".\" + monochrome + \".\" + chromaSubsamplingX + chromaSubsamplingY + chromaSamplePosition + \".\" + addLeadingZero(colorPrimaries) + \".\" + addLeadingZero(transferCharacteristics) + \".\" + addLeadingZero(matrixCoefficients) + \".\" + videoFullRangeFlag;\n                break;\n            }\n    }\n    return {\n        codec,\n        encrypted\n    };\n}\nfunction skipBERInteger(bytes, i) {\n    const limit = i + 5;\n    while(bytes[i++] & 0x80 && i < limit){}\n    return i;\n}\nfunction toHex(x) {\n    return (\"0\" + x.toString(16).toUpperCase()).slice(-2);\n}\nfunction addLeadingZero(num) {\n    return (num < 10 ? \"0\" : \"\") + num;\n}\nfunction patchEncyptionData(initSegment, decryptdata) {\n    if (!initSegment || !decryptdata) {\n        return initSegment;\n    }\n    const keyId = decryptdata.keyId;\n    if (keyId && decryptdata.isCommonEncryption) {\n        const traks = findBox(initSegment, [\n            \"moov\",\n            \"trak\"\n        ]);\n        traks.forEach((trak)=>{\n            const stsd = findBox(trak, [\n                \"mdia\",\n                \"minf\",\n                \"stbl\",\n                \"stsd\"\n            ])[0];\n            // skip the sample entry count\n            const sampleEntries = stsd.subarray(8);\n            let encBoxes = findBox(sampleEntries, [\n                \"enca\"\n            ]);\n            const isAudio = encBoxes.length > 0;\n            if (!isAudio) {\n                encBoxes = findBox(sampleEntries, [\n                    \"encv\"\n                ]);\n            }\n            encBoxes.forEach((enc)=>{\n                const encBoxChildren = isAudio ? enc.subarray(28) : enc.subarray(78);\n                const sinfBoxes = findBox(encBoxChildren, [\n                    \"sinf\"\n                ]);\n                sinfBoxes.forEach((sinf)=>{\n                    const tenc = parseSinf(sinf);\n                    if (tenc) {\n                        // Look for default key id (keyID offset is always 8 within the tenc box):\n                        const tencKeyId = tenc.subarray(8, 24);\n                        if (!tencKeyId.some((b)=>b !== 0)) {\n                            logger.log(`[eme] Patching keyId in 'enc${isAudio ? \"a\" : \"v\"}>sinf>>tenc' box: ${Hex.hexDump(tencKeyId)} -> ${Hex.hexDump(keyId)}`);\n                            tenc.set(keyId, 8);\n                        }\n                    }\n                });\n            });\n        });\n    }\n    return initSegment;\n}\nfunction parseSinf(sinf) {\n    const schm = findBox(sinf, [\n        \"schm\"\n    ])[0];\n    if (schm) {\n        const scheme = bin2str(schm.subarray(4, 8));\n        if (scheme === \"cbcs\" || scheme === \"cenc\") {\n            return findBox(sinf, [\n                \"schi\",\n                \"tenc\"\n            ])[0];\n        }\n    }\n    logger.error(`[eme] missing 'schm' box`);\n    return null;\n}\n/**\n * Determine the base media decode start time, in seconds, for an MP4\n * fragment. If multiple fragments are specified, the earliest time is\n * returned.\n *\n * The base media decode time can be parsed from track fragment\n * metadata:\n * ```\n * moof > traf > tfdt.baseMediaDecodeTime\n * ```\n * It requires the timescale value from the mdhd to interpret.\n *\n * @param initData - a hash of track type to timescale values\n * @param fmp4 - the bytes of the mp4 fragment\n * @returns the earliest base media decode start time for the\n * fragment, in seconds\n */ function getStartDTS(initData, fmp4) {\n    // we need info from two children of each track fragment box\n    return findBox(fmp4, [\n        \"moof\",\n        \"traf\"\n    ]).reduce((result, traf)=>{\n        const tfdt = findBox(traf, [\n            \"tfdt\"\n        ])[0];\n        const version = tfdt[0];\n        const start = findBox(traf, [\n            \"tfhd\"\n        ]).reduce((result, tfhd)=>{\n            // get the track id from the tfhd\n            const id = readUint32(tfhd, 4);\n            const track = initData[id];\n            if (track) {\n                let baseTime = readUint32(tfdt, 4);\n                if (version === 1) {\n                    // If value is too large, assume signed 64-bit. Negative track fragment decode times are invalid, but they exist in the wild.\n                    // This prevents large values from being used for initPTS, which can cause playlist sync issues.\n                    // https://github.com/video-dev/hls.js/issues/5303\n                    if (baseTime === UINT32_MAX$1) {\n                        logger.warn(`[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time`);\n                        return result;\n                    }\n                    baseTime *= UINT32_MAX$1 + 1;\n                    baseTime += readUint32(tfdt, 8);\n                }\n                // assume a 90kHz clock if no timescale was specified\n                const scale = track.timescale || 90e3;\n                // convert base time to seconds\n                const startTime = baseTime / scale;\n                if (isFiniteNumber(startTime) && (result === null || startTime < result)) {\n                    return startTime;\n                }\n            }\n            return result;\n        }, null);\n        if (start !== null && isFiniteNumber(start) && (result === null || start < result)) {\n            return start;\n        }\n        return result;\n    }, null);\n}\n/*\n  For Reference:\n  aligned(8) class TrackFragmentHeaderBox\n           extends FullBox(tfhd, 0, tf_flags){\n     unsigned int(32)  track_ID;\n     // all the following are optional fields\n     unsigned int(64)  base_data_offset;\n     unsigned int(32)  sample_description_index;\n     unsigned int(32)  default_sample_duration;\n     unsigned int(32)  default_sample_size;\n     unsigned int(32)  default_sample_flags\n  }\n */ function getDuration(data, initData) {\n    let rawDuration = 0;\n    let videoDuration = 0;\n    let audioDuration = 0;\n    const trafs = findBox(data, [\n        \"moof\",\n        \"traf\"\n    ]);\n    for(let i = 0; i < trafs.length; i++){\n        const traf = trafs[i];\n        // There is only one tfhd & trun per traf\n        // This is true for CMAF style content, and we should perhaps check the ftyp\n        // and only look for a single trun then, but for ISOBMFF we should check\n        // for multiple track runs.\n        const tfhd = findBox(traf, [\n            \"tfhd\"\n        ])[0];\n        // get the track id from the tfhd\n        const id = readUint32(tfhd, 4);\n        const track = initData[id];\n        if (!track) {\n            continue;\n        }\n        const trackDefault = track.default;\n        const tfhdFlags = readUint32(tfhd, 0) | (trackDefault == null ? void 0 : trackDefault.flags);\n        let sampleDuration = trackDefault == null ? void 0 : trackDefault.duration;\n        if (tfhdFlags & 0x000008) {\n            // 0x000008 indicates the presence of the default_sample_duration field\n            if (tfhdFlags & 0x000002) {\n                // 0x000002 indicates the presence of the sample_description_index field, which precedes default_sample_duration\n                // If present, the default_sample_duration exists at byte offset 12\n                sampleDuration = readUint32(tfhd, 12);\n            } else {\n                // Otherwise, the duration is at byte offset 8\n                sampleDuration = readUint32(tfhd, 8);\n            }\n        }\n        // assume a 90kHz clock if no timescale was specified\n        const timescale = track.timescale || 90e3;\n        const truns = findBox(traf, [\n            \"trun\"\n        ]);\n        for(let j = 0; j < truns.length; j++){\n            rawDuration = computeRawDurationFromSamples(truns[j]);\n            if (!rawDuration && sampleDuration) {\n                const sampleCount = readUint32(truns[j], 4);\n                rawDuration = sampleDuration * sampleCount;\n            }\n            if (track.type === ElementaryStreamTypes.VIDEO) {\n                videoDuration += rawDuration / timescale;\n            } else if (track.type === ElementaryStreamTypes.AUDIO) {\n                audioDuration += rawDuration / timescale;\n            }\n        }\n    }\n    if (videoDuration === 0 && audioDuration === 0) {\n        // If duration samples are not available in the traf use sidx subsegment_duration\n        let sidxMinStart = Infinity;\n        let sidxMaxEnd = 0;\n        let sidxDuration = 0;\n        const sidxs = findBox(data, [\n            \"sidx\"\n        ]);\n        for(let i = 0; i < sidxs.length; i++){\n            const sidx = parseSegmentIndex(sidxs[i]);\n            if (sidx != null && sidx.references) {\n                sidxMinStart = Math.min(sidxMinStart, sidx.earliestPresentationTime / sidx.timescale);\n                const subSegmentDuration = sidx.references.reduce((dur, ref)=>dur + ref.info.duration || 0, 0);\n                sidxMaxEnd = Math.max(sidxMaxEnd, subSegmentDuration + sidx.earliestPresentationTime / sidx.timescale);\n                sidxDuration = sidxMaxEnd - sidxMinStart;\n            }\n        }\n        if (sidxDuration && isFiniteNumber(sidxDuration)) {\n            return sidxDuration;\n        }\n    }\n    if (videoDuration) {\n        return videoDuration;\n    }\n    return audioDuration;\n}\n/*\n  For Reference:\n  aligned(8) class TrackRunBox\n           extends FullBox(trun, version, tr_flags) {\n     unsigned int(32)  sample_count;\n     // the following are optional fields\n     signed int(32) data_offset;\n     unsigned int(32)  first_sample_flags;\n     // all fields in the following array are optional\n     {\n        unsigned int(32)  sample_duration;\n        unsigned int(32)  sample_size;\n        unsigned int(32)  sample_flags\n        if (version == 0)\n           { unsigned int(32)\n        else\n           { signed int(32)\n     }[ sample_count ]\n  }\n */ function computeRawDurationFromSamples(trun) {\n    const flags = readUint32(trun, 0);\n    // Flags are at offset 0, non-optional sample_count is at offset 4. Therefore we start 8 bytes in.\n    // Each field is an int32, which is 4 bytes\n    let offset = 8;\n    // data-offset-present flag\n    if (flags & 0x000001) {\n        offset += 4;\n    }\n    // first-sample-flags-present flag\n    if (flags & 0x000004) {\n        offset += 4;\n    }\n    let duration = 0;\n    const sampleCount = readUint32(trun, 4);\n    for(let i = 0; i < sampleCount; i++){\n        // sample-duration-present flag\n        if (flags & 0x000100) {\n            const sampleDuration = readUint32(trun, offset);\n            duration += sampleDuration;\n            offset += 4;\n        }\n        // sample-size-present flag\n        if (flags & 0x000200) {\n            offset += 4;\n        }\n        // sample-flags-present flag\n        if (flags & 0x000400) {\n            offset += 4;\n        }\n        // sample-composition-time-offsets-present flag\n        if (flags & 0x000800) {\n            offset += 4;\n        }\n    }\n    return duration;\n}\nfunction offsetStartDTS(initData, fmp4, timeOffset) {\n    findBox(fmp4, [\n        \"moof\",\n        \"traf\"\n    ]).forEach((traf)=>{\n        findBox(traf, [\n            \"tfhd\"\n        ]).forEach((tfhd)=>{\n            // get the track id from the tfhd\n            const id = readUint32(tfhd, 4);\n            const track = initData[id];\n            if (!track) {\n                return;\n            }\n            // assume a 90kHz clock if no timescale was specified\n            const timescale = track.timescale || 90e3;\n            // get the base media decode time from the tfdt\n            findBox(traf, [\n                \"tfdt\"\n            ]).forEach((tfdt)=>{\n                const version = tfdt[0];\n                const offset = timeOffset * timescale;\n                if (offset) {\n                    let baseMediaDecodeTime = readUint32(tfdt, 4);\n                    if (version === 0) {\n                        baseMediaDecodeTime -= offset;\n                        baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);\n                        writeUint32(tfdt, 4, baseMediaDecodeTime);\n                    } else {\n                        baseMediaDecodeTime *= Math.pow(2, 32);\n                        baseMediaDecodeTime += readUint32(tfdt, 8);\n                        baseMediaDecodeTime -= offset;\n                        baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);\n                        const upper = Math.floor(baseMediaDecodeTime / (UINT32_MAX$1 + 1));\n                        const lower = Math.floor(baseMediaDecodeTime % (UINT32_MAX$1 + 1));\n                        writeUint32(tfdt, 4, upper);\n                        writeUint32(tfdt, 8, lower);\n                    }\n                }\n            });\n        });\n    });\n}\n// TODO: Check if the last moof+mdat pair is part of the valid range\nfunction segmentValidRange(data) {\n    const segmentedRange = {\n        valid: null,\n        remainder: null\n    };\n    const moofs = findBox(data, [\n        \"moof\"\n    ]);\n    if (moofs.length < 2) {\n        segmentedRange.remainder = data;\n        return segmentedRange;\n    }\n    const last = moofs[moofs.length - 1];\n    // Offset by 8 bytes; findBox offsets the start by as much\n    segmentedRange.valid = sliceUint8(data, 0, last.byteOffset - 8);\n    segmentedRange.remainder = sliceUint8(data, last.byteOffset - 8);\n    return segmentedRange;\n}\nfunction appendUint8Array(data1, data2) {\n    const temp = new Uint8Array(data1.length + data2.length);\n    temp.set(data1);\n    temp.set(data2, data1.length);\n    return temp;\n}\nfunction parseSamples(timeOffset, track) {\n    const seiSamples = [];\n    const videoData = track.samples;\n    const timescale = track.timescale;\n    const trackId = track.id;\n    let isHEVCFlavor = false;\n    const moofs = findBox(videoData, [\n        \"moof\"\n    ]);\n    moofs.map((moof)=>{\n        const moofOffset = moof.byteOffset - 8;\n        const trafs = findBox(moof, [\n            \"traf\"\n        ]);\n        trafs.map((traf)=>{\n            // get the base media decode time from the tfdt\n            const baseTime = findBox(traf, [\n                \"tfdt\"\n            ]).map((tfdt)=>{\n                const version = tfdt[0];\n                let result = readUint32(tfdt, 4);\n                if (version === 1) {\n                    result *= Math.pow(2, 32);\n                    result += readUint32(tfdt, 8);\n                }\n                return result / timescale;\n            })[0];\n            if (baseTime !== undefined) {\n                timeOffset = baseTime;\n            }\n            return findBox(traf, [\n                \"tfhd\"\n            ]).map((tfhd)=>{\n                const id = readUint32(tfhd, 4);\n                const tfhdFlags = readUint32(tfhd, 0) & 0xffffff;\n                const baseDataOffsetPresent = (tfhdFlags & 0x000001) !== 0;\n                const sampleDescriptionIndexPresent = (tfhdFlags & 0x000002) !== 0;\n                const defaultSampleDurationPresent = (tfhdFlags & 0x000008) !== 0;\n                let defaultSampleDuration = 0;\n                const defaultSampleSizePresent = (tfhdFlags & 0x000010) !== 0;\n                let defaultSampleSize = 0;\n                const defaultSampleFlagsPresent = (tfhdFlags & 0x000020) !== 0;\n                let tfhdOffset = 8;\n                if (id === trackId) {\n                    if (baseDataOffsetPresent) {\n                        tfhdOffset += 8;\n                    }\n                    if (sampleDescriptionIndexPresent) {\n                        tfhdOffset += 4;\n                    }\n                    if (defaultSampleDurationPresent) {\n                        defaultSampleDuration = readUint32(tfhd, tfhdOffset);\n                        tfhdOffset += 4;\n                    }\n                    if (defaultSampleSizePresent) {\n                        defaultSampleSize = readUint32(tfhd, tfhdOffset);\n                        tfhdOffset += 4;\n                    }\n                    if (defaultSampleFlagsPresent) {\n                        tfhdOffset += 4;\n                    }\n                    if (track.type === \"video\") {\n                        isHEVCFlavor = isHEVC(track.codec);\n                    }\n                    findBox(traf, [\n                        \"trun\"\n                    ]).map((trun)=>{\n                        const version = trun[0];\n                        const flags = readUint32(trun, 0) & 0xffffff;\n                        const dataOffsetPresent = (flags & 0x000001) !== 0;\n                        let dataOffset = 0;\n                        const firstSampleFlagsPresent = (flags & 0x000004) !== 0;\n                        const sampleDurationPresent = (flags & 0x000100) !== 0;\n                        let sampleDuration = 0;\n                        const sampleSizePresent = (flags & 0x000200) !== 0;\n                        let sampleSize = 0;\n                        const sampleFlagsPresent = (flags & 0x000400) !== 0;\n                        const sampleCompositionOffsetsPresent = (flags & 0x000800) !== 0;\n                        let compositionOffset = 0;\n                        const sampleCount = readUint32(trun, 4);\n                        let trunOffset = 8; // past version, flags, and sample count\n                        if (dataOffsetPresent) {\n                            dataOffset = readUint32(trun, trunOffset);\n                            trunOffset += 4;\n                        }\n                        if (firstSampleFlagsPresent) {\n                            trunOffset += 4;\n                        }\n                        let sampleOffset = dataOffset + moofOffset;\n                        for(let ix = 0; ix < sampleCount; ix++){\n                            if (sampleDurationPresent) {\n                                sampleDuration = readUint32(trun, trunOffset);\n                                trunOffset += 4;\n                            } else {\n                                sampleDuration = defaultSampleDuration;\n                            }\n                            if (sampleSizePresent) {\n                                sampleSize = readUint32(trun, trunOffset);\n                                trunOffset += 4;\n                            } else {\n                                sampleSize = defaultSampleSize;\n                            }\n                            if (sampleFlagsPresent) {\n                                trunOffset += 4;\n                            }\n                            if (sampleCompositionOffsetsPresent) {\n                                if (version === 0) {\n                                    compositionOffset = readUint32(trun, trunOffset);\n                                } else {\n                                    compositionOffset = readSint32(trun, trunOffset);\n                                }\n                                trunOffset += 4;\n                            }\n                            if (track.type === ElementaryStreamTypes.VIDEO) {\n                                let naluTotalSize = 0;\n                                while(naluTotalSize < sampleSize){\n                                    const naluSize = readUint32(videoData, sampleOffset);\n                                    sampleOffset += 4;\n                                    if (isSEIMessage(isHEVCFlavor, videoData[sampleOffset])) {\n                                        const data = videoData.subarray(sampleOffset, sampleOffset + naluSize);\n                                        parseSEIMessageFromNALu(data, isHEVCFlavor ? 2 : 1, timeOffset + compositionOffset / timescale, seiSamples);\n                                    }\n                                    sampleOffset += naluSize;\n                                    naluTotalSize += naluSize + 4;\n                                }\n                            }\n                            timeOffset += sampleDuration / timescale;\n                        }\n                    });\n                }\n            });\n        });\n    });\n    return seiSamples;\n}\nfunction isHEVC(codec) {\n    if (!codec) {\n        return false;\n    }\n    const delimit = codec.indexOf(\".\");\n    const baseCodec = delimit < 0 ? codec : codec.substring(0, delimit);\n    return baseCodec === \"hvc1\" || baseCodec === \"hev1\" || // Dolby Vision\n    baseCodec === \"dvh1\" || baseCodec === \"dvhe\";\n}\nfunction isSEIMessage(isHEVCFlavor, naluHeader) {\n    if (isHEVCFlavor) {\n        const naluType = naluHeader >> 1 & 0x3f;\n        return naluType === 39 || naluType === 40;\n    } else {\n        const naluType = naluHeader & 0x1f;\n        return naluType === 6;\n    }\n}\nfunction parseSEIMessageFromNALu(unescapedData, headerSize, pts, samples) {\n    const data = discardEPB(unescapedData);\n    let seiPtr = 0;\n    // skip nal header\n    seiPtr += headerSize;\n    let payloadType = 0;\n    let payloadSize = 0;\n    let b = 0;\n    while(seiPtr < data.length){\n        payloadType = 0;\n        do {\n            if (seiPtr >= data.length) {\n                break;\n            }\n            b = data[seiPtr++];\n            payloadType += b;\n        }while (b === 0xff);\n        // Parse payload size.\n        payloadSize = 0;\n        do {\n            if (seiPtr >= data.length) {\n                break;\n            }\n            b = data[seiPtr++];\n            payloadSize += b;\n        }while (b === 0xff);\n        const leftOver = data.length - seiPtr;\n        // Create a variable to process the payload\n        let payPtr = seiPtr;\n        // Increment the seiPtr to the end of the payload\n        if (payloadSize < leftOver) {\n            seiPtr += payloadSize;\n        } else if (payloadSize > leftOver) {\n            // Some type of corruption has happened?\n            logger.error(`Malformed SEI payload. ${payloadSize} is too small, only ${leftOver} bytes left to parse.`);\n            break;\n        }\n        if (payloadType === 4) {\n            const countryCode = data[payPtr++];\n            if (countryCode === 181) {\n                const providerCode = readUint16(data, payPtr);\n                payPtr += 2;\n                if (providerCode === 49) {\n                    const userStructure = readUint32(data, payPtr);\n                    payPtr += 4;\n                    if (userStructure === 0x47413934) {\n                        const userDataType = data[payPtr++];\n                        // Raw CEA-608 bytes wrapped in CEA-708 packet\n                        if (userDataType === 3) {\n                            const firstByte = data[payPtr++];\n                            const totalCCs = 0x1f & firstByte;\n                            const enabled = 0x40 & firstByte;\n                            const totalBytes = enabled ? 2 + totalCCs * 3 : 0;\n                            const byteArray = new Uint8Array(totalBytes);\n                            if (enabled) {\n                                byteArray[0] = firstByte;\n                                for(let i = 1; i < totalBytes; i++){\n                                    byteArray[i] = data[payPtr++];\n                                }\n                            }\n                            samples.push({\n                                type: userDataType,\n                                payloadType,\n                                pts,\n                                bytes: byteArray\n                            });\n                        }\n                    }\n                }\n            }\n        } else if (payloadType === 5) {\n            if (payloadSize > 16) {\n                const uuidStrArray = [];\n                for(let i = 0; i < 16; i++){\n                    const _b = data[payPtr++].toString(16);\n                    uuidStrArray.push(_b.length == 1 ? \"0\" + _b : _b);\n                    if (i === 3 || i === 5 || i === 7 || i === 9) {\n                        uuidStrArray.push(\"-\");\n                    }\n                }\n                const length = payloadSize - 16;\n                const userDataBytes = new Uint8Array(length);\n                for(let i = 0; i < length; i++){\n                    userDataBytes[i] = data[payPtr++];\n                }\n                samples.push({\n                    payloadType,\n                    pts,\n                    uuid: uuidStrArray.join(\"\"),\n                    userData: utf8ArrayToStr(userDataBytes),\n                    userDataBytes\n                });\n            }\n        }\n    }\n}\n/**\n * remove Emulation Prevention bytes from a RBSP\n */ function discardEPB(data) {\n    const length = data.byteLength;\n    const EPBPositions = [];\n    let i = 1;\n    // Find all `Emulation Prevention Bytes`\n    while(i < length - 2){\n        if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n            EPBPositions.push(i + 2);\n            i += 2;\n        } else {\n            i++;\n        }\n    }\n    // If no Emulation Prevention Bytes were found just return the original\n    // array\n    if (EPBPositions.length === 0) {\n        return data;\n    }\n    // Create a new array to hold the NAL unit data\n    const newLength = length - EPBPositions.length;\n    const newData = new Uint8Array(newLength);\n    let sourceIndex = 0;\n    for(i = 0; i < newLength; sourceIndex++, i++){\n        if (sourceIndex === EPBPositions[0]) {\n            // Skip this byte\n            sourceIndex++;\n            // Remove this position index\n            EPBPositions.shift();\n        }\n        newData[i] = data[sourceIndex];\n    }\n    return newData;\n}\nfunction parseEmsg(data) {\n    const version = data[0];\n    let schemeIdUri = \"\";\n    let value = \"\";\n    let timeScale = 0;\n    let presentationTimeDelta = 0;\n    let presentationTime = 0;\n    let eventDuration = 0;\n    let id = 0;\n    let offset = 0;\n    if (version === 0) {\n        while(bin2str(data.subarray(offset, offset + 1)) !== \"\\x00\"){\n            schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n            offset += 1;\n        }\n        schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n        offset += 1;\n        while(bin2str(data.subarray(offset, offset + 1)) !== \"\\x00\"){\n            value += bin2str(data.subarray(offset, offset + 1));\n            offset += 1;\n        }\n        value += bin2str(data.subarray(offset, offset + 1));\n        offset += 1;\n        timeScale = readUint32(data, 12);\n        presentationTimeDelta = readUint32(data, 16);\n        eventDuration = readUint32(data, 20);\n        id = readUint32(data, 24);\n        offset = 28;\n    } else if (version === 1) {\n        offset += 4;\n        timeScale = readUint32(data, offset);\n        offset += 4;\n        const leftPresentationTime = readUint32(data, offset);\n        offset += 4;\n        const rightPresentationTime = readUint32(data, offset);\n        offset += 4;\n        presentationTime = 2 ** 32 * leftPresentationTime + rightPresentationTime;\n        if (!isSafeInteger(presentationTime)) {\n            presentationTime = Number.MAX_SAFE_INTEGER;\n            logger.warn(\"Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box\");\n        }\n        eventDuration = readUint32(data, offset);\n        offset += 4;\n        id = readUint32(data, offset);\n        offset += 4;\n        while(bin2str(data.subarray(offset, offset + 1)) !== \"\\x00\"){\n            schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n            offset += 1;\n        }\n        schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n        offset += 1;\n        while(bin2str(data.subarray(offset, offset + 1)) !== \"\\x00\"){\n            value += bin2str(data.subarray(offset, offset + 1));\n            offset += 1;\n        }\n        value += bin2str(data.subarray(offset, offset + 1));\n        offset += 1;\n    }\n    const payload = data.subarray(offset, data.byteLength);\n    return {\n        schemeIdUri,\n        value,\n        timeScale,\n        presentationTime,\n        presentationTimeDelta,\n        eventDuration,\n        id,\n        payload\n    };\n}\nfunction mp4Box(type, ...payload) {\n    const len = payload.length;\n    let size = 8;\n    let i = len;\n    while(i--){\n        size += payload[i].byteLength;\n    }\n    const result = new Uint8Array(size);\n    result[0] = size >> 24 & 0xff;\n    result[1] = size >> 16 & 0xff;\n    result[2] = size >> 8 & 0xff;\n    result[3] = size & 0xff;\n    result.set(type, 4);\n    for(i = 0, size = 8; i < len; i++){\n        result.set(payload[i], size);\n        size += payload[i].byteLength;\n    }\n    return result;\n}\nfunction mp4pssh(systemId, keyids, data) {\n    if (systemId.byteLength !== 16) {\n        throw new RangeError(\"Invalid system id\");\n    }\n    let version;\n    let kids;\n    if (keyids) {\n        version = 1;\n        kids = new Uint8Array(keyids.length * 16);\n        for(let ix = 0; ix < keyids.length; ix++){\n            const k = keyids[ix]; // uint8array\n            if (k.byteLength !== 16) {\n                throw new RangeError(\"Invalid key\");\n            }\n            kids.set(k, ix * 16);\n        }\n    } else {\n        version = 0;\n        kids = new Uint8Array();\n    }\n    let kidCount;\n    if (version > 0) {\n        kidCount = new Uint8Array(4);\n        if (keyids.length > 0) {\n            new DataView(kidCount.buffer).setUint32(0, keyids.length, false);\n        }\n    } else {\n        kidCount = new Uint8Array();\n    }\n    const dataSize = new Uint8Array(4);\n    if (data && data.byteLength > 0) {\n        new DataView(dataSize.buffer).setUint32(0, data.byteLength, false);\n    }\n    return mp4Box([\n        112,\n        115,\n        115,\n        104\n    ], new Uint8Array([\n        version,\n        0x00,\n        0x00,\n        0x00 // Flags\n    ]), systemId, // 16 bytes\n    kidCount, kids, dataSize, data || new Uint8Array());\n}\nfunction parsePssh(initData) {\n    if (!(initData instanceof ArrayBuffer) || initData.byteLength < 32) {\n        return null;\n    }\n    const result = {\n        version: 0,\n        systemId: \"\",\n        kids: null,\n        data: null\n    };\n    const view = new DataView(initData);\n    const boxSize = view.getUint32(0);\n    if (initData.byteLength !== boxSize && boxSize > 44) {\n        return null;\n    }\n    const type = view.getUint32(4);\n    if (type !== 0x70737368) {\n        return null;\n    }\n    result.version = view.getUint32(8) >>> 24;\n    if (result.version > 1) {\n        return null;\n    }\n    result.systemId = Hex.hexDump(new Uint8Array(initData, 12, 16));\n    const dataSizeOrKidCount = view.getUint32(28);\n    if (result.version === 0) {\n        if (boxSize - 32 < dataSizeOrKidCount) {\n            return null;\n        }\n        result.data = new Uint8Array(initData, 32, dataSizeOrKidCount);\n    } else if (result.version === 1) {\n        result.kids = [];\n        for(let i = 0; i < dataSizeOrKidCount; i++){\n            result.kids.push(new Uint8Array(initData, 32 + i * 16, 16));\n        }\n    }\n    return result;\n}\nlet keyUriToKeyIdMap = {};\nclass LevelKey {\n    static clearKeyUriToKeyIdMap() {\n        keyUriToKeyIdMap = {};\n    }\n    constructor(method, uri, format, formatversions = [\n        1\n    ], iv = null){\n        this.uri = void 0;\n        this.method = void 0;\n        this.keyFormat = void 0;\n        this.keyFormatVersions = void 0;\n        this.encrypted = void 0;\n        this.isCommonEncryption = void 0;\n        this.iv = null;\n        this.key = null;\n        this.keyId = null;\n        this.pssh = null;\n        this.method = method;\n        this.uri = uri;\n        this.keyFormat = format;\n        this.keyFormatVersions = formatversions;\n        this.iv = iv;\n        this.encrypted = method ? method !== \"NONE\" : false;\n        this.isCommonEncryption = this.encrypted && method !== \"AES-128\";\n    }\n    isSupported() {\n        // If it's Segment encryption or No encryption, just select that key system\n        if (this.method) {\n            if (this.method === \"AES-128\" || this.method === \"NONE\") {\n                return true;\n            }\n            if (this.keyFormat === \"identity\") {\n                // Maintain support for clear SAMPLE-AES with MPEG-3 TS\n                return this.method === \"SAMPLE-AES\";\n            } else {\n                switch(this.keyFormat){\n                    case KeySystemFormats.FAIRPLAY:\n                    case KeySystemFormats.WIDEVINE:\n                    case KeySystemFormats.PLAYREADY:\n                    case KeySystemFormats.CLEARKEY:\n                        return [\n                            \"ISO-23001-7\",\n                            \"SAMPLE-AES\",\n                            \"SAMPLE-AES-CENC\",\n                            \"SAMPLE-AES-CTR\"\n                        ].indexOf(this.method) !== -1;\n                }\n            }\n        }\n        return false;\n    }\n    getDecryptData(sn) {\n        if (!this.encrypted || !this.uri) {\n            return null;\n        }\n        if (this.method === \"AES-128\" && this.uri && !this.iv) {\n            if (typeof sn !== \"number\") {\n                // We are fetching decryption data for a initialization segment\n                // If the segment was encrypted with AES-128\n                // It must have an IV defined. We cannot substitute the Segment Number in.\n                if (this.method === \"AES-128\" && !this.iv) {\n                    logger.warn(`missing IV for initialization segment with method=\"${this.method}\" - compliance issue`);\n                }\n                // Explicitly set sn to resulting value from implicit conversions 'initSegment' values for IV generation.\n                sn = 0;\n            }\n            const iv = createInitializationVector(sn);\n            const decryptdata = new LevelKey(this.method, this.uri, \"identity\", this.keyFormatVersions, iv);\n            return decryptdata;\n        }\n        // Initialize keyId if possible\n        const keyBytes = convertDataUriToArrayBytes(this.uri);\n        if (keyBytes) {\n            switch(this.keyFormat){\n                case KeySystemFormats.WIDEVINE:\n                    this.pssh = keyBytes;\n                    // In case of widevine keyID is embedded in PSSH box. Read Key ID.\n                    if (keyBytes.length >= 22) {\n                        this.keyId = keyBytes.subarray(keyBytes.length - 22, keyBytes.length - 6);\n                    }\n                    break;\n                case KeySystemFormats.PLAYREADY:\n                    {\n                        const PlayReadyKeySystemUUID = new Uint8Array([\n                            0x9a,\n                            0x04,\n                            0xf0,\n                            0x79,\n                            0x98,\n                            0x40,\n                            0x42,\n                            0x86,\n                            0xab,\n                            0x92,\n                            0xe6,\n                            0x5b,\n                            0xe0,\n                            0x88,\n                            0x5f,\n                            0x95\n                        ]);\n                        this.pssh = mp4pssh(PlayReadyKeySystemUUID, null, keyBytes);\n                        const keyBytesUtf16 = new Uint16Array(keyBytes.buffer, keyBytes.byteOffset, keyBytes.byteLength / 2);\n                        const keyByteStr = String.fromCharCode.apply(null, Array.from(keyBytesUtf16));\n                        // Parse Playready WRMHeader XML\n                        const xmlKeyBytes = keyByteStr.substring(keyByteStr.indexOf(\"<\"), keyByteStr.length);\n                        const parser = new DOMParser();\n                        const xmlDoc = parser.parseFromString(xmlKeyBytes, \"text/xml\");\n                        const keyData = xmlDoc.getElementsByTagName(\"KID\")[0];\n                        if (keyData) {\n                            const keyId = keyData.childNodes[0] ? keyData.childNodes[0].nodeValue : keyData.getAttribute(\"VALUE\");\n                            if (keyId) {\n                                const keyIdArray = base64Decode(keyId).subarray(0, 16);\n                                // KID value in PRO is a base64-encoded little endian GUID interpretation of UUID\n                                // KID value in tenc is a big endian UUID GUID interpretation of UUID\n                                changeEndianness(keyIdArray);\n                                this.keyId = keyIdArray;\n                            }\n                        }\n                        break;\n                    }\n                default:\n                    {\n                        let keydata = keyBytes.subarray(0, 16);\n                        if (keydata.length !== 16) {\n                            const padded = new Uint8Array(16);\n                            padded.set(keydata, 16 - keydata.length);\n                            keydata = padded;\n                        }\n                        this.keyId = keydata;\n                        break;\n                    }\n            }\n        }\n        // Default behavior: assign a new keyId for each uri\n        if (!this.keyId || this.keyId.byteLength !== 16) {\n            let keyId = keyUriToKeyIdMap[this.uri];\n            if (!keyId) {\n                const val = Object.keys(keyUriToKeyIdMap).length % Number.MAX_SAFE_INTEGER;\n                keyId = new Uint8Array(16);\n                const dv = new DataView(keyId.buffer, 12, 4); // Just set the last 4 bytes\n                dv.setUint32(0, val);\n                keyUriToKeyIdMap[this.uri] = keyId;\n            }\n            this.keyId = keyId;\n        }\n        return this;\n    }\n}\nfunction createInitializationVector(segmentNumber) {\n    const uint8View = new Uint8Array(16);\n    for(let i = 12; i < 16; i++){\n        uint8View[i] = segmentNumber >> 8 * (15 - i) & 0xff;\n    }\n    return uint8View;\n}\nconst VARIABLE_REPLACEMENT_REGEX = /\\{\\$([a-zA-Z0-9-_]+)\\}/g;\nfunction hasVariableReferences(str) {\n    return VARIABLE_REPLACEMENT_REGEX.test(str);\n}\nfunction substituteVariablesInAttributes(parsed, attr, attributeNames) {\n    if (parsed.variableList !== null || parsed.hasVariableRefs) {\n        for(let i = attributeNames.length; i--;){\n            const name = attributeNames[i];\n            const value = attr[name];\n            if (value) {\n                attr[name] = substituteVariables(parsed, value);\n            }\n        }\n    }\n}\nfunction substituteVariables(parsed, value) {\n    if (parsed.variableList !== null || parsed.hasVariableRefs) {\n        const variableList = parsed.variableList;\n        return value.replace(VARIABLE_REPLACEMENT_REGEX, (variableReference)=>{\n            const variableName = variableReference.substring(2, variableReference.length - 1);\n            const variableValue = variableList == null ? void 0 : variableList[variableName];\n            if (variableValue === undefined) {\n                parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`Missing preceding EXT-X-DEFINE tag for Variable Reference: \"${variableName}\"`));\n                return variableReference;\n            }\n            return variableValue;\n        });\n    }\n    return value;\n}\nfunction addVariableDefinition(parsed, attr, parentUrl) {\n    let variableList = parsed.variableList;\n    if (!variableList) {\n        parsed.variableList = variableList = {};\n    }\n    let NAME;\n    let VALUE;\n    if (\"QUERYPARAM\" in attr) {\n        NAME = attr.QUERYPARAM;\n        try {\n            const searchParams = new self.URL(parentUrl).searchParams;\n            if (searchParams.has(NAME)) {\n                VALUE = searchParams.get(NAME);\n            } else {\n                throw new Error(`\"${NAME}\" does not match any query parameter in URI: \"${parentUrl}\"`);\n            }\n        } catch (error) {\n            parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`EXT-X-DEFINE QUERYPARAM: ${error.message}`));\n        }\n    } else {\n        NAME = attr.NAME;\n        VALUE = attr.VALUE;\n    }\n    if (NAME in variableList) {\n        parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`EXT-X-DEFINE duplicate Variable Name declarations: \"${NAME}\"`));\n    } else {\n        variableList[NAME] = VALUE || \"\";\n    }\n}\nfunction importVariableDefinition(parsed, attr, sourceVariableList) {\n    const IMPORT = attr.IMPORT;\n    if (sourceVariableList && IMPORT in sourceVariableList) {\n        let variableList = parsed.variableList;\n        if (!variableList) {\n            parsed.variableList = variableList = {};\n        }\n        variableList[IMPORT] = sourceVariableList[IMPORT];\n    } else {\n        parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: \"${IMPORT}\"`));\n    }\n}\n/**\n * MediaSource helper\n */ function getMediaSource(preferManagedMediaSource = true) {\n    if (typeof self === \"undefined\") return undefined;\n    const mms = (preferManagedMediaSource || !self.MediaSource) && self.ManagedMediaSource;\n    return mms || self.MediaSource || self.WebKitMediaSource;\n}\n// from http://mp4ra.org/codecs.html\n// values indicate codec selection preference (lower is higher priority)\nconst sampleEntryCodesISO = {\n    audio: {\n        a3ds: 1,\n        \"ac-3\": 0.95,\n        \"ac-4\": 1,\n        alac: 0.9,\n        alaw: 1,\n        dra1: 1,\n        \"dts+\": 1,\n        \"dts-\": 1,\n        dtsc: 1,\n        dtse: 1,\n        dtsh: 1,\n        \"ec-3\": 0.9,\n        enca: 1,\n        fLaC: 0.9,\n        // MP4-RA listed codec entry for FLAC\n        flac: 0.9,\n        // legacy browser codec name for FLAC\n        FLAC: 0.9,\n        // some manifests may list \"FLAC\" with Apple's tools\n        g719: 1,\n        g726: 1,\n        m4ae: 1,\n        mha1: 1,\n        mha2: 1,\n        mhm1: 1,\n        mhm2: 1,\n        mlpa: 1,\n        mp4a: 1,\n        \"raw \": 1,\n        Opus: 1,\n        opus: 1,\n        // browsers expect this to be lowercase despite MP4RA says 'Opus'\n        samr: 1,\n        sawb: 1,\n        sawp: 1,\n        sevc: 1,\n        sqcp: 1,\n        ssmv: 1,\n        twos: 1,\n        ulaw: 1\n    },\n    video: {\n        avc1: 1,\n        avc2: 1,\n        avc3: 1,\n        avc4: 1,\n        avcp: 1,\n        av01: 0.8,\n        drac: 1,\n        dva1: 1,\n        dvav: 1,\n        dvh1: 0.7,\n        dvhe: 0.7,\n        encv: 1,\n        hev1: 0.75,\n        hvc1: 0.75,\n        mjp2: 1,\n        mp4v: 1,\n        mvc1: 1,\n        mvc2: 1,\n        mvc3: 1,\n        mvc4: 1,\n        resv: 1,\n        rv60: 1,\n        s263: 1,\n        svc1: 1,\n        svc2: 1,\n        \"vc-1\": 1,\n        vp08: 1,\n        vp09: 0.9\n    },\n    text: {\n        stpp: 1,\n        wvtt: 1\n    }\n};\nfunction isCodecType(codec, type) {\n    const typeCodes = sampleEntryCodesISO[type];\n    return !!typeCodes && !!typeCodes[codec.slice(0, 4)];\n}\nfunction areCodecsMediaSourceSupported(codecs, type, preferManagedMediaSource = true) {\n    return !codecs.split(\",\").some((codec)=>!isCodecMediaSourceSupported(codec, type, preferManagedMediaSource));\n}\nfunction isCodecMediaSourceSupported(codec, type, preferManagedMediaSource = true) {\n    var _MediaSource$isTypeSu;\n    const MediaSource = getMediaSource(preferManagedMediaSource);\n    return (_MediaSource$isTypeSu = MediaSource == null ? void 0 : MediaSource.isTypeSupported(mimeTypeForCodec(codec, type))) != null ? _MediaSource$isTypeSu : false;\n}\nfunction mimeTypeForCodec(codec, type) {\n    return `${type}/mp4;codecs=\"${codec}\"`;\n}\nfunction videoCodecPreferenceValue(videoCodec) {\n    if (videoCodec) {\n        const fourCC = videoCodec.substring(0, 4);\n        return sampleEntryCodesISO.video[fourCC];\n    }\n    return 2;\n}\nfunction codecsSetSelectionPreferenceValue(codecSet) {\n    return codecSet.split(\",\").reduce((num, fourCC)=>{\n        const preferenceValue = sampleEntryCodesISO.video[fourCC];\n        if (preferenceValue) {\n            return (preferenceValue * 2 + num) / (num ? 3 : 2);\n        }\n        return (sampleEntryCodesISO.audio[fourCC] + num) / (num ? 2 : 1);\n    }, 0);\n}\nconst CODEC_COMPATIBLE_NAMES = {};\nfunction getCodecCompatibleNameLower(lowerCaseCodec, preferManagedMediaSource = true) {\n    if (CODEC_COMPATIBLE_NAMES[lowerCaseCodec]) {\n        return CODEC_COMPATIBLE_NAMES[lowerCaseCodec];\n    }\n    // Idealy fLaC and Opus would be first (spec-compliant) but\n    // some browsers will report that fLaC is supported then fail.\n    // see: https://bugs.chromium.org/p/chromium/issues/detail?id=1422728\n    const codecsToCheck = {\n        flac: [\n            \"flac\",\n            \"fLaC\",\n            \"FLAC\"\n        ],\n        opus: [\n            \"opus\",\n            \"Opus\"\n        ]\n    }[lowerCaseCodec];\n    for(let i = 0; i < codecsToCheck.length; i++){\n        if (isCodecMediaSourceSupported(codecsToCheck[i], \"audio\", preferManagedMediaSource)) {\n            CODEC_COMPATIBLE_NAMES[lowerCaseCodec] = codecsToCheck[i];\n            return codecsToCheck[i];\n        }\n    }\n    return lowerCaseCodec;\n}\nconst AUDIO_CODEC_REGEXP = /flac|opus/i;\nfunction getCodecCompatibleName(codec, preferManagedMediaSource = true) {\n    return codec.replace(AUDIO_CODEC_REGEXP, (m)=>getCodecCompatibleNameLower(m.toLowerCase(), preferManagedMediaSource));\n}\nfunction pickMostCompleteCodecName(parsedCodec, levelCodec) {\n    // Parsing of mp4a codecs strings in mp4-tools from media is incomplete as of d8c6c7a\n    // so use level codec is parsed codec is unavailable or incomplete\n    if (parsedCodec && parsedCodec !== \"mp4a\") {\n        return parsedCodec;\n    }\n    return levelCodec;\n}\nfunction convertAVC1ToAVCOTI(codec) {\n    // Convert avc1 codec string from RFC-4281 to RFC-6381 for MediaSource.isTypeSupported\n    const avcdata = codec.split(\".\");\n    if (avcdata.length > 2) {\n        let result = avcdata.shift() + \".\";\n        result += parseInt(avcdata.shift()).toString(16);\n        result += (\"000\" + parseInt(avcdata.shift()).toString(16)).slice(-4);\n        return result;\n    }\n    return codec;\n}\nconst MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\\r\\n]*)(?:[\\r\\n](?:#[^\\r\\n]*)?)*([^\\r\\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\\r\\n]*)[\\r\\n]+/g;\nconst MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;\nconst IS_MEDIA_PLAYLIST = /^#EXT(?:INF|-X-TARGETDURATION):/m; // Handle empty Media Playlist (first EXTINF not signaled, but TARGETDURATION present)\nconst LEVEL_PLAYLIST_REGEX_FAST = new RegExp([\n    /#EXTINF:\\s*(\\d*(?:\\.\\d+)?)(?:,(.*)\\s+)?/.source,\n    // duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title\n    /(?!#) *(\\S[\\S ]*)/.source,\n    // segment URI, group 3 => the URI (note newline is not eaten)\n    /#EXT-X-BYTERANGE:*(.+)/.source,\n    // next segment's byterange, group 4 => range spec (x@y)\n    /#EXT-X-PROGRAM-DATE-TIME:(.+)/.source,\n    // next segment's program date/time group 5 => the datetime spec\n    /#.*/.source // All other non-segment oriented tags will match with all groups empty\n].join(\"|\"), \"g\");\nconst LEVEL_PLAYLIST_REGEX_SLOW = new RegExp([\n    /#(EXTM3U)/.source,\n    /#EXT-X-(DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source,\n    /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\\d+)/.source,\n    /#EXT-X-(DISCONTINUITY|ENDLIST|GAP|INDEPENDENT-SEGMENTS)/.source,\n    /(#)([^:]*):(.*)/.source,\n    /(#)(.*)(?:.*)\\r?\\n?/.source\n].join(\"|\"));\nclass M3U8Parser {\n    static findGroup(groups, mediaGroupId) {\n        for(let i = 0; i < groups.length; i++){\n            const group = groups[i];\n            if (group.id === mediaGroupId) {\n                return group;\n            }\n        }\n    }\n    static resolve(url, baseUrl) {\n        return urlToolkitExports.buildAbsoluteURL(baseUrl, url, {\n            alwaysNormalize: true\n        });\n    }\n    static isMediaPlaylist(str) {\n        return IS_MEDIA_PLAYLIST.test(str);\n    }\n    static parseMasterPlaylist(string, baseurl) {\n        const hasVariableRefs = hasVariableReferences(string);\n        const parsed = {\n            contentSteering: null,\n            levels: [],\n            playlistParsingError: null,\n            sessionData: null,\n            sessionKeys: null,\n            startTimeOffset: null,\n            variableList: null,\n            hasVariableRefs\n        };\n        const levelsWithKnownCodecs = [];\n        MASTER_PLAYLIST_REGEX.lastIndex = 0;\n        let result;\n        while((result = MASTER_PLAYLIST_REGEX.exec(string)) != null){\n            if (result[1]) {\n                var _level$unknownCodecs;\n                // '#EXT-X-STREAM-INF' is found, parse level tag  in group 1\n                const attrs = new AttrList(result[1]);\n                {\n                    substituteVariablesInAttributes(parsed, attrs, [\n                        \"CODECS\",\n                        \"SUPPLEMENTAL-CODECS\",\n                        \"ALLOWED-CPC\",\n                        \"PATHWAY-ID\",\n                        \"STABLE-VARIANT-ID\",\n                        \"AUDIO\",\n                        \"VIDEO\",\n                        \"SUBTITLES\",\n                        \"CLOSED-CAPTIONS\",\n                        \"NAME\"\n                    ]);\n                }\n                const uri = substituteVariables(parsed, result[2]);\n                const level = {\n                    attrs,\n                    bitrate: attrs.decimalInteger(\"BANDWIDTH\") || attrs.decimalInteger(\"AVERAGE-BANDWIDTH\"),\n                    name: attrs.NAME,\n                    url: M3U8Parser.resolve(uri, baseurl)\n                };\n                const resolution = attrs.decimalResolution(\"RESOLUTION\");\n                if (resolution) {\n                    level.width = resolution.width;\n                    level.height = resolution.height;\n                }\n                setCodecs(attrs.CODECS, level);\n                if (!((_level$unknownCodecs = level.unknownCodecs) != null && _level$unknownCodecs.length)) {\n                    levelsWithKnownCodecs.push(level);\n                }\n                parsed.levels.push(level);\n            } else if (result[3]) {\n                const tag = result[3];\n                const attributes = result[4];\n                switch(tag){\n                    case \"SESSION-DATA\":\n                        {\n                            // #EXT-X-SESSION-DATA\n                            const sessionAttrs = new AttrList(attributes);\n                            {\n                                substituteVariablesInAttributes(parsed, sessionAttrs, [\n                                    \"DATA-ID\",\n                                    \"LANGUAGE\",\n                                    \"VALUE\",\n                                    \"URI\"\n                                ]);\n                            }\n                            const dataId = sessionAttrs[\"DATA-ID\"];\n                            if (dataId) {\n                                if (parsed.sessionData === null) {\n                                    parsed.sessionData = {};\n                                }\n                                parsed.sessionData[dataId] = sessionAttrs;\n                            }\n                            break;\n                        }\n                    case \"SESSION-KEY\":\n                        {\n                            // #EXT-X-SESSION-KEY\n                            const sessionKey = parseKey(attributes, baseurl, parsed);\n                            if (sessionKey.encrypted && sessionKey.isSupported()) {\n                                if (parsed.sessionKeys === null) {\n                                    parsed.sessionKeys = [];\n                                }\n                                parsed.sessionKeys.push(sessionKey);\n                            } else {\n                                logger.warn(`[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: \"${attributes}\"`);\n                            }\n                            break;\n                        }\n                    case \"DEFINE\":\n                        {\n                            // #EXT-X-DEFINE\n                            {\n                                const variableAttributes = new AttrList(attributes);\n                                substituteVariablesInAttributes(parsed, variableAttributes, [\n                                    \"NAME\",\n                                    \"VALUE\",\n                                    \"QUERYPARAM\"\n                                ]);\n                                addVariableDefinition(parsed, variableAttributes, baseurl);\n                            }\n                            break;\n                        }\n                    case \"CONTENT-STEERING\":\n                        {\n                            // #EXT-X-CONTENT-STEERING\n                            const contentSteeringAttributes = new AttrList(attributes);\n                            {\n                                substituteVariablesInAttributes(parsed, contentSteeringAttributes, [\n                                    \"SERVER-URI\",\n                                    \"PATHWAY-ID\"\n                                ]);\n                            }\n                            parsed.contentSteering = {\n                                uri: M3U8Parser.resolve(contentSteeringAttributes[\"SERVER-URI\"], baseurl),\n                                pathwayId: contentSteeringAttributes[\"PATHWAY-ID\"] || \".\"\n                            };\n                            break;\n                        }\n                    case \"START\":\n                        {\n                            // #EXT-X-START\n                            parsed.startTimeOffset = parseStartTimeOffset(attributes);\n                            break;\n                        }\n                }\n            }\n        }\n        // Filter out levels with unknown codecs if it does not remove all levels\n        const stripUnknownCodecLevels = levelsWithKnownCodecs.length > 0 && levelsWithKnownCodecs.length < parsed.levels.length;\n        parsed.levels = stripUnknownCodecLevels ? levelsWithKnownCodecs : parsed.levels;\n        if (parsed.levels.length === 0) {\n            parsed.playlistParsingError = new Error(\"no levels found in manifest\");\n        }\n        return parsed;\n    }\n    static parseMasterPlaylistMedia(string, baseurl, parsed) {\n        let result;\n        const results = {};\n        const levels = parsed.levels;\n        const groupsByType = {\n            AUDIO: levels.map((level)=>({\n                    id: level.attrs.AUDIO,\n                    audioCodec: level.audioCodec\n                })),\n            SUBTITLES: levels.map((level)=>({\n                    id: level.attrs.SUBTITLES,\n                    textCodec: level.textCodec\n                })),\n            \"CLOSED-CAPTIONS\": []\n        };\n        let id = 0;\n        MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;\n        while((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) !== null){\n            const attrs = new AttrList(result[1]);\n            const type = attrs.TYPE;\n            if (type) {\n                const groups = groupsByType[type];\n                const medias = results[type] || [];\n                results[type] = medias;\n                {\n                    substituteVariablesInAttributes(parsed, attrs, [\n                        \"URI\",\n                        \"GROUP-ID\",\n                        \"LANGUAGE\",\n                        \"ASSOC-LANGUAGE\",\n                        \"STABLE-RENDITION-ID\",\n                        \"NAME\",\n                        \"INSTREAM-ID\",\n                        \"CHARACTERISTICS\",\n                        \"CHANNELS\"\n                    ]);\n                }\n                const lang = attrs.LANGUAGE;\n                const assocLang = attrs[\"ASSOC-LANGUAGE\"];\n                const channels = attrs.CHANNELS;\n                const characteristics = attrs.CHARACTERISTICS;\n                const instreamId = attrs[\"INSTREAM-ID\"];\n                const media = {\n                    attrs,\n                    bitrate: 0,\n                    id: id++,\n                    groupId: attrs[\"GROUP-ID\"] || \"\",\n                    name: attrs.NAME || lang || \"\",\n                    type,\n                    default: attrs.bool(\"DEFAULT\"),\n                    autoselect: attrs.bool(\"AUTOSELECT\"),\n                    forced: attrs.bool(\"FORCED\"),\n                    lang,\n                    url: attrs.URI ? M3U8Parser.resolve(attrs.URI, baseurl) : \"\"\n                };\n                if (assocLang) {\n                    media.assocLang = assocLang;\n                }\n                if (channels) {\n                    media.channels = channels;\n                }\n                if (characteristics) {\n                    media.characteristics = characteristics;\n                }\n                if (instreamId) {\n                    media.instreamId = instreamId;\n                }\n                if (groups != null && groups.length) {\n                    // If there are audio or text groups signalled in the manifest, let's look for a matching codec string for this track\n                    // If we don't find the track signalled, lets use the first audio groups codec we have\n                    // Acting as a best guess\n                    const groupCodec = M3U8Parser.findGroup(groups, media.groupId) || groups[0];\n                    assignCodec(media, groupCodec, \"audioCodec\");\n                    assignCodec(media, groupCodec, \"textCodec\");\n                }\n                medias.push(media);\n            }\n        }\n        return results;\n    }\n    static parseLevelPlaylist(string, baseurl, id, type, levelUrlId, multivariantVariableList) {\n        const level = new LevelDetails(baseurl);\n        const fragments = level.fragments;\n        // The most recent init segment seen (applies to all subsequent segments)\n        let currentInitSegment = null;\n        let currentSN = 0;\n        let currentPart = 0;\n        let totalduration = 0;\n        let discontinuityCounter = 0;\n        let prevFrag = null;\n        let frag = new Fragment(type, baseurl);\n        let result;\n        let i;\n        let levelkeys;\n        let firstPdtIndex = -1;\n        let createNextFrag = false;\n        let nextByteRange = null;\n        LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;\n        level.m3u8 = string;\n        level.hasVariableRefs = hasVariableReferences(string);\n        while((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null){\n            if (createNextFrag) {\n                createNextFrag = false;\n                frag = new Fragment(type, baseurl);\n                // setup the next fragment for part loading\n                frag.start = totalduration;\n                frag.sn = currentSN;\n                frag.cc = discontinuityCounter;\n                frag.level = id;\n                if (currentInitSegment) {\n                    frag.initSegment = currentInitSegment;\n                    frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;\n                    currentInitSegment.rawProgramDateTime = null;\n                    if (nextByteRange) {\n                        frag.setByteRange(nextByteRange);\n                        nextByteRange = null;\n                    }\n                }\n            }\n            const duration = result[1];\n            if (duration) {\n                // INF\n                frag.duration = parseFloat(duration);\n                // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n                const title = (\" \" + result[2]).slice(1);\n                frag.title = title || null;\n                frag.tagList.push(title ? [\n                    \"INF\",\n                    duration,\n                    title\n                ] : [\n                    \"INF\",\n                    duration\n                ]);\n            } else if (result[3]) {\n                // url\n                if (isFiniteNumber(frag.duration)) {\n                    frag.start = totalduration;\n                    if (levelkeys) {\n                        setFragLevelKeys(frag, levelkeys, level);\n                    }\n                    frag.sn = currentSN;\n                    frag.level = id;\n                    frag.cc = discontinuityCounter;\n                    fragments.push(frag);\n                    // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n                    const uri = (\" \" + result[3]).slice(1);\n                    frag.relurl = substituteVariables(level, uri);\n                    assignProgramDateTime(frag, prevFrag);\n                    prevFrag = frag;\n                    totalduration += frag.duration;\n                    currentSN++;\n                    currentPart = 0;\n                    createNextFrag = true;\n                }\n            } else if (result[4]) {\n                // X-BYTERANGE\n                const data = (\" \" + result[4]).slice(1);\n                if (prevFrag) {\n                    frag.setByteRange(data, prevFrag);\n                } else {\n                    frag.setByteRange(data);\n                }\n            } else if (result[5]) {\n                // PROGRAM-DATE-TIME\n                // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n                frag.rawProgramDateTime = (\" \" + result[5]).slice(1);\n                frag.tagList.push([\n                    \"PROGRAM-DATE-TIME\",\n                    frag.rawProgramDateTime\n                ]);\n                if (firstPdtIndex === -1) {\n                    firstPdtIndex = fragments.length;\n                }\n            } else {\n                result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);\n                if (!result) {\n                    logger.warn(\"No matches on slow regex match for level playlist!\");\n                    continue;\n                }\n                for(i = 1; i < result.length; i++){\n                    if (typeof result[i] !== \"undefined\") {\n                        break;\n                    }\n                }\n                // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n                const tag = (\" \" + result[i]).slice(1);\n                const value1 = (\" \" + result[i + 1]).slice(1);\n                const value2 = result[i + 2] ? (\" \" + result[i + 2]).slice(1) : \"\";\n                switch(tag){\n                    case \"PLAYLIST-TYPE\":\n                        level.type = value1.toUpperCase();\n                        break;\n                    case \"MEDIA-SEQUENCE\":\n                        currentSN = level.startSN = parseInt(value1);\n                        break;\n                    case \"SKIP\":\n                        {\n                            const skipAttrs = new AttrList(value1);\n                            {\n                                substituteVariablesInAttributes(level, skipAttrs, [\n                                    \"RECENTLY-REMOVED-DATERANGES\"\n                                ]);\n                            }\n                            const skippedSegments = skipAttrs.decimalInteger(\"SKIPPED-SEGMENTS\");\n                            if (isFiniteNumber(skippedSegments)) {\n                                level.skippedSegments = skippedSegments;\n                                // This will result in fragments[] containing undefined values, which we will fill in with `mergeDetails`\n                                for(let _i = skippedSegments; _i--;){\n                                    fragments.unshift(null);\n                                }\n                                currentSN += skippedSegments;\n                            }\n                            const recentlyRemovedDateranges = skipAttrs.enumeratedString(\"RECENTLY-REMOVED-DATERANGES\");\n                            if (recentlyRemovedDateranges) {\n                                level.recentlyRemovedDateranges = recentlyRemovedDateranges.split(\"\t\");\n                            }\n                            break;\n                        }\n                    case \"TARGETDURATION\":\n                        level.targetduration = Math.max(parseInt(value1), 1);\n                        break;\n                    case \"VERSION\":\n                        level.version = parseInt(value1);\n                        break;\n                    case \"INDEPENDENT-SEGMENTS\":\n                    case \"EXTM3U\":\n                        break;\n                    case \"ENDLIST\":\n                        level.live = false;\n                        break;\n                    case \"#\":\n                        if (value1 || value2) {\n                            frag.tagList.push(value2 ? [\n                                value1,\n                                value2\n                            ] : [\n                                value1\n                            ]);\n                        }\n                        break;\n                    case \"DISCONTINUITY\":\n                        discontinuityCounter++;\n                        frag.tagList.push([\n                            \"DIS\"\n                        ]);\n                        break;\n                    case \"GAP\":\n                        frag.gap = true;\n                        frag.tagList.push([\n                            tag\n                        ]);\n                        break;\n                    case \"BITRATE\":\n                        frag.tagList.push([\n                            tag,\n                            value1\n                        ]);\n                        break;\n                    case \"DATERANGE\":\n                        {\n                            const dateRangeAttr = new AttrList(value1);\n                            {\n                                substituteVariablesInAttributes(level, dateRangeAttr, [\n                                    \"ID\",\n                                    \"CLASS\",\n                                    \"START-DATE\",\n                                    \"END-DATE\",\n                                    \"SCTE35-CMD\",\n                                    \"SCTE35-OUT\",\n                                    \"SCTE35-IN\"\n                                ]);\n                                substituteVariablesInAttributes(level, dateRangeAttr, dateRangeAttr.clientAttrs);\n                            }\n                            const dateRange = new DateRange(dateRangeAttr, level.dateRanges[dateRangeAttr.ID]);\n                            if (dateRange.isValid || level.skippedSegments) {\n                                level.dateRanges[dateRange.id] = dateRange;\n                            } else {\n                                logger.warn(`Ignoring invalid DATERANGE tag: \"${value1}\"`);\n                            }\n                            // Add to fragment tag list for backwards compatibility (< v1.2.0)\n                            frag.tagList.push([\n                                \"EXT-X-DATERANGE\",\n                                value1\n                            ]);\n                            break;\n                        }\n                    case \"DEFINE\":\n                        {\n                            {\n                                const variableAttributes = new AttrList(value1);\n                                substituteVariablesInAttributes(level, variableAttributes, [\n                                    \"NAME\",\n                                    \"VALUE\",\n                                    \"IMPORT\",\n                                    \"QUERYPARAM\"\n                                ]);\n                                if (\"IMPORT\" in variableAttributes) {\n                                    importVariableDefinition(level, variableAttributes, multivariantVariableList);\n                                } else {\n                                    addVariableDefinition(level, variableAttributes, baseurl);\n                                }\n                            }\n                            break;\n                        }\n                    case \"DISCONTINUITY-SEQUENCE\":\n                        discontinuityCounter = parseInt(value1);\n                        break;\n                    case \"KEY\":\n                        {\n                            const levelKey = parseKey(value1, baseurl, level);\n                            if (levelKey.isSupported()) {\n                                if (levelKey.method === \"NONE\") {\n                                    levelkeys = undefined;\n                                    break;\n                                }\n                                if (!levelkeys) {\n                                    levelkeys = {};\n                                }\n                                if (levelkeys[levelKey.keyFormat]) {\n                                    levelkeys = _extends({}, levelkeys);\n                                }\n                                levelkeys[levelKey.keyFormat] = levelKey;\n                            } else {\n                                logger.warn(`[Keys] Ignoring invalid EXT-X-KEY tag: \"${value1}\"`);\n                            }\n                            break;\n                        }\n                    case \"START\":\n                        level.startTimeOffset = parseStartTimeOffset(value1);\n                        break;\n                    case \"MAP\":\n                        {\n                            const mapAttrs = new AttrList(value1);\n                            {\n                                substituteVariablesInAttributes(level, mapAttrs, [\n                                    \"BYTERANGE\",\n                                    \"URI\"\n                                ]);\n                            }\n                            if (frag.duration) {\n                                // Initial segment tag is after segment duration tag.\n                                //   #EXTINF: 6.0\n                                //   #EXT-X-MAP:URI=\"init.mp4\n                                const init = new Fragment(type, baseurl);\n                                setInitSegment(init, mapAttrs, id, levelkeys);\n                                currentInitSegment = init;\n                                frag.initSegment = currentInitSegment;\n                                if (currentInitSegment.rawProgramDateTime && !frag.rawProgramDateTime) {\n                                    frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;\n                                }\n                            } else {\n                                // Initial segment tag is before segment duration tag\n                                // Handle case where EXT-X-MAP is declared after EXT-X-BYTERANGE\n                                const end = frag.byteRangeEndOffset;\n                                if (end) {\n                                    const start = frag.byteRangeStartOffset;\n                                    nextByteRange = `${end - start}@${start}`;\n                                } else {\n                                    nextByteRange = null;\n                                }\n                                setInitSegment(frag, mapAttrs, id, levelkeys);\n                                currentInitSegment = frag;\n                                createNextFrag = true;\n                            }\n                            break;\n                        }\n                    case \"SERVER-CONTROL\":\n                        {\n                            const serverControlAttrs = new AttrList(value1);\n                            level.canBlockReload = serverControlAttrs.bool(\"CAN-BLOCK-RELOAD\");\n                            level.canSkipUntil = serverControlAttrs.optionalFloat(\"CAN-SKIP-UNTIL\", 0);\n                            level.canSkipDateRanges = level.canSkipUntil > 0 && serverControlAttrs.bool(\"CAN-SKIP-DATERANGES\");\n                            level.partHoldBack = serverControlAttrs.optionalFloat(\"PART-HOLD-BACK\", 0);\n                            level.holdBack = serverControlAttrs.optionalFloat(\"HOLD-BACK\", 0);\n                            break;\n                        }\n                    case \"PART-INF\":\n                        {\n                            const partInfAttrs = new AttrList(value1);\n                            level.partTarget = partInfAttrs.decimalFloatingPoint(\"PART-TARGET\");\n                            break;\n                        }\n                    case \"PART\":\n                        {\n                            let partList = level.partList;\n                            if (!partList) {\n                                partList = level.partList = [];\n                            }\n                            const previousFragmentPart = currentPart > 0 ? partList[partList.length - 1] : undefined;\n                            const index = currentPart++;\n                            const partAttrs = new AttrList(value1);\n                            {\n                                substituteVariablesInAttributes(level, partAttrs, [\n                                    \"BYTERANGE\",\n                                    \"URI\"\n                                ]);\n                            }\n                            const part = new Part(partAttrs, frag, baseurl, index, previousFragmentPart);\n                            partList.push(part);\n                            frag.duration += part.duration;\n                            break;\n                        }\n                    case \"PRELOAD-HINT\":\n                        {\n                            const preloadHintAttrs = new AttrList(value1);\n                            {\n                                substituteVariablesInAttributes(level, preloadHintAttrs, [\n                                    \"URI\"\n                                ]);\n                            }\n                            level.preloadHint = preloadHintAttrs;\n                            break;\n                        }\n                    case \"RENDITION-REPORT\":\n                        {\n                            const renditionReportAttrs = new AttrList(value1);\n                            {\n                                substituteVariablesInAttributes(level, renditionReportAttrs, [\n                                    \"URI\"\n                                ]);\n                            }\n                            level.renditionReports = level.renditionReports || [];\n                            level.renditionReports.push(renditionReportAttrs);\n                            break;\n                        }\n                    default:\n                        logger.warn(`line parsed but not handled: ${result}`);\n                        break;\n                }\n            }\n        }\n        if (prevFrag && !prevFrag.relurl) {\n            fragments.pop();\n            totalduration -= prevFrag.duration;\n            if (level.partList) {\n                level.fragmentHint = prevFrag;\n            }\n        } else if (level.partList) {\n            assignProgramDateTime(frag, prevFrag);\n            frag.cc = discontinuityCounter;\n            level.fragmentHint = frag;\n            if (levelkeys) {\n                setFragLevelKeys(frag, levelkeys, level);\n            }\n        }\n        const fragmentLength = fragments.length;\n        const firstFragment = fragments[0];\n        const lastFragment = fragments[fragmentLength - 1];\n        totalduration += level.skippedSegments * level.targetduration;\n        if (totalduration > 0 && fragmentLength && lastFragment) {\n            level.averagetargetduration = totalduration / fragmentLength;\n            const lastSn = lastFragment.sn;\n            level.endSN = lastSn !== \"initSegment\" ? lastSn : 0;\n            if (!level.live) {\n                lastFragment.endList = true;\n            }\n            if (firstFragment) {\n                level.startCC = firstFragment.cc;\n            }\n        } else {\n            level.endSN = 0;\n            level.startCC = 0;\n        }\n        if (level.fragmentHint) {\n            totalduration += level.fragmentHint.duration;\n        }\n        level.totalduration = totalduration;\n        level.endCC = discontinuityCounter;\n        /**\n     * Backfill any missing PDT values\n     * \"If the first EXT-X-PROGRAM-DATE-TIME tag in a Playlist appears after\n     * one or more Media Segment URIs, the client SHOULD extrapolate\n     * backward from that tag (using EXTINF durations and/or media\n     * timestamps) to associate dates with those segments.\"\n     * We have already extrapolated forward, but all fragments up to the first instance of PDT do not have their PDTs\n     * computed.\n     */ if (firstPdtIndex > 0) {\n            backfillProgramDateTimes(fragments, firstPdtIndex);\n        }\n        return level;\n    }\n}\nfunction parseKey(keyTagAttributes, baseurl, parsed) {\n    var _keyAttrs$METHOD, _keyAttrs$KEYFORMAT;\n    // https://tools.ietf.org/html/rfc8216#section-4.3.2.4\n    const keyAttrs = new AttrList(keyTagAttributes);\n    {\n        substituteVariablesInAttributes(parsed, keyAttrs, [\n            \"KEYFORMAT\",\n            \"KEYFORMATVERSIONS\",\n            \"URI\",\n            \"IV\",\n            \"URI\"\n        ]);\n    }\n    const decryptmethod = (_keyAttrs$METHOD = keyAttrs.METHOD) != null ? _keyAttrs$METHOD : \"\";\n    const decrypturi = keyAttrs.URI;\n    const decryptiv = keyAttrs.hexadecimalInteger(\"IV\");\n    const decryptkeyformatversions = keyAttrs.KEYFORMATVERSIONS;\n    // From RFC: This attribute is OPTIONAL; its absence indicates an implicit value of \"identity\".\n    const decryptkeyformat = (_keyAttrs$KEYFORMAT = keyAttrs.KEYFORMAT) != null ? _keyAttrs$KEYFORMAT : \"identity\";\n    if (decrypturi && keyAttrs.IV && !decryptiv) {\n        logger.error(`Invalid IV: ${keyAttrs.IV}`);\n    }\n    // If decrypturi is a URI with a scheme, then baseurl will be ignored\n    // No uri is allowed when METHOD is NONE\n    const resolvedUri = decrypturi ? M3U8Parser.resolve(decrypturi, baseurl) : \"\";\n    const keyFormatVersions = (decryptkeyformatversions ? decryptkeyformatversions : \"1\").split(\"/\").map(Number).filter(Number.isFinite);\n    return new LevelKey(decryptmethod, resolvedUri, decryptkeyformat, keyFormatVersions, decryptiv);\n}\nfunction parseStartTimeOffset(startAttributes) {\n    const startAttrs = new AttrList(startAttributes);\n    const startTimeOffset = startAttrs.decimalFloatingPoint(\"TIME-OFFSET\");\n    if (isFiniteNumber(startTimeOffset)) {\n        return startTimeOffset;\n    }\n    return null;\n}\nfunction setCodecs(codecsAttributeValue, level) {\n    let codecs = (codecsAttributeValue || \"\").split(/[ ,]+/).filter((c)=>c);\n    [\n        \"video\",\n        \"audio\",\n        \"text\"\n    ].forEach((type)=>{\n        const filtered = codecs.filter((codec)=>isCodecType(codec, type));\n        if (filtered.length) {\n            // Comma separated list of all codecs for type\n            level[`${type}Codec`] = filtered.join(\",\");\n            // Remove known codecs so that only unknownCodecs are left after iterating through each type\n            codecs = codecs.filter((codec)=>filtered.indexOf(codec) === -1);\n        }\n    });\n    level.unknownCodecs = codecs;\n}\nfunction assignCodec(media, groupItem, codecProperty) {\n    const codecValue = groupItem[codecProperty];\n    if (codecValue) {\n        media[codecProperty] = codecValue;\n    }\n}\nfunction backfillProgramDateTimes(fragments, firstPdtIndex) {\n    let fragPrev = fragments[firstPdtIndex];\n    for(let i = firstPdtIndex; i--;){\n        const frag = fragments[i];\n        // Exit on delta-playlist skipped segments\n        if (!frag) {\n            return;\n        }\n        frag.programDateTime = fragPrev.programDateTime - frag.duration * 1000;\n        fragPrev = frag;\n    }\n}\nfunction assignProgramDateTime(frag, prevFrag) {\n    if (frag.rawProgramDateTime) {\n        frag.programDateTime = Date.parse(frag.rawProgramDateTime);\n    } else if (prevFrag != null && prevFrag.programDateTime) {\n        frag.programDateTime = prevFrag.endProgramDateTime;\n    }\n    if (!isFiniteNumber(frag.programDateTime)) {\n        frag.programDateTime = null;\n        frag.rawProgramDateTime = null;\n    }\n}\nfunction setInitSegment(frag, mapAttrs, id, levelkeys) {\n    frag.relurl = mapAttrs.URI;\n    if (mapAttrs.BYTERANGE) {\n        frag.setByteRange(mapAttrs.BYTERANGE);\n    }\n    frag.level = id;\n    frag.sn = \"initSegment\";\n    if (levelkeys) {\n        frag.levelkeys = levelkeys;\n    }\n    frag.initSegment = null;\n}\nfunction setFragLevelKeys(frag, levelkeys, level) {\n    frag.levelkeys = levelkeys;\n    const { encryptedFragments } = level;\n    if ((!encryptedFragments.length || encryptedFragments[encryptedFragments.length - 1].levelkeys !== levelkeys) && Object.keys(levelkeys).some((format)=>levelkeys[format].isCommonEncryption)) {\n        encryptedFragments.push(frag);\n    }\n}\nvar PlaylistContextType = {\n    MANIFEST: \"manifest\",\n    LEVEL: \"level\",\n    AUDIO_TRACK: \"audioTrack\",\n    SUBTITLE_TRACK: \"subtitleTrack\"\n};\nvar PlaylistLevelType = {\n    MAIN: \"main\",\n    AUDIO: \"audio\",\n    SUBTITLE: \"subtitle\"\n};\nfunction mapContextToLevelType(context) {\n    const { type } = context;\n    switch(type){\n        case PlaylistContextType.AUDIO_TRACK:\n            return PlaylistLevelType.AUDIO;\n        case PlaylistContextType.SUBTITLE_TRACK:\n            return PlaylistLevelType.SUBTITLE;\n        default:\n            return PlaylistLevelType.MAIN;\n    }\n}\nfunction getResponseUrl(response, context) {\n    let url = response.url;\n    // responseURL not supported on some browsers (it is used to detect URL redirection)\n    // data-uri mode also not supported (but no need to detect redirection)\n    if (url === undefined || url.indexOf(\"data:\") === 0) {\n        // fallback to initial URL\n        url = context.url;\n    }\n    return url;\n}\nclass PlaylistLoader {\n    constructor(hls){\n        this.hls = void 0;\n        this.loaders = Object.create(null);\n        this.variableList = null;\n        this.hls = hls;\n        this.registerListeners();\n    }\n    startLoad(startPosition) {}\n    stopLoad() {\n        this.destroyInternalLoaders();\n    }\n    registerListeners() {\n        const { hls } = this;\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n        hls.on(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);\n        hls.on(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);\n    }\n    unregisterListeners() {\n        const { hls } = this;\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);\n        hls.off(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);\n        hls.off(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);\n    }\n    /**\n   * Returns defaults or configured loader-type overloads (pLoader and loader config params)\n   */ createInternalLoader(context) {\n        const config = this.hls.config;\n        const PLoader = config.pLoader;\n        const Loader = config.loader;\n        const InternalLoader = PLoader || Loader;\n        const loader = new InternalLoader(config);\n        this.loaders[context.type] = loader;\n        return loader;\n    }\n    getInternalLoader(context) {\n        return this.loaders[context.type];\n    }\n    resetInternalLoader(contextType) {\n        if (this.loaders[contextType]) {\n            delete this.loaders[contextType];\n        }\n    }\n    /**\n   * Call `destroy` on all internal loader instances mapped (one per context type)\n   */ destroyInternalLoaders() {\n        for(const contextType in this.loaders){\n            const loader = this.loaders[contextType];\n            if (loader) {\n                loader.destroy();\n            }\n            this.resetInternalLoader(contextType);\n        }\n    }\n    destroy() {\n        this.variableList = null;\n        this.unregisterListeners();\n        this.destroyInternalLoaders();\n    }\n    onManifestLoading(event, data) {\n        const { url } = data;\n        this.variableList = null;\n        this.load({\n            id: null,\n            level: 0,\n            responseType: \"text\",\n            type: PlaylistContextType.MANIFEST,\n            url,\n            deliveryDirectives: null\n        });\n    }\n    onLevelLoading(event, data) {\n        const { id, level, pathwayId, url, deliveryDirectives } = data;\n        this.load({\n            id,\n            level,\n            pathwayId,\n            responseType: \"text\",\n            type: PlaylistContextType.LEVEL,\n            url,\n            deliveryDirectives\n        });\n    }\n    onAudioTrackLoading(event, data) {\n        const { id, groupId, url, deliveryDirectives } = data;\n        this.load({\n            id,\n            groupId,\n            level: null,\n            responseType: \"text\",\n            type: PlaylistContextType.AUDIO_TRACK,\n            url,\n            deliveryDirectives\n        });\n    }\n    onSubtitleTrackLoading(event, data) {\n        const { id, groupId, url, deliveryDirectives } = data;\n        this.load({\n            id,\n            groupId,\n            level: null,\n            responseType: \"text\",\n            type: PlaylistContextType.SUBTITLE_TRACK,\n            url,\n            deliveryDirectives\n        });\n    }\n    load(context) {\n        var _context$deliveryDire;\n        const config = this.hls.config;\n        // logger.debug(`[playlist-loader]: Loading playlist of type ${context.type}, level: ${context.level}, id: ${context.id}`);\n        // Check if a loader for this context already exists\n        let loader = this.getInternalLoader(context);\n        if (loader) {\n            const loaderContext = loader.context;\n            if (loaderContext && loaderContext.url === context.url && loaderContext.level === context.level) {\n                // same URL can't overlap\n                logger.trace(\"[playlist-loader]: playlist request ongoing\");\n                return;\n            }\n            logger.log(`[playlist-loader]: aborting previous loader for type: ${context.type}`);\n            loader.abort();\n        }\n        // apply different configs for retries depending on\n        // context (manifest, level, audio/subs playlist)\n        let loadPolicy;\n        if (context.type === PlaylistContextType.MANIFEST) {\n            loadPolicy = config.manifestLoadPolicy.default;\n        } else {\n            loadPolicy = _extends({}, config.playlistLoadPolicy.default, {\n                timeoutRetry: null,\n                errorRetry: null\n            });\n        }\n        loader = this.createInternalLoader(context);\n        // Override level/track timeout for LL-HLS requests\n        // (the default of 10000ms is counter productive to blocking playlist reload requests)\n        if (isFiniteNumber((_context$deliveryDire = context.deliveryDirectives) == null ? void 0 : _context$deliveryDire.part)) {\n            let levelDetails;\n            if (context.type === PlaylistContextType.LEVEL && context.level !== null) {\n                levelDetails = this.hls.levels[context.level].details;\n            } else if (context.type === PlaylistContextType.AUDIO_TRACK && context.id !== null) {\n                levelDetails = this.hls.audioTracks[context.id].details;\n            } else if (context.type === PlaylistContextType.SUBTITLE_TRACK && context.id !== null) {\n                levelDetails = this.hls.subtitleTracks[context.id].details;\n            }\n            if (levelDetails) {\n                const partTarget = levelDetails.partTarget;\n                const targetDuration = levelDetails.targetduration;\n                if (partTarget && targetDuration) {\n                    const maxLowLatencyPlaylistRefresh = Math.max(partTarget * 3, targetDuration * 0.8) * 1000;\n                    loadPolicy = _extends({}, loadPolicy, {\n                        maxTimeToFirstByteMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs),\n                        maxLoadTimeMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs)\n                    });\n                }\n            }\n        }\n        const legacyRetryCompatibility = loadPolicy.errorRetry || loadPolicy.timeoutRetry || {};\n        const loaderConfig = {\n            loadPolicy,\n            timeout: loadPolicy.maxLoadTimeMs,\n            maxRetry: legacyRetryCompatibility.maxNumRetry || 0,\n            retryDelay: legacyRetryCompatibility.retryDelayMs || 0,\n            maxRetryDelay: legacyRetryCompatibility.maxRetryDelayMs || 0\n        };\n        const loaderCallbacks = {\n            onSuccess: (response, stats, context, networkDetails)=>{\n                const loader = this.getInternalLoader(context);\n                this.resetInternalLoader(context.type);\n                const string = response.data;\n                // Validate if it is an M3U8 at all\n                if (string.indexOf(\"#EXTM3U\") !== 0) {\n                    this.handleManifestParsingError(response, context, new Error(\"no EXTM3U delimiter\"), networkDetails || null, stats);\n                    return;\n                }\n                stats.parsing.start = performance.now();\n                if (M3U8Parser.isMediaPlaylist(string)) {\n                    this.handleTrackOrLevelPlaylist(response, stats, context, networkDetails || null, loader);\n                } else {\n                    this.handleMasterPlaylist(response, stats, context, networkDetails);\n                }\n            },\n            onError: (response, context, networkDetails, stats)=>{\n                this.handleNetworkError(context, networkDetails, false, response, stats);\n            },\n            onTimeout: (stats, context, networkDetails)=>{\n                this.handleNetworkError(context, networkDetails, true, undefined, stats);\n            }\n        };\n        // logger.debug(`[playlist-loader]: Calling internal loader delegate for URL: ${context.url}`);\n        loader.load(context, loaderConfig, loaderCallbacks);\n    }\n    handleMasterPlaylist(response, stats, context, networkDetails) {\n        const hls = this.hls;\n        const string = response.data;\n        const url = getResponseUrl(response, context);\n        const parsedResult = M3U8Parser.parseMasterPlaylist(string, url);\n        if (parsedResult.playlistParsingError) {\n            this.handleManifestParsingError(response, context, parsedResult.playlistParsingError, networkDetails, stats);\n            return;\n        }\n        const { contentSteering, levels, sessionData, sessionKeys, startTimeOffset, variableList } = parsedResult;\n        this.variableList = variableList;\n        const { AUDIO: audioTracks = [], SUBTITLES: subtitles, \"CLOSED-CAPTIONS\": captions } = M3U8Parser.parseMasterPlaylistMedia(string, url, parsedResult);\n        if (audioTracks.length) {\n            // check if we have found an audio track embedded in main playlist (audio track without URI attribute)\n            const embeddedAudioFound = audioTracks.some((audioTrack)=>!audioTrack.url);\n            // if no embedded audio track defined, but audio codec signaled in quality level,\n            // we need to signal this main audio track this could happen with playlists with\n            // alt audio rendition in which quality levels (main)\n            // contains both audio+video. but with mixed audio track not signaled\n            if (!embeddedAudioFound && levels[0].audioCodec && !levels[0].attrs.AUDIO) {\n                logger.log(\"[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one\");\n                audioTracks.unshift({\n                    type: \"main\",\n                    name: \"main\",\n                    groupId: \"main\",\n                    default: false,\n                    autoselect: false,\n                    forced: false,\n                    id: -1,\n                    attrs: new AttrList({}),\n                    bitrate: 0,\n                    url: \"\"\n                });\n            }\n        }\n        hls.trigger(Events.MANIFEST_LOADED, {\n            levels,\n            audioTracks,\n            subtitles,\n            captions,\n            contentSteering,\n            url,\n            stats,\n            networkDetails,\n            sessionData,\n            sessionKeys,\n            startTimeOffset,\n            variableList\n        });\n    }\n    handleTrackOrLevelPlaylist(response, stats, context, networkDetails, loader) {\n        const hls = this.hls;\n        const { id, level, type } = context;\n        const url = getResponseUrl(response, context);\n        const levelUrlId = 0;\n        const levelId = isFiniteNumber(level) ? level : isFiniteNumber(id) ? id : 0;\n        const levelType = mapContextToLevelType(context);\n        const levelDetails = M3U8Parser.parseLevelPlaylist(response.data, url, levelId, levelType, levelUrlId, this.variableList);\n        // We have done our first request (Manifest-type) and receive\n        // not a master playlist but a chunk-list (track/level)\n        // We fire the manifest-loaded event anyway with the parsed level-details\n        // by creating a single-level structure for it.\n        if (type === PlaylistContextType.MANIFEST) {\n            const singleLevel = {\n                attrs: new AttrList({}),\n                bitrate: 0,\n                details: levelDetails,\n                name: \"\",\n                url\n            };\n            hls.trigger(Events.MANIFEST_LOADED, {\n                levels: [\n                    singleLevel\n                ],\n                audioTracks: [],\n                url,\n                stats,\n                networkDetails,\n                sessionData: null,\n                sessionKeys: null,\n                contentSteering: null,\n                startTimeOffset: null,\n                variableList: null\n            });\n        }\n        // save parsing time\n        stats.parsing.end = performance.now();\n        // extend the context with the new levelDetails property\n        context.levelDetails = levelDetails;\n        this.handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader);\n    }\n    handleManifestParsingError(response, context, error, networkDetails, stats) {\n        this.hls.trigger(Events.ERROR, {\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.MANIFEST_PARSING_ERROR,\n            fatal: context.type === PlaylistContextType.MANIFEST,\n            url: response.url,\n            err: error,\n            error,\n            reason: error.message,\n            response,\n            context,\n            networkDetails,\n            stats\n        });\n    }\n    handleNetworkError(context, networkDetails, timeout = false, response, stats) {\n        let message = `A network ${timeout ? \"timeout\" : \"error\" + (response ? \" (status \" + response.code + \")\" : \"\")} occurred while loading ${context.type}`;\n        if (context.type === PlaylistContextType.LEVEL) {\n            message += `: ${context.level} id: ${context.id}`;\n        } else if (context.type === PlaylistContextType.AUDIO_TRACK || context.type === PlaylistContextType.SUBTITLE_TRACK) {\n            message += ` id: ${context.id} group-id: \"${context.groupId}\"`;\n        }\n        const error = new Error(message);\n        logger.warn(`[playlist-loader]: ${message}`);\n        let details = ErrorDetails.UNKNOWN;\n        let fatal = false;\n        const loader = this.getInternalLoader(context);\n        switch(context.type){\n            case PlaylistContextType.MANIFEST:\n                details = timeout ? ErrorDetails.MANIFEST_LOAD_TIMEOUT : ErrorDetails.MANIFEST_LOAD_ERROR;\n                fatal = true;\n                break;\n            case PlaylistContextType.LEVEL:\n                details = timeout ? ErrorDetails.LEVEL_LOAD_TIMEOUT : ErrorDetails.LEVEL_LOAD_ERROR;\n                fatal = false;\n                break;\n            case PlaylistContextType.AUDIO_TRACK:\n                details = timeout ? ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT : ErrorDetails.AUDIO_TRACK_LOAD_ERROR;\n                fatal = false;\n                break;\n            case PlaylistContextType.SUBTITLE_TRACK:\n                details = timeout ? ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT : ErrorDetails.SUBTITLE_LOAD_ERROR;\n                fatal = false;\n                break;\n        }\n        if (loader) {\n            this.resetInternalLoader(context.type);\n        }\n        const errorData = {\n            type: ErrorTypes.NETWORK_ERROR,\n            details,\n            fatal,\n            url: context.url,\n            loader,\n            context,\n            error,\n            networkDetails,\n            stats\n        };\n        if (response) {\n            const url = (networkDetails == null ? void 0 : networkDetails.url) || context.url;\n            errorData.response = _objectSpread2({\n                url,\n                data: undefined\n            }, response);\n        }\n        this.hls.trigger(Events.ERROR, errorData);\n    }\n    handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader) {\n        const hls = this.hls;\n        const { type, level, id, groupId, deliveryDirectives } = context;\n        const url = getResponseUrl(response, context);\n        const parent = mapContextToLevelType(context);\n        const levelIndex = typeof context.level === \"number\" && parent === PlaylistLevelType.MAIN ? level : undefined;\n        if (!levelDetails.fragments.length) {\n            const _error = new Error(\"No Segments found in Playlist\");\n            hls.trigger(Events.ERROR, {\n                type: ErrorTypes.NETWORK_ERROR,\n                details: ErrorDetails.LEVEL_EMPTY_ERROR,\n                fatal: false,\n                url,\n                error: _error,\n                reason: _error.message,\n                response,\n                context,\n                level: levelIndex,\n                parent,\n                networkDetails,\n                stats\n            });\n            return;\n        }\n        if (!levelDetails.targetduration) {\n            levelDetails.playlistParsingError = new Error(\"Missing Target Duration\");\n        }\n        const error = levelDetails.playlistParsingError;\n        if (error) {\n            hls.trigger(Events.ERROR, {\n                type: ErrorTypes.NETWORK_ERROR,\n                details: ErrorDetails.LEVEL_PARSING_ERROR,\n                fatal: false,\n                url,\n                error,\n                reason: error.message,\n                response,\n                context,\n                level: levelIndex,\n                parent,\n                networkDetails,\n                stats\n            });\n            return;\n        }\n        if (levelDetails.live && loader) {\n            if (loader.getCacheAge) {\n                levelDetails.ageHeader = loader.getCacheAge() || 0;\n            }\n            if (!loader.getCacheAge || isNaN(levelDetails.ageHeader)) {\n                levelDetails.ageHeader = 0;\n            }\n        }\n        switch(type){\n            case PlaylistContextType.MANIFEST:\n            case PlaylistContextType.LEVEL:\n                hls.trigger(Events.LEVEL_LOADED, {\n                    details: levelDetails,\n                    level: levelIndex || 0,\n                    id: id || 0,\n                    stats,\n                    networkDetails,\n                    deliveryDirectives\n                });\n                break;\n            case PlaylistContextType.AUDIO_TRACK:\n                hls.trigger(Events.AUDIO_TRACK_LOADED, {\n                    details: levelDetails,\n                    id: id || 0,\n                    groupId: groupId || \"\",\n                    stats,\n                    networkDetails,\n                    deliveryDirectives\n                });\n                break;\n            case PlaylistContextType.SUBTITLE_TRACK:\n                hls.trigger(Events.SUBTITLE_TRACK_LOADED, {\n                    details: levelDetails,\n                    id: id || 0,\n                    groupId: groupId || \"\",\n                    stats,\n                    networkDetails,\n                    deliveryDirectives\n                });\n                break;\n        }\n    }\n}\nfunction sendAddTrackEvent(track, videoEl) {\n    let event;\n    try {\n        event = new Event(\"addtrack\");\n    } catch (err) {\n        // for IE11\n        event = document.createEvent(\"Event\");\n        event.initEvent(\"addtrack\", false, false);\n    }\n    event.track = track;\n    videoEl.dispatchEvent(event);\n}\nfunction addCueToTrack(track, cue) {\n    // Sometimes there are cue overlaps on segmented vtts so the same\n    // cue can appear more than once in different vtt files.\n    // This avoid showing duplicated cues with same timecode and text.\n    const mode = track.mode;\n    if (mode === \"disabled\") {\n        track.mode = \"hidden\";\n    }\n    if (track.cues && !track.cues.getCueById(cue.id)) {\n        try {\n            track.addCue(cue);\n            if (!track.cues.getCueById(cue.id)) {\n                throw new Error(`addCue is failed for: ${cue}`);\n            }\n        } catch (err) {\n            logger.debug(`[texttrack-utils]: ${err}`);\n            try {\n                const textTrackCue = new self.TextTrackCue(cue.startTime, cue.endTime, cue.text);\n                textTrackCue.id = cue.id;\n                track.addCue(textTrackCue);\n            } catch (err2) {\n                logger.debug(`[texttrack-utils]: Legacy TextTrackCue fallback failed: ${err2}`);\n            }\n        }\n    }\n    if (mode === \"disabled\") {\n        track.mode = mode;\n    }\n}\nfunction clearCurrentCues(track) {\n    // When track.mode is disabled, track.cues will be null.\n    // To guarantee the removal of cues, we need to temporarily\n    // change the mode to hidden\n    const mode = track.mode;\n    if (mode === \"disabled\") {\n        track.mode = \"hidden\";\n    }\n    if (track.cues) {\n        for(let i = track.cues.length; i--;){\n            track.removeCue(track.cues[i]);\n        }\n    }\n    if (mode === \"disabled\") {\n        track.mode = mode;\n    }\n}\nfunction removeCuesInRange(track, start, end, predicate) {\n    const mode = track.mode;\n    if (mode === \"disabled\") {\n        track.mode = \"hidden\";\n    }\n    if (track.cues && track.cues.length > 0) {\n        const cues = getCuesInRange(track.cues, start, end);\n        for(let i = 0; i < cues.length; i++){\n            if (!predicate || predicate(cues[i])) {\n                track.removeCue(cues[i]);\n            }\n        }\n    }\n    if (mode === \"disabled\") {\n        track.mode = mode;\n    }\n}\n// Find first cue starting after given time.\n// Modified version of binary search O(log(n)).\nfunction getFirstCueIndexAfterTime(cues, time) {\n    // If first cue starts after time, start there\n    if (time < cues[0].startTime) {\n        return 0;\n    }\n    // If the last cue ends before time there is no overlap\n    const len = cues.length - 1;\n    if (time > cues[len].endTime) {\n        return -1;\n    }\n    let left = 0;\n    let right = len;\n    while(left <= right){\n        const mid = Math.floor((right + left) / 2);\n        if (time < cues[mid].startTime) {\n            right = mid - 1;\n        } else if (time > cues[mid].startTime && left < len) {\n            left = mid + 1;\n        } else {\n            // If it's not lower or higher, it must be equal.\n            return mid;\n        }\n    }\n    // At this point, left and right have swapped.\n    // No direct match was found, left or right element must be the closest. Check which one has the smallest diff.\n    return cues[left].startTime - time < time - cues[right].startTime ? left : right;\n}\nfunction getCuesInRange(cues, start, end) {\n    const cuesFound = [];\n    const firstCueInRange = getFirstCueIndexAfterTime(cues, start);\n    if (firstCueInRange > -1) {\n        for(let i = firstCueInRange, len = cues.length; i < len; i++){\n            const cue = cues[i];\n            if (cue.startTime >= start && cue.endTime <= end) {\n                cuesFound.push(cue);\n            } else if (cue.startTime > end) {\n                return cuesFound;\n            }\n        }\n    }\n    return cuesFound;\n}\nfunction filterSubtitleTracks(textTrackList) {\n    const tracks = [];\n    for(let i = 0; i < textTrackList.length; i++){\n        const track = textTrackList[i];\n        // Edge adds a track without a label; we don't want to use it\n        if ((track.kind === \"subtitles\" || track.kind === \"captions\") && track.label) {\n            tracks.push(textTrackList[i]);\n        }\n    }\n    return tracks;\n}\nvar MetadataSchema = {\n    audioId3: \"org.id3\",\n    dateRange: \"com.apple.quicktime.HLS\",\n    emsg: \"https://aomedia.org/emsg/ID3\"\n};\nconst MIN_CUE_DURATION = 0.25;\nfunction getCueClass() {\n    if (typeof self === \"undefined\") return undefined;\n    return self.VTTCue || self.TextTrackCue;\n}\nfunction createCueWithDataFields(Cue, startTime, endTime, data, type) {\n    let cue = new Cue(startTime, endTime, \"\");\n    try {\n        cue.value = data;\n        if (type) {\n            cue.type = type;\n        }\n    } catch (e) {\n        cue = new Cue(startTime, endTime, JSON.stringify(type ? _objectSpread2({\n            type\n        }, data) : data));\n    }\n    return cue;\n}\n// VTTCue latest draft allows an infinite duration, fallback\n// to MAX_VALUE if necessary\nconst MAX_CUE_ENDTIME = (()=>{\n    const Cue = getCueClass();\n    try {\n        Cue && new Cue(0, Number.POSITIVE_INFINITY, \"\");\n    } catch (e) {\n        return Number.MAX_VALUE;\n    }\n    return Number.POSITIVE_INFINITY;\n})();\nfunction dateRangeDateToTimelineSeconds(date, offset) {\n    return date.getTime() / 1000 - offset;\n}\nfunction hexToArrayBuffer(str) {\n    return Uint8Array.from(str.replace(/^0x/, \"\").replace(/([\\da-fA-F]{2}) ?/g, \"0x$1 \").replace(/ +$/, \"\").split(\" \")).buffer;\n}\nclass ID3TrackController {\n    constructor(hls){\n        this.hls = void 0;\n        this.id3Track = null;\n        this.media = null;\n        this.dateRangeCuesAppended = {};\n        this.hls = hls;\n        this._registerListeners();\n    }\n    destroy() {\n        this._unregisterListeners();\n        this.id3Track = null;\n        this.media = null;\n        this.dateRangeCuesAppended = {};\n        // @ts-ignore\n        this.hls = null;\n    }\n    _registerListeners() {\n        const { hls } = this;\n        hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);\n        hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n        hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    }\n    _unregisterListeners() {\n        const { hls } = this;\n        hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);\n        hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n        hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    }\n    // Add ID3 metatadata text track.\n    onMediaAttached(event, data) {\n        this.media = data.media;\n    }\n    onMediaDetaching() {\n        if (!this.id3Track) {\n            return;\n        }\n        clearCurrentCues(this.id3Track);\n        this.id3Track = null;\n        this.media = null;\n        this.dateRangeCuesAppended = {};\n    }\n    onManifestLoading() {\n        this.dateRangeCuesAppended = {};\n    }\n    createTrack(media) {\n        const track = this.getID3Track(media.textTracks);\n        track.mode = \"hidden\";\n        return track;\n    }\n    getID3Track(textTracks) {\n        if (!this.media) {\n            return;\n        }\n        for(let i = 0; i < textTracks.length; i++){\n            const textTrack = textTracks[i];\n            if (textTrack.kind === \"metadata\" && textTrack.label === \"id3\") {\n                // send 'addtrack' when reusing the textTrack for metadata,\n                // same as what we do for captions\n                sendAddTrackEvent(textTrack, this.media);\n                return textTrack;\n            }\n        }\n        return this.media.addTextTrack(\"metadata\", \"id3\");\n    }\n    onFragParsingMetadata(event, data) {\n        if (!this.media) {\n            return;\n        }\n        const { hls: { config: { enableEmsgMetadataCues, enableID3MetadataCues } } } = this;\n        if (!enableEmsgMetadataCues && !enableID3MetadataCues) {\n            return;\n        }\n        const { samples } = data;\n        // create track dynamically\n        if (!this.id3Track) {\n            this.id3Track = this.createTrack(this.media);\n        }\n        const Cue = getCueClass();\n        if (!Cue) {\n            return;\n        }\n        for(let i = 0; i < samples.length; i++){\n            const type = samples[i].type;\n            if (type === MetadataSchema.emsg && !enableEmsgMetadataCues || !enableID3MetadataCues) {\n                continue;\n            }\n            const frames = getID3Frames(samples[i].data);\n            if (frames) {\n                const startTime = samples[i].pts;\n                let endTime = startTime + samples[i].duration;\n                if (endTime > MAX_CUE_ENDTIME) {\n                    endTime = MAX_CUE_ENDTIME;\n                }\n                const timeDiff = endTime - startTime;\n                if (timeDiff <= 0) {\n                    endTime = startTime + MIN_CUE_DURATION;\n                }\n                for(let j = 0; j < frames.length; j++){\n                    const frame = frames[j];\n                    // Safari doesn't put the timestamp frame in the TextTrack\n                    if (!isTimeStampFrame(frame)) {\n                        // add a bounds to any unbounded cues\n                        this.updateId3CueEnds(startTime, type);\n                        const cue = createCueWithDataFields(Cue, startTime, endTime, frame, type);\n                        if (cue) {\n                            this.id3Track.addCue(cue);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    updateId3CueEnds(startTime, type) {\n        var _this$id3Track;\n        const cues = (_this$id3Track = this.id3Track) == null ? void 0 : _this$id3Track.cues;\n        if (cues) {\n            for(let i = cues.length; i--;){\n                const cue = cues[i];\n                if (cue.type === type && cue.startTime < startTime && cue.endTime === MAX_CUE_ENDTIME) {\n                    cue.endTime = startTime;\n                }\n            }\n        }\n    }\n    onBufferFlushing(event, { startOffset, endOffset, type }) {\n        const { id3Track, hls } = this;\n        if (!hls) {\n            return;\n        }\n        const { config: { enableEmsgMetadataCues, enableID3MetadataCues } } = hls;\n        if (id3Track && (enableEmsgMetadataCues || enableID3MetadataCues)) {\n            let predicate;\n            if (type === \"audio\") {\n                predicate = (cue)=>cue.type === MetadataSchema.audioId3 && enableID3MetadataCues;\n            } else if (type === \"video\") {\n                predicate = (cue)=>cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;\n            } else {\n                predicate = (cue)=>cue.type === MetadataSchema.audioId3 && enableID3MetadataCues || cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;\n            }\n            removeCuesInRange(id3Track, startOffset, endOffset, predicate);\n        }\n    }\n    onLevelUpdated(event, { details }) {\n        if (!this.media || !details.hasProgramDateTime || !this.hls.config.enableDateRangeMetadataCues) {\n            return;\n        }\n        const { dateRangeCuesAppended, id3Track } = this;\n        const { dateRanges } = details;\n        const ids = Object.keys(dateRanges);\n        // Remove cues from track not found in details.dateRanges\n        if (id3Track) {\n            const idsToRemove = Object.keys(dateRangeCuesAppended).filter((id)=>!ids.includes(id));\n            for(let i = idsToRemove.length; i--;){\n                const id = idsToRemove[i];\n                Object.keys(dateRangeCuesAppended[id].cues).forEach((key)=>{\n                    id3Track.removeCue(dateRangeCuesAppended[id].cues[key]);\n                });\n                delete dateRangeCuesAppended[id];\n            }\n        }\n        // Exit if the playlist does not have Date Ranges or does not have Program Date Time\n        const lastFragment = details.fragments[details.fragments.length - 1];\n        if (ids.length === 0 || !isFiniteNumber(lastFragment == null ? void 0 : lastFragment.programDateTime)) {\n            return;\n        }\n        if (!this.id3Track) {\n            this.id3Track = this.createTrack(this.media);\n        }\n        const dateTimeOffset = lastFragment.programDateTime / 1000 - lastFragment.start;\n        const Cue = getCueClass();\n        for(let i = 0; i < ids.length; i++){\n            const id = ids[i];\n            const dateRange = dateRanges[id];\n            const startTime = dateRangeDateToTimelineSeconds(dateRange.startDate, dateTimeOffset);\n            // Process DateRanges to determine end-time (known DURATION, END-DATE, or END-ON-NEXT)\n            const appendedDateRangeCues = dateRangeCuesAppended[id];\n            const cues = (appendedDateRangeCues == null ? void 0 : appendedDateRangeCues.cues) || {};\n            let durationKnown = (appendedDateRangeCues == null ? void 0 : appendedDateRangeCues.durationKnown) || false;\n            let endTime = MAX_CUE_ENDTIME;\n            const endDate = dateRange.endDate;\n            if (endDate) {\n                endTime = dateRangeDateToTimelineSeconds(endDate, dateTimeOffset);\n                durationKnown = true;\n            } else if (dateRange.endOnNext && !durationKnown) {\n                const nextDateRangeWithSameClass = ids.reduce((candidateDateRange, id)=>{\n                    if (id !== dateRange.id) {\n                        const otherDateRange = dateRanges[id];\n                        if (otherDateRange.class === dateRange.class && otherDateRange.startDate > dateRange.startDate && (!candidateDateRange || dateRange.startDate < candidateDateRange.startDate)) {\n                            return otherDateRange;\n                        }\n                    }\n                    return candidateDateRange;\n                }, null);\n                if (nextDateRangeWithSameClass) {\n                    endTime = dateRangeDateToTimelineSeconds(nextDateRangeWithSameClass.startDate, dateTimeOffset);\n                    durationKnown = true;\n                }\n            }\n            // Create TextTrack Cues for each MetadataGroup Item (select DateRange attribute)\n            // This is to emulate Safari HLS playback handling of DateRange tags\n            const attributes = Object.keys(dateRange.attr);\n            for(let j = 0; j < attributes.length; j++){\n                const key = attributes[j];\n                if (!isDateRangeCueAttribute(key)) {\n                    continue;\n                }\n                const cue = cues[key];\n                if (cue) {\n                    if (durationKnown && !appendedDateRangeCues.durationKnown) {\n                        cue.endTime = endTime;\n                    }\n                } else if (Cue) {\n                    let data = dateRange.attr[key];\n                    if (isSCTE35Attribute(key)) {\n                        data = hexToArrayBuffer(data);\n                    }\n                    const _cue = createCueWithDataFields(Cue, startTime, endTime, {\n                        key,\n                        data\n                    }, MetadataSchema.dateRange);\n                    if (_cue) {\n                        _cue.id = id;\n                        this.id3Track.addCue(_cue);\n                        cues[key] = _cue;\n                    }\n                }\n            }\n            // Keep track of processed DateRanges by ID for updating cues with new DateRange tag attributes\n            dateRangeCuesAppended[id] = {\n                cues,\n                dateRange,\n                durationKnown\n            };\n        }\n    }\n}\nclass LatencyController {\n    constructor(hls){\n        this.hls = void 0;\n        this.config = void 0;\n        this.media = null;\n        this.levelDetails = null;\n        this.currentTime = 0;\n        this.stallCount = 0;\n        this._latency = null;\n        this.timeupdateHandler = ()=>this.timeupdate();\n        this.hls = hls;\n        this.config = hls.config;\n        this.registerListeners();\n    }\n    get latency() {\n        return this._latency || 0;\n    }\n    get maxLatency() {\n        const { config, levelDetails } = this;\n        if (config.liveMaxLatencyDuration !== undefined) {\n            return config.liveMaxLatencyDuration;\n        }\n        return levelDetails ? config.liveMaxLatencyDurationCount * levelDetails.targetduration : 0;\n    }\n    get targetLatency() {\n        const { levelDetails } = this;\n        if (levelDetails === null) {\n            return null;\n        }\n        const { holdBack, partHoldBack, targetduration } = levelDetails;\n        const { liveSyncDuration, liveSyncDurationCount, lowLatencyMode } = this.config;\n        const userConfig = this.hls.userConfig;\n        let targetLatency = lowLatencyMode ? partHoldBack || holdBack : holdBack;\n        if (userConfig.liveSyncDuration || userConfig.liveSyncDurationCount || targetLatency === 0) {\n            targetLatency = liveSyncDuration !== undefined ? liveSyncDuration : liveSyncDurationCount * targetduration;\n        }\n        const maxLiveSyncOnStallIncrease = targetduration;\n        const liveSyncOnStallIncrease = 1.0;\n        return targetLatency + Math.min(this.stallCount * liveSyncOnStallIncrease, maxLiveSyncOnStallIncrease);\n    }\n    get liveSyncPosition() {\n        const liveEdge = this.estimateLiveEdge();\n        const targetLatency = this.targetLatency;\n        const levelDetails = this.levelDetails;\n        if (liveEdge === null || targetLatency === null || levelDetails === null) {\n            return null;\n        }\n        const edge = levelDetails.edge;\n        const syncPosition = liveEdge - targetLatency - this.edgeStalled;\n        const min = edge - levelDetails.totalduration;\n        const max = edge - (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration);\n        return Math.min(Math.max(min, syncPosition), max);\n    }\n    get drift() {\n        const { levelDetails } = this;\n        if (levelDetails === null) {\n            return 1;\n        }\n        return levelDetails.drift;\n    }\n    get edgeStalled() {\n        const { levelDetails } = this;\n        if (levelDetails === null) {\n            return 0;\n        }\n        const maxLevelUpdateAge = (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration) * 3;\n        return Math.max(levelDetails.age - maxLevelUpdateAge, 0);\n    }\n    get forwardBufferLength() {\n        const { media, levelDetails } = this;\n        if (!media || !levelDetails) {\n            return 0;\n        }\n        const bufferedRanges = media.buffered.length;\n        return (bufferedRanges ? media.buffered.end(bufferedRanges - 1) : levelDetails.edge) - this.currentTime;\n    }\n    destroy() {\n        this.unregisterListeners();\n        this.onMediaDetaching();\n        this.levelDetails = null;\n        // @ts-ignore\n        this.hls = this.timeupdateHandler = null;\n    }\n    registerListeners() {\n        this.hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        this.hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        this.hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        this.hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n        this.hls.on(Events.ERROR, this.onError, this);\n    }\n    unregisterListeners() {\n        this.hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        this.hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        this.hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        this.hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n        this.hls.off(Events.ERROR, this.onError, this);\n    }\n    onMediaAttached(event, data) {\n        this.media = data.media;\n        this.media.addEventListener(\"timeupdate\", this.timeupdateHandler);\n    }\n    onMediaDetaching() {\n        if (this.media) {\n            this.media.removeEventListener(\"timeupdate\", this.timeupdateHandler);\n            this.media = null;\n        }\n    }\n    onManifestLoading() {\n        this.levelDetails = null;\n        this._latency = null;\n        this.stallCount = 0;\n    }\n    onLevelUpdated(event, { details }) {\n        this.levelDetails = details;\n        if (details.advanced) {\n            this.timeupdate();\n        }\n        if (!details.live && this.media) {\n            this.media.removeEventListener(\"timeupdate\", this.timeupdateHandler);\n        }\n    }\n    onError(event, data) {\n        var _this$levelDetails;\n        if (data.details !== ErrorDetails.BUFFER_STALLED_ERROR) {\n            return;\n        }\n        this.stallCount++;\n        if ((_this$levelDetails = this.levelDetails) != null && _this$levelDetails.live) {\n            logger.warn(\"[playback-rate-controller]: Stall detected, adjusting target latency\");\n        }\n    }\n    timeupdate() {\n        const { media, levelDetails } = this;\n        if (!media || !levelDetails) {\n            return;\n        }\n        this.currentTime = media.currentTime;\n        const latency = this.computeLatency();\n        if (latency === null) {\n            return;\n        }\n        this._latency = latency;\n        // Adapt playbackRate to meet target latency in low-latency mode\n        const { lowLatencyMode, maxLiveSyncPlaybackRate } = this.config;\n        if (!lowLatencyMode || maxLiveSyncPlaybackRate === 1 || !levelDetails.live) {\n            return;\n        }\n        const targetLatency = this.targetLatency;\n        if (targetLatency === null) {\n            return;\n        }\n        const distanceFromTarget = latency - targetLatency;\n        // Only adjust playbackRate when within one target duration of targetLatency\n        // and more than one second from under-buffering.\n        // Playback further than one target duration from target can be considered DVR playback.\n        const liveMinLatencyDuration = Math.min(this.maxLatency, targetLatency + levelDetails.targetduration);\n        const inLiveRange = distanceFromTarget < liveMinLatencyDuration;\n        if (inLiveRange && distanceFromTarget > 0.05 && this.forwardBufferLength > 1) {\n            const max = Math.min(2, Math.max(1.0, maxLiveSyncPlaybackRate));\n            const rate = Math.round(2 / (1 + Math.exp(-0.75 * distanceFromTarget - this.edgeStalled)) * 20) / 20;\n            media.playbackRate = Math.min(max, Math.max(1, rate));\n        } else if (media.playbackRate !== 1 && media.playbackRate !== 0) {\n            media.playbackRate = 1;\n        }\n    }\n    estimateLiveEdge() {\n        const { levelDetails } = this;\n        if (levelDetails === null) {\n            return null;\n        }\n        return levelDetails.edge + levelDetails.age;\n    }\n    computeLatency() {\n        const liveEdge = this.estimateLiveEdge();\n        if (liveEdge === null) {\n            return null;\n        }\n        return liveEdge - this.currentTime;\n    }\n}\nconst HdcpLevels = [\n    \"NONE\",\n    \"TYPE-0\",\n    \"TYPE-1\",\n    null\n];\nfunction isHdcpLevel(value) {\n    return HdcpLevels.indexOf(value) > -1;\n}\nconst VideoRangeValues = [\n    \"SDR\",\n    \"PQ\",\n    \"HLG\"\n];\nfunction isVideoRange(value) {\n    return !!value && VideoRangeValues.indexOf(value) > -1;\n}\nvar HlsSkip = {\n    No: \"\",\n    Yes: \"YES\",\n    v2: \"v2\"\n};\nfunction getSkipValue(details, msn) {\n    const { canSkipUntil, canSkipDateRanges, endSN } = details;\n    const snChangeGoal = msn !== undefined ? msn - endSN : 0;\n    if (canSkipUntil && snChangeGoal < canSkipUntil) {\n        if (canSkipDateRanges) {\n            return HlsSkip.v2;\n        }\n        return HlsSkip.Yes;\n    }\n    return HlsSkip.No;\n}\nclass HlsUrlParameters {\n    constructor(msn, part, skip){\n        this.msn = void 0;\n        this.part = void 0;\n        this.skip = void 0;\n        this.msn = msn;\n        this.part = part;\n        this.skip = skip;\n    }\n    addDirectives(uri) {\n        const url = new self.URL(uri);\n        if (this.msn !== undefined) {\n            url.searchParams.set(\"_HLS_msn\", this.msn.toString());\n        }\n        if (this.part !== undefined) {\n            url.searchParams.set(\"_HLS_part\", this.part.toString());\n        }\n        if (this.skip) {\n            url.searchParams.set(\"_HLS_skip\", this.skip);\n        }\n        return url.href;\n    }\n}\nclass Level {\n    constructor(data){\n        this._attrs = void 0;\n        this.audioCodec = void 0;\n        this.bitrate = void 0;\n        this.codecSet = void 0;\n        this.url = void 0;\n        this.frameRate = void 0;\n        this.height = void 0;\n        this.id = void 0;\n        this.name = void 0;\n        this.videoCodec = void 0;\n        this.width = void 0;\n        this.details = void 0;\n        this.fragmentError = 0;\n        this.loadError = 0;\n        this.loaded = void 0;\n        this.realBitrate = 0;\n        this.supportedPromise = void 0;\n        this.supportedResult = void 0;\n        this._avgBitrate = 0;\n        this._audioGroups = void 0;\n        this._subtitleGroups = void 0;\n        // Deprecated (retained for backwards compatibility)\n        this._urlId = 0;\n        this.url = [\n            data.url\n        ];\n        this._attrs = [\n            data.attrs\n        ];\n        this.bitrate = data.bitrate;\n        if (data.details) {\n            this.details = data.details;\n        }\n        this.id = data.id || 0;\n        this.name = data.name;\n        this.width = data.width || 0;\n        this.height = data.height || 0;\n        this.frameRate = data.attrs.optionalFloat(\"FRAME-RATE\", 0);\n        this._avgBitrate = data.attrs.decimalInteger(\"AVERAGE-BANDWIDTH\");\n        this.audioCodec = data.audioCodec;\n        this.videoCodec = data.videoCodec;\n        this.codecSet = [\n            data.videoCodec,\n            data.audioCodec\n        ].filter((c)=>!!c).map((s)=>s.substring(0, 4)).join(\",\");\n        this.addGroupId(\"audio\", data.attrs.AUDIO);\n        this.addGroupId(\"text\", data.attrs.SUBTITLES);\n    }\n    get maxBitrate() {\n        return Math.max(this.realBitrate, this.bitrate);\n    }\n    get averageBitrate() {\n        return this._avgBitrate || this.realBitrate || this.bitrate;\n    }\n    get attrs() {\n        return this._attrs[0];\n    }\n    get codecs() {\n        return this.attrs.CODECS || \"\";\n    }\n    get pathwayId() {\n        return this.attrs[\"PATHWAY-ID\"] || \".\";\n    }\n    get videoRange() {\n        return this.attrs[\"VIDEO-RANGE\"] || \"SDR\";\n    }\n    get score() {\n        return this.attrs.optionalFloat(\"SCORE\", 0);\n    }\n    get uri() {\n        return this.url[0] || \"\";\n    }\n    hasAudioGroup(groupId) {\n        return hasGroup(this._audioGroups, groupId);\n    }\n    hasSubtitleGroup(groupId) {\n        return hasGroup(this._subtitleGroups, groupId);\n    }\n    get audioGroups() {\n        return this._audioGroups;\n    }\n    get subtitleGroups() {\n        return this._subtitleGroups;\n    }\n    addGroupId(type, groupId) {\n        if (!groupId) {\n            return;\n        }\n        if (type === \"audio\") {\n            let audioGroups = this._audioGroups;\n            if (!audioGroups) {\n                audioGroups = this._audioGroups = [];\n            }\n            if (audioGroups.indexOf(groupId) === -1) {\n                audioGroups.push(groupId);\n            }\n        } else if (type === \"text\") {\n            let subtitleGroups = this._subtitleGroups;\n            if (!subtitleGroups) {\n                subtitleGroups = this._subtitleGroups = [];\n            }\n            if (subtitleGroups.indexOf(groupId) === -1) {\n                subtitleGroups.push(groupId);\n            }\n        }\n    }\n    // Deprecated methods (retained for backwards compatibility)\n    get urlId() {\n        return 0;\n    }\n    set urlId(value) {}\n    get audioGroupIds() {\n        return this.audioGroups ? [\n            this.audioGroupId\n        ] : undefined;\n    }\n    get textGroupIds() {\n        return this.subtitleGroups ? [\n            this.textGroupId\n        ] : undefined;\n    }\n    get audioGroupId() {\n        var _this$audioGroups;\n        return (_this$audioGroups = this.audioGroups) == null ? void 0 : _this$audioGroups[0];\n    }\n    get textGroupId() {\n        var _this$subtitleGroups;\n        return (_this$subtitleGroups = this.subtitleGroups) == null ? void 0 : _this$subtitleGroups[0];\n    }\n    addFallback() {}\n}\nfunction hasGroup(groups, groupId) {\n    if (!groupId || !groups) {\n        return false;\n    }\n    return groups.indexOf(groupId) !== -1;\n}\nfunction updateFromToPTS(fragFrom, fragTo) {\n    const fragToPTS = fragTo.startPTS;\n    // if we know startPTS[toIdx]\n    if (isFiniteNumber(fragToPTS)) {\n        // update fragment duration.\n        // it helps to fix drifts between playlist reported duration and fragment real duration\n        let duration = 0;\n        let frag;\n        if (fragTo.sn > fragFrom.sn) {\n            duration = fragToPTS - fragFrom.start;\n            frag = fragFrom;\n        } else {\n            duration = fragFrom.start - fragToPTS;\n            frag = fragTo;\n        }\n        if (frag.duration !== duration) {\n            frag.duration = duration;\n        }\n    // we dont know startPTS[toIdx]\n    } else if (fragTo.sn > fragFrom.sn) {\n        const contiguous = fragFrom.cc === fragTo.cc;\n        // TODO: With part-loading end/durations we need to confirm the whole fragment is loaded before using (or setting) minEndPTS\n        if (contiguous && fragFrom.minEndPTS) {\n            fragTo.start = fragFrom.start + (fragFrom.minEndPTS - fragFrom.start);\n        } else {\n            fragTo.start = fragFrom.start + fragFrom.duration;\n        }\n    } else {\n        fragTo.start = Math.max(fragFrom.start - fragTo.duration, 0);\n    }\n}\nfunction updateFragPTSDTS(details, frag, startPTS, endPTS, startDTS, endDTS) {\n    const parsedMediaDuration = endPTS - startPTS;\n    if (parsedMediaDuration <= 0) {\n        logger.warn(\"Fragment should have a positive duration\", frag);\n        endPTS = startPTS + frag.duration;\n        endDTS = startDTS + frag.duration;\n    }\n    let maxStartPTS = startPTS;\n    let minEndPTS = endPTS;\n    const fragStartPts = frag.startPTS;\n    const fragEndPts = frag.endPTS;\n    if (isFiniteNumber(fragStartPts)) {\n        // delta PTS between audio and video\n        const deltaPTS = Math.abs(fragStartPts - startPTS);\n        if (!isFiniteNumber(frag.deltaPTS)) {\n            frag.deltaPTS = deltaPTS;\n        } else {\n            frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);\n        }\n        maxStartPTS = Math.max(startPTS, fragStartPts);\n        startPTS = Math.min(startPTS, fragStartPts);\n        startDTS = Math.min(startDTS, frag.startDTS);\n        minEndPTS = Math.min(endPTS, fragEndPts);\n        endPTS = Math.max(endPTS, fragEndPts);\n        endDTS = Math.max(endDTS, frag.endDTS);\n    }\n    const drift = startPTS - frag.start;\n    if (frag.start !== 0) {\n        frag.start = startPTS;\n    }\n    frag.duration = endPTS - frag.start;\n    frag.startPTS = startPTS;\n    frag.maxStartPTS = maxStartPTS;\n    frag.startDTS = startDTS;\n    frag.endPTS = endPTS;\n    frag.minEndPTS = minEndPTS;\n    frag.endDTS = endDTS;\n    const sn = frag.sn; // 'initSegment'\n    // exit if sn out of range\n    if (!details || sn < details.startSN || sn > details.endSN) {\n        return 0;\n    }\n    let i;\n    const fragIdx = sn - details.startSN;\n    const fragments = details.fragments;\n    // update frag reference in fragments array\n    // rationale is that fragments array might not contain this frag object.\n    // this will happen if playlist has been refreshed between frag loading and call to updateFragPTSDTS()\n    // if we don't update frag, we won't be able to propagate PTS info on the playlist\n    // resulting in invalid sliding computation\n    fragments[fragIdx] = frag;\n    // adjust fragment PTS/duration from seqnum-1 to frag 0\n    for(i = fragIdx; i > 0; i--){\n        updateFromToPTS(fragments[i], fragments[i - 1]);\n    }\n    // adjust fragment PTS/duration from seqnum to last frag\n    for(i = fragIdx; i < fragments.length - 1; i++){\n        updateFromToPTS(fragments[i], fragments[i + 1]);\n    }\n    if (details.fragmentHint) {\n        updateFromToPTS(fragments[fragments.length - 1], details.fragmentHint);\n    }\n    details.PTSKnown = details.alignedSliding = true;\n    return drift;\n}\nfunction mergeDetails(oldDetails, newDetails) {\n    // Track the last initSegment processed. Initialize it to the last one on the timeline.\n    let currentInitSegment = null;\n    const oldFragments = oldDetails.fragments;\n    for(let i = oldFragments.length - 1; i >= 0; i--){\n        const oldInit = oldFragments[i].initSegment;\n        if (oldInit) {\n            currentInitSegment = oldInit;\n            break;\n        }\n    }\n    if (oldDetails.fragmentHint) {\n        // prevent PTS and duration from being adjusted on the next hint\n        delete oldDetails.fragmentHint.endPTS;\n    }\n    // check if old/new playlists have fragments in common\n    // loop through overlapping SN and update startPTS , cc, and duration if any found\n    let ccOffset = 0;\n    let PTSFrag;\n    mapFragmentIntersection(oldDetails, newDetails, (oldFrag, newFrag)=>{\n        if (oldFrag.relurl) {\n            // Do not compare CC if the old fragment has no url. This is a level.fragmentHint used by LL-HLS parts.\n            // It maybe be off by 1 if it was created before any parts or discontinuity tags were appended to the end\n            // of the playlist.\n            ccOffset = oldFrag.cc - newFrag.cc;\n        }\n        if (isFiniteNumber(oldFrag.startPTS) && isFiniteNumber(oldFrag.endPTS)) {\n            newFrag.start = newFrag.startPTS = oldFrag.startPTS;\n            newFrag.startDTS = oldFrag.startDTS;\n            newFrag.maxStartPTS = oldFrag.maxStartPTS;\n            newFrag.endPTS = oldFrag.endPTS;\n            newFrag.endDTS = oldFrag.endDTS;\n            newFrag.minEndPTS = oldFrag.minEndPTS;\n            newFrag.duration = oldFrag.endPTS - oldFrag.startPTS;\n            if (newFrag.duration) {\n                PTSFrag = newFrag;\n            }\n            // PTS is known when any segment has startPTS and endPTS\n            newDetails.PTSKnown = newDetails.alignedSliding = true;\n        }\n        newFrag.elementaryStreams = oldFrag.elementaryStreams;\n        newFrag.loader = oldFrag.loader;\n        newFrag.stats = oldFrag.stats;\n        if (oldFrag.initSegment) {\n            newFrag.initSegment = oldFrag.initSegment;\n            currentInitSegment = oldFrag.initSegment;\n        }\n    });\n    if (currentInitSegment) {\n        const fragmentsToCheck = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;\n        fragmentsToCheck.forEach((frag)=>{\n            var _currentInitSegment;\n            if (frag && (!frag.initSegment || frag.initSegment.relurl === ((_currentInitSegment = currentInitSegment) == null ? void 0 : _currentInitSegment.relurl))) {\n                frag.initSegment = currentInitSegment;\n            }\n        });\n    }\n    if (newDetails.skippedSegments) {\n        newDetails.deltaUpdateFailed = newDetails.fragments.some((frag)=>!frag);\n        if (newDetails.deltaUpdateFailed) {\n            logger.warn(\"[level-helper] Previous playlist missing segments skipped in delta playlist\");\n            for(let i = newDetails.skippedSegments; i--;){\n                newDetails.fragments.shift();\n            }\n            newDetails.startSN = newDetails.fragments[0].sn;\n            newDetails.startCC = newDetails.fragments[0].cc;\n        } else if (newDetails.canSkipDateRanges) {\n            newDetails.dateRanges = mergeDateRanges(oldDetails.dateRanges, newDetails.dateRanges, newDetails.recentlyRemovedDateranges);\n        }\n    }\n    const newFragments = newDetails.fragments;\n    if (ccOffset) {\n        logger.warn(\"discontinuity sliding from playlist, take drift into account\");\n        for(let i = 0; i < newFragments.length; i++){\n            newFragments[i].cc += ccOffset;\n        }\n    }\n    if (newDetails.skippedSegments) {\n        newDetails.startCC = newDetails.fragments[0].cc;\n    }\n    // Merge parts\n    mapPartIntersection(oldDetails.partList, newDetails.partList, (oldPart, newPart)=>{\n        newPart.elementaryStreams = oldPart.elementaryStreams;\n        newPart.stats = oldPart.stats;\n    });\n    // if at least one fragment contains PTS info, recompute PTS information for all fragments\n    if (PTSFrag) {\n        updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);\n    } else {\n        // ensure that delta is within oldFragments range\n        // also adjust sliding in case delta is 0 (we could have old=[50-60] and new=old=[50-61])\n        // in that case we also need to adjust start offset of all fragments\n        adjustSliding(oldDetails, newDetails);\n    }\n    if (newFragments.length) {\n        newDetails.totalduration = newDetails.edge - newFragments[0].start;\n    }\n    newDetails.driftStartTime = oldDetails.driftStartTime;\n    newDetails.driftStart = oldDetails.driftStart;\n    const advancedDateTime = newDetails.advancedDateTime;\n    if (newDetails.advanced && advancedDateTime) {\n        const edge = newDetails.edge;\n        if (!newDetails.driftStart) {\n            newDetails.driftStartTime = advancedDateTime;\n            newDetails.driftStart = edge;\n        }\n        newDetails.driftEndTime = advancedDateTime;\n        newDetails.driftEnd = edge;\n    } else {\n        newDetails.driftEndTime = oldDetails.driftEndTime;\n        newDetails.driftEnd = oldDetails.driftEnd;\n        newDetails.advancedDateTime = oldDetails.advancedDateTime;\n    }\n}\nfunction mergeDateRanges(oldDateRanges, deltaDateRanges, recentlyRemovedDateranges) {\n    const dateRanges = _extends({}, oldDateRanges);\n    if (recentlyRemovedDateranges) {\n        recentlyRemovedDateranges.forEach((id)=>{\n            delete dateRanges[id];\n        });\n    }\n    Object.keys(deltaDateRanges).forEach((id)=>{\n        const dateRange = new DateRange(deltaDateRanges[id].attr, dateRanges[id]);\n        if (dateRange.isValid) {\n            dateRanges[id] = dateRange;\n        } else {\n            logger.warn(`Ignoring invalid Playlist Delta Update DATERANGE tag: \"${JSON.stringify(deltaDateRanges[id].attr)}\"`);\n        }\n    });\n    return dateRanges;\n}\nfunction mapPartIntersection(oldParts, newParts, intersectionFn) {\n    if (oldParts && newParts) {\n        let delta = 0;\n        for(let i = 0, len = oldParts.length; i <= len; i++){\n            const oldPart = oldParts[i];\n            const newPart = newParts[i + delta];\n            if (oldPart && newPart && oldPart.index === newPart.index && oldPart.fragment.sn === newPart.fragment.sn) {\n                intersectionFn(oldPart, newPart);\n            } else {\n                delta--;\n            }\n        }\n    }\n}\nfunction mapFragmentIntersection(oldDetails, newDetails, intersectionFn) {\n    const skippedSegments = newDetails.skippedSegments;\n    const start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN;\n    const end = (oldDetails.fragmentHint ? 1 : 0) + (skippedSegments ? newDetails.endSN : Math.min(oldDetails.endSN, newDetails.endSN)) - newDetails.startSN;\n    const delta = newDetails.startSN - oldDetails.startSN;\n    const newFrags = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;\n    const oldFrags = oldDetails.fragmentHint ? oldDetails.fragments.concat(oldDetails.fragmentHint) : oldDetails.fragments;\n    for(let i = start; i <= end; i++){\n        const oldFrag = oldFrags[delta + i];\n        let newFrag = newFrags[i];\n        if (skippedSegments && !newFrag && i < skippedSegments) {\n            // Fill in skipped segments in delta playlist\n            newFrag = newDetails.fragments[i] = oldFrag;\n        }\n        if (oldFrag && newFrag) {\n            intersectionFn(oldFrag, newFrag);\n        }\n    }\n}\nfunction adjustSliding(oldDetails, newDetails) {\n    const delta = newDetails.startSN + newDetails.skippedSegments - oldDetails.startSN;\n    const oldFragments = oldDetails.fragments;\n    if (delta < 0 || delta >= oldFragments.length) {\n        return;\n    }\n    addSliding(newDetails, oldFragments[delta].start);\n}\nfunction addSliding(details, start) {\n    if (start) {\n        const fragments = details.fragments;\n        for(let i = details.skippedSegments; i < fragments.length; i++){\n            fragments[i].start += start;\n        }\n        if (details.fragmentHint) {\n            details.fragmentHint.start += start;\n        }\n    }\n}\nfunction computeReloadInterval(newDetails, distanceToLiveEdgeMs = Infinity) {\n    let reloadInterval = 1000 * newDetails.targetduration;\n    if (newDetails.updated) {\n        // Use last segment duration when shorter than target duration and near live edge\n        const fragments = newDetails.fragments;\n        const liveEdgeMaxTargetDurations = 4;\n        if (fragments.length && reloadInterval * liveEdgeMaxTargetDurations > distanceToLiveEdgeMs) {\n            const lastSegmentDuration = fragments[fragments.length - 1].duration * 1000;\n            if (lastSegmentDuration < reloadInterval) {\n                reloadInterval = lastSegmentDuration;\n            }\n        }\n    } else {\n        // estimate = 'miss half average';\n        // follow HLS Spec, If the client reloads a Playlist file and finds that it has not\n        // changed then it MUST wait for a period of one-half the target\n        // duration before retrying.\n        reloadInterval /= 2;\n    }\n    return Math.round(reloadInterval);\n}\nfunction getFragmentWithSN(level, sn, fragCurrent) {\n    if (!(level != null && level.details)) {\n        return null;\n    }\n    const levelDetails = level.details;\n    let fragment = levelDetails.fragments[sn - levelDetails.startSN];\n    if (fragment) {\n        return fragment;\n    }\n    fragment = levelDetails.fragmentHint;\n    if (fragment && fragment.sn === sn) {\n        return fragment;\n    }\n    if (sn < levelDetails.startSN && fragCurrent && fragCurrent.sn === sn) {\n        return fragCurrent;\n    }\n    return null;\n}\nfunction getPartWith(level, sn, partIndex) {\n    var _level$details;\n    if (!(level != null && level.details)) {\n        return null;\n    }\n    return findPart((_level$details = level.details) == null ? void 0 : _level$details.partList, sn, partIndex);\n}\nfunction findPart(partList, sn, partIndex) {\n    if (partList) {\n        for(let i = partList.length; i--;){\n            const part = partList[i];\n            if (part.index === partIndex && part.fragment.sn === sn) {\n                return part;\n            }\n        }\n    }\n    return null;\n}\nfunction reassignFragmentLevelIndexes(levels) {\n    levels.forEach((level, index)=>{\n        const { details } = level;\n        if (details != null && details.fragments) {\n            details.fragments.forEach((fragment)=>{\n                fragment.level = index;\n            });\n        }\n    });\n}\nfunction isTimeoutError(error) {\n    switch(error.details){\n        case ErrorDetails.FRAG_LOAD_TIMEOUT:\n        case ErrorDetails.KEY_LOAD_TIMEOUT:\n        case ErrorDetails.LEVEL_LOAD_TIMEOUT:\n        case ErrorDetails.MANIFEST_LOAD_TIMEOUT:\n            return true;\n    }\n    return false;\n}\nfunction getRetryConfig(loadPolicy, error) {\n    const isTimeout = isTimeoutError(error);\n    return loadPolicy.default[`${isTimeout ? \"timeout\" : \"error\"}Retry`];\n}\nfunction getRetryDelay(retryConfig, retryCount) {\n    // exponential backoff capped to max retry delay\n    const backoffFactor = retryConfig.backoff === \"linear\" ? 1 : Math.pow(2, retryCount);\n    return Math.min(backoffFactor * retryConfig.retryDelayMs, retryConfig.maxRetryDelayMs);\n}\nfunction getLoaderConfigWithoutReties(loderConfig) {\n    return _objectSpread2(_objectSpread2({}, loderConfig), {\n        errorRetry: null,\n        timeoutRetry: null\n    });\n}\nfunction shouldRetry(retryConfig, retryCount, isTimeout, loaderResponse) {\n    if (!retryConfig) {\n        return false;\n    }\n    const httpStatus = loaderResponse == null ? void 0 : loaderResponse.code;\n    const retry = retryCount < retryConfig.maxNumRetry && (retryForHttpStatus(httpStatus) || !!isTimeout);\n    return retryConfig.shouldRetry ? retryConfig.shouldRetry(retryConfig, retryCount, isTimeout, loaderResponse, retry) : retry;\n}\nfunction retryForHttpStatus(httpStatus) {\n    // Do not retry on status 4xx, status 0 (CORS error), or undefined (decrypt/gap/parse error)\n    return httpStatus === 0 && navigator.onLine === false || !!httpStatus && (httpStatus < 400 || httpStatus > 499);\n}\nconst BinarySearch = {\n    /**\n   * Searches for an item in an array which matches a certain condition.\n   * This requires the condition to only match one item in the array,\n   * and for the array to be ordered.\n   *\n   * @param list The array to search.\n   * @param comparisonFn\n   *      Called and provided a candidate item as the first argument.\n   *      Should return:\n   *          > -1 if the item should be located at a lower index than the provided item.\n   *          > 1 if the item should be located at a higher index than the provided item.\n   *          > 0 if the item is the item you're looking for.\n   *\n   * @returns the object if found, otherwise returns null\n   */ search: function(list, comparisonFn) {\n        let minIndex = 0;\n        let maxIndex = list.length - 1;\n        let currentIndex = null;\n        let currentElement = null;\n        while(minIndex <= maxIndex){\n            currentIndex = (minIndex + maxIndex) / 2 | 0;\n            currentElement = list[currentIndex];\n            const comparisonResult = comparisonFn(currentElement);\n            if (comparisonResult > 0) {\n                minIndex = currentIndex + 1;\n            } else if (comparisonResult < 0) {\n                maxIndex = currentIndex - 1;\n            } else {\n                return currentElement;\n            }\n        }\n        return null;\n    }\n};\n/**\n * Returns first fragment whose endPdt value exceeds the given PDT, or null.\n * @param fragments - The array of candidate fragments\n * @param PDTValue - The PDT value which must be exceeded\n * @param maxFragLookUpTolerance - The amount of time that a fragment's start/end can be within in order to be considered contiguous\n */ function findFragmentByPDT(fragments, PDTValue, maxFragLookUpTolerance) {\n    if (PDTValue === null || !Array.isArray(fragments) || !fragments.length || !isFiniteNumber(PDTValue)) {\n        return null;\n    }\n    // if less than start\n    const startPDT = fragments[0].programDateTime;\n    if (PDTValue < (startPDT || 0)) {\n        return null;\n    }\n    const endPDT = fragments[fragments.length - 1].endProgramDateTime;\n    if (PDTValue >= (endPDT || 0)) {\n        return null;\n    }\n    maxFragLookUpTolerance = maxFragLookUpTolerance || 0;\n    for(let seg = 0; seg < fragments.length; ++seg){\n        const frag = fragments[seg];\n        if (pdtWithinToleranceTest(PDTValue, maxFragLookUpTolerance, frag)) {\n            return frag;\n        }\n    }\n    return null;\n}\n/**\n * Finds a fragment based on the SN of the previous fragment; or based on the needs of the current buffer.\n * This method compensates for small buffer gaps by applying a tolerance to the start of any candidate fragment, thus\n * breaking any traps which would cause the same fragment to be continuously selected within a small range.\n * @param fragPrevious - The last frag successfully appended\n * @param fragments - The array of candidate fragments\n * @param bufferEnd - The end of the contiguous buffered range the playhead is currently within\n * @param maxFragLookUpTolerance - The amount of time that a fragment's start/end can be within in order to be considered contiguous\n * @returns a matching fragment or null\n */ function findFragmentByPTS(fragPrevious, fragments, bufferEnd = 0, maxFragLookUpTolerance = 0) {\n    let fragNext = null;\n    if (fragPrevious) {\n        fragNext = fragments[fragPrevious.sn - fragments[0].sn + 1] || null;\n        // check for buffer-end rounding error\n        const bufferEdgeError = fragPrevious.endDTS - bufferEnd;\n        if (bufferEdgeError > 0 && bufferEdgeError < 0.0000015) {\n            bufferEnd += 0.0000015;\n        }\n    } else if (bufferEnd === 0 && fragments[0].start === 0) {\n        fragNext = fragments[0];\n    }\n    // Prefer the next fragment if it's within tolerance\n    if (fragNext && (!fragPrevious || fragPrevious.level === fragNext.level) && fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, fragNext) === 0) {\n        return fragNext;\n    }\n    // We might be seeking past the tolerance so find the best match\n    const foundFragment = BinarySearch.search(fragments, fragmentWithinToleranceTest.bind(null, bufferEnd, maxFragLookUpTolerance));\n    if (foundFragment && (foundFragment !== fragPrevious || !fragNext)) {\n        return foundFragment;\n    }\n    // If no match was found return the next fragment after fragPrevious, or null\n    return fragNext;\n}\n/**\n * The test function used by the findFragmentBySn's BinarySearch to look for the best match to the current buffer conditions.\n * @param candidate - The fragment to test\n * @param bufferEnd - The end of the current buffered range the playhead is currently within\n * @param maxFragLookUpTolerance - The amount of time that a fragment's start can be within in order to be considered contiguous\n * @returns 0 if it matches, 1 if too low, -1 if too high\n */ function fragmentWithinToleranceTest(bufferEnd = 0, maxFragLookUpTolerance = 0, candidate) {\n    // eagerly accept an accurate match (no tolerance)\n    if (candidate.start <= bufferEnd && candidate.start + candidate.duration > bufferEnd) {\n        return 0;\n    }\n    // offset should be within fragment boundary - config.maxFragLookUpTolerance\n    // this is to cope with situations like\n    // bufferEnd = 9.991\n    // frag[] : [0,10]\n    // frag[1] : [10,20]\n    // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here\n    //              frag start               frag start+duration\n    //                  |-----------------------------|\n    //              <--->                         <--->\n    //  ...--------><-----------------------------><---------....\n    // previous frag         matching fragment         next frag\n    //  return -1             return 0                 return 1\n    // logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);\n    // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments\n    const candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0));\n    if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {\n        return 1;\n    } else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {\n        // if maxFragLookUpTolerance will have negative value then don't return -1 for first element\n        return -1;\n    }\n    return 0;\n}\n/**\n * The test function used by the findFragmentByPdt's BinarySearch to look for the best match to the current buffer conditions.\n * This function tests the candidate's program date time values, as represented in Unix time\n * @param candidate - The fragment to test\n * @param pdtBufferEnd - The Unix time representing the end of the current buffered range\n * @param maxFragLookUpTolerance - The amount of time that a fragment's start can be within in order to be considered contiguous\n * @returns true if contiguous, false otherwise\n */ function pdtWithinToleranceTest(pdtBufferEnd, maxFragLookUpTolerance, candidate) {\n    const candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0)) * 1000;\n    // endProgramDateTime can be null, default to zero\n    const endProgramDateTime = candidate.endProgramDateTime || 0;\n    return endProgramDateTime - candidateLookupTolerance > pdtBufferEnd;\n}\nfunction findFragWithCC(fragments, cc) {\n    return BinarySearch.search(fragments, (candidate)=>{\n        if (candidate.cc < cc) {\n            return 1;\n        } else if (candidate.cc > cc) {\n            return -1;\n        } else {\n            return 0;\n        }\n    });\n}\nvar NetworkErrorAction = {\n    DoNothing: 0,\n    SendEndCallback: 1,\n    SendAlternateToPenaltyBox: 2,\n    RemoveAlternatePermanently: 3,\n    InsertDiscontinuity: 4,\n    RetryRequest: 5\n};\nvar ErrorActionFlags = {\n    None: 0,\n    MoveAllAlternatesMatchingHost: 1,\n    MoveAllAlternatesMatchingHDCP: 2,\n    SwitchToSDR: 4\n}; // Reserved for future use\nclass ErrorController {\n    constructor(hls){\n        this.hls = void 0;\n        this.playlistError = 0;\n        this.penalizedRenditions = {};\n        this.log = void 0;\n        this.warn = void 0;\n        this.error = void 0;\n        this.hls = hls;\n        this.log = logger.log.bind(logger, `[info]:`);\n        this.warn = logger.warn.bind(logger, `[warning]:`);\n        this.error = logger.error.bind(logger, `[error]:`);\n        this.registerListeners();\n    }\n    registerListeners() {\n        const hls = this.hls;\n        hls.on(Events.ERROR, this.onError, this);\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    }\n    unregisterListeners() {\n        const hls = this.hls;\n        if (!hls) {\n            return;\n        }\n        hls.off(Events.ERROR, this.onError, this);\n        hls.off(Events.ERROR, this.onErrorOut, this);\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    }\n    destroy() {\n        this.unregisterListeners();\n        // @ts-ignore\n        this.hls = null;\n        this.penalizedRenditions = {};\n    }\n    startLoad(startPosition) {}\n    stopLoad() {\n        this.playlistError = 0;\n    }\n    getVariantLevelIndex(frag) {\n        return (frag == null ? void 0 : frag.type) === PlaylistLevelType.MAIN ? frag.level : this.hls.loadLevel;\n    }\n    onManifestLoading() {\n        this.playlistError = 0;\n        this.penalizedRenditions = {};\n    }\n    onLevelUpdated() {\n        this.playlistError = 0;\n    }\n    onError(event, data) {\n        var _data$frag, _data$level;\n        if (data.fatal) {\n            return;\n        }\n        const hls = this.hls;\n        const context = data.context;\n        switch(data.details){\n            case ErrorDetails.FRAG_LOAD_ERROR:\n            case ErrorDetails.FRAG_LOAD_TIMEOUT:\n            case ErrorDetails.KEY_LOAD_ERROR:\n            case ErrorDetails.KEY_LOAD_TIMEOUT:\n                data.errorAction = this.getFragRetryOrSwitchAction(data);\n                return;\n            case ErrorDetails.FRAG_PARSING_ERROR:\n                // ignore empty segment errors marked as gap\n                if ((_data$frag = data.frag) != null && _data$frag.gap) {\n                    data.errorAction = {\n                        action: NetworkErrorAction.DoNothing,\n                        flags: ErrorActionFlags.None\n                    };\n                    return;\n                }\n            // falls through\n            case ErrorDetails.FRAG_GAP:\n            case ErrorDetails.FRAG_DECRYPT_ERROR:\n                {\n                    // Switch level if possible, otherwise allow retry count to reach max error retries\n                    data.errorAction = this.getFragRetryOrSwitchAction(data);\n                    data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;\n                    return;\n                }\n            case ErrorDetails.LEVEL_EMPTY_ERROR:\n            case ErrorDetails.LEVEL_PARSING_ERROR:\n                {\n                    var _data$context, _data$context$levelDe;\n                    // Only retry when empty and live\n                    const levelIndex = data.parent === PlaylistLevelType.MAIN ? data.level : hls.loadLevel;\n                    if (data.details === ErrorDetails.LEVEL_EMPTY_ERROR && !!((_data$context = data.context) != null && (_data$context$levelDe = _data$context.levelDetails) != null && _data$context$levelDe.live)) {\n                        data.errorAction = this.getPlaylistRetryOrSwitchAction(data, levelIndex);\n                    } else {\n                        // Escalate to fatal if not retrying or switching\n                        data.levelRetry = false;\n                        data.errorAction = this.getLevelSwitchAction(data, levelIndex);\n                    }\n                }\n                return;\n            case ErrorDetails.LEVEL_LOAD_ERROR:\n            case ErrorDetails.LEVEL_LOAD_TIMEOUT:\n                if (typeof (context == null ? void 0 : context.level) === \"number\") {\n                    data.errorAction = this.getPlaylistRetryOrSwitchAction(data, context.level);\n                }\n                return;\n            case ErrorDetails.AUDIO_TRACK_LOAD_ERROR:\n            case ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:\n            case ErrorDetails.SUBTITLE_LOAD_ERROR:\n            case ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT:\n                if (context) {\n                    const level = hls.levels[hls.loadLevel];\n                    if (level && (context.type === PlaylistContextType.AUDIO_TRACK && level.hasAudioGroup(context.groupId) || context.type === PlaylistContextType.SUBTITLE_TRACK && level.hasSubtitleGroup(context.groupId))) {\n                        // Perform Pathway switch or Redundant failover if possible for fastest recovery\n                        // otherwise allow playlist retry count to reach max error retries\n                        data.errorAction = this.getPlaylistRetryOrSwitchAction(data, hls.loadLevel);\n                        data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;\n                        data.errorAction.flags = ErrorActionFlags.MoveAllAlternatesMatchingHost;\n                        return;\n                    }\n                }\n                return;\n            case ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:\n                {\n                    const level = hls.levels[hls.loadLevel];\n                    const restrictedHdcpLevel = level == null ? void 0 : level.attrs[\"HDCP-LEVEL\"];\n                    if (restrictedHdcpLevel) {\n                        data.errorAction = {\n                            action: NetworkErrorAction.SendAlternateToPenaltyBox,\n                            flags: ErrorActionFlags.MoveAllAlternatesMatchingHDCP,\n                            hdcpLevel: restrictedHdcpLevel\n                        };\n                    } else {\n                        this.keySystemError(data);\n                    }\n                }\n                return;\n            case ErrorDetails.BUFFER_ADD_CODEC_ERROR:\n            case ErrorDetails.REMUX_ALLOC_ERROR:\n            case ErrorDetails.BUFFER_APPEND_ERROR:\n                data.errorAction = this.getLevelSwitchAction(data, (_data$level = data.level) != null ? _data$level : hls.loadLevel);\n                return;\n            case ErrorDetails.INTERNAL_EXCEPTION:\n            case ErrorDetails.BUFFER_APPENDING_ERROR:\n            case ErrorDetails.BUFFER_FULL_ERROR:\n            case ErrorDetails.LEVEL_SWITCH_ERROR:\n            case ErrorDetails.BUFFER_STALLED_ERROR:\n            case ErrorDetails.BUFFER_SEEK_OVER_HOLE:\n            case ErrorDetails.BUFFER_NUDGE_ON_STALL:\n                data.errorAction = {\n                    action: NetworkErrorAction.DoNothing,\n                    flags: ErrorActionFlags.None\n                };\n                return;\n        }\n        if (data.type === ErrorTypes.KEY_SYSTEM_ERROR) {\n            this.keySystemError(data);\n        }\n    }\n    keySystemError(data) {\n        const levelIndex = this.getVariantLevelIndex(data.frag);\n        // Do not retry level. Escalate to fatal if switching levels fails.\n        data.levelRetry = false;\n        data.errorAction = this.getLevelSwitchAction(data, levelIndex);\n    }\n    getPlaylistRetryOrSwitchAction(data, levelIndex) {\n        const hls = this.hls;\n        const retryConfig = getRetryConfig(hls.config.playlistLoadPolicy, data);\n        const retryCount = this.playlistError++;\n        const retry = shouldRetry(retryConfig, retryCount, isTimeoutError(data), data.response);\n        if (retry) {\n            return {\n                action: NetworkErrorAction.RetryRequest,\n                flags: ErrorActionFlags.None,\n                retryConfig,\n                retryCount\n            };\n        }\n        const errorAction = this.getLevelSwitchAction(data, levelIndex);\n        if (retryConfig) {\n            errorAction.retryConfig = retryConfig;\n            errorAction.retryCount = retryCount;\n        }\n        return errorAction;\n    }\n    getFragRetryOrSwitchAction(data) {\n        const hls = this.hls;\n        // Share fragment error count accross media options (main, audio, subs)\n        // This allows for level based rendition switching when media option assets fail\n        const variantLevelIndex = this.getVariantLevelIndex(data.frag);\n        const level = hls.levels[variantLevelIndex];\n        const { fragLoadPolicy, keyLoadPolicy } = hls.config;\n        const retryConfig = getRetryConfig(data.details.startsWith(\"key\") ? keyLoadPolicy : fragLoadPolicy, data);\n        const fragmentErrors = hls.levels.reduce((acc, level)=>acc + level.fragmentError, 0);\n        // Switch levels when out of retried or level index out of bounds\n        if (level) {\n            if (data.details !== ErrorDetails.FRAG_GAP) {\n                level.fragmentError++;\n            }\n            const retry = shouldRetry(retryConfig, fragmentErrors, isTimeoutError(data), data.response);\n            if (retry) {\n                return {\n                    action: NetworkErrorAction.RetryRequest,\n                    flags: ErrorActionFlags.None,\n                    retryConfig,\n                    retryCount: fragmentErrors\n                };\n            }\n        }\n        // Reach max retry count, or Missing level reference\n        // Switch to valid index\n        const errorAction = this.getLevelSwitchAction(data, variantLevelIndex);\n        // Add retry details to allow skipping of FRAG_PARSING_ERROR\n        if (retryConfig) {\n            errorAction.retryConfig = retryConfig;\n            errorAction.retryCount = fragmentErrors;\n        }\n        return errorAction;\n    }\n    getLevelSwitchAction(data, levelIndex) {\n        const hls = this.hls;\n        if (levelIndex === null || levelIndex === undefined) {\n            levelIndex = hls.loadLevel;\n        }\n        const level = this.hls.levels[levelIndex];\n        if (level) {\n            var _data$frag2, _data$context2;\n            const errorDetails = data.details;\n            level.loadError++;\n            if (errorDetails === ErrorDetails.BUFFER_APPEND_ERROR) {\n                level.fragmentError++;\n            }\n            // Search for next level to retry\n            let nextLevel = -1;\n            const { levels, loadLevel, minAutoLevel, maxAutoLevel } = hls;\n            if (!hls.autoLevelEnabled) {\n                hls.loadLevel = -1;\n            }\n            const fragErrorType = (_data$frag2 = data.frag) == null ? void 0 : _data$frag2.type;\n            // Find alternate audio codec if available on audio codec error\n            const isAudioCodecError = fragErrorType === PlaylistLevelType.AUDIO && errorDetails === ErrorDetails.FRAG_PARSING_ERROR || data.sourceBufferName === \"audio\" && (errorDetails === ErrorDetails.BUFFER_ADD_CODEC_ERROR || errorDetails === ErrorDetails.BUFFER_APPEND_ERROR);\n            const findAudioCodecAlternate = isAudioCodecError && levels.some(({ audioCodec })=>level.audioCodec !== audioCodec);\n            // Find alternate video codec if available on video codec error\n            const isVideoCodecError = data.sourceBufferName === \"video\" && (errorDetails === ErrorDetails.BUFFER_ADD_CODEC_ERROR || errorDetails === ErrorDetails.BUFFER_APPEND_ERROR);\n            const findVideoCodecAlternate = isVideoCodecError && levels.some(({ codecSet, audioCodec })=>level.codecSet !== codecSet && level.audioCodec === audioCodec);\n            const { type: playlistErrorType, groupId: playlistErrorGroupId } = (_data$context2 = data.context) != null ? _data$context2 : {};\n            for(let i = levels.length; i--;){\n                const candidate = (i + loadLevel) % levels.length;\n                if (candidate !== loadLevel && candidate >= minAutoLevel && candidate <= maxAutoLevel && levels[candidate].loadError === 0) {\n                    var _level$audioGroups, _level$subtitleGroups;\n                    const levelCandidate = levels[candidate];\n                    // Skip level switch if GAP tag is found in next level at same position\n                    if (errorDetails === ErrorDetails.FRAG_GAP && data.frag) {\n                        const levelDetails = levels[candidate].details;\n                        if (levelDetails) {\n                            const fragCandidate = findFragmentByPTS(data.frag, levelDetails.fragments, data.frag.start);\n                            if (fragCandidate != null && fragCandidate.gap) {\n                                continue;\n                            }\n                        }\n                    } else if (playlistErrorType === PlaylistContextType.AUDIO_TRACK && levelCandidate.hasAudioGroup(playlistErrorGroupId) || playlistErrorType === PlaylistContextType.SUBTITLE_TRACK && levelCandidate.hasSubtitleGroup(playlistErrorGroupId)) {\n                        continue;\n                    } else if (fragErrorType === PlaylistLevelType.AUDIO && (_level$audioGroups = level.audioGroups) != null && _level$audioGroups.some((groupId)=>levelCandidate.hasAudioGroup(groupId)) || fragErrorType === PlaylistLevelType.SUBTITLE && (_level$subtitleGroups = level.subtitleGroups) != null && _level$subtitleGroups.some((groupId)=>levelCandidate.hasSubtitleGroup(groupId)) || findAudioCodecAlternate && level.audioCodec === levelCandidate.audioCodec || !findAudioCodecAlternate && level.audioCodec !== levelCandidate.audioCodec || findVideoCodecAlternate && level.codecSet === levelCandidate.codecSet) {\n                        continue;\n                    }\n                    nextLevel = candidate;\n                    break;\n                }\n            }\n            if (nextLevel > -1 && hls.loadLevel !== nextLevel) {\n                data.levelRetry = true;\n                this.playlistError = 0;\n                return {\n                    action: NetworkErrorAction.SendAlternateToPenaltyBox,\n                    flags: ErrorActionFlags.None,\n                    nextAutoLevel: nextLevel\n                };\n            }\n        }\n        // No levels to switch / Manual level selection / Level not found\n        // Resolve with Pathway switch, Redundant fail-over, or stay on lowest Level\n        return {\n            action: NetworkErrorAction.SendAlternateToPenaltyBox,\n            flags: ErrorActionFlags.MoveAllAlternatesMatchingHost\n        };\n    }\n    onErrorOut(event, data) {\n        var _data$errorAction;\n        switch((_data$errorAction = data.errorAction) == null ? void 0 : _data$errorAction.action){\n            case NetworkErrorAction.DoNothing:\n                break;\n            case NetworkErrorAction.SendAlternateToPenaltyBox:\n                this.sendAlternateToPenaltyBox(data);\n                if (!data.errorAction.resolved && data.details !== ErrorDetails.FRAG_GAP) {\n                    data.fatal = true;\n                } else if (/MediaSource readyState: ended/.test(data.error.message)) {\n                    this.warn(`MediaSource ended after \"${data.sourceBufferName}\" sourceBuffer append error. Attempting to recover from media error.`);\n                    this.hls.recoverMediaError();\n                }\n                break;\n            case NetworkErrorAction.RetryRequest:\n                break;\n        }\n        if (data.fatal) {\n            this.hls.stopLoad();\n            return;\n        }\n    }\n    sendAlternateToPenaltyBox(data) {\n        const hls = this.hls;\n        const errorAction = data.errorAction;\n        if (!errorAction) {\n            return;\n        }\n        const { flags, hdcpLevel, nextAutoLevel } = errorAction;\n        switch(flags){\n            case ErrorActionFlags.None:\n                this.switchLevel(data, nextAutoLevel);\n                break;\n            case ErrorActionFlags.MoveAllAlternatesMatchingHDCP:\n                if (hdcpLevel) {\n                    hls.maxHdcpLevel = HdcpLevels[HdcpLevels.indexOf(hdcpLevel) - 1];\n                    errorAction.resolved = true;\n                }\n                this.warn(`Restricting playback to HDCP-LEVEL of \"${hls.maxHdcpLevel}\" or lower`);\n                break;\n        }\n        // If not resolved by previous actions try to switch to next level\n        if (!errorAction.resolved) {\n            this.switchLevel(data, nextAutoLevel);\n        }\n    }\n    switchLevel(data, levelIndex) {\n        if (levelIndex !== undefined && data.errorAction) {\n            this.warn(`switching to level ${levelIndex} after ${data.details}`);\n            this.hls.nextAutoLevel = levelIndex;\n            data.errorAction.resolved = true;\n            // Stream controller is responsible for this but won't switch on false start\n            this.hls.nextLoadLevel = this.hls.nextAutoLevel;\n        }\n    }\n}\nclass BasePlaylistController {\n    constructor(hls, logPrefix){\n        this.hls = void 0;\n        this.timer = -1;\n        this.requestScheduled = -1;\n        this.canLoad = false;\n        this.log = void 0;\n        this.warn = void 0;\n        this.log = logger.log.bind(logger, `${logPrefix}:`);\n        this.warn = logger.warn.bind(logger, `${logPrefix}:`);\n        this.hls = hls;\n    }\n    destroy() {\n        this.clearTimer();\n        // @ts-ignore\n        this.hls = this.log = this.warn = null;\n    }\n    clearTimer() {\n        if (this.timer !== -1) {\n            self.clearTimeout(this.timer);\n            this.timer = -1;\n        }\n    }\n    startLoad() {\n        this.canLoad = true;\n        this.requestScheduled = -1;\n        this.loadPlaylist();\n    }\n    stopLoad() {\n        this.canLoad = false;\n        this.clearTimer();\n    }\n    switchParams(playlistUri, previous) {\n        const renditionReports = previous == null ? void 0 : previous.renditionReports;\n        if (renditionReports) {\n            let foundIndex = -1;\n            for(let i = 0; i < renditionReports.length; i++){\n                const attr = renditionReports[i];\n                let uri;\n                try {\n                    uri = new self.URL(attr.URI, previous.url).href;\n                } catch (error) {\n                    logger.warn(`Could not construct new URL for Rendition Report: ${error}`);\n                    uri = attr.URI || \"\";\n                }\n                // Use exact match. Otherwise, the last partial match, if any, will be used\n                // (Playlist URI includes a query string that the Rendition Report does not)\n                if (uri === playlistUri) {\n                    foundIndex = i;\n                    break;\n                } else if (uri === playlistUri.substring(0, uri.length)) {\n                    foundIndex = i;\n                }\n            }\n            if (foundIndex !== -1) {\n                const attr = renditionReports[foundIndex];\n                const msn = parseInt(attr[\"LAST-MSN\"]) || (previous == null ? void 0 : previous.lastPartSn);\n                let part = parseInt(attr[\"LAST-PART\"]) || (previous == null ? void 0 : previous.lastPartIndex);\n                if (this.hls.config.lowLatencyMode) {\n                    const currentGoal = Math.min(previous.age - previous.partTarget, previous.targetduration);\n                    if (part >= 0 && currentGoal > previous.partTarget) {\n                        part += 1;\n                    }\n                }\n                return new HlsUrlParameters(msn, part >= 0 ? part : undefined, HlsSkip.No);\n            }\n        }\n    }\n    loadPlaylist(hlsUrlParameters) {\n        if (this.requestScheduled === -1) {\n            this.requestScheduled = self.performance.now();\n        }\n    // Loading is handled by the subclasses\n    }\n    shouldLoadPlaylist(playlist) {\n        return this.canLoad && !!playlist && !!playlist.url && (!playlist.details || playlist.details.live);\n    }\n    shouldReloadPlaylist(playlist) {\n        return this.timer === -1 && this.requestScheduled === -1 && this.shouldLoadPlaylist(playlist);\n    }\n    playlistLoaded(index, data, previousDetails) {\n        const { details, stats } = data;\n        // Set last updated date-time\n        const now = self.performance.now();\n        const elapsed = stats.loading.first ? Math.max(0, now - stats.loading.first) : 0;\n        details.advancedDateTime = Date.now() - elapsed;\n        // if current playlist is a live playlist, arm a timer to reload it\n        if (details.live || previousDetails != null && previousDetails.live) {\n            details.reloaded(previousDetails);\n            if (previousDetails) {\n                this.log(`live playlist ${index} ${details.advanced ? \"REFRESHED \" + details.lastPartSn + \"-\" + details.lastPartIndex : details.updated ? \"UPDATED\" : \"MISSED\"}`);\n            }\n            // Merge live playlists to adjust fragment starts and fill in delta playlist skipped segments\n            if (previousDetails && details.fragments.length > 0) {\n                mergeDetails(previousDetails, details);\n            }\n            if (!this.canLoad || !details.live) {\n                return;\n            }\n            let deliveryDirectives;\n            let msn = undefined;\n            let part = undefined;\n            if (details.canBlockReload && details.endSN && details.advanced) {\n                // Load level with LL-HLS delivery directives\n                const lowLatencyMode = this.hls.config.lowLatencyMode;\n                const lastPartSn = details.lastPartSn;\n                const endSn = details.endSN;\n                const lastPartIndex = details.lastPartIndex;\n                const hasParts = lastPartIndex !== -1;\n                const lastPart = lastPartSn === endSn;\n                // When low latency mode is disabled, we'll skip part requests once the last part index is found\n                const nextSnStartIndex = lowLatencyMode ? 0 : lastPartIndex;\n                if (hasParts) {\n                    msn = lastPart ? endSn + 1 : lastPartSn;\n                    part = lastPart ? nextSnStartIndex : lastPartIndex + 1;\n                } else {\n                    msn = endSn + 1;\n                }\n                // Low-Latency CDN Tune-in: \"age\" header and time since load indicates we're behind by more than one part\n                // Update directives to obtain the Playlist that has the estimated additional duration of media\n                const lastAdvanced = details.age;\n                const cdnAge = lastAdvanced + details.ageHeader;\n                let currentGoal = Math.min(cdnAge - details.partTarget, details.targetduration * 1.5);\n                if (currentGoal > 0) {\n                    if (previousDetails && currentGoal > previousDetails.tuneInGoal) {\n                        // If we attempted to get the next or latest playlist update, but currentGoal increased,\n                        // then we either can't catchup, or the \"age\" header cannot be trusted.\n                        this.warn(`CDN Tune-in goal increased from: ${previousDetails.tuneInGoal} to: ${currentGoal} with playlist age: ${details.age}`);\n                        currentGoal = 0;\n                    } else {\n                        const segments = Math.floor(currentGoal / details.targetduration);\n                        msn += segments;\n                        if (part !== undefined) {\n                            const parts = Math.round(currentGoal % details.targetduration / details.partTarget);\n                            part += parts;\n                        }\n                        this.log(`CDN Tune-in age: ${details.ageHeader}s last advanced ${lastAdvanced.toFixed(2)}s goal: ${currentGoal} skip sn ${segments} to part ${part}`);\n                    }\n                    details.tuneInGoal = currentGoal;\n                }\n                deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);\n                if (lowLatencyMode || !lastPart) {\n                    this.loadPlaylist(deliveryDirectives);\n                    return;\n                }\n            } else if (details.canBlockReload || details.canSkipUntil) {\n                deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);\n            }\n            const bufferInfo = this.hls.mainForwardBufferInfo;\n            const position = bufferInfo ? bufferInfo.end - bufferInfo.len : 0;\n            const distanceToLiveEdgeMs = (details.edge - position) * 1000;\n            const reloadInterval = computeReloadInterval(details, distanceToLiveEdgeMs);\n            if (details.updated && now > this.requestScheduled + reloadInterval) {\n                this.requestScheduled = stats.loading.start;\n            }\n            if (msn !== undefined && details.canBlockReload) {\n                this.requestScheduled = stats.loading.first + reloadInterval - (details.partTarget * 1000 || 1000);\n            } else if (this.requestScheduled === -1 || this.requestScheduled + reloadInterval < now) {\n                this.requestScheduled = now;\n            } else if (this.requestScheduled - now <= 0) {\n                this.requestScheduled += reloadInterval;\n            }\n            let estimatedTimeUntilUpdate = this.requestScheduled - now;\n            estimatedTimeUntilUpdate = Math.max(0, estimatedTimeUntilUpdate);\n            this.log(`reload live playlist ${index} in ${Math.round(estimatedTimeUntilUpdate)} ms`);\n            // this.log(\n            //   `live reload ${details.updated ? 'REFRESHED' : 'MISSED'}\n            // reload in ${estimatedTimeUntilUpdate / 1000}\n            // round trip ${(stats.loading.end - stats.loading.start) / 1000}\n            // diff ${\n            //   (reloadInterval -\n            //     (estimatedTimeUntilUpdate +\n            //       stats.loading.end -\n            //       stats.loading.start)) /\n            //   1000\n            // }\n            // reload interval ${reloadInterval / 1000}\n            // target duration ${details.targetduration}\n            // distance to edge ${distanceToLiveEdgeMs / 1000}`\n            // );\n            this.timer = self.setTimeout(()=>this.loadPlaylist(deliveryDirectives), estimatedTimeUntilUpdate);\n        } else {\n            this.clearTimer();\n        }\n    }\n    getDeliveryDirectives(details, previousDeliveryDirectives, msn, part) {\n        let skip = getSkipValue(details, msn);\n        if (previousDeliveryDirectives != null && previousDeliveryDirectives.skip && details.deltaUpdateFailed) {\n            msn = previousDeliveryDirectives.msn;\n            part = previousDeliveryDirectives.part;\n            skip = HlsSkip.No;\n        }\n        return new HlsUrlParameters(msn, part, skip);\n    }\n    checkRetry(errorEvent) {\n        const errorDetails = errorEvent.details;\n        const isTimeout = isTimeoutError(errorEvent);\n        const errorAction = errorEvent.errorAction;\n        const { action, retryCount = 0, retryConfig } = errorAction || {};\n        const retry = !!errorAction && !!retryConfig && (action === NetworkErrorAction.RetryRequest || !errorAction.resolved && action === NetworkErrorAction.SendAlternateToPenaltyBox);\n        if (retry) {\n            var _errorEvent$context;\n            this.requestScheduled = -1;\n            if (retryCount >= retryConfig.maxNumRetry) {\n                return false;\n            }\n            if (isTimeout && (_errorEvent$context = errorEvent.context) != null && _errorEvent$context.deliveryDirectives) {\n                // The LL-HLS request already timed out so retry immediately\n                this.warn(`Retrying playlist loading ${retryCount + 1}/${retryConfig.maxNumRetry} after \"${errorDetails}\" without delivery-directives`);\n                this.loadPlaylist();\n            } else {\n                const delay = getRetryDelay(retryConfig, retryCount);\n                // Schedule level/track reload\n                this.timer = self.setTimeout(()=>this.loadPlaylist(), delay);\n                this.warn(`Retrying playlist loading ${retryCount + 1}/${retryConfig.maxNumRetry} after \"${errorDetails}\" in ${delay}ms`);\n            }\n            // `levelRetry = true` used to inform other controllers that a retry is happening\n            errorEvent.levelRetry = true;\n            errorAction.resolved = true;\n        }\n        return retry;\n    }\n}\n/*\n * compute an Exponential Weighted moving average\n * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average\n *  - heavily inspired from shaka-player\n */ class EWMA {\n    //  About half of the estimated value will be from the last |halfLife| samples by weight.\n    constructor(halfLife, estimate = 0, weight = 0){\n        this.halfLife = void 0;\n        this.alpha_ = void 0;\n        this.estimate_ = void 0;\n        this.totalWeight_ = void 0;\n        this.halfLife = halfLife;\n        // Larger values of alpha expire historical data more slowly.\n        this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;\n        this.estimate_ = estimate;\n        this.totalWeight_ = weight;\n    }\n    sample(weight, value) {\n        const adjAlpha = Math.pow(this.alpha_, weight);\n        this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;\n        this.totalWeight_ += weight;\n    }\n    getTotalWeight() {\n        return this.totalWeight_;\n    }\n    getEstimate() {\n        if (this.alpha_) {\n            const zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);\n            if (zeroFactor) {\n                return this.estimate_ / zeroFactor;\n            }\n        }\n        return this.estimate_;\n    }\n}\n/*\n * EWMA Bandwidth Estimator\n *  - heavily inspired from shaka-player\n * Tracks bandwidth samples and estimates available bandwidth.\n * Based on the minimum of two exponentially-weighted moving averages with\n * different half-lives.\n */ class EwmaBandWidthEstimator {\n    constructor(slow, fast, defaultEstimate, defaultTTFB = 100){\n        this.defaultEstimate_ = void 0;\n        this.minWeight_ = void 0;\n        this.minDelayMs_ = void 0;\n        this.slow_ = void 0;\n        this.fast_ = void 0;\n        this.defaultTTFB_ = void 0;\n        this.ttfb_ = void 0;\n        this.defaultEstimate_ = defaultEstimate;\n        this.minWeight_ = 0.001;\n        this.minDelayMs_ = 50;\n        this.slow_ = new EWMA(slow);\n        this.fast_ = new EWMA(fast);\n        this.defaultTTFB_ = defaultTTFB;\n        this.ttfb_ = new EWMA(slow);\n    }\n    update(slow, fast) {\n        const { slow_, fast_, ttfb_ } = this;\n        if (slow_.halfLife !== slow) {\n            this.slow_ = new EWMA(slow, slow_.getEstimate(), slow_.getTotalWeight());\n        }\n        if (fast_.halfLife !== fast) {\n            this.fast_ = new EWMA(fast, fast_.getEstimate(), fast_.getTotalWeight());\n        }\n        if (ttfb_.halfLife !== slow) {\n            this.ttfb_ = new EWMA(slow, ttfb_.getEstimate(), ttfb_.getTotalWeight());\n        }\n    }\n    sample(durationMs, numBytes) {\n        durationMs = Math.max(durationMs, this.minDelayMs_);\n        const numBits = 8 * numBytes;\n        // weight is duration in seconds\n        const durationS = durationMs / 1000;\n        // value is bandwidth in bits/s\n        const bandwidthInBps = numBits / durationS;\n        this.fast_.sample(durationS, bandwidthInBps);\n        this.slow_.sample(durationS, bandwidthInBps);\n    }\n    sampleTTFB(ttfb) {\n        // weight is frequency curve applied to TTFB in seconds\n        // (longer times have less weight with expected input under 1 second)\n        const seconds = ttfb / 1000;\n        const weight = Math.sqrt(2) * Math.exp(-Math.pow(seconds, 2) / 2);\n        this.ttfb_.sample(weight, Math.max(ttfb, 5));\n    }\n    canEstimate() {\n        return this.fast_.getTotalWeight() >= this.minWeight_;\n    }\n    getEstimate() {\n        if (this.canEstimate()) {\n            // console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));\n            // console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));\n            // Take the minimum of these two estimates.  This should have the effect of\n            // adapting down quickly, but up more slowly.\n            return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());\n        } else {\n            return this.defaultEstimate_;\n        }\n    }\n    getEstimateTTFB() {\n        if (this.ttfb_.getTotalWeight() >= this.minWeight_) {\n            return this.ttfb_.getEstimate();\n        } else {\n            return this.defaultTTFB_;\n        }\n    }\n    destroy() {}\n}\nconst SUPPORTED_INFO_DEFAULT = {\n    supported: true,\n    configurations: [],\n    decodingInfoResults: [\n        {\n            supported: true,\n            powerEfficient: true,\n            smooth: true\n        }\n    ]\n};\nconst SUPPORTED_INFO_CACHE = {};\nfunction requiresMediaCapabilitiesDecodingInfo(level, audioTracksByGroup, currentVideoRange, currentFrameRate, currentBw, audioPreference) {\n    // Only test support when configuration is exceeds minimum options\n    const audioGroups = level.audioCodec ? level.audioGroups : null;\n    const audioCodecPreference = audioPreference == null ? void 0 : audioPreference.audioCodec;\n    const channelsPreference = audioPreference == null ? void 0 : audioPreference.channels;\n    const maxChannels = channelsPreference ? parseInt(channelsPreference) : audioCodecPreference ? Infinity : 2;\n    let audioChannels = null;\n    if (audioGroups != null && audioGroups.length) {\n        try {\n            if (audioGroups.length === 1 && audioGroups[0]) {\n                audioChannels = audioTracksByGroup.groups[audioGroups[0]].channels;\n            } else {\n                audioChannels = audioGroups.reduce((acc, groupId)=>{\n                    if (groupId) {\n                        const audioTrackGroup = audioTracksByGroup.groups[groupId];\n                        if (!audioTrackGroup) {\n                            throw new Error(`Audio track group ${groupId} not found`);\n                        }\n                        // Sum all channel key values\n                        Object.keys(audioTrackGroup.channels).forEach((key)=>{\n                            acc[key] = (acc[key] || 0) + audioTrackGroup.channels[key];\n                        });\n                    }\n                    return acc;\n                }, {\n                    2: 0\n                });\n            }\n        } catch (error) {\n            return true;\n        }\n    }\n    return level.videoCodec !== undefined && (level.width > 1920 && level.height > 1088 || level.height > 1920 && level.width > 1088 || level.frameRate > Math.max(currentFrameRate, 30) || level.videoRange !== \"SDR\" && level.videoRange !== currentVideoRange || level.bitrate > Math.max(currentBw, 8e6)) || !!audioChannels && isFiniteNumber(maxChannels) && Object.keys(audioChannels).some((channels)=>parseInt(channels) > maxChannels);\n}\nfunction getMediaDecodingInfoPromise(level, audioTracksByGroup, mediaCapabilities) {\n    const videoCodecs = level.videoCodec;\n    const audioCodecs = level.audioCodec;\n    if (!videoCodecs || !audioCodecs || !mediaCapabilities) {\n        return Promise.resolve(SUPPORTED_INFO_DEFAULT);\n    }\n    const baseVideoConfiguration = {\n        width: level.width,\n        height: level.height,\n        bitrate: Math.ceil(Math.max(level.bitrate * 0.9, level.averageBitrate)),\n        // Assume a framerate of 30fps since MediaCapabilities will not accept Level default of 0.\n        framerate: level.frameRate || 30\n    };\n    const videoRange = level.videoRange;\n    if (videoRange !== \"SDR\") {\n        baseVideoConfiguration.transferFunction = videoRange.toLowerCase();\n    }\n    const configurations = videoCodecs.split(\",\").map((videoCodec)=>({\n            type: \"media-source\",\n            video: _objectSpread2(_objectSpread2({}, baseVideoConfiguration), {}, {\n                contentType: mimeTypeForCodec(videoCodec, \"video\")\n            })\n        }));\n    if (audioCodecs && level.audioGroups) {\n        level.audioGroups.forEach((audioGroupId)=>{\n            var _audioTracksByGroup$g;\n            if (!audioGroupId) {\n                return;\n            }\n            (_audioTracksByGroup$g = audioTracksByGroup.groups[audioGroupId]) == null ? void 0 : _audioTracksByGroup$g.tracks.forEach((audioTrack)=>{\n                if (audioTrack.groupId === audioGroupId) {\n                    const channels = audioTrack.channels || \"\";\n                    const channelsNumber = parseFloat(channels);\n                    if (isFiniteNumber(channelsNumber) && channelsNumber > 2) {\n                        configurations.push.apply(configurations, audioCodecs.split(\",\").map((audioCodec)=>({\n                                type: \"media-source\",\n                                audio: {\n                                    contentType: mimeTypeForCodec(audioCodec, \"audio\"),\n                                    channels: \"\" + channelsNumber\n                                }\n                            })));\n                    }\n                }\n            });\n        });\n    }\n    return Promise.all(configurations.map((configuration)=>{\n        // Cache MediaCapabilities promises\n        const decodingInfoKey = getMediaDecodingInfoKey(configuration);\n        return SUPPORTED_INFO_CACHE[decodingInfoKey] || (SUPPORTED_INFO_CACHE[decodingInfoKey] = mediaCapabilities.decodingInfo(configuration));\n    })).then((decodingInfoResults)=>({\n            supported: !decodingInfoResults.some((info)=>!info.supported),\n            configurations,\n            decodingInfoResults\n        })).catch((error)=>({\n            supported: false,\n            configurations,\n            decodingInfoResults: [],\n            error\n        }));\n}\nfunction getMediaDecodingInfoKey(config) {\n    const { audio, video } = config;\n    const mediaConfig = video || audio;\n    if (mediaConfig) {\n        const codec = mediaConfig.contentType.split('\"')[1];\n        if (video) {\n            return `r${video.height}x${video.width}f${Math.ceil(video.framerate)}${video.transferFunction || \"sd\"}_${codec}_${Math.ceil(video.bitrate / 1e5)}`;\n        }\n        if (audio) {\n            return `c${audio.channels}${audio.spatialRendering ? \"s\" : \"n\"}_${codec}`;\n        }\n    }\n    return \"\";\n}\n/**\n * @returns Whether we can detect and validate HDR capability within the window context\n */ function isHdrSupported() {\n    if (typeof matchMedia === \"function\") {\n        const mediaQueryList = matchMedia(\"(dynamic-range: high)\");\n        const badQuery = matchMedia(\"bad query\");\n        if (mediaQueryList.media !== badQuery.media) {\n            return mediaQueryList.matches === true;\n        }\n    }\n    return false;\n}\n/**\n * Sanitizes inputs to return the active video selection options for HDR/SDR.\n * When both inputs are null:\n *\n *    `{ preferHDR: false, allowedVideoRanges: [] }`\n *\n * When `currentVideoRange` non-null, maintain the active range:\n *\n *    `{ preferHDR: currentVideoRange !== 'SDR', allowedVideoRanges: [currentVideoRange] }`\n *\n * When VideoSelectionOption non-null:\n *\n *  - Allow all video ranges if `allowedVideoRanges` unspecified.\n *  - If `preferHDR` is non-null use the value to filter `allowedVideoRanges`.\n *  - Else check window for HDR support and set `preferHDR` to the result.\n *\n * @param currentVideoRange\n * @param videoPreference\n */ function getVideoSelectionOptions(currentVideoRange, videoPreference) {\n    let preferHDR = false;\n    let allowedVideoRanges = [];\n    if (currentVideoRange) {\n        preferHDR = currentVideoRange !== \"SDR\";\n        allowedVideoRanges = [\n            currentVideoRange\n        ];\n    }\n    if (videoPreference) {\n        allowedVideoRanges = videoPreference.allowedVideoRanges || VideoRangeValues.slice(0);\n        preferHDR = videoPreference.preferHDR !== undefined ? videoPreference.preferHDR : isHdrSupported();\n        if (preferHDR) {\n            allowedVideoRanges = allowedVideoRanges.filter((range)=>range !== \"SDR\");\n        } else {\n            allowedVideoRanges = [\n                \"SDR\"\n            ];\n        }\n    }\n    return {\n        preferHDR,\n        allowedVideoRanges\n    };\n}\nfunction getStartCodecTier(codecTiers, currentVideoRange, currentBw, audioPreference, videoPreference) {\n    const codecSets = Object.keys(codecTiers);\n    const channelsPreference = audioPreference == null ? void 0 : audioPreference.channels;\n    const audioCodecPreference = audioPreference == null ? void 0 : audioPreference.audioCodec;\n    const preferStereo = channelsPreference && parseInt(channelsPreference) === 2;\n    // Use first level set to determine stereo, and minimum resolution and framerate\n    let hasStereo = true;\n    let hasCurrentVideoRange = false;\n    let minHeight = Infinity;\n    let minFramerate = Infinity;\n    let minBitrate = Infinity;\n    let selectedScore = 0;\n    let videoRanges = [];\n    const { preferHDR, allowedVideoRanges } = getVideoSelectionOptions(currentVideoRange, videoPreference);\n    for(let i = codecSets.length; i--;){\n        const tier = codecTiers[codecSets[i]];\n        hasStereo = tier.channels[2] > 0;\n        minHeight = Math.min(minHeight, tier.minHeight);\n        minFramerate = Math.min(minFramerate, tier.minFramerate);\n        minBitrate = Math.min(minBitrate, tier.minBitrate);\n        const matchingVideoRanges = allowedVideoRanges.filter((range)=>tier.videoRanges[range] > 0);\n        if (matchingVideoRanges.length > 0) {\n            hasCurrentVideoRange = true;\n            videoRanges = matchingVideoRanges;\n        }\n    }\n    minHeight = isFiniteNumber(minHeight) ? minHeight : 0;\n    minFramerate = isFiniteNumber(minFramerate) ? minFramerate : 0;\n    const maxHeight = Math.max(1080, minHeight);\n    const maxFramerate = Math.max(30, minFramerate);\n    minBitrate = isFiniteNumber(minBitrate) ? minBitrate : currentBw;\n    currentBw = Math.max(minBitrate, currentBw);\n    // If there are no variants with matching preference, set currentVideoRange to undefined\n    if (!hasCurrentVideoRange) {\n        currentVideoRange = undefined;\n        videoRanges = [];\n    }\n    const codecSet = codecSets.reduce((selected, candidate)=>{\n        // Remove candiates which do not meet bitrate, default audio, stereo or channels preference, 1080p or lower, 30fps or lower, or SDR/HDR selection if present\n        const candidateTier = codecTiers[candidate];\n        if (candidate === selected) {\n            return selected;\n        }\n        if (candidateTier.minBitrate > currentBw) {\n            logStartCodecCandidateIgnored(candidate, `min bitrate of ${candidateTier.minBitrate} > current estimate of ${currentBw}`);\n            return selected;\n        }\n        if (!candidateTier.hasDefaultAudio) {\n            logStartCodecCandidateIgnored(candidate, `no renditions with default or auto-select sound found`);\n            return selected;\n        }\n        if (audioCodecPreference && candidate.indexOf(audioCodecPreference.substring(0, 4)) % 5 !== 0) {\n            logStartCodecCandidateIgnored(candidate, `audio codec preference \"${audioCodecPreference}\" not found`);\n            return selected;\n        }\n        if (channelsPreference && !preferStereo) {\n            if (!candidateTier.channels[channelsPreference]) {\n                logStartCodecCandidateIgnored(candidate, `no renditions with ${channelsPreference} channel sound found (channels options: ${Object.keys(candidateTier.channels)})`);\n                return selected;\n            }\n        } else if ((!audioCodecPreference || preferStereo) && hasStereo && candidateTier.channels[\"2\"] === 0) {\n            logStartCodecCandidateIgnored(candidate, `no renditions with stereo sound found`);\n            return selected;\n        }\n        if (candidateTier.minHeight > maxHeight) {\n            logStartCodecCandidateIgnored(candidate, `min resolution of ${candidateTier.minHeight} > maximum of ${maxHeight}`);\n            return selected;\n        }\n        if (candidateTier.minFramerate > maxFramerate) {\n            logStartCodecCandidateIgnored(candidate, `min framerate of ${candidateTier.minFramerate} > maximum of ${maxFramerate}`);\n            return selected;\n        }\n        if (!videoRanges.some((range)=>candidateTier.videoRanges[range] > 0)) {\n            logStartCodecCandidateIgnored(candidate, `no variants with VIDEO-RANGE of ${JSON.stringify(videoRanges)} found`);\n            return selected;\n        }\n        if (candidateTier.maxScore < selectedScore) {\n            logStartCodecCandidateIgnored(candidate, `max score of ${candidateTier.maxScore} < selected max of ${selectedScore}`);\n            return selected;\n        }\n        // Remove candiates with less preferred codecs or more errors\n        if (selected && (codecsSetSelectionPreferenceValue(candidate) >= codecsSetSelectionPreferenceValue(selected) || candidateTier.fragmentError > codecTiers[selected].fragmentError)) {\n            return selected;\n        }\n        selectedScore = candidateTier.maxScore;\n        return candidate;\n    }, undefined);\n    return {\n        codecSet,\n        videoRanges,\n        preferHDR,\n        minFramerate,\n        minBitrate\n    };\n}\nfunction logStartCodecCandidateIgnored(codeSet, reason) {\n    logger.log(`[abr] start candidates with \"${codeSet}\" ignored because ${reason}`);\n}\nfunction getAudioTracksByGroup(allAudioTracks) {\n    return allAudioTracks.reduce((audioTracksByGroup, track)=>{\n        let trackGroup = audioTracksByGroup.groups[track.groupId];\n        if (!trackGroup) {\n            trackGroup = audioTracksByGroup.groups[track.groupId] = {\n                tracks: [],\n                channels: {\n                    2: 0\n                },\n                hasDefault: false,\n                hasAutoSelect: false\n            };\n        }\n        trackGroup.tracks.push(track);\n        const channelsKey = track.channels || \"2\";\n        trackGroup.channels[channelsKey] = (trackGroup.channels[channelsKey] || 0) + 1;\n        trackGroup.hasDefault = trackGroup.hasDefault || track.default;\n        trackGroup.hasAutoSelect = trackGroup.hasAutoSelect || track.autoselect;\n        if (trackGroup.hasDefault) {\n            audioTracksByGroup.hasDefaultAudio = true;\n        }\n        if (trackGroup.hasAutoSelect) {\n            audioTracksByGroup.hasAutoSelectAudio = true;\n        }\n        return audioTracksByGroup;\n    }, {\n        hasDefaultAudio: false,\n        hasAutoSelectAudio: false,\n        groups: {}\n    });\n}\nfunction getCodecTiers(levels, audioTracksByGroup, minAutoLevel, maxAutoLevel) {\n    return levels.slice(minAutoLevel, maxAutoLevel + 1).reduce((tiers, level)=>{\n        if (!level.codecSet) {\n            return tiers;\n        }\n        const audioGroups = level.audioGroups;\n        let tier = tiers[level.codecSet];\n        if (!tier) {\n            tiers[level.codecSet] = tier = {\n                minBitrate: Infinity,\n                minHeight: Infinity,\n                minFramerate: Infinity,\n                maxScore: 0,\n                videoRanges: {\n                    SDR: 0\n                },\n                channels: {\n                    \"2\": 0\n                },\n                hasDefaultAudio: !audioGroups,\n                fragmentError: 0\n            };\n        }\n        tier.minBitrate = Math.min(tier.minBitrate, level.bitrate);\n        const lesserWidthOrHeight = Math.min(level.height, level.width);\n        tier.minHeight = Math.min(tier.minHeight, lesserWidthOrHeight);\n        tier.minFramerate = Math.min(tier.minFramerate, level.frameRate);\n        tier.maxScore = Math.max(tier.maxScore, level.score);\n        tier.fragmentError += level.fragmentError;\n        tier.videoRanges[level.videoRange] = (tier.videoRanges[level.videoRange] || 0) + 1;\n        if (audioGroups) {\n            audioGroups.forEach((audioGroupId)=>{\n                if (!audioGroupId) {\n                    return;\n                }\n                const audioGroup = audioTracksByGroup.groups[audioGroupId];\n                // Default audio is any group with DEFAULT=YES, or if missing then any group with AUTOSELECT=YES, or all variants\n                tier.hasDefaultAudio = tier.hasDefaultAudio || audioTracksByGroup.hasDefaultAudio ? audioGroup.hasDefault : audioGroup.hasAutoSelect || !audioTracksByGroup.hasDefaultAudio && !audioTracksByGroup.hasAutoSelectAudio;\n                Object.keys(audioGroup.channels).forEach((channels)=>{\n                    tier.channels[channels] = (tier.channels[channels] || 0) + audioGroup.channels[channels];\n                });\n            });\n        }\n        return tiers;\n    }, {});\n}\nfunction findMatchingOption(option, tracks, matchPredicate) {\n    if (\"attrs\" in option) {\n        const index = tracks.indexOf(option);\n        if (index !== -1) {\n            return index;\n        }\n    }\n    for(let i = 0; i < tracks.length; i++){\n        const track = tracks[i];\n        if (matchesOption(option, track, matchPredicate)) {\n            return i;\n        }\n    }\n    return -1;\n}\nfunction matchesOption(option, track, matchPredicate) {\n    const { groupId, name, lang, assocLang, characteristics, default: isDefault } = option;\n    const forced = option.forced;\n    return (groupId === undefined || track.groupId === groupId) && (name === undefined || track.name === name) && (lang === undefined || track.lang === lang) && (lang === undefined || track.assocLang === assocLang) && (isDefault === undefined || track.default === isDefault) && (forced === undefined || track.forced === forced) && (characteristics === undefined || characteristicsMatch(characteristics, track.characteristics)) && (matchPredicate === undefined || matchPredicate(option, track));\n}\nfunction characteristicsMatch(characteristicsA, characteristicsB = \"\") {\n    const arrA = characteristicsA.split(\",\");\n    const arrB = characteristicsB.split(\",\");\n    // Expects each item to be unique:\n    return arrA.length === arrB.length && !arrA.some((el)=>arrB.indexOf(el) === -1);\n}\nfunction audioMatchPredicate(option, track) {\n    const { audioCodec, channels } = option;\n    return (audioCodec === undefined || (track.audioCodec || \"\").substring(0, 4) === audioCodec.substring(0, 4)) && (channels === undefined || channels === (track.channels || \"2\"));\n}\nfunction findClosestLevelWithAudioGroup(option, levels, allAudioTracks, searchIndex, matchPredicate) {\n    const currentLevel = levels[searchIndex];\n    // Are there variants with same URI as current level?\n    // If so, find a match that does not require any level URI change\n    const variants = levels.reduce((variantMap, level, index)=>{\n        const uri = level.uri;\n        const renditions = variantMap[uri] || (variantMap[uri] = []);\n        renditions.push(index);\n        return variantMap;\n    }, {});\n    const renditions = variants[currentLevel.uri];\n    if (renditions.length > 1) {\n        searchIndex = Math.max.apply(Math, renditions);\n    }\n    // Find best match\n    const currentVideoRange = currentLevel.videoRange;\n    const currentFrameRate = currentLevel.frameRate;\n    const currentVideoCodec = currentLevel.codecSet.substring(0, 4);\n    const matchingVideo = searchDownAndUpList(levels, searchIndex, (level)=>{\n        if (level.videoRange !== currentVideoRange || level.frameRate !== currentFrameRate || level.codecSet.substring(0, 4) !== currentVideoCodec) {\n            return false;\n        }\n        const audioGroups = level.audioGroups;\n        const tracks = allAudioTracks.filter((track)=>!audioGroups || audioGroups.indexOf(track.groupId) !== -1);\n        return findMatchingOption(option, tracks, matchPredicate) > -1;\n    });\n    if (matchingVideo > -1) {\n        return matchingVideo;\n    }\n    return searchDownAndUpList(levels, searchIndex, (level)=>{\n        const audioGroups = level.audioGroups;\n        const tracks = allAudioTracks.filter((track)=>!audioGroups || audioGroups.indexOf(track.groupId) !== -1);\n        return findMatchingOption(option, tracks, matchPredicate) > -1;\n    });\n}\nfunction searchDownAndUpList(arr, searchIndex, predicate) {\n    for(let i = searchIndex; i; i--){\n        if (predicate(arr[i])) {\n            return i;\n        }\n    }\n    for(let i = searchIndex + 1; i < arr.length; i++){\n        if (predicate(arr[i])) {\n            return i;\n        }\n    }\n    return -1;\n}\nclass AbrController {\n    constructor(_hls){\n        this.hls = void 0;\n        this.lastLevelLoadSec = 0;\n        this.lastLoadedFragLevel = -1;\n        this.firstSelection = -1;\n        this._nextAutoLevel = -1;\n        this.nextAutoLevelKey = \"\";\n        this.audioTracksByGroup = null;\n        this.codecTiers = null;\n        this.timer = -1;\n        this.fragCurrent = null;\n        this.partCurrent = null;\n        this.bitrateTestDelay = 0;\n        this.bwEstimator = void 0;\n        /*\n        This method monitors the download rate of the current fragment, and will downswitch if that fragment will not load\n        quickly enough to prevent underbuffering\n      */ this._abandonRulesCheck = ()=>{\n            const { fragCurrent: frag, partCurrent: part, hls } = this;\n            const { autoLevelEnabled, media } = hls;\n            if (!frag || !media) {\n                return;\n            }\n            const now = performance.now();\n            const stats = part ? part.stats : frag.stats;\n            const duration = part ? part.duration : frag.duration;\n            const timeLoading = now - stats.loading.start;\n            const minAutoLevel = hls.minAutoLevel;\n            // If frag loading is aborted, complete, or from lowest level, stop timer and return\n            if (stats.aborted || stats.loaded && stats.loaded === stats.total || frag.level <= minAutoLevel) {\n                this.clearTimer();\n                // reset forced auto level value so that next level will be selected\n                this._nextAutoLevel = -1;\n                return;\n            }\n            // This check only runs if we're in ABR mode and actually playing\n            if (!autoLevelEnabled || media.paused || !media.playbackRate || !media.readyState) {\n                return;\n            }\n            const bufferInfo = hls.mainForwardBufferInfo;\n            if (bufferInfo === null) {\n                return;\n            }\n            const ttfbEstimate = this.bwEstimator.getEstimateTTFB();\n            const playbackRate = Math.abs(media.playbackRate);\n            // To maintain stable adaptive playback, only begin monitoring frag loading after half or more of its playback duration has passed\n            if (timeLoading <= Math.max(ttfbEstimate, 1000 * (duration / (playbackRate * 2)))) {\n                return;\n            }\n            // bufferStarvationDelay is an estimate of the amount time (in seconds) it will take to exhaust the buffer\n            const bufferStarvationDelay = bufferInfo.len / playbackRate;\n            const ttfb = stats.loading.first ? stats.loading.first - stats.loading.start : -1;\n            const loadedFirstByte = stats.loaded && ttfb > -1;\n            const bwEstimate = this.getBwEstimate();\n            const levels = hls.levels;\n            const level = levels[frag.level];\n            const expectedLen = stats.total || Math.max(stats.loaded, Math.round(duration * level.averageBitrate / 8));\n            let timeStreaming = loadedFirstByte ? timeLoading - ttfb : timeLoading;\n            if (timeStreaming < 1 && loadedFirstByte) {\n                timeStreaming = Math.min(timeLoading, stats.loaded * 8 / bwEstimate);\n            }\n            const loadRate = loadedFirstByte ? stats.loaded * 1000 / timeStreaming : 0;\n            // fragLoadDelay is an estimate of the time (in seconds) it will take to buffer the remainder of the fragment\n            const fragLoadedDelay = loadRate ? (expectedLen - stats.loaded) / loadRate : expectedLen * 8 / bwEstimate + ttfbEstimate / 1000;\n            // Only downswitch if the time to finish loading the current fragment is greater than the amount of buffer left\n            if (fragLoadedDelay <= bufferStarvationDelay) {\n                return;\n            }\n            const bwe = loadRate ? loadRate * 8 : bwEstimate;\n            let fragLevelNextLoadedDelay = Number.POSITIVE_INFINITY;\n            let nextLoadLevel;\n            // Iterate through lower level and try to find the largest one that avoids rebuffering\n            for(nextLoadLevel = frag.level - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--){\n                // compute time to load next fragment at lower level\n                // 8 = bits per byte (bps/Bps)\n                const levelNextBitrate = levels[nextLoadLevel].maxBitrate;\n                fragLevelNextLoadedDelay = this.getTimeToLoadFrag(ttfbEstimate / 1000, bwe, duration * levelNextBitrate, !levels[nextLoadLevel].details);\n                if (fragLevelNextLoadedDelay < bufferStarvationDelay) {\n                    break;\n                }\n            }\n            // Only emergency switch down if it takes less time to load a new fragment at lowest level instead of continuing\n            // to load the current one\n            if (fragLevelNextLoadedDelay >= fragLoadedDelay) {\n                return;\n            }\n            // if estimated load time of new segment is completely unreasonable, ignore and do not emergency switch down\n            if (fragLevelNextLoadedDelay > duration * 10) {\n                return;\n            }\n            hls.nextLoadLevel = hls.nextAutoLevel = nextLoadLevel;\n            if (loadedFirstByte) {\n                // If there has been loading progress, sample bandwidth using loading time offset by minimum TTFB time\n                this.bwEstimator.sample(timeLoading - Math.min(ttfbEstimate, ttfb), stats.loaded);\n            } else {\n                // If there has been no loading progress, sample TTFB\n                this.bwEstimator.sampleTTFB(timeLoading);\n            }\n            const nextLoadLevelBitrate = levels[nextLoadLevel].maxBitrate;\n            if (this.getBwEstimate() * this.hls.config.abrBandWidthUpFactor > nextLoadLevelBitrate) {\n                this.resetEstimator(nextLoadLevelBitrate);\n            }\n            this.clearTimer();\n            logger.warn(`[abr] Fragment ${frag.sn}${part ? \" part \" + part.index : \"\"} of level ${frag.level} is loading too slowly;\n      Time to underbuffer: ${bufferStarvationDelay.toFixed(3)} s\n      Estimated load time for current fragment: ${fragLoadedDelay.toFixed(3)} s\n      Estimated load time for down switch fragment: ${fragLevelNextLoadedDelay.toFixed(3)} s\n      TTFB estimate: ${ttfb | 0} ms\n      Current BW estimate: ${isFiniteNumber(bwEstimate) ? bwEstimate | 0 : \"Unknown\"} bps\n      New BW estimate: ${this.getBwEstimate() | 0} bps\n      Switching to level ${nextLoadLevel} @ ${nextLoadLevelBitrate | 0} bps`);\n            hls.trigger(Events.FRAG_LOAD_EMERGENCY_ABORTED, {\n                frag,\n                part,\n                stats\n            });\n        };\n        this.hls = _hls;\n        this.bwEstimator = this.initEstimator();\n        this.registerListeners();\n    }\n    resetEstimator(abrEwmaDefaultEstimate) {\n        if (abrEwmaDefaultEstimate) {\n            logger.log(`setting initial bwe to ${abrEwmaDefaultEstimate}`);\n            this.hls.config.abrEwmaDefaultEstimate = abrEwmaDefaultEstimate;\n        }\n        this.firstSelection = -1;\n        this.bwEstimator = this.initEstimator();\n    }\n    initEstimator() {\n        const config = this.hls.config;\n        return new EwmaBandWidthEstimator(config.abrEwmaSlowVoD, config.abrEwmaFastVoD, config.abrEwmaDefaultEstimate);\n    }\n    registerListeners() {\n        const { hls } = this;\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.FRAG_LOADING, this.onFragLoading, this);\n        hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);\n        hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n        hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n        hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n        hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n        hls.on(Events.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this);\n        hls.on(Events.ERROR, this.onError, this);\n    }\n    unregisterListeners() {\n        const { hls } = this;\n        if (!hls) {\n            return;\n        }\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.FRAG_LOADING, this.onFragLoading, this);\n        hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);\n        hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n        hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n        hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n        hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n        hls.off(Events.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this);\n        hls.off(Events.ERROR, this.onError, this);\n    }\n    destroy() {\n        this.unregisterListeners();\n        this.clearTimer();\n        // @ts-ignore\n        this.hls = this._abandonRulesCheck = null;\n        this.fragCurrent = this.partCurrent = null;\n    }\n    onManifestLoading(event, data) {\n        this.lastLoadedFragLevel = -1;\n        this.firstSelection = -1;\n        this.lastLevelLoadSec = 0;\n        this.fragCurrent = this.partCurrent = null;\n        this.onLevelsUpdated();\n        this.clearTimer();\n    }\n    onLevelsUpdated() {\n        if (this.lastLoadedFragLevel > -1 && this.fragCurrent) {\n            this.lastLoadedFragLevel = this.fragCurrent.level;\n        }\n        this._nextAutoLevel = -1;\n        this.onMaxAutoLevelUpdated();\n        this.codecTiers = null;\n        this.audioTracksByGroup = null;\n    }\n    onMaxAutoLevelUpdated() {\n        this.firstSelection = -1;\n        this.nextAutoLevelKey = \"\";\n    }\n    onFragLoading(event, data) {\n        const frag = data.frag;\n        if (this.ignoreFragment(frag)) {\n            return;\n        }\n        if (!frag.bitrateTest) {\n            var _data$part;\n            this.fragCurrent = frag;\n            this.partCurrent = (_data$part = data.part) != null ? _data$part : null;\n        }\n        this.clearTimer();\n        this.timer = self.setInterval(this._abandonRulesCheck, 100);\n    }\n    onLevelSwitching(event, data) {\n        this.clearTimer();\n    }\n    onError(event, data) {\n        if (data.fatal) {\n            return;\n        }\n        switch(data.details){\n            case ErrorDetails.BUFFER_ADD_CODEC_ERROR:\n            case ErrorDetails.BUFFER_APPEND_ERROR:\n                // Reset last loaded level so that a new selection can be made after calling recoverMediaError\n                this.lastLoadedFragLevel = -1;\n                this.firstSelection = -1;\n                break;\n            case ErrorDetails.FRAG_LOAD_TIMEOUT:\n                {\n                    const frag = data.frag;\n                    const { fragCurrent, partCurrent: part } = this;\n                    if (frag && fragCurrent && frag.sn === fragCurrent.sn && frag.level === fragCurrent.level) {\n                        const now = performance.now();\n                        const stats = part ? part.stats : frag.stats;\n                        const timeLoading = now - stats.loading.start;\n                        const ttfb = stats.loading.first ? stats.loading.first - stats.loading.start : -1;\n                        const loadedFirstByte = stats.loaded && ttfb > -1;\n                        if (loadedFirstByte) {\n                            const ttfbEstimate = this.bwEstimator.getEstimateTTFB();\n                            this.bwEstimator.sample(timeLoading - Math.min(ttfbEstimate, ttfb), stats.loaded);\n                        } else {\n                            this.bwEstimator.sampleTTFB(timeLoading);\n                        }\n                    }\n                    break;\n                }\n        }\n    }\n    getTimeToLoadFrag(timeToFirstByteSec, bandwidth, fragSizeBits, isSwitch) {\n        const fragLoadSec = timeToFirstByteSec + fragSizeBits / bandwidth;\n        const playlistLoadSec = isSwitch ? this.lastLevelLoadSec : 0;\n        return fragLoadSec + playlistLoadSec;\n    }\n    onLevelLoaded(event, data) {\n        const config = this.hls.config;\n        const { loading } = data.stats;\n        const timeLoadingMs = loading.end - loading.start;\n        if (isFiniteNumber(timeLoadingMs)) {\n            this.lastLevelLoadSec = timeLoadingMs / 1000;\n        }\n        if (data.details.live) {\n            this.bwEstimator.update(config.abrEwmaSlowLive, config.abrEwmaFastLive);\n        } else {\n            this.bwEstimator.update(config.abrEwmaSlowVoD, config.abrEwmaFastVoD);\n        }\n    }\n    onFragLoaded(event, { frag, part }) {\n        const stats = part ? part.stats : frag.stats;\n        if (frag.type === PlaylistLevelType.MAIN) {\n            this.bwEstimator.sampleTTFB(stats.loading.first - stats.loading.start);\n        }\n        if (this.ignoreFragment(frag)) {\n            return;\n        }\n        // stop monitoring bw once frag loaded\n        this.clearTimer();\n        // reset forced auto level value so that next level will be selected\n        if (frag.level === this._nextAutoLevel) {\n            this._nextAutoLevel = -1;\n        }\n        this.firstSelection = -1;\n        // compute level average bitrate\n        if (this.hls.config.abrMaxWithRealBitrate) {\n            const duration = part ? part.duration : frag.duration;\n            const level = this.hls.levels[frag.level];\n            const loadedBytes = (level.loaded ? level.loaded.bytes : 0) + stats.loaded;\n            const loadedDuration = (level.loaded ? level.loaded.duration : 0) + duration;\n            level.loaded = {\n                bytes: loadedBytes,\n                duration: loadedDuration\n            };\n            level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);\n        }\n        if (frag.bitrateTest) {\n            const fragBufferedData = {\n                stats,\n                frag,\n                part,\n                id: frag.type\n            };\n            this.onFragBuffered(Events.FRAG_BUFFERED, fragBufferedData);\n            frag.bitrateTest = false;\n        } else {\n            // store level id after successful fragment load for playback\n            this.lastLoadedFragLevel = frag.level;\n        }\n    }\n    onFragBuffered(event, data) {\n        const { frag, part } = data;\n        const stats = part != null && part.stats.loaded ? part.stats : frag.stats;\n        if (stats.aborted) {\n            return;\n        }\n        if (this.ignoreFragment(frag)) {\n            return;\n        }\n        // Use the difference between parsing and request instead of buffering and request to compute fragLoadingProcessing;\n        // rationale is that buffer appending only happens once media is attached. This can happen when config.startFragPrefetch\n        // is used. If we used buffering in that case, our BW estimate sample will be very large.\n        const processingMs = stats.parsing.end - stats.loading.start - Math.min(stats.loading.first - stats.loading.start, this.bwEstimator.getEstimateTTFB());\n        this.bwEstimator.sample(processingMs, stats.loaded);\n        stats.bwEstimate = this.getBwEstimate();\n        if (frag.bitrateTest) {\n            this.bitrateTestDelay = processingMs / 1000;\n        } else {\n            this.bitrateTestDelay = 0;\n        }\n    }\n    ignoreFragment(frag) {\n        // Only count non-alt-audio frags which were actually buffered in our BW calculations\n        return frag.type !== PlaylistLevelType.MAIN || frag.sn === \"initSegment\";\n    }\n    clearTimer() {\n        if (this.timer > -1) {\n            self.clearInterval(this.timer);\n            this.timer = -1;\n        }\n    }\n    get firstAutoLevel() {\n        const { maxAutoLevel, minAutoLevel } = this.hls;\n        const bwEstimate = this.getBwEstimate();\n        const maxStartDelay = this.hls.config.maxStarvationDelay;\n        const abrAutoLevel = this.findBestLevel(bwEstimate, minAutoLevel, maxAutoLevel, 0, maxStartDelay, 1, 1);\n        if (abrAutoLevel > -1) {\n            return abrAutoLevel;\n        }\n        const firstLevel = this.hls.firstLevel;\n        const clamped = Math.min(Math.max(firstLevel, minAutoLevel), maxAutoLevel);\n        logger.warn(`[abr] Could not find best starting auto level. Defaulting to first in playlist ${firstLevel} clamped to ${clamped}`);\n        return clamped;\n    }\n    get forcedAutoLevel() {\n        if (this.nextAutoLevelKey) {\n            return -1;\n        }\n        return this._nextAutoLevel;\n    }\n    // return next auto level\n    get nextAutoLevel() {\n        const forcedAutoLevel = this.forcedAutoLevel;\n        const bwEstimator = this.bwEstimator;\n        const useEstimate = bwEstimator.canEstimate();\n        const loadedFirstFrag = this.lastLoadedFragLevel > -1;\n        // in case next auto level has been forced, and bw not available or not reliable, return forced value\n        if (forcedAutoLevel !== -1 && (!useEstimate || !loadedFirstFrag || this.nextAutoLevelKey === this.getAutoLevelKey())) {\n            return forcedAutoLevel;\n        }\n        // compute next level using ABR logic\n        const nextABRAutoLevel = useEstimate && loadedFirstFrag ? this.getNextABRAutoLevel() : this.firstAutoLevel;\n        // use forced auto level while it hasn't errored more than ABR selection\n        if (forcedAutoLevel !== -1) {\n            const levels = this.hls.levels;\n            if (levels.length > Math.max(forcedAutoLevel, nextABRAutoLevel) && levels[forcedAutoLevel].loadError <= levels[nextABRAutoLevel].loadError) {\n                return forcedAutoLevel;\n            }\n        }\n        // save result until state has changed\n        this._nextAutoLevel = nextABRAutoLevel;\n        this.nextAutoLevelKey = this.getAutoLevelKey();\n        return nextABRAutoLevel;\n    }\n    getAutoLevelKey() {\n        return `${this.getBwEstimate()}_${this.getStarvationDelay().toFixed(2)}`;\n    }\n    getNextABRAutoLevel() {\n        const { fragCurrent, partCurrent, hls } = this;\n        const { maxAutoLevel, config, minAutoLevel } = hls;\n        const currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;\n        const avgbw = this.getBwEstimate();\n        // bufferStarvationDelay is the wall-clock time left until the playback buffer is exhausted.\n        const bufferStarvationDelay = this.getStarvationDelay();\n        let bwFactor = config.abrBandWidthFactor;\n        let bwUpFactor = config.abrBandWidthUpFactor;\n        // First, look to see if we can find a level matching with our avg bandwidth AND that could also guarantee no rebuffering at all\n        if (bufferStarvationDelay) {\n            const _bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, 0, bwFactor, bwUpFactor);\n            if (_bestLevel >= 0) {\n                return _bestLevel;\n            }\n        }\n        // not possible to get rid of rebuffering... try to find level that will guarantee less than maxStarvationDelay of rebuffering\n        let maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay;\n        if (!bufferStarvationDelay) {\n            // in case buffer is empty, let's check if previous fragment was loaded to perform a bitrate test\n            const bitrateTestDelay = this.bitrateTestDelay;\n            if (bitrateTestDelay) {\n                // if it is the case, then we need to adjust our max starvation delay using maxLoadingDelay config value\n                // max video loading delay used in  automatic start level selection :\n                // in that mode ABR controller will ensure that video loading time (ie the time to fetch the first fragment at lowest quality level +\n                // the time to fetch the fragment at the appropriate quality level is less than ```maxLoadingDelay``` )\n                // cap maxLoadingDelay and ensure it is not bigger 'than bitrate test' frag duration\n                const maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;\n                maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;\n                logger.info(`[abr] bitrate test took ${Math.round(1000 * bitrateTestDelay)}ms, set first fragment max fetchDuration to ${Math.round(1000 * maxStarvationDelay)} ms`);\n                // don't use conservative factor on bitrate test\n                bwFactor = bwUpFactor = 1;\n            }\n        }\n        const bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, maxStarvationDelay, bwFactor, bwUpFactor);\n        logger.info(`[abr] ${bufferStarvationDelay ? \"rebuffering expected\" : \"buffer is empty\"}, optimal quality level ${bestLevel}`);\n        if (bestLevel > -1) {\n            return bestLevel;\n        }\n        // If no matching level found, see if min auto level would be a better option\n        const minLevel = hls.levels[minAutoLevel];\n        const autoLevel = hls.levels[hls.loadLevel];\n        if ((minLevel == null ? void 0 : minLevel.bitrate) < (autoLevel == null ? void 0 : autoLevel.bitrate)) {\n            return minAutoLevel;\n        }\n        // or if bitrate is not lower, continue to use loadLevel\n        return hls.loadLevel;\n    }\n    getStarvationDelay() {\n        const hls = this.hls;\n        const media = hls.media;\n        if (!media) {\n            return Infinity;\n        }\n        // playbackRate is the absolute value of the playback rate; if media.playbackRate is 0, we use 1 to load as\n        // if we're playing back at the normal rate.\n        const playbackRate = media && media.playbackRate !== 0 ? Math.abs(media.playbackRate) : 1.0;\n        const bufferInfo = hls.mainForwardBufferInfo;\n        return (bufferInfo ? bufferInfo.len : 0) / playbackRate;\n    }\n    getBwEstimate() {\n        return this.bwEstimator.canEstimate() ? this.bwEstimator.getEstimate() : this.hls.config.abrEwmaDefaultEstimate;\n    }\n    findBestLevel(currentBw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, maxStarvationDelay, bwFactor, bwUpFactor) {\n        var _level$details;\n        const maxFetchDuration = bufferStarvationDelay + maxStarvationDelay;\n        const lastLoadedFragLevel = this.lastLoadedFragLevel;\n        const selectionBaseLevel = lastLoadedFragLevel === -1 ? this.hls.firstLevel : lastLoadedFragLevel;\n        const { fragCurrent, partCurrent } = this;\n        const { levels, allAudioTracks, loadLevel, config } = this.hls;\n        if (levels.length === 1) {\n            return 0;\n        }\n        const level = levels[selectionBaseLevel];\n        const live = !!(level != null && (_level$details = level.details) != null && _level$details.live);\n        const firstSelection = loadLevel === -1 || lastLoadedFragLevel === -1;\n        let currentCodecSet;\n        let currentVideoRange = \"SDR\";\n        let currentFrameRate = (level == null ? void 0 : level.frameRate) || 0;\n        const { audioPreference, videoPreference } = config;\n        const audioTracksByGroup = this.audioTracksByGroup || (this.audioTracksByGroup = getAudioTracksByGroup(allAudioTracks));\n        if (firstSelection) {\n            if (this.firstSelection !== -1) {\n                return this.firstSelection;\n            }\n            const codecTiers = this.codecTiers || (this.codecTiers = getCodecTiers(levels, audioTracksByGroup, minAutoLevel, maxAutoLevel));\n            const startTier = getStartCodecTier(codecTiers, currentVideoRange, currentBw, audioPreference, videoPreference);\n            const { codecSet, videoRanges, minFramerate, minBitrate, preferHDR } = startTier;\n            currentCodecSet = codecSet;\n            currentVideoRange = preferHDR ? videoRanges[videoRanges.length - 1] : videoRanges[0];\n            currentFrameRate = minFramerate;\n            currentBw = Math.max(currentBw, minBitrate);\n            logger.log(`[abr] picked start tier ${JSON.stringify(startTier)}`);\n        } else {\n            currentCodecSet = level == null ? void 0 : level.codecSet;\n            currentVideoRange = level == null ? void 0 : level.videoRange;\n        }\n        const currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;\n        const ttfbEstimateSec = this.bwEstimator.getEstimateTTFB() / 1000;\n        const levelsSkipped = [];\n        for(let i = maxAutoLevel; i >= minAutoLevel; i--){\n            var _levelInfo$supportedR;\n            const levelInfo = levels[i];\n            const upSwitch = i > selectionBaseLevel;\n            if (!levelInfo) {\n                continue;\n            }\n            if (config.useMediaCapabilities && !levelInfo.supportedResult && !levelInfo.supportedPromise) {\n                const mediaCapabilities = navigator.mediaCapabilities;\n                if (typeof (mediaCapabilities == null ? void 0 : mediaCapabilities.decodingInfo) === \"function\" && requiresMediaCapabilitiesDecodingInfo(levelInfo, audioTracksByGroup, currentVideoRange, currentFrameRate, currentBw, audioPreference)) {\n                    levelInfo.supportedPromise = getMediaDecodingInfoPromise(levelInfo, audioTracksByGroup, mediaCapabilities);\n                    levelInfo.supportedPromise.then((decodingInfo)=>{\n                        if (!this.hls) {\n                            return;\n                        }\n                        levelInfo.supportedResult = decodingInfo;\n                        const levels = this.hls.levels;\n                        const index = levels.indexOf(levelInfo);\n                        if (decodingInfo.error) {\n                            logger.warn(`[abr] MediaCapabilities decodingInfo error: \"${decodingInfo.error}\" for level ${index} ${JSON.stringify(decodingInfo)}`);\n                        } else if (!decodingInfo.supported) {\n                            logger.warn(`[abr] Unsupported MediaCapabilities decodingInfo result for level ${index} ${JSON.stringify(decodingInfo)}`);\n                            if (index > -1 && levels.length > 1) {\n                                logger.log(`[abr] Removing unsupported level ${index}`);\n                                this.hls.removeLevel(index);\n                            }\n                        }\n                    });\n                } else {\n                    levelInfo.supportedResult = SUPPORTED_INFO_DEFAULT;\n                }\n            }\n            // skip candidates which change codec-family or video-range,\n            // and which decrease or increase frame-rate for up and down-switch respectfully\n            if (currentCodecSet && levelInfo.codecSet !== currentCodecSet || currentVideoRange && levelInfo.videoRange !== currentVideoRange || upSwitch && currentFrameRate > levelInfo.frameRate || !upSwitch && currentFrameRate > 0 && currentFrameRate < levelInfo.frameRate || levelInfo.supportedResult && !((_levelInfo$supportedR = levelInfo.supportedResult.decodingInfoResults) != null && _levelInfo$supportedR[0].smooth)) {\n                levelsSkipped.push(i);\n                continue;\n            }\n            const levelDetails = levelInfo.details;\n            const avgDuration = (partCurrent ? levelDetails == null ? void 0 : levelDetails.partTarget : levelDetails == null ? void 0 : levelDetails.averagetargetduration) || currentFragDuration;\n            let adjustedbw;\n            // follow algorithm captured from stagefright :\n            // https://android.googlesource.com/platform/frameworks/av/+/master/media/libstagefright/httplive/LiveSession.cpp\n            // Pick the highest bandwidth stream below or equal to estimated bandwidth.\n            // consider only 80% of the available bandwidth, but if we are switching up,\n            // be even more conservative (70%) to avoid overestimating and immediately\n            // switching back.\n            if (!upSwitch) {\n                adjustedbw = bwFactor * currentBw;\n            } else {\n                adjustedbw = bwUpFactor * currentBw;\n            }\n            // Use average bitrate when starvation delay (buffer length) is gt or eq two segment durations and rebuffering is not expected (maxStarvationDelay > 0)\n            const bitrate = currentFragDuration && bufferStarvationDelay >= currentFragDuration * 2 && maxStarvationDelay === 0 ? levels[i].averageBitrate : levels[i].maxBitrate;\n            const fetchDuration = this.getTimeToLoadFrag(ttfbEstimateSec, adjustedbw, bitrate * avgDuration, levelDetails === undefined);\n            const canSwitchWithinTolerance = // if adjusted bw is greater than level bitrate AND\n            adjustedbw >= bitrate && // no level change, or new level has no error history\n            (i === lastLoadedFragLevel || levelInfo.loadError === 0 && levelInfo.fragmentError === 0) && // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches\n            // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...\n            // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that findBestLevel will return -1\n            (fetchDuration <= ttfbEstimateSec || !isFiniteNumber(fetchDuration) || live && !this.bitrateTestDelay || fetchDuration < maxFetchDuration);\n            if (canSwitchWithinTolerance) {\n                const forcedAutoLevel = this.forcedAutoLevel;\n                if (i !== loadLevel && (forcedAutoLevel === -1 || forcedAutoLevel !== loadLevel)) {\n                    if (levelsSkipped.length) {\n                        logger.trace(`[abr] Skipped level(s) ${levelsSkipped.join(\",\")} of ${maxAutoLevel} max with CODECS and VIDEO-RANGE:\"${levels[levelsSkipped[0]].codecs}\" ${levels[levelsSkipped[0]].videoRange}; not compatible with \"${level.codecs}\" ${currentVideoRange}`);\n                    }\n                    logger.info(`[abr] switch candidate:${selectionBaseLevel}->${i} adjustedbw(${Math.round(adjustedbw)})-bitrate=${Math.round(adjustedbw - bitrate)} ttfb:${ttfbEstimateSec.toFixed(1)} avgDuration:${avgDuration.toFixed(1)} maxFetchDuration:${maxFetchDuration.toFixed(1)} fetchDuration:${fetchDuration.toFixed(1)} firstSelection:${firstSelection} codecSet:${currentCodecSet} videoRange:${currentVideoRange} hls.loadLevel:${loadLevel}`);\n                }\n                if (firstSelection) {\n                    this.firstSelection = i;\n                }\n                // as we are looping from highest to lowest, this will return the best achievable quality level\n                return i;\n            }\n        }\n        // not enough time budget even with quality level 0 ... rebuffering might happen\n        return -1;\n    }\n    set nextAutoLevel(nextLevel) {\n        const { maxAutoLevel, minAutoLevel } = this.hls;\n        const value = Math.min(Math.max(nextLevel, minAutoLevel), maxAutoLevel);\n        if (this._nextAutoLevel !== value) {\n            this.nextAutoLevelKey = \"\";\n            this._nextAutoLevel = value;\n        }\n    }\n}\n/**\n * @ignore\n * Sub-class specialization of EventHandler base class.\n *\n * TaskLoop allows to schedule a task function being called (optionnaly repeatedly) on the main loop,\n * scheduled asynchroneously, avoiding recursive calls in the same tick.\n *\n * The task itself is implemented in `doTick`. It can be requested and called for single execution\n * using the `tick` method.\n *\n * It will be assured that the task execution method (`tick`) only gets called once per main loop \"tick\",\n * no matter how often it gets requested for execution. Execution in further ticks will be scheduled accordingly.\n *\n * If further execution requests have already been scheduled on the next tick, it can be checked with `hasNextTick`,\n * and cancelled with `clearNextTick`.\n *\n * The task can be scheduled as an interval repeatedly with a period as parameter (see `setInterval`, `clearInterval`).\n *\n * Sub-classes need to implement the `doTick` method which will effectively have the task execution routine.\n *\n * Further explanations:\n *\n * The baseclass has a `tick` method that will schedule the doTick call. It may be called synchroneously\n * only for a stack-depth of one. On re-entrant calls, sub-sequent calls are scheduled for next main loop ticks.\n *\n * When the task execution (`tick` method) is called in re-entrant way this is detected and\n * we are limiting the task execution per call stack to exactly one, but scheduling/post-poning further\n * task processing on the next main loop iteration (also known as \"next tick\" in the Node/JS runtime lingo).\n */ class TaskLoop {\n    constructor(){\n        this._boundTick = void 0;\n        this._tickTimer = null;\n        this._tickInterval = null;\n        this._tickCallCount = 0;\n        this._boundTick = this.tick.bind(this);\n    }\n    destroy() {\n        this.onHandlerDestroying();\n        this.onHandlerDestroyed();\n    }\n    onHandlerDestroying() {\n        // clear all timers before unregistering from event bus\n        this.clearNextTick();\n        this.clearInterval();\n    }\n    onHandlerDestroyed() {}\n    hasInterval() {\n        return !!this._tickInterval;\n    }\n    hasNextTick() {\n        return !!this._tickTimer;\n    }\n    /**\n   * @param millis - Interval time (ms)\n   * @eturns True when interval has been scheduled, false when already scheduled (no effect)\n   */ setInterval(millis) {\n        if (!this._tickInterval) {\n            this._tickCallCount = 0;\n            this._tickInterval = self.setInterval(this._boundTick, millis);\n            return true;\n        }\n        return false;\n    }\n    /**\n   * @returns True when interval was cleared, false when none was set (no effect)\n   */ clearInterval() {\n        if (this._tickInterval) {\n            self.clearInterval(this._tickInterval);\n            this._tickInterval = null;\n            return true;\n        }\n        return false;\n    }\n    /**\n   * @returns True when timeout was cleared, false when none was set (no effect)\n   */ clearNextTick() {\n        if (this._tickTimer) {\n            self.clearTimeout(this._tickTimer);\n            this._tickTimer = null;\n            return true;\n        }\n        return false;\n    }\n    /**\n   * Will call the subclass doTick implementation in this main loop tick\n   * or in the next one (via setTimeout(,0)) in case it has already been called\n   * in this tick (in case this is a re-entrant call).\n   */ tick() {\n        this._tickCallCount++;\n        if (this._tickCallCount === 1) {\n            this.doTick();\n            // re-entrant call to tick from previous doTick call stack\n            // -> schedule a call on the next main loop iteration to process this task processing request\n            if (this._tickCallCount > 1) {\n                // make sure only one timer exists at any time at max\n                this.tickImmediate();\n            }\n            this._tickCallCount = 0;\n        }\n    }\n    tickImmediate() {\n        this.clearNextTick();\n        this._tickTimer = self.setTimeout(this._boundTick, 0);\n    }\n    /**\n   * For subclass to implement task logic\n   * @abstract\n   */ doTick() {}\n}\nvar FragmentState = {\n    NOT_LOADED: \"NOT_LOADED\",\n    APPENDING: \"APPENDING\",\n    PARTIAL: \"PARTIAL\",\n    OK: \"OK\"\n};\nclass FragmentTracker {\n    constructor(hls){\n        this.activePartLists = Object.create(null);\n        this.endListFragments = Object.create(null);\n        this.fragments = Object.create(null);\n        this.timeRanges = Object.create(null);\n        this.bufferPadding = 0.2;\n        this.hls = void 0;\n        this.hasGaps = false;\n        this.hls = hls;\n        this._registerListeners();\n    }\n    _registerListeners() {\n        const { hls } = this;\n        hls.on(Events.BUFFER_APPENDED, this.onBufferAppended, this);\n        hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n        hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);\n    }\n    _unregisterListeners() {\n        const { hls } = this;\n        hls.off(Events.BUFFER_APPENDED, this.onBufferAppended, this);\n        hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n        hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);\n    }\n    destroy() {\n        this._unregisterListeners();\n        // @ts-ignore\n        this.fragments = // @ts-ignore\n        this.activePartLists = // @ts-ignore\n        this.endListFragments = this.timeRanges = null;\n    }\n    /**\n   * Return a Fragment or Part with an appended range that matches the position and levelType\n   * Otherwise, return null\n   */ getAppendedFrag(position, levelType) {\n        const activeParts = this.activePartLists[levelType];\n        if (activeParts) {\n            for(let i = activeParts.length; i--;){\n                const activePart = activeParts[i];\n                if (!activePart) {\n                    break;\n                }\n                const appendedPTS = activePart.end;\n                if (activePart.start <= position && appendedPTS !== null && position <= appendedPTS) {\n                    return activePart;\n                }\n            }\n        }\n        return this.getBufferedFrag(position, levelType);\n    }\n    /**\n   * Return a buffered Fragment that matches the position and levelType.\n   * A buffered Fragment is one whose loading, parsing and appending is done (completed or \"partial\" meaning aborted).\n   * If not found any Fragment, return null\n   */ getBufferedFrag(position, levelType) {\n        const { fragments } = this;\n        const keys = Object.keys(fragments);\n        for(let i = keys.length; i--;){\n            const fragmentEntity = fragments[keys[i]];\n            if ((fragmentEntity == null ? void 0 : fragmentEntity.body.type) === levelType && fragmentEntity.buffered) {\n                const frag = fragmentEntity.body;\n                if (frag.start <= position && position <= frag.end) {\n                    return frag;\n                }\n            }\n        }\n        return null;\n    }\n    /**\n   * Partial fragments effected by coded frame eviction will be removed\n   * The browser will unload parts of the buffer to free up memory for new buffer data\n   * Fragments will need to be reloaded when the buffer is freed up, removing partial fragments will allow them to reload(since there might be parts that are still playable)\n   */ detectEvictedFragments(elementaryStream, timeRange, playlistType, appendedPart) {\n        if (this.timeRanges) {\n            this.timeRanges[elementaryStream] = timeRange;\n        }\n        // Check if any flagged fragments have been unloaded\n        // excluding anything newer than appendedPartSn\n        const appendedPartSn = (appendedPart == null ? void 0 : appendedPart.fragment.sn) || -1;\n        Object.keys(this.fragments).forEach((key)=>{\n            const fragmentEntity = this.fragments[key];\n            if (!fragmentEntity) {\n                return;\n            }\n            if (appendedPartSn >= fragmentEntity.body.sn) {\n                return;\n            }\n            if (!fragmentEntity.buffered && !fragmentEntity.loaded) {\n                if (fragmentEntity.body.type === playlistType) {\n                    this.removeFragment(fragmentEntity.body);\n                }\n                return;\n            }\n            const esData = fragmentEntity.range[elementaryStream];\n            if (!esData) {\n                return;\n            }\n            esData.time.some((time)=>{\n                const isNotBuffered = !this.isTimeBuffered(time.startPTS, time.endPTS, timeRange);\n                if (isNotBuffered) {\n                    // Unregister partial fragment as it needs to load again to be reused\n                    this.removeFragment(fragmentEntity.body);\n                }\n                return isNotBuffered;\n            });\n        });\n    }\n    /**\n   * Checks if the fragment passed in is loaded in the buffer properly\n   * Partially loaded fragments will be registered as a partial fragment\n   */ detectPartialFragments(data) {\n        const timeRanges = this.timeRanges;\n        const { frag, part } = data;\n        if (!timeRanges || frag.sn === \"initSegment\") {\n            return;\n        }\n        const fragKey = getFragmentKey(frag);\n        const fragmentEntity = this.fragments[fragKey];\n        if (!fragmentEntity || fragmentEntity.buffered && frag.gap) {\n            return;\n        }\n        const isFragHint = !frag.relurl;\n        Object.keys(timeRanges).forEach((elementaryStream)=>{\n            const streamInfo = frag.elementaryStreams[elementaryStream];\n            if (!streamInfo) {\n                return;\n            }\n            const timeRange = timeRanges[elementaryStream];\n            const partial = isFragHint || streamInfo.partial === true;\n            fragmentEntity.range[elementaryStream] = this.getBufferedTimes(frag, part, partial, timeRange);\n        });\n        fragmentEntity.loaded = null;\n        if (Object.keys(fragmentEntity.range).length) {\n            fragmentEntity.buffered = true;\n            const endList = fragmentEntity.body.endList = frag.endList || fragmentEntity.body.endList;\n            if (endList) {\n                this.endListFragments[fragmentEntity.body.type] = fragmentEntity;\n            }\n            if (!isPartial(fragmentEntity)) {\n                // Remove older fragment parts from lookup after frag is tracked as buffered\n                this.removeParts(frag.sn - 1, frag.type);\n            }\n        } else {\n            // remove fragment if nothing was appended\n            this.removeFragment(fragmentEntity.body);\n        }\n    }\n    removeParts(snToKeep, levelType) {\n        const activeParts = this.activePartLists[levelType];\n        if (!activeParts) {\n            return;\n        }\n        this.activePartLists[levelType] = activeParts.filter((part)=>part.fragment.sn >= snToKeep);\n    }\n    fragBuffered(frag, force) {\n        const fragKey = getFragmentKey(frag);\n        let fragmentEntity = this.fragments[fragKey];\n        if (!fragmentEntity && force) {\n            fragmentEntity = this.fragments[fragKey] = {\n                body: frag,\n                appendedPTS: null,\n                loaded: null,\n                buffered: false,\n                range: Object.create(null)\n            };\n            if (frag.gap) {\n                this.hasGaps = true;\n            }\n        }\n        if (fragmentEntity) {\n            fragmentEntity.loaded = null;\n            fragmentEntity.buffered = true;\n        }\n    }\n    getBufferedTimes(fragment, part, partial, timeRange) {\n        const buffered = {\n            time: [],\n            partial\n        };\n        const startPTS = fragment.start;\n        const endPTS = fragment.end;\n        const minEndPTS = fragment.minEndPTS || endPTS;\n        const maxStartPTS = fragment.maxStartPTS || startPTS;\n        for(let i = 0; i < timeRange.length; i++){\n            const startTime = timeRange.start(i) - this.bufferPadding;\n            const endTime = timeRange.end(i) + this.bufferPadding;\n            if (maxStartPTS >= startTime && minEndPTS <= endTime) {\n                // Fragment is entirely contained in buffer\n                // No need to check the other timeRange times since it's completely playable\n                buffered.time.push({\n                    startPTS: Math.max(startPTS, timeRange.start(i)),\n                    endPTS: Math.min(endPTS, timeRange.end(i))\n                });\n                break;\n            } else if (startPTS < endTime && endPTS > startTime) {\n                const start = Math.max(startPTS, timeRange.start(i));\n                const end = Math.min(endPTS, timeRange.end(i));\n                if (end > start) {\n                    buffered.partial = true;\n                    // Check for intersection with buffer\n                    // Get playable sections of the fragment\n                    buffered.time.push({\n                        startPTS: start,\n                        endPTS: end\n                    });\n                }\n            } else if (endPTS <= startTime) {\n                break;\n            }\n        }\n        return buffered;\n    }\n    /**\n   * Gets the partial fragment for a certain time\n   */ getPartialFragment(time) {\n        let bestFragment = null;\n        let timePadding;\n        let startTime;\n        let endTime;\n        let bestOverlap = 0;\n        const { bufferPadding, fragments } = this;\n        Object.keys(fragments).forEach((key)=>{\n            const fragmentEntity = fragments[key];\n            if (!fragmentEntity) {\n                return;\n            }\n            if (isPartial(fragmentEntity)) {\n                startTime = fragmentEntity.body.start - bufferPadding;\n                endTime = fragmentEntity.body.end + bufferPadding;\n                if (time >= startTime && time <= endTime) {\n                    // Use the fragment that has the most padding from start and end time\n                    timePadding = Math.min(time - startTime, endTime - time);\n                    if (bestOverlap <= timePadding) {\n                        bestFragment = fragmentEntity.body;\n                        bestOverlap = timePadding;\n                    }\n                }\n            }\n        });\n        return bestFragment;\n    }\n    isEndListAppended(type) {\n        const lastFragmentEntity = this.endListFragments[type];\n        return lastFragmentEntity !== undefined && (lastFragmentEntity.buffered || isPartial(lastFragmentEntity));\n    }\n    getState(fragment) {\n        const fragKey = getFragmentKey(fragment);\n        const fragmentEntity = this.fragments[fragKey];\n        if (fragmentEntity) {\n            if (!fragmentEntity.buffered) {\n                return FragmentState.APPENDING;\n            } else if (isPartial(fragmentEntity)) {\n                return FragmentState.PARTIAL;\n            } else {\n                return FragmentState.OK;\n            }\n        }\n        return FragmentState.NOT_LOADED;\n    }\n    isTimeBuffered(startPTS, endPTS, timeRange) {\n        let startTime;\n        let endTime;\n        for(let i = 0; i < timeRange.length; i++){\n            startTime = timeRange.start(i) - this.bufferPadding;\n            endTime = timeRange.end(i) + this.bufferPadding;\n            if (startPTS >= startTime && endPTS <= endTime) {\n                return true;\n            }\n            if (endPTS <= startTime) {\n                // No need to check the rest of the timeRange as it is in order\n                return false;\n            }\n        }\n        return false;\n    }\n    onFragLoaded(event, data) {\n        const { frag, part } = data;\n        // don't track initsegment (for which sn is not a number)\n        // don't track frags used for bitrateTest, they're irrelevant.\n        if (frag.sn === \"initSegment\" || frag.bitrateTest) {\n            return;\n        }\n        // Fragment entity `loaded` FragLoadedData is null when loading parts\n        const loaded = part ? null : data;\n        const fragKey = getFragmentKey(frag);\n        this.fragments[fragKey] = {\n            body: frag,\n            appendedPTS: null,\n            loaded,\n            buffered: false,\n            range: Object.create(null)\n        };\n    }\n    onBufferAppended(event, data) {\n        const { frag, part, timeRanges } = data;\n        if (frag.sn === \"initSegment\") {\n            return;\n        }\n        const playlistType = frag.type;\n        if (part) {\n            let activeParts = this.activePartLists[playlistType];\n            if (!activeParts) {\n                this.activePartLists[playlistType] = activeParts = [];\n            }\n            activeParts.push(part);\n        }\n        // Store the latest timeRanges loaded in the buffer\n        this.timeRanges = timeRanges;\n        Object.keys(timeRanges).forEach((elementaryStream)=>{\n            const timeRange = timeRanges[elementaryStream];\n            this.detectEvictedFragments(elementaryStream, timeRange, playlistType, part);\n        });\n    }\n    onFragBuffered(event, data) {\n        this.detectPartialFragments(data);\n    }\n    hasFragment(fragment) {\n        const fragKey = getFragmentKey(fragment);\n        return !!this.fragments[fragKey];\n    }\n    hasParts(type) {\n        var _this$activePartLists;\n        return !!((_this$activePartLists = this.activePartLists[type]) != null && _this$activePartLists.length);\n    }\n    removeFragmentsInRange(start, end, playlistType, withGapOnly, unbufferedOnly) {\n        if (withGapOnly && !this.hasGaps) {\n            return;\n        }\n        Object.keys(this.fragments).forEach((key)=>{\n            const fragmentEntity = this.fragments[key];\n            if (!fragmentEntity) {\n                return;\n            }\n            const frag = fragmentEntity.body;\n            if (frag.type !== playlistType || withGapOnly && !frag.gap) {\n                return;\n            }\n            if (frag.start < end && frag.end > start && (fragmentEntity.buffered || unbufferedOnly)) {\n                this.removeFragment(frag);\n            }\n        });\n    }\n    removeFragment(fragment) {\n        const fragKey = getFragmentKey(fragment);\n        fragment.stats.loaded = 0;\n        fragment.clearElementaryStreamInfo();\n        const activeParts = this.activePartLists[fragment.type];\n        if (activeParts) {\n            const snToRemove = fragment.sn;\n            this.activePartLists[fragment.type] = activeParts.filter((part)=>part.fragment.sn !== snToRemove);\n        }\n        delete this.fragments[fragKey];\n        if (fragment.endList) {\n            delete this.endListFragments[fragment.type];\n        }\n    }\n    removeAllFragments() {\n        this.fragments = Object.create(null);\n        this.endListFragments = Object.create(null);\n        this.activePartLists = Object.create(null);\n        this.hasGaps = false;\n    }\n}\nfunction isPartial(fragmentEntity) {\n    var _fragmentEntity$range, _fragmentEntity$range2, _fragmentEntity$range3;\n    return fragmentEntity.buffered && (fragmentEntity.body.gap || ((_fragmentEntity$range = fragmentEntity.range.video) == null ? void 0 : _fragmentEntity$range.partial) || ((_fragmentEntity$range2 = fragmentEntity.range.audio) == null ? void 0 : _fragmentEntity$range2.partial) || ((_fragmentEntity$range3 = fragmentEntity.range.audiovideo) == null ? void 0 : _fragmentEntity$range3.partial));\n}\nfunction getFragmentKey(fragment) {\n    return `${fragment.type}_${fragment.level}_${fragment.sn}`;\n}\n/**\n * Provides methods dealing with buffer length retrieval for example.\n *\n * In general, a helper around HTML5 MediaElement TimeRanges gathered from `buffered` property.\n *\n * Also @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/buffered\n */ const noopBuffered = {\n    length: 0,\n    start: ()=>0,\n    end: ()=>0\n};\nclass BufferHelper {\n    /**\n   * Return true if `media`'s buffered include `position`\n   */ static isBuffered(media, position) {\n        try {\n            if (media) {\n                const buffered = BufferHelper.getBuffered(media);\n                for(let i = 0; i < buffered.length; i++){\n                    if (position >= buffered.start(i) && position <= buffered.end(i)) {\n                        return true;\n                    }\n                }\n            }\n        } catch (error) {\n        // this is to catch\n        // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':\n        // This SourceBuffer has been removed from the parent media source\n        }\n        return false;\n    }\n    static bufferInfo(media, pos, maxHoleDuration) {\n        try {\n            if (media) {\n                const vbuffered = BufferHelper.getBuffered(media);\n                const buffered = [];\n                let i;\n                for(i = 0; i < vbuffered.length; i++){\n                    buffered.push({\n                        start: vbuffered.start(i),\n                        end: vbuffered.end(i)\n                    });\n                }\n                return this.bufferedInfo(buffered, pos, maxHoleDuration);\n            }\n        } catch (error) {\n        // this is to catch\n        // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':\n        // This SourceBuffer has been removed from the parent media source\n        }\n        return {\n            len: 0,\n            start: pos,\n            end: pos,\n            nextStart: undefined\n        };\n    }\n    static bufferedInfo(buffered, pos, maxHoleDuration) {\n        pos = Math.max(0, pos);\n        // sort on buffer.start/smaller end (IE does not always return sorted buffered range)\n        buffered.sort(function(a, b) {\n            const diff = a.start - b.start;\n            if (diff) {\n                return diff;\n            } else {\n                return b.end - a.end;\n            }\n        });\n        let buffered2 = [];\n        if (maxHoleDuration) {\n            // there might be some small holes between buffer time range\n            // consider that holes smaller than maxHoleDuration are irrelevant and build another\n            // buffer time range representations that discards those holes\n            for(let i = 0; i < buffered.length; i++){\n                const buf2len = buffered2.length;\n                if (buf2len) {\n                    const buf2end = buffered2[buf2len - 1].end;\n                    // if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)\n                    if (buffered[i].start - buf2end < maxHoleDuration) {\n                        // merge overlapping time ranges\n                        // update lastRange.end only if smaller than item.end\n                        // e.g.  [ 1, 15] with  [ 2,8] => [ 1,15] (no need to modify lastRange.end)\n                        // whereas [ 1, 8] with  [ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])\n                        if (buffered[i].end > buf2end) {\n                            buffered2[buf2len - 1].end = buffered[i].end;\n                        }\n                    } else {\n                        // big hole\n                        buffered2.push(buffered[i]);\n                    }\n                } else {\n                    // first value\n                    buffered2.push(buffered[i]);\n                }\n            }\n        } else {\n            buffered2 = buffered;\n        }\n        let bufferLen = 0;\n        // bufferStartNext can possibly be undefined based on the conditional logic below\n        let bufferStartNext;\n        // bufferStart and bufferEnd are buffer boundaries around current video position\n        let bufferStart = pos;\n        let bufferEnd = pos;\n        for(let i = 0; i < buffered2.length; i++){\n            const start = buffered2[i].start;\n            const end = buffered2[i].end;\n            // logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));\n            if (pos + maxHoleDuration >= start && pos < end) {\n                // play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length\n                bufferStart = start;\n                bufferEnd = end;\n                bufferLen = bufferEnd - pos;\n            } else if (pos + maxHoleDuration < start) {\n                bufferStartNext = start;\n                break;\n            }\n        }\n        return {\n            len: bufferLen,\n            start: bufferStart || 0,\n            end: bufferEnd || 0,\n            nextStart: bufferStartNext\n        };\n    }\n    /**\n   * Safe method to get buffered property.\n   * SourceBuffer.buffered may throw if SourceBuffer is removed from it's MediaSource\n   */ static getBuffered(media) {\n        try {\n            return media.buffered;\n        } catch (e) {\n            logger.log(\"failed to get media.buffered\", e);\n            return noopBuffered;\n        }\n    }\n}\nclass ChunkMetadata {\n    constructor(level, sn, id, size = 0, part = -1, partial = false){\n        this.level = void 0;\n        this.sn = void 0;\n        this.part = void 0;\n        this.id = void 0;\n        this.size = void 0;\n        this.partial = void 0;\n        this.transmuxing = getNewPerformanceTiming();\n        this.buffering = {\n            audio: getNewPerformanceTiming(),\n            video: getNewPerformanceTiming(),\n            audiovideo: getNewPerformanceTiming()\n        };\n        this.level = level;\n        this.sn = sn;\n        this.id = id;\n        this.size = size;\n        this.part = part;\n        this.partial = partial;\n    }\n}\nfunction getNewPerformanceTiming() {\n    return {\n        start: 0,\n        executeStart: 0,\n        executeEnd: 0,\n        end: 0\n    };\n}\nfunction findFirstFragWithCC(fragments, cc) {\n    for(let i = 0, len = fragments.length; i < len; i++){\n        var _fragments$i;\n        if (((_fragments$i = fragments[i]) == null ? void 0 : _fragments$i.cc) === cc) {\n            return fragments[i];\n        }\n    }\n    return null;\n}\nfunction shouldAlignOnDiscontinuities(lastFrag, switchDetails, details) {\n    if (switchDetails) {\n        if (details.endCC > details.startCC || lastFrag && lastFrag.cc < details.startCC) {\n            return true;\n        }\n    }\n    return false;\n}\n// Find the first frag in the previous level which matches the CC of the first frag of the new level\nfunction findDiscontinuousReferenceFrag(prevDetails, curDetails) {\n    const prevFrags = prevDetails.fragments;\n    const curFrags = curDetails.fragments;\n    if (!curFrags.length || !prevFrags.length) {\n        logger.log(\"No fragments to align\");\n        return;\n    }\n    const prevStartFrag = findFirstFragWithCC(prevFrags, curFrags[0].cc);\n    if (!prevStartFrag || prevStartFrag && !prevStartFrag.startPTS) {\n        logger.log(\"No frag in previous level to align on\");\n        return;\n    }\n    return prevStartFrag;\n}\nfunction adjustFragmentStart(frag, sliding) {\n    if (frag) {\n        const start = frag.start + sliding;\n        frag.start = frag.startPTS = start;\n        frag.endPTS = start + frag.duration;\n    }\n}\nfunction adjustSlidingStart(sliding, details) {\n    // Update segments\n    const fragments = details.fragments;\n    for(let i = 0, len = fragments.length; i < len; i++){\n        adjustFragmentStart(fragments[i], sliding);\n    }\n    // Update LL-HLS parts at the end of the playlist\n    if (details.fragmentHint) {\n        adjustFragmentStart(details.fragmentHint, sliding);\n    }\n    details.alignedSliding = true;\n}\n/**\n * Using the parameters of the last level, this function computes PTS' of the new fragments so that they form a\n * contiguous stream with the last fragments.\n * The PTS of a fragment lets Hls.js know where it fits into a stream - by knowing every PTS, we know which fragment to\n * download at any given time. PTS is normally computed when the fragment is demuxed, so taking this step saves us time\n * and an extra download.\n * @param lastFrag\n * @param lastLevel\n * @param details\n */ function alignStream(lastFrag, switchDetails, details) {\n    if (!switchDetails) {\n        return;\n    }\n    alignDiscontinuities(lastFrag, details, switchDetails);\n    if (!details.alignedSliding && switchDetails) {\n        // If the PTS wasn't figured out via discontinuity sequence that means there was no CC increase within the level.\n        // Aligning via Program Date Time should therefore be reliable, since PDT should be the same within the same\n        // discontinuity sequence.\n        alignMediaPlaylistByPDT(details, switchDetails);\n    }\n    if (!details.alignedSliding && switchDetails && !details.skippedSegments) {\n        // Try to align on sn so that we pick a better start fragment.\n        // Do not perform this on playlists with delta updates as this is only to align levels on switch\n        // and adjustSliding only adjusts fragments after skippedSegments.\n        adjustSliding(switchDetails, details);\n    }\n}\n/**\n * Computes the PTS if a new level's fragments using the PTS of a fragment in the last level which shares the same\n * discontinuity sequence.\n * @param lastFrag - The last Fragment which shares the same discontinuity sequence\n * @param lastLevel - The details of the last loaded level\n * @param details - The details of the new level\n */ function alignDiscontinuities(lastFrag, details, switchDetails) {\n    if (shouldAlignOnDiscontinuities(lastFrag, switchDetails, details)) {\n        const referenceFrag = findDiscontinuousReferenceFrag(switchDetails, details);\n        if (referenceFrag && isFiniteNumber(referenceFrag.start)) {\n            logger.log(`Adjusting PTS using last level due to CC increase within current level ${details.url}`);\n            adjustSlidingStart(referenceFrag.start, details);\n        }\n    }\n}\n/**\n * Ensures appropriate time-alignment between renditions based on PDT.\n * This function assumes the timelines represented in `refDetails` are accurate, including the PDTs\n * for the last discontinuity sequence number shared by both playlists when present,\n * and uses the \"wallclock\"/PDT timeline as a cross-reference to `details`, adjusting the presentation\n * times/timelines of `details` accordingly.\n * Given the asynchronous nature of fetches and initial loads of live `main` and audio/subtitle tracks,\n * the primary purpose of this function is to ensure the \"local timelines\" of audio/subtitle tracks\n * are aligned to the main/video timeline, using PDT as the cross-reference/\"anchor\" that should\n * be consistent across playlists, per the HLS spec.\n * @param details - The details of the rendition you'd like to time-align (e.g. an audio rendition).\n * @param refDetails - The details of the reference rendition with start and PDT times for alignment.\n */ function alignMediaPlaylistByPDT(details, refDetails) {\n    if (!details.hasProgramDateTime || !refDetails.hasProgramDateTime) {\n        return;\n    }\n    const fragments = details.fragments;\n    const refFragments = refDetails.fragments;\n    if (!fragments.length || !refFragments.length) {\n        return;\n    }\n    // Calculate a delta to apply to all fragments according to the delta in PDT times and start times\n    // of a fragment in the reference details, and a fragment in the target details of the same discontinuity.\n    // If a fragment of the same discontinuity was not found use the middle fragment of both.\n    let refFrag;\n    let frag;\n    const targetCC = Math.min(refDetails.endCC, details.endCC);\n    if (refDetails.startCC < targetCC && details.startCC < targetCC) {\n        refFrag = findFirstFragWithCC(refFragments, targetCC);\n        frag = findFirstFragWithCC(fragments, targetCC);\n    }\n    if (!refFrag || !frag) {\n        refFrag = refFragments[Math.floor(refFragments.length / 2)];\n        frag = findFirstFragWithCC(fragments, refFrag.cc) || fragments[Math.floor(fragments.length / 2)];\n    }\n    const refPDT = refFrag.programDateTime;\n    const targetPDT = frag.programDateTime;\n    if (!refPDT || !targetPDT) {\n        return;\n    }\n    const delta = (targetPDT - refPDT) / 1000 - (frag.start - refFrag.start);\n    adjustSlidingStart(delta, details);\n}\nconst MIN_CHUNK_SIZE = Math.pow(2, 17); // 128kb\nclass FragmentLoader {\n    constructor(config){\n        this.config = void 0;\n        this.loader = null;\n        this.partLoadTimeout = -1;\n        this.config = config;\n    }\n    destroy() {\n        if (this.loader) {\n            this.loader.destroy();\n            this.loader = null;\n        }\n    }\n    abort() {\n        if (this.loader) {\n            // Abort the loader for current fragment. Only one may load at any given time\n            this.loader.abort();\n        }\n    }\n    load(frag, onProgress) {\n        const url = frag.url;\n        if (!url) {\n            return Promise.reject(new LoadError({\n                type: ErrorTypes.NETWORK_ERROR,\n                details: ErrorDetails.FRAG_LOAD_ERROR,\n                fatal: false,\n                frag,\n                error: new Error(`Fragment does not have a ${url ? \"part list\" : \"url\"}`),\n                networkDetails: null\n            }));\n        }\n        this.abort();\n        const config = this.config;\n        const FragmentILoader = config.fLoader;\n        const DefaultILoader = config.loader;\n        return new Promise((resolve, reject)=>{\n            if (this.loader) {\n                this.loader.destroy();\n            }\n            if (frag.gap) {\n                if (frag.tagList.some((tags)=>tags[0] === \"GAP\")) {\n                    reject(createGapLoadError(frag));\n                    return;\n                } else {\n                    // Reset temporary treatment as GAP tag\n                    frag.gap = false;\n                }\n            }\n            const loader = this.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);\n            const loaderContext = createLoaderContext(frag);\n            const loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);\n            const loaderConfig = {\n                loadPolicy,\n                timeout: loadPolicy.maxLoadTimeMs,\n                maxRetry: 0,\n                retryDelay: 0,\n                maxRetryDelay: 0,\n                highWaterMark: frag.sn === \"initSegment\" ? Infinity : MIN_CHUNK_SIZE\n            };\n            // Assign frag stats to the loader's stats reference\n            frag.stats = loader.stats;\n            loader.load(loaderContext, loaderConfig, {\n                onSuccess: (response, stats, context, networkDetails)=>{\n                    this.resetLoader(frag, loader);\n                    let payload = response.data;\n                    if (context.resetIV && frag.decryptdata) {\n                        frag.decryptdata.iv = new Uint8Array(payload.slice(0, 16));\n                        payload = payload.slice(16);\n                    }\n                    resolve({\n                        frag,\n                        part: null,\n                        payload,\n                        networkDetails\n                    });\n                },\n                onError: (response, context, networkDetails, stats)=>{\n                    this.resetLoader(frag, loader);\n                    reject(new LoadError({\n                        type: ErrorTypes.NETWORK_ERROR,\n                        details: ErrorDetails.FRAG_LOAD_ERROR,\n                        fatal: false,\n                        frag,\n                        response: _objectSpread2({\n                            url,\n                            data: undefined\n                        }, response),\n                        error: new Error(`HTTP Error ${response.code} ${response.text}`),\n                        networkDetails,\n                        stats\n                    }));\n                },\n                onAbort: (stats, context, networkDetails)=>{\n                    this.resetLoader(frag, loader);\n                    reject(new LoadError({\n                        type: ErrorTypes.NETWORK_ERROR,\n                        details: ErrorDetails.INTERNAL_ABORTED,\n                        fatal: false,\n                        frag,\n                        error: new Error(\"Aborted\"),\n                        networkDetails,\n                        stats\n                    }));\n                },\n                onTimeout: (stats, context, networkDetails)=>{\n                    this.resetLoader(frag, loader);\n                    reject(new LoadError({\n                        type: ErrorTypes.NETWORK_ERROR,\n                        details: ErrorDetails.FRAG_LOAD_TIMEOUT,\n                        fatal: false,\n                        frag,\n                        error: new Error(`Timeout after ${loaderConfig.timeout}ms`),\n                        networkDetails,\n                        stats\n                    }));\n                },\n                onProgress: (stats, context, data, networkDetails)=>{\n                    if (onProgress) {\n                        onProgress({\n                            frag,\n                            part: null,\n                            payload: data,\n                            networkDetails\n                        });\n                    }\n                }\n            });\n        });\n    }\n    loadPart(frag, part, onProgress) {\n        this.abort();\n        const config = this.config;\n        const FragmentILoader = config.fLoader;\n        const DefaultILoader = config.loader;\n        return new Promise((resolve, reject)=>{\n            if (this.loader) {\n                this.loader.destroy();\n            }\n            if (frag.gap || part.gap) {\n                reject(createGapLoadError(frag, part));\n                return;\n            }\n            const loader = this.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);\n            const loaderContext = createLoaderContext(frag, part);\n            // Should we define another load policy for parts?\n            const loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);\n            const loaderConfig = {\n                loadPolicy,\n                timeout: loadPolicy.maxLoadTimeMs,\n                maxRetry: 0,\n                retryDelay: 0,\n                maxRetryDelay: 0,\n                highWaterMark: MIN_CHUNK_SIZE\n            };\n            // Assign part stats to the loader's stats reference\n            part.stats = loader.stats;\n            loader.load(loaderContext, loaderConfig, {\n                onSuccess: (response, stats, context, networkDetails)=>{\n                    this.resetLoader(frag, loader);\n                    this.updateStatsFromPart(frag, part);\n                    const partLoadedData = {\n                        frag,\n                        part,\n                        payload: response.data,\n                        networkDetails\n                    };\n                    onProgress(partLoadedData);\n                    resolve(partLoadedData);\n                },\n                onError: (response, context, networkDetails, stats)=>{\n                    this.resetLoader(frag, loader);\n                    reject(new LoadError({\n                        type: ErrorTypes.NETWORK_ERROR,\n                        details: ErrorDetails.FRAG_LOAD_ERROR,\n                        fatal: false,\n                        frag,\n                        part,\n                        response: _objectSpread2({\n                            url: loaderContext.url,\n                            data: undefined\n                        }, response),\n                        error: new Error(`HTTP Error ${response.code} ${response.text}`),\n                        networkDetails,\n                        stats\n                    }));\n                },\n                onAbort: (stats, context, networkDetails)=>{\n                    frag.stats.aborted = part.stats.aborted;\n                    this.resetLoader(frag, loader);\n                    reject(new LoadError({\n                        type: ErrorTypes.NETWORK_ERROR,\n                        details: ErrorDetails.INTERNAL_ABORTED,\n                        fatal: false,\n                        frag,\n                        part,\n                        error: new Error(\"Aborted\"),\n                        networkDetails,\n                        stats\n                    }));\n                },\n                onTimeout: (stats, context, networkDetails)=>{\n                    this.resetLoader(frag, loader);\n                    reject(new LoadError({\n                        type: ErrorTypes.NETWORK_ERROR,\n                        details: ErrorDetails.FRAG_LOAD_TIMEOUT,\n                        fatal: false,\n                        frag,\n                        part,\n                        error: new Error(`Timeout after ${loaderConfig.timeout}ms`),\n                        networkDetails,\n                        stats\n                    }));\n                }\n            });\n        });\n    }\n    updateStatsFromPart(frag, part) {\n        const fragStats = frag.stats;\n        const partStats = part.stats;\n        const partTotal = partStats.total;\n        fragStats.loaded += partStats.loaded;\n        if (partTotal) {\n            const estTotalParts = Math.round(frag.duration / part.duration);\n            const estLoadedParts = Math.min(Math.round(fragStats.loaded / partTotal), estTotalParts);\n            const estRemainingParts = estTotalParts - estLoadedParts;\n            const estRemainingBytes = estRemainingParts * Math.round(fragStats.loaded / estLoadedParts);\n            fragStats.total = fragStats.loaded + estRemainingBytes;\n        } else {\n            fragStats.total = Math.max(fragStats.loaded, fragStats.total);\n        }\n        const fragLoading = fragStats.loading;\n        const partLoading = partStats.loading;\n        if (fragLoading.start) {\n            // add to fragment loader latency\n            fragLoading.first += partLoading.first - partLoading.start;\n        } else {\n            fragLoading.start = partLoading.start;\n            fragLoading.first = partLoading.first;\n        }\n        fragLoading.end = partLoading.end;\n    }\n    resetLoader(frag, loader) {\n        frag.loader = null;\n        if (this.loader === loader) {\n            self.clearTimeout(this.partLoadTimeout);\n            this.loader = null;\n        }\n        loader.destroy();\n    }\n}\nfunction createLoaderContext(frag, part = null) {\n    const segment = part || frag;\n    const loaderContext = {\n        frag,\n        part,\n        responseType: \"arraybuffer\",\n        url: segment.url,\n        headers: {},\n        rangeStart: 0,\n        rangeEnd: 0\n    };\n    const start = segment.byteRangeStartOffset;\n    const end = segment.byteRangeEndOffset;\n    if (isFiniteNumber(start) && isFiniteNumber(end)) {\n        var _frag$decryptdata;\n        let byteRangeStart = start;\n        let byteRangeEnd = end;\n        if (frag.sn === \"initSegment\" && ((_frag$decryptdata = frag.decryptdata) == null ? void 0 : _frag$decryptdata.method) === \"AES-128\") {\n            // MAP segment encrypted with method 'AES-128', when served with HTTP Range,\n            // has the unencrypted size specified in the range.\n            // Ref: https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-08#section-6.3.6\n            const fragmentLen = end - start;\n            if (fragmentLen % 16) {\n                byteRangeEnd = end + (16 - fragmentLen % 16);\n            }\n            if (start !== 0) {\n                loaderContext.resetIV = true;\n                byteRangeStart = start - 16;\n            }\n        }\n        loaderContext.rangeStart = byteRangeStart;\n        loaderContext.rangeEnd = byteRangeEnd;\n    }\n    return loaderContext;\n}\nfunction createGapLoadError(frag, part) {\n    const error = new Error(`GAP ${frag.gap ? \"tag\" : \"attribute\"} found`);\n    const errorData = {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.FRAG_GAP,\n        fatal: false,\n        frag,\n        error,\n        networkDetails: null\n    };\n    if (part) {\n        errorData.part = part;\n    }\n    (part ? part : frag).stats.aborted = true;\n    return new LoadError(errorData);\n}\nclass LoadError extends Error {\n    constructor(data){\n        super(data.error.message);\n        this.data = void 0;\n        this.data = data;\n    }\n}\nclass AESCrypto {\n    constructor(subtle, iv){\n        this.subtle = void 0;\n        this.aesIV = void 0;\n        this.subtle = subtle;\n        this.aesIV = iv;\n    }\n    decrypt(data, key) {\n        return this.subtle.decrypt({\n            name: \"AES-CBC\",\n            iv: this.aesIV\n        }, key, data);\n    }\n}\nclass FastAESKey {\n    constructor(subtle, key){\n        this.subtle = void 0;\n        this.key = void 0;\n        this.subtle = subtle;\n        this.key = key;\n    }\n    expandKey() {\n        return this.subtle.importKey(\"raw\", this.key, {\n            name: \"AES-CBC\"\n        }, false, [\n            \"encrypt\",\n            \"decrypt\"\n        ]);\n    }\n}\n// PKCS7\nfunction removePadding(array) {\n    const outputBytes = array.byteLength;\n    const paddingBytes = outputBytes && new DataView(array.buffer).getUint8(outputBytes - 1);\n    if (paddingBytes) {\n        return sliceUint8(array, 0, outputBytes - paddingBytes);\n    }\n    return array;\n}\nclass AESDecryptor {\n    constructor(){\n        this.rcon = [\n            0x0,\n            0x1,\n            0x2,\n            0x4,\n            0x8,\n            0x10,\n            0x20,\n            0x40,\n            0x80,\n            0x1b,\n            0x36\n        ];\n        this.subMix = [\n            new Uint32Array(256),\n            new Uint32Array(256),\n            new Uint32Array(256),\n            new Uint32Array(256)\n        ];\n        this.invSubMix = [\n            new Uint32Array(256),\n            new Uint32Array(256),\n            new Uint32Array(256),\n            new Uint32Array(256)\n        ];\n        this.sBox = new Uint32Array(256);\n        this.invSBox = new Uint32Array(256);\n        this.key = new Uint32Array(0);\n        this.ksRows = 0;\n        this.keySize = 0;\n        this.keySchedule = void 0;\n        this.invKeySchedule = void 0;\n        this.initTable();\n    }\n    // Using view.getUint32() also swaps the byte order.\n    uint8ArrayToUint32Array_(arrayBuffer) {\n        const view = new DataView(arrayBuffer);\n        const newArray = new Uint32Array(4);\n        for(let i = 0; i < 4; i++){\n            newArray[i] = view.getUint32(i * 4);\n        }\n        return newArray;\n    }\n    initTable() {\n        const sBox = this.sBox;\n        const invSBox = this.invSBox;\n        const subMix = this.subMix;\n        const subMix0 = subMix[0];\n        const subMix1 = subMix[1];\n        const subMix2 = subMix[2];\n        const subMix3 = subMix[3];\n        const invSubMix = this.invSubMix;\n        const invSubMix0 = invSubMix[0];\n        const invSubMix1 = invSubMix[1];\n        const invSubMix2 = invSubMix[2];\n        const invSubMix3 = invSubMix[3];\n        const d = new Uint32Array(256);\n        let x = 0;\n        let xi = 0;\n        let i = 0;\n        for(i = 0; i < 256; i++){\n            if (i < 128) {\n                d[i] = i << 1;\n            } else {\n                d[i] = i << 1 ^ 0x11b;\n            }\n        }\n        for(i = 0; i < 256; i++){\n            let sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;\n            sx = sx >>> 8 ^ sx & 0xff ^ 0x63;\n            sBox[x] = sx;\n            invSBox[sx] = x;\n            // Compute multiplication\n            const x2 = d[x];\n            const x4 = d[x2];\n            const x8 = d[x4];\n            // Compute sub/invSub bytes, mix columns tables\n            let t = d[sx] * 0x101 ^ sx * 0x1010100;\n            subMix0[x] = t << 24 | t >>> 8;\n            subMix1[x] = t << 16 | t >>> 16;\n            subMix2[x] = t << 8 | t >>> 24;\n            subMix3[x] = t;\n            // Compute inv sub bytes, inv mix columns tables\n            t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;\n            invSubMix0[sx] = t << 24 | t >>> 8;\n            invSubMix1[sx] = t << 16 | t >>> 16;\n            invSubMix2[sx] = t << 8 | t >>> 24;\n            invSubMix3[sx] = t;\n            // Compute next counter\n            if (!x) {\n                x = xi = 1;\n            } else {\n                x = x2 ^ d[d[d[x8 ^ x2]]];\n                xi ^= d[d[xi]];\n            }\n        }\n    }\n    expandKey(keyBuffer) {\n        // convert keyBuffer to Uint32Array\n        const key = this.uint8ArrayToUint32Array_(keyBuffer);\n        let sameKey = true;\n        let offset = 0;\n        while(offset < key.length && sameKey){\n            sameKey = key[offset] === this.key[offset];\n            offset++;\n        }\n        if (sameKey) {\n            return;\n        }\n        this.key = key;\n        const keySize = this.keySize = key.length;\n        if (keySize !== 4 && keySize !== 6 && keySize !== 8) {\n            throw new Error(\"Invalid aes key size=\" + keySize);\n        }\n        const ksRows = this.ksRows = (keySize + 6 + 1) * 4;\n        let ksRow;\n        let invKsRow;\n        const keySchedule = this.keySchedule = new Uint32Array(ksRows);\n        const invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);\n        const sbox = this.sBox;\n        const rcon = this.rcon;\n        const invSubMix = this.invSubMix;\n        const invSubMix0 = invSubMix[0];\n        const invSubMix1 = invSubMix[1];\n        const invSubMix2 = invSubMix[2];\n        const invSubMix3 = invSubMix[3];\n        let prev;\n        let t;\n        for(ksRow = 0; ksRow < ksRows; ksRow++){\n            if (ksRow < keySize) {\n                prev = keySchedule[ksRow] = key[ksRow];\n                continue;\n            }\n            t = prev;\n            if (ksRow % keySize === 0) {\n                // Rot word\n                t = t << 8 | t >>> 24;\n                // Sub word\n                t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];\n                // Mix Rcon\n                t ^= rcon[ksRow / keySize | 0] << 24;\n            } else if (keySize > 6 && ksRow % keySize === 4) {\n                // Sub word\n                t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];\n            }\n            keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;\n        }\n        for(invKsRow = 0; invKsRow < ksRows; invKsRow++){\n            ksRow = ksRows - invKsRow;\n            if (invKsRow & 3) {\n                t = keySchedule[ksRow];\n            } else {\n                t = keySchedule[ksRow - 4];\n            }\n            if (invKsRow < 4 || ksRow <= 4) {\n                invKeySchedule[invKsRow] = t;\n            } else {\n                invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 0xff]] ^ invSubMix2[sbox[t >>> 8 & 0xff]] ^ invSubMix3[sbox[t & 0xff]];\n            }\n            invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;\n        }\n    }\n    // Adding this as a method greatly improves performance.\n    networkToHostOrderSwap(word) {\n        return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;\n    }\n    decrypt(inputArrayBuffer, offset, aesIV) {\n        const nRounds = this.keySize + 6;\n        const invKeySchedule = this.invKeySchedule;\n        const invSBOX = this.invSBox;\n        const invSubMix = this.invSubMix;\n        const invSubMix0 = invSubMix[0];\n        const invSubMix1 = invSubMix[1];\n        const invSubMix2 = invSubMix[2];\n        const invSubMix3 = invSubMix[3];\n        const initVector = this.uint8ArrayToUint32Array_(aesIV);\n        let initVector0 = initVector[0];\n        let initVector1 = initVector[1];\n        let initVector2 = initVector[2];\n        let initVector3 = initVector[3];\n        const inputInt32 = new Int32Array(inputArrayBuffer);\n        const outputInt32 = new Int32Array(inputInt32.length);\n        let t0, t1, t2, t3;\n        let s0, s1, s2, s3;\n        let inputWords0, inputWords1, inputWords2, inputWords3;\n        let ksRow, i;\n        const swapWord = this.networkToHostOrderSwap;\n        while(offset < inputInt32.length){\n            inputWords0 = swapWord(inputInt32[offset]);\n            inputWords1 = swapWord(inputInt32[offset + 1]);\n            inputWords2 = swapWord(inputInt32[offset + 2]);\n            inputWords3 = swapWord(inputInt32[offset + 3]);\n            s0 = inputWords0 ^ invKeySchedule[0];\n            s1 = inputWords3 ^ invKeySchedule[1];\n            s2 = inputWords2 ^ invKeySchedule[2];\n            s3 = inputWords1 ^ invKeySchedule[3];\n            ksRow = 4;\n            // Iterate through the rounds of decryption\n            for(i = 1; i < nRounds; i++){\n                t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 0xff] ^ invSubMix2[s2 >> 8 & 0xff] ^ invSubMix3[s3 & 0xff] ^ invKeySchedule[ksRow];\n                t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 0xff] ^ invSubMix2[s3 >> 8 & 0xff] ^ invSubMix3[s0 & 0xff] ^ invKeySchedule[ksRow + 1];\n                t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 0xff] ^ invSubMix2[s0 >> 8 & 0xff] ^ invSubMix3[s1 & 0xff] ^ invKeySchedule[ksRow + 2];\n                t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 0xff] ^ invSubMix2[s1 >> 8 & 0xff] ^ invSubMix3[s2 & 0xff] ^ invKeySchedule[ksRow + 3];\n                // Update state\n                s0 = t0;\n                s1 = t1;\n                s2 = t2;\n                s3 = t3;\n                ksRow = ksRow + 4;\n            }\n            // Shift rows, sub bytes, add round key\n            t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 0xff] << 16 ^ invSBOX[s2 >> 8 & 0xff] << 8 ^ invSBOX[s3 & 0xff] ^ invKeySchedule[ksRow];\n            t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 0xff] << 16 ^ invSBOX[s3 >> 8 & 0xff] << 8 ^ invSBOX[s0 & 0xff] ^ invKeySchedule[ksRow + 1];\n            t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 0xff] << 16 ^ invSBOX[s0 >> 8 & 0xff] << 8 ^ invSBOX[s1 & 0xff] ^ invKeySchedule[ksRow + 2];\n            t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 0xff] << 16 ^ invSBOX[s1 >> 8 & 0xff] << 8 ^ invSBOX[s2 & 0xff] ^ invKeySchedule[ksRow + 3];\n            // Write\n            outputInt32[offset] = swapWord(t0 ^ initVector0);\n            outputInt32[offset + 1] = swapWord(t3 ^ initVector1);\n            outputInt32[offset + 2] = swapWord(t2 ^ initVector2);\n            outputInt32[offset + 3] = swapWord(t1 ^ initVector3);\n            // reset initVector to last 4 unsigned int\n            initVector0 = inputWords0;\n            initVector1 = inputWords1;\n            initVector2 = inputWords2;\n            initVector3 = inputWords3;\n            offset = offset + 4;\n        }\n        return outputInt32.buffer;\n    }\n}\nconst CHUNK_SIZE = 16; // 16 bytes, 128 bits\nclass Decrypter {\n    constructor(config, { removePKCS7Padding = true } = {}){\n        this.logEnabled = true;\n        this.removePKCS7Padding = void 0;\n        this.subtle = null;\n        this.softwareDecrypter = null;\n        this.key = null;\n        this.fastAesKey = null;\n        this.remainderData = null;\n        this.currentIV = null;\n        this.currentResult = null;\n        this.useSoftware = void 0;\n        this.useSoftware = config.enableSoftwareAES;\n        this.removePKCS7Padding = removePKCS7Padding;\n        // built in decryptor expects PKCS7 padding\n        if (removePKCS7Padding) {\n            try {\n                const browserCrypto = self.crypto;\n                if (browserCrypto) {\n                    this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\n                }\n            } catch (e) {\n            /* no-op */ }\n        }\n        if (this.subtle === null) {\n            this.useSoftware = true;\n        }\n    }\n    destroy() {\n        this.subtle = null;\n        this.softwareDecrypter = null;\n        this.key = null;\n        this.fastAesKey = null;\n        this.remainderData = null;\n        this.currentIV = null;\n        this.currentResult = null;\n    }\n    isSync() {\n        return this.useSoftware;\n    }\n    flush() {\n        const { currentResult, remainderData } = this;\n        if (!currentResult || remainderData) {\n            this.reset();\n            return null;\n        }\n        const data = new Uint8Array(currentResult);\n        this.reset();\n        if (this.removePKCS7Padding) {\n            return removePadding(data);\n        }\n        return data;\n    }\n    reset() {\n        this.currentResult = null;\n        this.currentIV = null;\n        this.remainderData = null;\n        if (this.softwareDecrypter) {\n            this.softwareDecrypter = null;\n        }\n    }\n    decrypt(data, key, iv) {\n        if (this.useSoftware) {\n            return new Promise((resolve, reject)=>{\n                this.softwareDecrypt(new Uint8Array(data), key, iv);\n                const decryptResult = this.flush();\n                if (decryptResult) {\n                    resolve(decryptResult.buffer);\n                } else {\n                    reject(new Error(\"[softwareDecrypt] Failed to decrypt data\"));\n                }\n            });\n        }\n        return this.webCryptoDecrypt(new Uint8Array(data), key, iv);\n    }\n    // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached\n    // data is handled in the flush() call\n    softwareDecrypt(data, key, iv) {\n        const { currentIV, currentResult, remainderData } = this;\n        this.logOnce(\"JS AES decrypt\");\n        // The output is staggered during progressive parsing - the current result is cached, and emitted on the next call\n        // This is done in order to strip PKCS7 padding, which is found at the end of each segment. We only know we've reached\n        // the end on flush(), but by that time we have already received all bytes for the segment.\n        // Progressive decryption does not work with WebCrypto\n        if (remainderData) {\n            data = appendUint8Array(remainderData, data);\n            this.remainderData = null;\n        }\n        // Byte length must be a multiple of 16 (AES-128 = 128 bit blocks = 16 bytes)\n        const currentChunk = this.getValidChunk(data);\n        if (!currentChunk.length) {\n            return null;\n        }\n        if (currentIV) {\n            iv = currentIV;\n        }\n        let softwareDecrypter = this.softwareDecrypter;\n        if (!softwareDecrypter) {\n            softwareDecrypter = this.softwareDecrypter = new AESDecryptor();\n        }\n        softwareDecrypter.expandKey(key);\n        const result = currentResult;\n        this.currentResult = softwareDecrypter.decrypt(currentChunk.buffer, 0, iv);\n        this.currentIV = sliceUint8(currentChunk, -16).buffer;\n        if (!result) {\n            return null;\n        }\n        return result;\n    }\n    webCryptoDecrypt(data, key, iv) {\n        const subtle = this.subtle;\n        if (this.key !== key || !this.fastAesKey) {\n            this.key = key;\n            this.fastAesKey = new FastAESKey(subtle, key);\n        }\n        return this.fastAesKey.expandKey().then((aesKey)=>{\n            // decrypt using web crypto\n            if (!subtle) {\n                return Promise.reject(new Error(\"web crypto not initialized\"));\n            }\n            this.logOnce(\"WebCrypto AES decrypt\");\n            const crypto1 = new AESCrypto(subtle, new Uint8Array(iv));\n            return crypto1.decrypt(data.buffer, aesKey);\n        }).catch((err)=>{\n            logger.warn(`[decrypter]: WebCrypto Error, disable WebCrypto API, ${err.name}: ${err.message}`);\n            return this.onWebCryptoError(data, key, iv);\n        });\n    }\n    onWebCryptoError(data, key, iv) {\n        this.useSoftware = true;\n        this.logEnabled = true;\n        this.softwareDecrypt(data, key, iv);\n        const decryptResult = this.flush();\n        if (decryptResult) {\n            return decryptResult.buffer;\n        }\n        throw new Error(\"WebCrypto and softwareDecrypt: failed to decrypt data\");\n    }\n    getValidChunk(data) {\n        let currentChunk = data;\n        const splitPoint = data.length - data.length % CHUNK_SIZE;\n        if (splitPoint !== data.length) {\n            currentChunk = sliceUint8(data, 0, splitPoint);\n            this.remainderData = sliceUint8(data, splitPoint);\n        }\n        return currentChunk;\n    }\n    logOnce(msg) {\n        if (!this.logEnabled) {\n            return;\n        }\n        logger.log(`[decrypter]: ${msg}`);\n        this.logEnabled = false;\n    }\n}\n/**\n *  TimeRanges to string helper\n */ const TimeRanges = {\n    toString: function(r) {\n        let log = \"\";\n        const len = r.length;\n        for(let i = 0; i < len; i++){\n            log += `[${r.start(i).toFixed(3)}-${r.end(i).toFixed(3)}]`;\n        }\n        return log;\n    }\n};\nconst State = {\n    STOPPED: \"STOPPED\",\n    IDLE: \"IDLE\",\n    KEY_LOADING: \"KEY_LOADING\",\n    FRAG_LOADING: \"FRAG_LOADING\",\n    FRAG_LOADING_WAITING_RETRY: \"FRAG_LOADING_WAITING_RETRY\",\n    WAITING_TRACK: \"WAITING_TRACK\",\n    PARSING: \"PARSING\",\n    PARSED: \"PARSED\",\n    ENDED: \"ENDED\",\n    ERROR: \"ERROR\",\n    WAITING_INIT_PTS: \"WAITING_INIT_PTS\",\n    WAITING_LEVEL: \"WAITING_LEVEL\"\n};\nclass BaseStreamController extends TaskLoop {\n    constructor(hls, fragmentTracker, keyLoader, logPrefix, playlistType){\n        super();\n        this.hls = void 0;\n        this.fragPrevious = null;\n        this.fragCurrent = null;\n        this.fragmentTracker = void 0;\n        this.transmuxer = null;\n        this._state = State.STOPPED;\n        this.playlistType = void 0;\n        this.media = null;\n        this.mediaBuffer = null;\n        this.config = void 0;\n        this.bitrateTest = false;\n        this.lastCurrentTime = 0;\n        this.nextLoadPosition = 0;\n        this.startPosition = 0;\n        this.startTimeOffset = null;\n        this.loadedmetadata = false;\n        this.retryDate = 0;\n        this.levels = null;\n        this.fragmentLoader = void 0;\n        this.keyLoader = void 0;\n        this.levelLastLoaded = null;\n        this.startFragRequested = false;\n        this.decrypter = void 0;\n        this.initPTS = [];\n        this.onvseeking = null;\n        this.onvended = null;\n        this.logPrefix = \"\";\n        this.log = void 0;\n        this.warn = void 0;\n        this.playlistType = playlistType;\n        this.logPrefix = logPrefix;\n        this.log = logger.log.bind(logger, `${logPrefix}:`);\n        this.warn = logger.warn.bind(logger, `${logPrefix}:`);\n        this.hls = hls;\n        this.fragmentLoader = new FragmentLoader(hls.config);\n        this.keyLoader = keyLoader;\n        this.fragmentTracker = fragmentTracker;\n        this.config = hls.config;\n        this.decrypter = new Decrypter(hls.config);\n        hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    }\n    doTick() {\n        this.onTickEnd();\n    }\n    onTickEnd() {}\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    startLoad(startPosition) {}\n    stopLoad() {\n        this.fragmentLoader.abort();\n        this.keyLoader.abort(this.playlistType);\n        const frag = this.fragCurrent;\n        if (frag != null && frag.loader) {\n            frag.abortRequests();\n            this.fragmentTracker.removeFragment(frag);\n        }\n        this.resetTransmuxer();\n        this.fragCurrent = null;\n        this.fragPrevious = null;\n        this.clearInterval();\n        this.clearNextTick();\n        this.state = State.STOPPED;\n    }\n    _streamEnded(bufferInfo, levelDetails) {\n        // If playlist is live, there is another buffered range after the current range, nothing buffered, media is detached,\n        // of nothing loading/loaded return false\n        if (levelDetails.live || bufferInfo.nextStart || !bufferInfo.end || !this.media) {\n            return false;\n        }\n        const partList = levelDetails.partList;\n        // Since the last part isn't guaranteed to correspond to the last playlist segment for Low-Latency HLS,\n        // check instead if the last part is buffered.\n        if (partList != null && partList.length) {\n            const lastPart = partList[partList.length - 1];\n            // Checking the midpoint of the part for potential margin of error and related issues.\n            // NOTE: Technically I believe parts could yield content that is < the computed duration (including potential a duration of 0)\n            // and still be spec-compliant, so there may still be edge cases here. Likewise, there could be issues in end of stream\n            // part mismatches for independent audio and video playlists/segments.\n            const lastPartBuffered = BufferHelper.isBuffered(this.media, lastPart.start + lastPart.duration / 2);\n            return lastPartBuffered;\n        }\n        const playlistType = levelDetails.fragments[levelDetails.fragments.length - 1].type;\n        return this.fragmentTracker.isEndListAppended(playlistType);\n    }\n    getLevelDetails() {\n        if (this.levels && this.levelLastLoaded !== null) {\n            var _this$levelLastLoaded;\n            return (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details;\n        }\n    }\n    onMediaAttached(event, data) {\n        const media = this.media = this.mediaBuffer = data.media;\n        this.onvseeking = this.onMediaSeeking.bind(this);\n        this.onvended = this.onMediaEnded.bind(this);\n        media.addEventListener(\"seeking\", this.onvseeking);\n        media.addEventListener(\"ended\", this.onvended);\n        const config = this.config;\n        if (this.levels && config.autoStartLoad && this.state === State.STOPPED) {\n            this.startLoad(config.startPosition);\n        }\n    }\n    onMediaDetaching() {\n        const media = this.media;\n        if (media != null && media.ended) {\n            this.log(\"MSE detaching and video ended, reset startPosition\");\n            this.startPosition = this.lastCurrentTime = 0;\n        }\n        // remove video listeners\n        if (media && this.onvseeking && this.onvended) {\n            media.removeEventListener(\"seeking\", this.onvseeking);\n            media.removeEventListener(\"ended\", this.onvended);\n            this.onvseeking = this.onvended = null;\n        }\n        if (this.keyLoader) {\n            this.keyLoader.detach();\n        }\n        this.media = this.mediaBuffer = null;\n        this.loadedmetadata = false;\n        this.fragmentTracker.removeAllFragments();\n        this.stopLoad();\n    }\n    onMediaSeeking() {\n        const { config, fragCurrent, media, mediaBuffer, state } = this;\n        const currentTime = media ? media.currentTime : 0;\n        const bufferInfo = BufferHelper.bufferInfo(mediaBuffer ? mediaBuffer : media, currentTime, config.maxBufferHole);\n        this.log(`media seeking to ${isFiniteNumber(currentTime) ? currentTime.toFixed(3) : currentTime}, state: ${state}`);\n        if (this.state === State.ENDED) {\n            this.resetLoadingState();\n        } else if (fragCurrent) {\n            // Seeking while frag load is in progress\n            const tolerance = config.maxFragLookUpTolerance;\n            const fragStartOffset = fragCurrent.start - tolerance;\n            const fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;\n            // if seeking out of buffered range or into new one\n            if (!bufferInfo.len || fragEndOffset < bufferInfo.start || fragStartOffset > bufferInfo.end) {\n                const pastFragment = currentTime > fragEndOffset;\n                // if the seek position is outside the current fragment range\n                if (currentTime < fragStartOffset || pastFragment) {\n                    if (pastFragment && fragCurrent.loader) {\n                        this.log(\"seeking outside of buffer while fragment load in progress, cancel fragment load\");\n                        fragCurrent.abortRequests();\n                        this.resetLoadingState();\n                    }\n                    this.fragPrevious = null;\n                }\n            }\n        }\n        if (media) {\n            // Remove gap fragments\n            this.fragmentTracker.removeFragmentsInRange(currentTime, Infinity, this.playlistType, true);\n            this.lastCurrentTime = currentTime;\n        }\n        // in case seeking occurs although no media buffered, adjust startPosition and nextLoadPosition to seek target\n        if (!this.loadedmetadata && !bufferInfo.len) {\n            this.nextLoadPosition = this.startPosition = currentTime;\n        }\n        // Async tick to speed up processing\n        this.tickImmediate();\n    }\n    onMediaEnded() {\n        // reset startPosition and lastCurrentTime to restart playback @ stream beginning\n        this.startPosition = this.lastCurrentTime = 0;\n    }\n    onManifestLoaded(event, data) {\n        this.startTimeOffset = data.startTimeOffset;\n        this.initPTS = [];\n    }\n    onHandlerDestroying() {\n        this.hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n        this.stopLoad();\n        super.onHandlerDestroying();\n        // @ts-ignore\n        this.hls = null;\n    }\n    onHandlerDestroyed() {\n        this.state = State.STOPPED;\n        if (this.fragmentLoader) {\n            this.fragmentLoader.destroy();\n        }\n        if (this.keyLoader) {\n            this.keyLoader.destroy();\n        }\n        if (this.decrypter) {\n            this.decrypter.destroy();\n        }\n        this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null;\n        super.onHandlerDestroyed();\n    }\n    loadFragment(frag, level, targetBufferTime) {\n        this._loadFragForPlayback(frag, level, targetBufferTime);\n    }\n    _loadFragForPlayback(frag, level, targetBufferTime) {\n        const progressCallback = (data)=>{\n            if (this.fragContextChanged(frag)) {\n                this.warn(`Fragment ${frag.sn}${data.part ? \" p: \" + data.part.index : \"\"} of level ${frag.level} was dropped during download.`);\n                this.fragmentTracker.removeFragment(frag);\n                return;\n            }\n            frag.stats.chunkCount++;\n            this._handleFragmentLoadProgress(data);\n        };\n        this._doFragLoad(frag, level, targetBufferTime, progressCallback).then((data)=>{\n            if (!data) {\n                // if we're here we probably needed to backtrack or are waiting for more parts\n                return;\n            }\n            const state = this.state;\n            if (this.fragContextChanged(frag)) {\n                if (state === State.FRAG_LOADING || !this.fragCurrent && state === State.PARSING) {\n                    this.fragmentTracker.removeFragment(frag);\n                    this.state = State.IDLE;\n                }\n                return;\n            }\n            if (\"payload\" in data) {\n                this.log(`Loaded fragment ${frag.sn} of level ${frag.level}`);\n                this.hls.trigger(Events.FRAG_LOADED, data);\n            }\n            // Pass through the whole payload; controllers not implementing progressive loading receive data from this callback\n            this._handleFragmentLoadComplete(data);\n        }).catch((reason)=>{\n            if (this.state === State.STOPPED || this.state === State.ERROR) {\n                return;\n            }\n            this.warn(reason);\n            this.resetFragmentLoading(frag);\n        });\n    }\n    clearTrackerIfNeeded(frag) {\n        var _this$mediaBuffer;\n        const { fragmentTracker } = this;\n        const fragState = fragmentTracker.getState(frag);\n        if (fragState === FragmentState.APPENDING) {\n            // Lower the buffer size and try again\n            const playlistType = frag.type;\n            const bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);\n            const minForwardBufferLength = Math.max(frag.duration, bufferedInfo ? bufferedInfo.len : this.config.maxBufferLength);\n            if (this.reduceMaxBufferLength(minForwardBufferLength)) {\n                fragmentTracker.removeFragment(frag);\n            }\n        } else if (((_this$mediaBuffer = this.mediaBuffer) == null ? void 0 : _this$mediaBuffer.buffered.length) === 0) {\n            // Stop gap for bad tracker / buffer flush behavior\n            fragmentTracker.removeAllFragments();\n        } else if (fragmentTracker.hasParts(frag.type)) {\n            // In low latency mode, remove fragments for which only some parts were buffered\n            fragmentTracker.detectPartialFragments({\n                frag,\n                part: null,\n                stats: frag.stats,\n                id: frag.type\n            });\n            if (fragmentTracker.getState(frag) === FragmentState.PARTIAL) {\n                fragmentTracker.removeFragment(frag);\n            }\n        }\n    }\n    checkLiveUpdate(details) {\n        if (details.updated && !details.live) {\n            // Live stream ended, update fragment tracker\n            const lastFragment = details.fragments[details.fragments.length - 1];\n            this.fragmentTracker.detectPartialFragments({\n                frag: lastFragment,\n                part: null,\n                stats: lastFragment.stats,\n                id: lastFragment.type\n            });\n        }\n        if (!details.fragments[0]) {\n            details.deltaUpdateFailed = true;\n        }\n    }\n    flushMainBuffer(startOffset, endOffset, type = null) {\n        if (!(startOffset - endOffset)) {\n            return;\n        }\n        // When alternate audio is playing, the audio-stream-controller is responsible for the audio buffer. Otherwise,\n        // passing a null type flushes both buffers\n        const flushScope = {\n            startOffset,\n            endOffset,\n            type\n        };\n        this.hls.trigger(Events.BUFFER_FLUSHING, flushScope);\n    }\n    _loadInitSegment(frag, level) {\n        this._doFragLoad(frag, level).then((data)=>{\n            if (!data || this.fragContextChanged(frag) || !this.levels) {\n                throw new Error(\"init load aborted\");\n            }\n            return data;\n        }).then((data)=>{\n            const { hls } = this;\n            const { payload } = data;\n            const decryptData = frag.decryptdata;\n            // check to see if the payload needs to be decrypted\n            if (payload && payload.byteLength > 0 && decryptData != null && decryptData.key && decryptData.iv && decryptData.method === \"AES-128\") {\n                const startTime = self.performance.now();\n                // decrypt init segment data\n                return this.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).catch((err)=>{\n                    hls.trigger(Events.ERROR, {\n                        type: ErrorTypes.MEDIA_ERROR,\n                        details: ErrorDetails.FRAG_DECRYPT_ERROR,\n                        fatal: false,\n                        error: err,\n                        reason: err.message,\n                        frag\n                    });\n                    throw err;\n                }).then((decryptedData)=>{\n                    const endTime = self.performance.now();\n                    hls.trigger(Events.FRAG_DECRYPTED, {\n                        frag,\n                        payload: decryptedData,\n                        stats: {\n                            tstart: startTime,\n                            tdecrypt: endTime\n                        }\n                    });\n                    data.payload = decryptedData;\n                    return this.completeInitSegmentLoad(data);\n                });\n            }\n            return this.completeInitSegmentLoad(data);\n        }).catch((reason)=>{\n            if (this.state === State.STOPPED || this.state === State.ERROR) {\n                return;\n            }\n            this.warn(reason);\n            this.resetFragmentLoading(frag);\n        });\n    }\n    completeInitSegmentLoad(data) {\n        const { levels } = this;\n        if (!levels) {\n            throw new Error(\"init load aborted, missing levels\");\n        }\n        const stats = data.frag.stats;\n        this.state = State.IDLE;\n        data.frag.data = new Uint8Array(data.payload);\n        stats.parsing.start = stats.buffering.start = self.performance.now();\n        stats.parsing.end = stats.buffering.end = self.performance.now();\n        this.tick();\n    }\n    fragContextChanged(frag) {\n        const { fragCurrent } = this;\n        return !frag || !fragCurrent || frag.sn !== fragCurrent.sn || frag.level !== fragCurrent.level;\n    }\n    fragBufferedComplete(frag, part) {\n        var _frag$startPTS, _frag$endPTS, _this$fragCurrent, _this$fragPrevious;\n        const media = this.mediaBuffer ? this.mediaBuffer : this.media;\n        this.log(`Buffered ${frag.type} sn: ${frag.sn}${part ? \" part: \" + part.index : \"\"} of ${this.playlistType === PlaylistLevelType.MAIN ? \"level\" : \"track\"} ${frag.level} (frag:[${((_frag$startPTS = frag.startPTS) != null ? _frag$startPTS : NaN).toFixed(3)}-${((_frag$endPTS = frag.endPTS) != null ? _frag$endPTS : NaN).toFixed(3)}] > buffer:${media ? TimeRanges.toString(BufferHelper.getBuffered(media)) : \"(detached)\"})`);\n        if (frag.sn !== \"initSegment\") {\n            var _this$levels;\n            if (frag.type !== PlaylistLevelType.SUBTITLE) {\n                const el = frag.elementaryStreams;\n                if (!Object.keys(el).some((type)=>!!el[type])) {\n                    // empty segment\n                    this.state = State.IDLE;\n                    return;\n                }\n            }\n            const level = (_this$levels = this.levels) == null ? void 0 : _this$levels[frag.level];\n            if (level != null && level.fragmentError) {\n                this.log(`Resetting level fragment error count of ${level.fragmentError} on frag buffered`);\n                level.fragmentError = 0;\n            }\n        }\n        this.state = State.IDLE;\n        if (!media) {\n            return;\n        }\n        if (!this.loadedmetadata && frag.type == PlaylistLevelType.MAIN && media.buffered.length && ((_this$fragCurrent = this.fragCurrent) == null ? void 0 : _this$fragCurrent.sn) === ((_this$fragPrevious = this.fragPrevious) == null ? void 0 : _this$fragPrevious.sn)) {\n            this.loadedmetadata = true;\n            this.seekToStartPos();\n        }\n        this.tick();\n    }\n    seekToStartPos() {}\n    _handleFragmentLoadComplete(fragLoadedEndData) {\n        const { transmuxer } = this;\n        if (!transmuxer) {\n            return;\n        }\n        const { frag, part, partsLoaded } = fragLoadedEndData;\n        // If we did not load parts, or loaded all parts, we have complete (not partial) fragment data\n        const complete = !partsLoaded || partsLoaded.length === 0 || partsLoaded.some((fragLoaded)=>!fragLoaded);\n        const chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount + 1, 0, part ? part.index : -1, !complete);\n        transmuxer.flush(chunkMeta);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _handleFragmentLoadProgress(frag) {}\n    _doFragLoad(frag, level, targetBufferTime = null, progressCallback) {\n        var _frag$decryptdata;\n        const details = level == null ? void 0 : level.details;\n        if (!this.levels || !details) {\n            throw new Error(`frag load aborted, missing level${details ? \"\" : \" detail\"}s`);\n        }\n        let keyLoadingPromise = null;\n        if (frag.encrypted && !((_frag$decryptdata = frag.decryptdata) != null && _frag$decryptdata.key)) {\n            this.log(`Loading key for ${frag.sn} of [${details.startSN}-${details.endSN}], ${this.logPrefix === \"[stream-controller]\" ? \"level\" : \"track\"} ${frag.level}`);\n            this.state = State.KEY_LOADING;\n            this.fragCurrent = frag;\n            keyLoadingPromise = this.keyLoader.load(frag).then((keyLoadedData)=>{\n                if (!this.fragContextChanged(keyLoadedData.frag)) {\n                    this.hls.trigger(Events.KEY_LOADED, keyLoadedData);\n                    if (this.state === State.KEY_LOADING) {\n                        this.state = State.IDLE;\n                    }\n                    return keyLoadedData;\n                }\n            });\n            this.hls.trigger(Events.KEY_LOADING, {\n                frag\n            });\n            if (this.fragCurrent === null) {\n                keyLoadingPromise = Promise.reject(new Error(`frag load aborted, context changed in KEY_LOADING`));\n            }\n        } else if (!frag.encrypted && details.encryptedFragments.length) {\n            this.keyLoader.loadClear(frag, details.encryptedFragments);\n        }\n        targetBufferTime = Math.max(frag.start, targetBufferTime || 0);\n        if (this.config.lowLatencyMode && frag.sn !== \"initSegment\") {\n            const partList = details.partList;\n            if (partList && progressCallback) {\n                if (targetBufferTime > frag.end && details.fragmentHint) {\n                    frag = details.fragmentHint;\n                }\n                const partIndex = this.getNextPart(partList, frag, targetBufferTime);\n                if (partIndex > -1) {\n                    const part = partList[partIndex];\n                    this.log(`Loading part sn: ${frag.sn} p: ${part.index} cc: ${frag.cc} of playlist [${details.startSN}-${details.endSN}] parts [0-${partIndex}-${partList.length - 1}] ${this.logPrefix === \"[stream-controller]\" ? \"level\" : \"track\"}: ${frag.level}, target: ${parseFloat(targetBufferTime.toFixed(3))}`);\n                    this.nextLoadPosition = part.start + part.duration;\n                    this.state = State.FRAG_LOADING;\n                    let _result;\n                    if (keyLoadingPromise) {\n                        _result = keyLoadingPromise.then((keyLoadedData)=>{\n                            if (!keyLoadedData || this.fragContextChanged(keyLoadedData.frag)) {\n                                return null;\n                            }\n                            return this.doFragPartsLoad(frag, part, level, progressCallback);\n                        }).catch((error)=>this.handleFragLoadError(error));\n                    } else {\n                        _result = this.doFragPartsLoad(frag, part, level, progressCallback).catch((error)=>this.handleFragLoadError(error));\n                    }\n                    this.hls.trigger(Events.FRAG_LOADING, {\n                        frag,\n                        part,\n                        targetBufferTime\n                    });\n                    if (this.fragCurrent === null) {\n                        return Promise.reject(new Error(`frag load aborted, context changed in FRAG_LOADING parts`));\n                    }\n                    return _result;\n                } else if (!frag.url || this.loadedEndOfParts(partList, targetBufferTime)) {\n                    // Fragment hint has no parts\n                    return Promise.resolve(null);\n                }\n            }\n        }\n        this.log(`Loading fragment ${frag.sn} cc: ${frag.cc} ${details ? \"of [\" + details.startSN + \"-\" + details.endSN + \"] \" : \"\"}${this.logPrefix === \"[stream-controller]\" ? \"level\" : \"track\"}: ${frag.level}, target: ${parseFloat(targetBufferTime.toFixed(3))}`);\n        // Don't update nextLoadPosition for fragments which are not buffered\n        if (isFiniteNumber(frag.sn) && !this.bitrateTest) {\n            this.nextLoadPosition = frag.start + frag.duration;\n        }\n        this.state = State.FRAG_LOADING;\n        // Load key before streaming fragment data\n        const dataOnProgress = this.config.progressive;\n        let result;\n        if (dataOnProgress && keyLoadingPromise) {\n            result = keyLoadingPromise.then((keyLoadedData)=>{\n                if (!keyLoadedData || this.fragContextChanged(keyLoadedData == null ? void 0 : keyLoadedData.frag)) {\n                    return null;\n                }\n                return this.fragmentLoader.load(frag, progressCallback);\n            }).catch((error)=>this.handleFragLoadError(error));\n        } else {\n            // load unencrypted fragment data with progress event,\n            // or handle fragment result after key and fragment are finished loading\n            result = Promise.all([\n                this.fragmentLoader.load(frag, dataOnProgress ? progressCallback : undefined),\n                keyLoadingPromise\n            ]).then(([fragLoadedData])=>{\n                if (!dataOnProgress && fragLoadedData && progressCallback) {\n                    progressCallback(fragLoadedData);\n                }\n                return fragLoadedData;\n            }).catch((error)=>this.handleFragLoadError(error));\n        }\n        this.hls.trigger(Events.FRAG_LOADING, {\n            frag,\n            targetBufferTime\n        });\n        if (this.fragCurrent === null) {\n            return Promise.reject(new Error(`frag load aborted, context changed in FRAG_LOADING`));\n        }\n        return result;\n    }\n    doFragPartsLoad(frag, fromPart, level, progressCallback) {\n        return new Promise((resolve, reject)=>{\n            var _level$details;\n            const partsLoaded = [];\n            const initialPartList = (_level$details = level.details) == null ? void 0 : _level$details.partList;\n            const loadPart = (part)=>{\n                this.fragmentLoader.loadPart(frag, part, progressCallback).then((partLoadedData)=>{\n                    partsLoaded[part.index] = partLoadedData;\n                    const loadedPart = partLoadedData.part;\n                    this.hls.trigger(Events.FRAG_LOADED, partLoadedData);\n                    const nextPart = getPartWith(level, frag.sn, part.index + 1) || findPart(initialPartList, frag.sn, part.index + 1);\n                    if (nextPart) {\n                        loadPart(nextPart);\n                    } else {\n                        return resolve({\n                            frag,\n                            part: loadedPart,\n                            partsLoaded\n                        });\n                    }\n                }).catch(reject);\n            };\n            loadPart(fromPart);\n        });\n    }\n    handleFragLoadError(error) {\n        if (\"data\" in error) {\n            const data = error.data;\n            if (error.data && data.details === ErrorDetails.INTERNAL_ABORTED) {\n                this.handleFragLoadAborted(data.frag, data.part);\n            } else {\n                this.hls.trigger(Events.ERROR, data);\n            }\n        } else {\n            this.hls.trigger(Events.ERROR, {\n                type: ErrorTypes.OTHER_ERROR,\n                details: ErrorDetails.INTERNAL_EXCEPTION,\n                err: error,\n                error,\n                fatal: true\n            });\n        }\n        return null;\n    }\n    _handleTransmuxerFlush(chunkMeta) {\n        const context = this.getCurrentContext(chunkMeta);\n        if (!context || this.state !== State.PARSING) {\n            if (!this.fragCurrent && this.state !== State.STOPPED && this.state !== State.ERROR) {\n                this.state = State.IDLE;\n            }\n            return;\n        }\n        const { frag, part, level } = context;\n        const now = self.performance.now();\n        frag.stats.parsing.end = now;\n        if (part) {\n            part.stats.parsing.end = now;\n        }\n        this.updateLevelTiming(frag, part, level, chunkMeta.partial);\n    }\n    getCurrentContext(chunkMeta) {\n        const { levels, fragCurrent } = this;\n        const { level: levelIndex, sn, part: partIndex } = chunkMeta;\n        if (!(levels != null && levels[levelIndex])) {\n            this.warn(`Levels object was unset while buffering fragment ${sn} of level ${levelIndex}. The current chunk will not be buffered.`);\n            return null;\n        }\n        const level = levels[levelIndex];\n        const part = partIndex > -1 ? getPartWith(level, sn, partIndex) : null;\n        const frag = part ? part.fragment : getFragmentWithSN(level, sn, fragCurrent);\n        if (!frag) {\n            return null;\n        }\n        if (fragCurrent && fragCurrent !== frag) {\n            frag.stats = fragCurrent.stats;\n        }\n        return {\n            frag,\n            part,\n            level\n        };\n    }\n    bufferFragmentData(data, frag, part, chunkMeta, noBacktracking) {\n        var _buffer;\n        if (!data || this.state !== State.PARSING) {\n            return;\n        }\n        const { data1, data2 } = data;\n        let buffer = data1;\n        if (data1 && data2) {\n            // Combine the moof + mdat so that we buffer with a single append\n            buffer = appendUint8Array(data1, data2);\n        }\n        if (!((_buffer = buffer) != null && _buffer.length)) {\n            return;\n        }\n        const segment = {\n            type: data.type,\n            frag,\n            part,\n            chunkMeta,\n            parent: frag.type,\n            data: buffer\n        };\n        this.hls.trigger(Events.BUFFER_APPENDING, segment);\n        if (data.dropped && data.independent && !part) {\n            if (noBacktracking) {\n                return;\n            }\n            // Clear buffer so that we reload previous segments sequentially if required\n            this.flushBufferGap(frag);\n        }\n    }\n    flushBufferGap(frag) {\n        const media = this.media;\n        if (!media) {\n            return;\n        }\n        // If currentTime is not buffered, clear the back buffer so that we can backtrack as much as needed\n        if (!BufferHelper.isBuffered(media, media.currentTime)) {\n            this.flushMainBuffer(0, frag.start);\n            return;\n        }\n        // Remove back-buffer without interrupting playback to allow back tracking\n        const currentTime = media.currentTime;\n        const bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);\n        const fragDuration = frag.duration;\n        const segmentFraction = Math.min(this.config.maxFragLookUpTolerance * 2, fragDuration * 0.25);\n        const start = Math.max(Math.min(frag.start - segmentFraction, bufferInfo.end - segmentFraction), currentTime + segmentFraction);\n        if (frag.start - start > segmentFraction) {\n            this.flushMainBuffer(start, frag.start);\n        }\n    }\n    getFwdBufferInfo(bufferable, type) {\n        const pos = this.getLoadPosition();\n        if (!isFiniteNumber(pos)) {\n            return null;\n        }\n        return this.getFwdBufferInfoAtPos(bufferable, pos, type);\n    }\n    getFwdBufferInfoAtPos(bufferable, pos, type) {\n        const { config: { maxBufferHole } } = this;\n        const bufferInfo = BufferHelper.bufferInfo(bufferable, pos, maxBufferHole);\n        // Workaround flaw in getting forward buffer when maxBufferHole is smaller than gap at current pos\n        if (bufferInfo.len === 0 && bufferInfo.nextStart !== undefined) {\n            const bufferedFragAtPos = this.fragmentTracker.getBufferedFrag(pos, type);\n            if (bufferedFragAtPos && bufferInfo.nextStart < bufferedFragAtPos.end) {\n                return BufferHelper.bufferInfo(bufferable, pos, Math.max(bufferInfo.nextStart, maxBufferHole));\n            }\n        }\n        return bufferInfo;\n    }\n    getMaxBufferLength(levelBitrate) {\n        const { config } = this;\n        let maxBufLen;\n        if (levelBitrate) {\n            maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);\n        } else {\n            maxBufLen = config.maxBufferLength;\n        }\n        return Math.min(maxBufLen, config.maxMaxBufferLength);\n    }\n    reduceMaxBufferLength(threshold) {\n        const config = this.config;\n        const minLength = threshold || config.maxBufferLength;\n        if (config.maxMaxBufferLength >= minLength) {\n            // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...\n            config.maxMaxBufferLength /= 2;\n            this.warn(`Reduce max buffer length to ${config.maxMaxBufferLength}s`);\n            return true;\n        }\n        return false;\n    }\n    getAppendedFrag(position, playlistType = PlaylistLevelType.MAIN) {\n        const fragOrPart = this.fragmentTracker.getAppendedFrag(position, PlaylistLevelType.MAIN);\n        if (fragOrPart && \"fragment\" in fragOrPart) {\n            return fragOrPart.fragment;\n        }\n        return fragOrPart;\n    }\n    getNextFragment(pos, levelDetails) {\n        const fragments = levelDetails.fragments;\n        const fragLen = fragments.length;\n        if (!fragLen) {\n            return null;\n        }\n        // find fragment index, contiguous with end of buffer position\n        const { config } = this;\n        const start = fragments[0].start;\n        let frag;\n        if (levelDetails.live) {\n            const initialLiveManifestSize = config.initialLiveManifestSize;\n            if (fragLen < initialLiveManifestSize) {\n                this.warn(`Not enough fragments to start playback (have: ${fragLen}, need: ${initialLiveManifestSize})`);\n                return null;\n            }\n            // The real fragment start times for a live stream are only known after the PTS range for that level is known.\n            // In order to discover the range, we load the best matching fragment for that level and demux it.\n            // Do not load using live logic if the starting frag is requested - we want to use getFragmentAtPosition() so that\n            // we get the fragment matching that start time\n            if (!levelDetails.PTSKnown && !this.startFragRequested && this.startPosition === -1 || pos < start) {\n                frag = this.getInitialLiveFragment(levelDetails, fragments);\n                this.startPosition = this.nextLoadPosition = frag ? this.hls.liveSyncPosition || frag.start : pos;\n            }\n        } else if (pos <= start) {\n            // VoD playlist: if loadPosition before start of playlist, load first fragment\n            frag = fragments[0];\n        }\n        // If we haven't run into any special cases already, just load the fragment most closely matching the requested position\n        if (!frag) {\n            const end = config.lowLatencyMode ? levelDetails.partEnd : levelDetails.fragmentEnd;\n            frag = this.getFragmentAtPosition(pos, end, levelDetails);\n        }\n        return this.mapToInitFragWhenRequired(frag);\n    }\n    isLoopLoading(frag, targetBufferTime) {\n        const trackerState = this.fragmentTracker.getState(frag);\n        return (trackerState === FragmentState.OK || trackerState === FragmentState.PARTIAL && !!frag.gap) && this.nextLoadPosition > targetBufferTime;\n    }\n    getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, playlistType, maxBufLen) {\n        const gapStart = frag.gap;\n        const nextFragment = this.getNextFragment(this.nextLoadPosition, levelDetails);\n        if (nextFragment === null) {\n            return nextFragment;\n        }\n        frag = nextFragment;\n        if (gapStart && frag && !frag.gap && bufferInfo.nextStart) {\n            // Media buffered after GAP tags should not make the next buffer timerange exceed forward buffer length\n            const nextbufferInfo = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, bufferInfo.nextStart, playlistType);\n            if (nextbufferInfo !== null && bufferInfo.len + nextbufferInfo.len >= maxBufLen) {\n                // Returning here might result in not finding an audio and video candiate to skip to\n                this.log(`buffer full after gaps in \"${playlistType}\" playlist starting at sn: ${frag.sn}`);\n                return null;\n            }\n        }\n        return frag;\n    }\n    mapToInitFragWhenRequired(frag) {\n        // If an initSegment is present, it must be buffered first\n        if (frag != null && frag.initSegment && !(frag != null && frag.initSegment.data) && !this.bitrateTest) {\n            return frag.initSegment;\n        }\n        return frag;\n    }\n    getNextPart(partList, frag, targetBufferTime) {\n        let nextPart = -1;\n        let contiguous = false;\n        let independentAttrOmitted = true;\n        for(let i = 0, len = partList.length; i < len; i++){\n            const part = partList[i];\n            independentAttrOmitted = independentAttrOmitted && !part.independent;\n            if (nextPart > -1 && targetBufferTime < part.start) {\n                break;\n            }\n            const loaded = part.loaded;\n            if (loaded) {\n                nextPart = -1;\n            } else if ((contiguous || part.independent || independentAttrOmitted) && part.fragment === frag) {\n                nextPart = i;\n            }\n            contiguous = loaded;\n        }\n        return nextPart;\n    }\n    loadedEndOfParts(partList, targetBufferTime) {\n        const lastPart = partList[partList.length - 1];\n        return lastPart && targetBufferTime > lastPart.start && lastPart.loaded;\n    }\n    /*\n   This method is used find the best matching first fragment for a live playlist. This fragment is used to calculate the\n   \"sliding\" of the playlist, which is its offset from the start of playback. After sliding we can compute the real\n   start and end times for each fragment in the playlist (after which this method will not need to be called).\n  */ getInitialLiveFragment(levelDetails, fragments) {\n        const fragPrevious = this.fragPrevious;\n        let frag = null;\n        if (fragPrevious) {\n            if (levelDetails.hasProgramDateTime) {\n                // Prefer using PDT, because it can be accurate enough to choose the correct fragment without knowing the level sliding\n                this.log(`Live playlist, switching playlist, load frag with same PDT: ${fragPrevious.programDateTime}`);\n                frag = findFragmentByPDT(fragments, fragPrevious.endProgramDateTime, this.config.maxFragLookUpTolerance);\n            }\n            if (!frag) {\n                // SN does not need to be accurate between renditions, but depending on the packaging it may be so.\n                const targetSN = fragPrevious.sn + 1;\n                if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {\n                    const fragNext = fragments[targetSN - levelDetails.startSN];\n                    // Ensure that we're staying within the continuity range, since PTS resets upon a new range\n                    if (fragPrevious.cc === fragNext.cc) {\n                        frag = fragNext;\n                        this.log(`Live playlist, switching playlist, load frag with next SN: ${frag.sn}`);\n                    }\n                }\n                // It's important to stay within the continuity range if available; otherwise the fragments in the playlist\n                // will have the wrong start times\n                if (!frag) {\n                    frag = findFragWithCC(fragments, fragPrevious.cc);\n                    if (frag) {\n                        this.log(`Live playlist, switching playlist, load frag with same CC: ${frag.sn}`);\n                    }\n                }\n            }\n        } else {\n            // Find a new start fragment when fragPrevious is null\n            const liveStart = this.hls.liveSyncPosition;\n            if (liveStart !== null) {\n                frag = this.getFragmentAtPosition(liveStart, this.bitrateTest ? levelDetails.fragmentEnd : levelDetails.edge, levelDetails);\n            }\n        }\n        return frag;\n    }\n    /*\n  This method finds the best matching fragment given the provided position.\n   */ getFragmentAtPosition(bufferEnd, end, levelDetails) {\n        const { config } = this;\n        let { fragPrevious } = this;\n        let { fragments, endSN } = levelDetails;\n        const { fragmentHint } = levelDetails;\n        const tolerance = config.maxFragLookUpTolerance;\n        const partList = levelDetails.partList;\n        const loadingParts = !!(config.lowLatencyMode && partList != null && partList.length && fragmentHint);\n        if (loadingParts && fragmentHint && !this.bitrateTest) {\n            // Include incomplete fragment with parts at end\n            fragments = fragments.concat(fragmentHint);\n            endSN = fragmentHint.sn;\n        }\n        let frag;\n        if (bufferEnd < end) {\n            const lookupTolerance = bufferEnd > end - tolerance ? 0 : tolerance;\n            // Remove the tolerance if it would put the bufferEnd past the actual end of stream\n            // Uses buffer and sequence number to calculate switch segment (required if using EXT-X-DISCONTINUITY-SEQUENCE)\n            frag = findFragmentByPTS(fragPrevious, fragments, bufferEnd, lookupTolerance);\n        } else {\n            // reach end of playlist\n            frag = fragments[fragments.length - 1];\n        }\n        if (frag) {\n            const curSNIdx = frag.sn - levelDetails.startSN;\n            // Move fragPrevious forward to support forcing the next fragment to load\n            // when the buffer catches up to a previously buffered range.\n            const fragState = this.fragmentTracker.getState(frag);\n            if (fragState === FragmentState.OK || fragState === FragmentState.PARTIAL && frag.gap) {\n                fragPrevious = frag;\n            }\n            if (fragPrevious && frag.sn === fragPrevious.sn && (!loadingParts || partList[0].fragment.sn > frag.sn)) {\n                // Force the next fragment to load if the previous one was already selected. This can occasionally happen with\n                // non-uniform fragment durations\n                const sameLevel = fragPrevious && frag.level === fragPrevious.level;\n                if (sameLevel) {\n                    const nextFrag = fragments[curSNIdx + 1];\n                    if (frag.sn < endSN && this.fragmentTracker.getState(nextFrag) !== FragmentState.OK) {\n                        frag = nextFrag;\n                    } else {\n                        frag = null;\n                    }\n                }\n            }\n        }\n        return frag;\n    }\n    synchronizeToLiveEdge(levelDetails) {\n        const { config, media } = this;\n        if (!media) {\n            return;\n        }\n        const liveSyncPosition = this.hls.liveSyncPosition;\n        const currentTime = media.currentTime;\n        const start = levelDetails.fragments[0].start;\n        const end = levelDetails.edge;\n        const withinSlidingWindow = currentTime >= start - config.maxFragLookUpTolerance && currentTime <= end;\n        // Continue if we can seek forward to sync position or if current time is outside of sliding window\n        if (liveSyncPosition !== null && media.duration > liveSyncPosition && (currentTime < liveSyncPosition || !withinSlidingWindow)) {\n            // Continue if buffer is starving or if current time is behind max latency\n            const maxLatency = config.liveMaxLatencyDuration !== undefined ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;\n            if (!withinSlidingWindow && media.readyState < 4 || currentTime < end - maxLatency) {\n                if (!this.loadedmetadata) {\n                    this.nextLoadPosition = liveSyncPosition;\n                }\n                // Only seek if ready and there is not a significant forward buffer available for playback\n                if (media.readyState) {\n                    this.warn(`Playback: ${currentTime.toFixed(3)} is located too far from the end of live sliding playlist: ${end}, reset currentTime to : ${liveSyncPosition.toFixed(3)}`);\n                    media.currentTime = liveSyncPosition;\n                }\n            }\n        }\n    }\n    alignPlaylists(details, previousDetails, switchDetails) {\n        // FIXME: If not for `shouldAlignOnDiscontinuities` requiring fragPrevious.cc,\n        //  this could all go in level-helper mergeDetails()\n        const length = details.fragments.length;\n        if (!length) {\n            this.warn(`No fragments in live playlist`);\n            return 0;\n        }\n        const slidingStart = details.fragments[0].start;\n        const firstLevelLoad = !previousDetails;\n        const aligned = details.alignedSliding && isFiniteNumber(slidingStart);\n        if (firstLevelLoad || !aligned && !slidingStart) {\n            const { fragPrevious } = this;\n            alignStream(fragPrevious, switchDetails, details);\n            const alignedSlidingStart = details.fragments[0].start;\n            this.log(`Live playlist sliding: ${alignedSlidingStart.toFixed(2)} start-sn: ${previousDetails ? previousDetails.startSN : \"na\"}->${details.startSN} prev-sn: ${fragPrevious ? fragPrevious.sn : \"na\"} fragments: ${length}`);\n            return alignedSlidingStart;\n        }\n        return slidingStart;\n    }\n    waitForCdnTuneIn(details) {\n        // Wait for Low-Latency CDN Tune-in to get an updated playlist\n        const advancePartLimit = 3;\n        return details.live && details.canBlockReload && details.partTarget && details.tuneInGoal > Math.max(details.partHoldBack, details.partTarget * advancePartLimit);\n    }\n    setStartPosition(details, sliding) {\n        // compute start position if set to -1. use it straight away if value is defined\n        let startPosition = this.startPosition;\n        if (startPosition < sliding) {\n            startPosition = -1;\n        }\n        if (startPosition === -1 || this.lastCurrentTime === -1) {\n            // Use Playlist EXT-X-START:TIME-OFFSET when set\n            // Prioritize Multivariant Playlist offset so that main, audio, and subtitle stream-controller start times match\n            const offsetInMultivariantPlaylist = this.startTimeOffset !== null;\n            const startTimeOffset = offsetInMultivariantPlaylist ? this.startTimeOffset : details.startTimeOffset;\n            if (startTimeOffset !== null && isFiniteNumber(startTimeOffset)) {\n                startPosition = sliding + startTimeOffset;\n                if (startTimeOffset < 0) {\n                    startPosition += details.totalduration;\n                }\n                startPosition = Math.min(Math.max(sliding, startPosition), sliding + details.totalduration);\n                this.log(`Start time offset ${startTimeOffset} found in ${offsetInMultivariantPlaylist ? \"multivariant\" : \"media\"} playlist, adjust startPosition to ${startPosition}`);\n                this.startPosition = startPosition;\n            } else if (details.live) {\n                // Leave this.startPosition at -1, so that we can use `getInitialLiveFragment` logic when startPosition has\n                // not been specified via the config or an as an argument to startLoad (#3736).\n                startPosition = this.hls.liveSyncPosition || sliding;\n            } else {\n                this.startPosition = startPosition = 0;\n            }\n            this.lastCurrentTime = startPosition;\n        }\n        this.nextLoadPosition = startPosition;\n    }\n    getLoadPosition() {\n        const { media } = this;\n        // if we have not yet loaded any fragment, start loading from start position\n        let pos = 0;\n        if (this.loadedmetadata && media) {\n            pos = media.currentTime;\n        } else if (this.nextLoadPosition) {\n            pos = this.nextLoadPosition;\n        }\n        return pos;\n    }\n    handleFragLoadAborted(frag, part) {\n        if (this.transmuxer && frag.sn !== \"initSegment\" && frag.stats.aborted) {\n            this.warn(`Fragment ${frag.sn}${part ? \" part \" + part.index : \"\"} of level ${frag.level} was aborted`);\n            this.resetFragmentLoading(frag);\n        }\n    }\n    resetFragmentLoading(frag) {\n        if (!this.fragCurrent || !this.fragContextChanged(frag) && this.state !== State.FRAG_LOADING_WAITING_RETRY) {\n            this.state = State.IDLE;\n        }\n    }\n    onFragmentOrKeyLoadError(filterType, data) {\n        if (data.chunkMeta && !data.frag) {\n            const context = this.getCurrentContext(data.chunkMeta);\n            if (context) {\n                data.frag = context.frag;\n            }\n        }\n        const frag = data.frag;\n        // Handle frag error related to caller's filterType\n        if (!frag || frag.type !== filterType || !this.levels) {\n            return;\n        }\n        if (this.fragContextChanged(frag)) {\n            var _this$fragCurrent2;\n            this.warn(`Frag load error must match current frag to retry ${frag.url} > ${(_this$fragCurrent2 = this.fragCurrent) == null ? void 0 : _this$fragCurrent2.url}`);\n            return;\n        }\n        const gapTagEncountered = data.details === ErrorDetails.FRAG_GAP;\n        if (gapTagEncountered) {\n            this.fragmentTracker.fragBuffered(frag, true);\n        }\n        // keep retrying until the limit will be reached\n        const errorAction = data.errorAction;\n        const { action, retryCount = 0, retryConfig } = errorAction || {};\n        if (errorAction && action === NetworkErrorAction.RetryRequest && retryConfig) {\n            this.resetStartWhenNotLoaded(this.levelLastLoaded);\n            const delay = getRetryDelay(retryConfig, retryCount);\n            this.warn(`Fragment ${frag.sn} of ${filterType} ${frag.level} errored with ${data.details}, retrying loading ${retryCount + 1}/${retryConfig.maxNumRetry} in ${delay}ms`);\n            errorAction.resolved = true;\n            this.retryDate = self.performance.now() + delay;\n            this.state = State.FRAG_LOADING_WAITING_RETRY;\n        } else if (retryConfig && errorAction) {\n            this.resetFragmentErrors(filterType);\n            if (retryCount < retryConfig.maxNumRetry) {\n                // Network retry is skipped when level switch is preferred\n                if (!gapTagEncountered && action !== NetworkErrorAction.RemoveAlternatePermanently) {\n                    errorAction.resolved = true;\n                }\n            } else {\n                logger.warn(`${data.details} reached or exceeded max retry (${retryCount})`);\n                return;\n            }\n        } else if ((errorAction == null ? void 0 : errorAction.action) === NetworkErrorAction.SendAlternateToPenaltyBox) {\n            this.state = State.WAITING_LEVEL;\n        } else {\n            this.state = State.ERROR;\n        }\n        // Perform next async tick sooner to speed up error action resolution\n        this.tickImmediate();\n    }\n    reduceLengthAndFlushBuffer(data) {\n        // if in appending state\n        if (this.state === State.PARSING || this.state === State.PARSED) {\n            const playlistType = data.parent;\n            const bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);\n            // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end\n            // reduce max buf len if current position is buffered\n            const buffered = bufferedInfo && bufferedInfo.len > 0.5;\n            if (buffered) {\n                this.reduceMaxBufferLength(bufferedInfo.len);\n            }\n            const flushBuffer = !buffered;\n            if (flushBuffer) {\n                // current position is not buffered, but browser is still complaining about buffer full error\n                // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708\n                // in that case flush the whole audio buffer to recover\n                this.warn(`Buffer full error while media.currentTime is not buffered, flush ${playlistType} buffer`);\n            }\n            if (data.frag) {\n                this.fragmentTracker.removeFragment(data.frag);\n                this.nextLoadPosition = data.frag.start;\n            }\n            this.resetLoadingState();\n            return flushBuffer;\n        }\n        return false;\n    }\n    resetFragmentErrors(filterType) {\n        if (filterType === PlaylistLevelType.AUDIO) {\n            // Reset current fragment since audio track audio is essential and may not have a fail-over track\n            this.fragCurrent = null;\n        }\n        // Fragment errors that result in a level switch or redundant fail-over\n        // should reset the stream controller state to idle\n        if (!this.loadedmetadata) {\n            this.startFragRequested = false;\n        }\n        if (this.state !== State.STOPPED) {\n            this.state = State.IDLE;\n        }\n    }\n    afterBufferFlushed(media, bufferType, playlistType) {\n        if (!media) {\n            return;\n        }\n        // After successful buffer flushing, filter flushed fragments from bufferedFrags use mediaBuffered instead of media\n        // (so that we will check against video.buffered ranges in case of alt audio track)\n        const bufferedTimeRanges = BufferHelper.getBuffered(media);\n        this.fragmentTracker.detectEvictedFragments(bufferType, bufferedTimeRanges, playlistType);\n        if (this.state === State.ENDED) {\n            this.resetLoadingState();\n        }\n    }\n    resetLoadingState() {\n        this.log(\"Reset loading state\");\n        this.fragCurrent = null;\n        this.fragPrevious = null;\n        this.state = State.IDLE;\n    }\n    resetStartWhenNotLoaded(level) {\n        // if loadedmetadata is not set, it means that first frag request failed\n        // in that case, reset startFragRequested flag\n        if (!this.loadedmetadata) {\n            this.startFragRequested = false;\n            const details = level ? level.details : null;\n            if (details != null && details.live) {\n                // Update the start position and return to IDLE to recover live start\n                this.startPosition = -1;\n                this.setStartPosition(details, 0);\n                this.resetLoadingState();\n            } else {\n                this.nextLoadPosition = this.startPosition;\n            }\n        }\n    }\n    resetWhenMissingContext(chunkMeta) {\n        this.warn(`The loading context changed while buffering fragment ${chunkMeta.sn} of level ${chunkMeta.level}. This chunk will not be buffered.`);\n        this.removeUnbufferedFrags();\n        this.resetStartWhenNotLoaded(this.levelLastLoaded);\n        this.resetLoadingState();\n    }\n    removeUnbufferedFrags(start = 0) {\n        this.fragmentTracker.removeFragmentsInRange(start, Infinity, this.playlistType, false, true);\n    }\n    updateLevelTiming(frag, part, level, partial) {\n        var _this$transmuxer;\n        const details = level.details;\n        if (!details) {\n            this.warn(\"level.details undefined\");\n            return;\n        }\n        const parsed = Object.keys(frag.elementaryStreams).reduce((result, type)=>{\n            const info = frag.elementaryStreams[type];\n            if (info) {\n                const parsedDuration = info.endPTS - info.startPTS;\n                if (parsedDuration <= 0) {\n                    // Destroy the transmuxer after it's next time offset failed to advance because duration was <= 0.\n                    // The new transmuxer will be configured with a time offset matching the next fragment start,\n                    // preventing the timeline from shifting.\n                    this.warn(`Could not parse fragment ${frag.sn} ${type} duration reliably (${parsedDuration})`);\n                    return result || false;\n                }\n                const drift = partial ? 0 : updateFragPTSDTS(details, frag, info.startPTS, info.endPTS, info.startDTS, info.endDTS);\n                this.hls.trigger(Events.LEVEL_PTS_UPDATED, {\n                    details,\n                    level,\n                    drift,\n                    type,\n                    frag,\n                    start: info.startPTS,\n                    end: info.endPTS\n                });\n                return true;\n            }\n            return result;\n        }, false);\n        if (!parsed && ((_this$transmuxer = this.transmuxer) == null ? void 0 : _this$transmuxer.error) === null) {\n            const error = new Error(`Found no media in fragment ${frag.sn} of level ${frag.level} resetting transmuxer to fallback to playlist timing`);\n            if (level.fragmentError === 0) {\n                // Mark and track the odd empty segment as a gap to avoid reloading\n                level.fragmentError++;\n                frag.gap = true;\n                this.fragmentTracker.removeFragment(frag);\n                this.fragmentTracker.fragBuffered(frag, true);\n            }\n            this.warn(error.message);\n            this.hls.trigger(Events.ERROR, {\n                type: ErrorTypes.MEDIA_ERROR,\n                details: ErrorDetails.FRAG_PARSING_ERROR,\n                fatal: false,\n                error,\n                frag,\n                reason: `Found no media in msn ${frag.sn} of level \"${level.url}\"`\n            });\n            if (!this.hls) {\n                return;\n            }\n            this.resetTransmuxer();\n        // For this error fallthrough. Marking parsed will allow advancing to next fragment.\n        }\n        this.state = State.PARSED;\n        this.hls.trigger(Events.FRAG_PARSED, {\n            frag,\n            part\n        });\n    }\n    resetTransmuxer() {\n        if (this.transmuxer) {\n            this.transmuxer.destroy();\n            this.transmuxer = null;\n        }\n    }\n    recoverWorkerError(data) {\n        if (data.event === \"demuxerWorker\") {\n            this.fragmentTracker.removeAllFragments();\n            this.resetTransmuxer();\n            this.resetStartWhenNotLoaded(this.levelLastLoaded);\n            this.resetLoadingState();\n        }\n    }\n    set state(nextState) {\n        const previousState = this._state;\n        if (previousState !== nextState) {\n            this._state = nextState;\n            this.log(`${previousState}->${nextState}`);\n        }\n    }\n    get state() {\n        return this._state;\n    }\n}\nclass ChunkCache {\n    constructor(){\n        this.chunks = [];\n        this.dataLength = 0;\n    }\n    push(chunk) {\n        this.chunks.push(chunk);\n        this.dataLength += chunk.length;\n    }\n    flush() {\n        const { chunks, dataLength } = this;\n        let result;\n        if (!chunks.length) {\n            return new Uint8Array(0);\n        } else if (chunks.length === 1) {\n            result = chunks[0];\n        } else {\n            result = concatUint8Arrays(chunks, dataLength);\n        }\n        this.reset();\n        return result;\n    }\n    reset() {\n        this.chunks.length = 0;\n        this.dataLength = 0;\n    }\n}\nfunction concatUint8Arrays(chunks, dataLength) {\n    const result = new Uint8Array(dataLength);\n    let offset = 0;\n    for(let i = 0; i < chunks.length; i++){\n        const chunk = chunks[i];\n        result.set(chunk, offset);\n        offset += chunk.length;\n    }\n    return result;\n}\n// ensure the worker ends up in the bundle\n// If the worker should not be included this gets aliased to empty.js\nfunction hasUMDWorker() {\n    return typeof __HLS_WORKER_BUNDLE__ === \"function\";\n}\nfunction injectWorker() {\n    const blob = new self.Blob([\n        `var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(${__HLS_WORKER_BUNDLE__.toString()})(true);`\n    ], {\n        type: \"text/javascript\"\n    });\n    const objectURL = self.URL.createObjectURL(blob);\n    const worker = new self.Worker(objectURL);\n    return {\n        worker,\n        objectURL\n    };\n}\nfunction loadWorker(path) {\n    const scriptURL = new self.URL(path, self.location.href).href;\n    const worker = new self.Worker(scriptURL);\n    return {\n        worker,\n        scriptURL\n    };\n}\nfunction dummyTrack(type = \"\", inputTimeScale = 90000) {\n    return {\n        type,\n        id: -1,\n        pid: -1,\n        inputTimeScale,\n        sequenceNumber: -1,\n        samples: [],\n        dropped: 0\n    };\n}\nclass BaseAudioDemuxer {\n    constructor(){\n        this._audioTrack = void 0;\n        this._id3Track = void 0;\n        this.frameIndex = 0;\n        this.cachedData = null;\n        this.basePTS = null;\n        this.initPTS = null;\n        this.lastPTS = null;\n    }\n    resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n        this._id3Track = {\n            type: \"id3\",\n            id: 3,\n            pid: -1,\n            inputTimeScale: 90000,\n            sequenceNumber: 0,\n            samples: [],\n            dropped: 0\n        };\n    }\n    resetTimeStamp(deaultTimestamp) {\n        this.initPTS = deaultTimestamp;\n        this.resetContiguity();\n    }\n    resetContiguity() {\n        this.basePTS = null;\n        this.lastPTS = null;\n        this.frameIndex = 0;\n    }\n    canParse(data, offset) {\n        return false;\n    }\n    appendFrame(track, data, offset) {}\n    // feed incoming data to the front of the parsing pipeline\n    demux(data, timeOffset) {\n        if (this.cachedData) {\n            data = appendUint8Array(this.cachedData, data);\n            this.cachedData = null;\n        }\n        let id3Data = getID3Data(data, 0);\n        let offset = id3Data ? id3Data.length : 0;\n        let lastDataIndex;\n        const track = this._audioTrack;\n        const id3Track = this._id3Track;\n        const timestamp = id3Data ? getTimeStamp(id3Data) : undefined;\n        const length = data.length;\n        if (this.basePTS === null || this.frameIndex === 0 && isFiniteNumber(timestamp)) {\n            this.basePTS = initPTSFn(timestamp, timeOffset, this.initPTS);\n            this.lastPTS = this.basePTS;\n        }\n        if (this.lastPTS === null) {\n            this.lastPTS = this.basePTS;\n        }\n        // more expressive than alternative: id3Data?.length\n        if (id3Data && id3Data.length > 0) {\n            id3Track.samples.push({\n                pts: this.lastPTS,\n                dts: this.lastPTS,\n                data: id3Data,\n                type: MetadataSchema.audioId3,\n                duration: Number.POSITIVE_INFINITY\n            });\n        }\n        while(offset < length){\n            if (this.canParse(data, offset)) {\n                const frame = this.appendFrame(track, data, offset);\n                if (frame) {\n                    this.frameIndex++;\n                    this.lastPTS = frame.sample.pts;\n                    offset += frame.length;\n                    lastDataIndex = offset;\n                } else {\n                    offset = length;\n                }\n            } else if (canParse$2(data, offset)) {\n                // after a ID3.canParse, a call to ID3.getID3Data *should* always returns some data\n                id3Data = getID3Data(data, offset);\n                id3Track.samples.push({\n                    pts: this.lastPTS,\n                    dts: this.lastPTS,\n                    data: id3Data,\n                    type: MetadataSchema.audioId3,\n                    duration: Number.POSITIVE_INFINITY\n                });\n                offset += id3Data.length;\n                lastDataIndex = offset;\n            } else {\n                offset++;\n            }\n            if (offset === length && lastDataIndex !== length) {\n                const partialData = sliceUint8(data, lastDataIndex);\n                if (this.cachedData) {\n                    this.cachedData = appendUint8Array(this.cachedData, partialData);\n                } else {\n                    this.cachedData = partialData;\n                }\n            }\n        }\n        return {\n            audioTrack: track,\n            videoTrack: dummyTrack(),\n            id3Track,\n            textTrack: dummyTrack()\n        };\n    }\n    demuxSampleAes(data, keyData, timeOffset) {\n        return Promise.reject(new Error(`[${this}] This demuxer does not support Sample-AES decryption`));\n    }\n    flush(timeOffset) {\n        // Parse cache in case of remaining frames.\n        const cachedData = this.cachedData;\n        if (cachedData) {\n            this.cachedData = null;\n            this.demux(cachedData, 0);\n        }\n        return {\n            audioTrack: this._audioTrack,\n            videoTrack: dummyTrack(),\n            id3Track: this._id3Track,\n            textTrack: dummyTrack()\n        };\n    }\n    destroy() {}\n}\n/**\n * Initialize PTS\n * <p>\n *    use timestamp unless it is undefined, NaN or Infinity\n * </p>\n */ const initPTSFn = (timestamp, timeOffset, initPTS)=>{\n    if (isFiniteNumber(timestamp)) {\n        return timestamp * 90;\n    }\n    const init90kHz = initPTS ? initPTS.baseTime * 90000 / initPTS.timescale : 0;\n    return timeOffset * 90000 + init90kHz;\n};\n/**\n * ADTS parser helper\n * @link https://wiki.multimedia.cx/index.php?title=ADTS\n */ function getAudioConfig(observer, data, offset, audioCodec) {\n    let adtsObjectType;\n    let adtsExtensionSamplingIndex;\n    let adtsChannelConfig;\n    let config;\n    const userAgent = navigator.userAgent.toLowerCase();\n    const manifestCodec = audioCodec;\n    const adtsSamplingRates = [\n        96000,\n        88200,\n        64000,\n        48000,\n        44100,\n        32000,\n        24000,\n        22050,\n        16000,\n        12000,\n        11025,\n        8000,\n        7350\n    ];\n    // byte 2\n    adtsObjectType = ((data[offset + 2] & 0xc0) >>> 6) + 1;\n    const adtsSamplingIndex = (data[offset + 2] & 0x3c) >>> 2;\n    if (adtsSamplingIndex > adtsSamplingRates.length - 1) {\n        const error = new Error(`invalid ADTS sampling index:${adtsSamplingIndex}`);\n        observer.emit(Events.ERROR, Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.FRAG_PARSING_ERROR,\n            fatal: true,\n            error,\n            reason: error.message\n        });\n        return;\n    }\n    adtsChannelConfig = (data[offset + 2] & 0x01) << 2;\n    // byte 3\n    adtsChannelConfig |= (data[offset + 3] & 0xc0) >>> 6;\n    logger.log(`manifest codec:${audioCodec}, ADTS type:${adtsObjectType}, samplingIndex:${adtsSamplingIndex}`);\n    // firefox: freq less than 24kHz = AAC SBR (HE-AAC)\n    if (/firefox/i.test(userAgent)) {\n        if (adtsSamplingIndex >= 6) {\n            adtsObjectType = 5;\n            config = new Array(4);\n            // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n            // there is a factor 2 between frame sample rate and output sample rate\n            // multiply frequency by 2 (see table below, equivalent to substract 3)\n            adtsExtensionSamplingIndex = adtsSamplingIndex - 3;\n        } else {\n            adtsObjectType = 2;\n            config = new Array(2);\n            adtsExtensionSamplingIndex = adtsSamplingIndex;\n        }\n    // Android : always use AAC\n    } else if (userAgent.indexOf(\"android\") !== -1) {\n        adtsObjectType = 2;\n        config = new Array(2);\n        adtsExtensionSamplingIndex = adtsSamplingIndex;\n    } else {\n        /*  for other browsers (Chrome/Vivaldi/Opera ...)\n        always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)\n    */ adtsObjectType = 5;\n        config = new Array(4);\n        // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)\n        if (audioCodec && (audioCodec.indexOf(\"mp4a.40.29\") !== -1 || audioCodec.indexOf(\"mp4a.40.5\") !== -1) || !audioCodec && adtsSamplingIndex >= 6) {\n            // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n            // there is a factor 2 between frame sample rate and output sample rate\n            // multiply frequency by 2 (see table below, equivalent to substract 3)\n            adtsExtensionSamplingIndex = adtsSamplingIndex - 3;\n        } else {\n            // if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1) OR (manifest codec not specified and mono audio)\n            // Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.  This is not a problem with stereo.\n            if (audioCodec && audioCodec.indexOf(\"mp4a.40.2\") !== -1 && (adtsSamplingIndex >= 6 && adtsChannelConfig === 1 || /vivaldi/i.test(userAgent)) || !audioCodec && adtsChannelConfig === 1) {\n                adtsObjectType = 2;\n                config = new Array(2);\n            }\n            adtsExtensionSamplingIndex = adtsSamplingIndex;\n        }\n    }\n    /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config\n      ISO 14496-3 (AAC).pdf - Table 1.13  Syntax of AudioSpecificConfig()\n    Audio Profile / Audio Object Type\n    0: Null\n    1: AAC Main\n    2: AAC LC (Low Complexity)\n    3: AAC SSR (Scalable Sample Rate)\n    4: AAC LTP (Long Term Prediction)\n    5: SBR (Spectral Band Replication)\n    6: AAC Scalable\n   sampling freq\n    0: 96000 Hz\n    1: 88200 Hz\n    2: 64000 Hz\n    3: 48000 Hz\n    4: 44100 Hz\n    5: 32000 Hz\n    6: 24000 Hz\n    7: 22050 Hz\n    8: 16000 Hz\n    9: 12000 Hz\n    10: 11025 Hz\n    11: 8000 Hz\n    12: 7350 Hz\n    13: Reserved\n    14: Reserved\n    15: frequency is written explictly\n    Channel Configurations\n    These are the channel configurations:\n    0: Defined in AOT Specifc Config\n    1: 1 channel: front-center\n    2: 2 channels: front-left, front-right\n  */ // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1\n    config[0] = adtsObjectType << 3;\n    // samplingFrequencyIndex\n    config[0] |= (adtsSamplingIndex & 0x0e) >> 1;\n    config[1] |= (adtsSamplingIndex & 0x01) << 7;\n    // channelConfiguration\n    config[1] |= adtsChannelConfig << 3;\n    if (adtsObjectType === 5) {\n        // adtsExtensionSamplingIndex\n        config[1] |= (adtsExtensionSamplingIndex & 0x0e) >> 1;\n        config[2] = (adtsExtensionSamplingIndex & 0x01) << 7;\n        // adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???\n        //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc\n        config[2] |= 2 << 2;\n        config[3] = 0;\n    }\n    return {\n        config,\n        samplerate: adtsSamplingRates[adtsSamplingIndex],\n        channelCount: adtsChannelConfig,\n        codec: \"mp4a.40.\" + adtsObjectType,\n        manifestCodec\n    };\n}\nfunction isHeaderPattern$1(data, offset) {\n    return data[offset] === 0xff && (data[offset + 1] & 0xf6) === 0xf0;\n}\nfunction getHeaderLength(data, offset) {\n    return data[offset + 1] & 0x01 ? 7 : 9;\n}\nfunction getFullFrameLength(data, offset) {\n    return (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xe0) >>> 5;\n}\nfunction canGetFrameLength(data, offset) {\n    return offset + 5 < data.length;\n}\nfunction isHeader$1(data, offset) {\n    // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1\n    // Layer bits (position 14 and 15) in header should be always 0 for ADTS\n    // More info https://wiki.multimedia.cx/index.php?title=ADTS\n    return offset + 1 < data.length && isHeaderPattern$1(data, offset);\n}\nfunction canParse$1(data, offset) {\n    return canGetFrameLength(data, offset) && isHeaderPattern$1(data, offset) && getFullFrameLength(data, offset) <= data.length - offset;\n}\nfunction probe$1(data, offset) {\n    // same as isHeader but we also check that ADTS frame follows last ADTS frame\n    // or end of data is reached\n    if (isHeader$1(data, offset)) {\n        // ADTS header Length\n        const headerLength = getHeaderLength(data, offset);\n        if (offset + headerLength >= data.length) {\n            return false;\n        }\n        // ADTS frame Length\n        const frameLength = getFullFrameLength(data, offset);\n        if (frameLength <= headerLength) {\n            return false;\n        }\n        const newOffset = offset + frameLength;\n        return newOffset === data.length || isHeader$1(data, newOffset);\n    }\n    return false;\n}\nfunction initTrackConfig(track, observer, data, offset, audioCodec) {\n    if (!track.samplerate) {\n        const config = getAudioConfig(observer, data, offset, audioCodec);\n        if (!config) {\n            return;\n        }\n        track.config = config.config;\n        track.samplerate = config.samplerate;\n        track.channelCount = config.channelCount;\n        track.codec = config.codec;\n        track.manifestCodec = config.manifestCodec;\n        logger.log(`parsed codec:${track.codec}, rate:${config.samplerate}, channels:${config.channelCount}`);\n    }\n}\nfunction getFrameDuration(samplerate) {\n    return 1024 * 90000 / samplerate;\n}\nfunction parseFrameHeader(data, offset) {\n    // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header\n    const headerLength = getHeaderLength(data, offset);\n    if (offset + headerLength <= data.length) {\n        // retrieve frame size\n        const frameLength = getFullFrameLength(data, offset) - headerLength;\n        if (frameLength > 0) {\n            // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}`);\n            return {\n                headerLength,\n                frameLength\n            };\n        }\n    }\n}\nfunction appendFrame$2(track, data, offset, pts, frameIndex) {\n    const frameDuration = getFrameDuration(track.samplerate);\n    const stamp = pts + frameIndex * frameDuration;\n    const header = parseFrameHeader(data, offset);\n    let unit;\n    if (header) {\n        const { frameLength, headerLength } = header;\n        const _length = headerLength + frameLength;\n        const missing = Math.max(0, offset + _length - data.length);\n        // logger.log(`AAC frame ${frameIndex}, pts:${stamp} length@offset/total: ${frameLength}@${offset+headerLength}/${data.byteLength} missing: ${missing}`);\n        if (missing) {\n            unit = new Uint8Array(_length - headerLength);\n            unit.set(data.subarray(offset + headerLength, data.length), 0);\n        } else {\n            unit = data.subarray(offset + headerLength, offset + _length);\n        }\n        const _sample = {\n            unit,\n            pts: stamp\n        };\n        if (!missing) {\n            track.samples.push(_sample);\n        }\n        return {\n            sample: _sample,\n            length: _length,\n            missing\n        };\n    }\n    // overflow incomplete header\n    const length = data.length - offset;\n    unit = new Uint8Array(length);\n    unit.set(data.subarray(offset, data.length), 0);\n    const sample = {\n        unit,\n        pts: stamp\n    };\n    return {\n        sample,\n        length,\n        missing: -1\n    };\n}\n/**\n *  MPEG parser helper\n */ let chromeVersion$1 = null;\nconst BitratesMap = [\n    32,\n    64,\n    96,\n    128,\n    160,\n    192,\n    224,\n    256,\n    288,\n    320,\n    352,\n    384,\n    416,\n    448,\n    32,\n    48,\n    56,\n    64,\n    80,\n    96,\n    112,\n    128,\n    160,\n    192,\n    224,\n    256,\n    320,\n    384,\n    32,\n    40,\n    48,\n    56,\n    64,\n    80,\n    96,\n    112,\n    128,\n    160,\n    192,\n    224,\n    256,\n    320,\n    32,\n    48,\n    56,\n    64,\n    80,\n    96,\n    112,\n    128,\n    144,\n    160,\n    176,\n    192,\n    224,\n    256,\n    8,\n    16,\n    24,\n    32,\n    40,\n    48,\n    56,\n    64,\n    80,\n    96,\n    112,\n    128,\n    144,\n    160\n];\nconst SamplingRateMap = [\n    44100,\n    48000,\n    32000,\n    22050,\n    24000,\n    16000,\n    11025,\n    12000,\n    8000\n];\nconst SamplesCoefficients = [\n    // MPEG 2.5\n    [\n        0,\n        // Reserved\n        72,\n        // Layer3\n        144,\n        // Layer2\n        12 // Layer1\n    ],\n    // Reserved\n    [\n        0,\n        // Reserved\n        0,\n        // Layer3\n        0,\n        // Layer2\n        0 // Layer1\n    ],\n    // MPEG 2\n    [\n        0,\n        // Reserved\n        72,\n        // Layer3\n        144,\n        // Layer2\n        12 // Layer1\n    ],\n    // MPEG 1\n    [\n        0,\n        // Reserved\n        144,\n        // Layer3\n        144,\n        // Layer2\n        12 // Layer1\n    ]\n];\nconst BytesInSlot = [\n    0,\n    // Reserved\n    1,\n    // Layer3\n    1,\n    // Layer2\n    4 // Layer1\n];\nfunction appendFrame$1(track, data, offset, pts, frameIndex) {\n    // Using http://www.datavoyage.com/mpgscript/mpeghdr.htm as a reference\n    if (offset + 24 > data.length) {\n        return;\n    }\n    const header = parseHeader(data, offset);\n    if (header && offset + header.frameLength <= data.length) {\n        const frameDuration = header.samplesPerFrame * 90000 / header.sampleRate;\n        const stamp = pts + frameIndex * frameDuration;\n        const sample = {\n            unit: data.subarray(offset, offset + header.frameLength),\n            pts: stamp,\n            dts: stamp\n        };\n        track.config = [];\n        track.channelCount = header.channelCount;\n        track.samplerate = header.sampleRate;\n        track.samples.push(sample);\n        return {\n            sample,\n            length: header.frameLength,\n            missing: 0\n        };\n    }\n}\nfunction parseHeader(data, offset) {\n    const mpegVersion = data[offset + 1] >> 3 & 3;\n    const mpegLayer = data[offset + 1] >> 1 & 3;\n    const bitRateIndex = data[offset + 2] >> 4 & 15;\n    const sampleRateIndex = data[offset + 2] >> 2 & 3;\n    if (mpegVersion !== 1 && bitRateIndex !== 0 && bitRateIndex !== 15 && sampleRateIndex !== 3) {\n        const paddingBit = data[offset + 2] >> 1 & 1;\n        const channelMode = data[offset + 3] >> 6;\n        const columnInBitrates = mpegVersion === 3 ? 3 - mpegLayer : mpegLayer === 3 ? 3 : 4;\n        const bitRate = BitratesMap[columnInBitrates * 14 + bitRateIndex - 1] * 1000;\n        const columnInSampleRates = mpegVersion === 3 ? 0 : mpegVersion === 2 ? 1 : 2;\n        const sampleRate = SamplingRateMap[columnInSampleRates * 3 + sampleRateIndex];\n        const channelCount = channelMode === 3 ? 1 : 2; // If bits of channel mode are `11` then it is a single channel (Mono)\n        const sampleCoefficient = SamplesCoefficients[mpegVersion][mpegLayer];\n        const bytesInSlot = BytesInSlot[mpegLayer];\n        const samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;\n        const frameLength = Math.floor(sampleCoefficient * bitRate / sampleRate + paddingBit) * bytesInSlot;\n        if (chromeVersion$1 === null) {\n            const userAgent = navigator.userAgent || \"\";\n            const result = userAgent.match(/Chrome\\/(\\d+)/i);\n            chromeVersion$1 = result ? parseInt(result[1]) : 0;\n        }\n        const needChromeFix = !!chromeVersion$1 && chromeVersion$1 <= 87;\n        if (needChromeFix && mpegLayer === 2 && bitRate >= 224000 && channelMode === 0) {\n            // Work around bug in Chromium by setting channelMode to dual-channel (01) instead of stereo (00)\n            data[offset + 3] = data[offset + 3] | 0x80;\n        }\n        return {\n            sampleRate,\n            channelCount,\n            frameLength,\n            samplesPerFrame\n        };\n    }\n}\nfunction isHeaderPattern(data, offset) {\n    return data[offset] === 0xff && (data[offset + 1] & 0xe0) === 0xe0 && (data[offset + 1] & 0x06) !== 0x00;\n}\nfunction isHeader(data, offset) {\n    // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1\n    // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)\n    // More info http://www.mp3-tech.org/programmer/frame_header.html\n    return offset + 1 < data.length && isHeaderPattern(data, offset);\n}\nfunction canParse(data, offset) {\n    const headerSize = 4;\n    return isHeaderPattern(data, offset) && headerSize <= data.length - offset;\n}\nfunction probe(data, offset) {\n    // same as isHeader but we also check that MPEG frame follows last MPEG frame\n    // or end of data is reached\n    if (offset + 1 < data.length && isHeaderPattern(data, offset)) {\n        // MPEG header Length\n        const headerLength = 4;\n        // MPEG frame Length\n        const header = parseHeader(data, offset);\n        let frameLength = headerLength;\n        if (header != null && header.frameLength) {\n            frameLength = header.frameLength;\n        }\n        const newOffset = offset + frameLength;\n        return newOffset === data.length || isHeader(data, newOffset);\n    }\n    return false;\n}\n/**\n * AAC demuxer\n */ class AACDemuxer extends BaseAudioDemuxer {\n    constructor(observer, config){\n        super();\n        this.observer = void 0;\n        this.config = void 0;\n        this.observer = observer;\n        this.config = config;\n    }\n    resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n        super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);\n        this._audioTrack = {\n            container: \"audio/adts\",\n            type: \"audio\",\n            id: 2,\n            pid: -1,\n            sequenceNumber: 0,\n            segmentCodec: \"aac\",\n            samples: [],\n            manifestCodec: audioCodec,\n            duration: trackDuration,\n            inputTimeScale: 90000,\n            dropped: 0\n        };\n    }\n    // Source for probe info - https://wiki.multimedia.cx/index.php?title=ADTS\n    static probe(data) {\n        if (!data) {\n            return false;\n        }\n        // Check for the ADTS sync word\n        // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1\n        // Layer bits (position 14 and 15) in header should be always 0 for ADTS\n        // More info https://wiki.multimedia.cx/index.php?title=ADTS\n        const id3Data = getID3Data(data, 0);\n        let offset = (id3Data == null ? void 0 : id3Data.length) || 0;\n        if (probe(data, offset)) {\n            return false;\n        }\n        for(let length = data.length; offset < length; offset++){\n            if (probe$1(data, offset)) {\n                logger.log(\"ADTS sync word found !\");\n                return true;\n            }\n        }\n        return false;\n    }\n    canParse(data, offset) {\n        return canParse$1(data, offset);\n    }\n    appendFrame(track, data, offset) {\n        initTrackConfig(track, this.observer, data, offset, track.manifestCodec);\n        const frame = appendFrame$2(track, data, offset, this.basePTS, this.frameIndex);\n        if (frame && frame.missing === 0) {\n            return frame;\n        }\n    }\n}\nconst emsgSchemePattern = /\\/emsg[-/]ID3/i;\nclass MP4Demuxer {\n    constructor(observer, config){\n        this.remainderData = null;\n        this.timeOffset = 0;\n        this.config = void 0;\n        this.videoTrack = void 0;\n        this.audioTrack = void 0;\n        this.id3Track = void 0;\n        this.txtTrack = void 0;\n        this.config = config;\n    }\n    resetTimeStamp() {}\n    resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n        const videoTrack = this.videoTrack = dummyTrack(\"video\", 1);\n        const audioTrack = this.audioTrack = dummyTrack(\"audio\", 1);\n        const captionTrack = this.txtTrack = dummyTrack(\"text\", 1);\n        this.id3Track = dummyTrack(\"id3\", 1);\n        this.timeOffset = 0;\n        if (!(initSegment != null && initSegment.byteLength)) {\n            return;\n        }\n        const initData = parseInitSegment(initSegment);\n        if (initData.video) {\n            const { id, timescale, codec } = initData.video;\n            videoTrack.id = id;\n            videoTrack.timescale = captionTrack.timescale = timescale;\n            videoTrack.codec = codec;\n        }\n        if (initData.audio) {\n            const { id, timescale, codec } = initData.audio;\n            audioTrack.id = id;\n            audioTrack.timescale = timescale;\n            audioTrack.codec = codec;\n        }\n        captionTrack.id = RemuxerTrackIdConfig.text;\n        videoTrack.sampleDuration = 0;\n        videoTrack.duration = audioTrack.duration = trackDuration;\n    }\n    resetContiguity() {\n        this.remainderData = null;\n    }\n    static probe(data) {\n        return hasMoofData(data);\n    }\n    demux(data, timeOffset) {\n        this.timeOffset = timeOffset;\n        // Load all data into the avc track. The CMAF remuxer will look for the data in the samples object; the rest of the fields do not matter\n        let videoSamples = data;\n        const videoTrack = this.videoTrack;\n        const textTrack = this.txtTrack;\n        if (this.config.progressive) {\n            // Split the bytestream into two ranges: one encompassing all data up until the start of the last moof, and everything else.\n            // This is done to guarantee that we're sending valid data to MSE - when demuxing progressively, we have no guarantee\n            // that the fetch loader gives us flush moof+mdat pairs. If we push jagged data to MSE, it will throw an exception.\n            if (this.remainderData) {\n                videoSamples = appendUint8Array(this.remainderData, data);\n            }\n            const segmentedData = segmentValidRange(videoSamples);\n            this.remainderData = segmentedData.remainder;\n            videoTrack.samples = segmentedData.valid || new Uint8Array();\n        } else {\n            videoTrack.samples = videoSamples;\n        }\n        const id3Track = this.extractID3Track(videoTrack, timeOffset);\n        textTrack.samples = parseSamples(timeOffset, videoTrack);\n        return {\n            videoTrack,\n            audioTrack: this.audioTrack,\n            id3Track,\n            textTrack: this.txtTrack\n        };\n    }\n    flush() {\n        const timeOffset = this.timeOffset;\n        const videoTrack = this.videoTrack;\n        const textTrack = this.txtTrack;\n        videoTrack.samples = this.remainderData || new Uint8Array();\n        this.remainderData = null;\n        const id3Track = this.extractID3Track(videoTrack, this.timeOffset);\n        textTrack.samples = parseSamples(timeOffset, videoTrack);\n        return {\n            videoTrack,\n            audioTrack: dummyTrack(),\n            id3Track,\n            textTrack: dummyTrack()\n        };\n    }\n    extractID3Track(videoTrack, timeOffset) {\n        const id3Track = this.id3Track;\n        if (videoTrack.samples.length) {\n            const emsgs = findBox(videoTrack.samples, [\n                \"emsg\"\n            ]);\n            if (emsgs) {\n                emsgs.forEach((data)=>{\n                    const emsgInfo = parseEmsg(data);\n                    if (emsgSchemePattern.test(emsgInfo.schemeIdUri)) {\n                        const pts = isFiniteNumber(emsgInfo.presentationTime) ? emsgInfo.presentationTime / emsgInfo.timeScale : timeOffset + emsgInfo.presentationTimeDelta / emsgInfo.timeScale;\n                        let duration = emsgInfo.eventDuration === 0xffffffff ? Number.POSITIVE_INFINITY : emsgInfo.eventDuration / emsgInfo.timeScale;\n                        // Safari takes anything <= 0.001 seconds and maps it to Infinity\n                        if (duration <= 0.001) {\n                            duration = Number.POSITIVE_INFINITY;\n                        }\n                        const payload = emsgInfo.payload;\n                        id3Track.samples.push({\n                            data: payload,\n                            len: payload.byteLength,\n                            dts: pts,\n                            pts: pts,\n                            type: MetadataSchema.emsg,\n                            duration: duration\n                        });\n                    }\n                });\n            }\n        }\n        return id3Track;\n    }\n    demuxSampleAes(data, keyData, timeOffset) {\n        return Promise.reject(new Error(\"The MP4 demuxer does not support SAMPLE-AES decryption\"));\n    }\n    destroy() {}\n}\nconst getAudioBSID = (data, offset)=>{\n    // check the bsid to confirm ac-3 | ec-3\n    let bsid = 0;\n    let numBits = 5;\n    offset += numBits;\n    const temp = new Uint32Array(1); // unsigned 32 bit for temporary storage\n    const mask = new Uint32Array(1); // unsigned 32 bit mask value\n    const byte = new Uint8Array(1); // unsigned 8 bit for temporary storage\n    while(numBits > 0){\n        byte[0] = data[offset];\n        // read remaining bits, upto 8 bits at a time\n        const bits = Math.min(numBits, 8);\n        const shift = 8 - bits;\n        mask[0] = 0xff000000 >>> 24 + shift << shift;\n        temp[0] = (byte[0] & mask[0]) >> shift;\n        bsid = !bsid ? temp[0] : bsid << bits | temp[0];\n        offset += 1;\n        numBits -= bits;\n    }\n    return bsid;\n};\nclass AC3Demuxer extends BaseAudioDemuxer {\n    constructor(observer){\n        super();\n        this.observer = void 0;\n        this.observer = observer;\n    }\n    resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n        super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);\n        this._audioTrack = {\n            container: \"audio/ac-3\",\n            type: \"audio\",\n            id: 2,\n            pid: -1,\n            sequenceNumber: 0,\n            segmentCodec: \"ac3\",\n            samples: [],\n            manifestCodec: audioCodec,\n            duration: trackDuration,\n            inputTimeScale: 90000,\n            dropped: 0\n        };\n    }\n    canParse(data, offset) {\n        return offset + 64 < data.length;\n    }\n    appendFrame(track, data, offset) {\n        const frameLength = appendFrame(track, data, offset, this.basePTS, this.frameIndex);\n        if (frameLength !== -1) {\n            const sample = track.samples[track.samples.length - 1];\n            return {\n                sample,\n                length: frameLength,\n                missing: 0\n            };\n        }\n    }\n    static probe(data) {\n        if (!data) {\n            return false;\n        }\n        const id3Data = getID3Data(data, 0);\n        if (!id3Data) {\n            return false;\n        }\n        // look for the ac-3 sync bytes\n        const offset = id3Data.length;\n        if (data[offset] === 0x0b && data[offset + 1] === 0x77 && getTimeStamp(id3Data) !== undefined && // check the bsid to confirm ac-3\n        getAudioBSID(data, offset) < 16) {\n            return true;\n        }\n        return false;\n    }\n}\nfunction appendFrame(track, data, start, pts, frameIndex) {\n    if (start + 8 > data.length) {\n        return -1; // not enough bytes left\n    }\n    if (data[start] !== 0x0b || data[start + 1] !== 0x77) {\n        return -1; // invalid magic\n    }\n    // get sample rate\n    const samplingRateCode = data[start + 4] >> 6;\n    if (samplingRateCode >= 3) {\n        return -1; // invalid sampling rate\n    }\n    const samplingRateMap = [\n        48000,\n        44100,\n        32000\n    ];\n    const sampleRate = samplingRateMap[samplingRateCode];\n    // get frame size\n    const frameSizeCode = data[start + 4] & 0x3f;\n    const frameSizeMap = [\n        64,\n        69,\n        96,\n        64,\n        70,\n        96,\n        80,\n        87,\n        120,\n        80,\n        88,\n        120,\n        96,\n        104,\n        144,\n        96,\n        105,\n        144,\n        112,\n        121,\n        168,\n        112,\n        122,\n        168,\n        128,\n        139,\n        192,\n        128,\n        140,\n        192,\n        160,\n        174,\n        240,\n        160,\n        175,\n        240,\n        192,\n        208,\n        288,\n        192,\n        209,\n        288,\n        224,\n        243,\n        336,\n        224,\n        244,\n        336,\n        256,\n        278,\n        384,\n        256,\n        279,\n        384,\n        320,\n        348,\n        480,\n        320,\n        349,\n        480,\n        384,\n        417,\n        576,\n        384,\n        418,\n        576,\n        448,\n        487,\n        672,\n        448,\n        488,\n        672,\n        512,\n        557,\n        768,\n        512,\n        558,\n        768,\n        640,\n        696,\n        960,\n        640,\n        697,\n        960,\n        768,\n        835,\n        1152,\n        768,\n        836,\n        1152,\n        896,\n        975,\n        1344,\n        896,\n        976,\n        1344,\n        1024,\n        1114,\n        1536,\n        1024,\n        1115,\n        1536,\n        1152,\n        1253,\n        1728,\n        1152,\n        1254,\n        1728,\n        1280,\n        1393,\n        1920,\n        1280,\n        1394,\n        1920\n    ];\n    const frameLength = frameSizeMap[frameSizeCode * 3 + samplingRateCode] * 2;\n    if (start + frameLength > data.length) {\n        return -1;\n    }\n    // get channel count\n    const channelMode = data[start + 6] >> 5;\n    let skipCount = 0;\n    if (channelMode === 2) {\n        skipCount += 2;\n    } else {\n        if (channelMode & 1 && channelMode !== 1) {\n            skipCount += 2;\n        }\n        if (channelMode & 4) {\n            skipCount += 2;\n        }\n    }\n    const lfeon = (data[start + 6] << 8 | data[start + 7]) >> 12 - skipCount & 1;\n    const channelsMap = [\n        2,\n        1,\n        2,\n        3,\n        3,\n        4,\n        4,\n        5\n    ];\n    const channelCount = channelsMap[channelMode] + lfeon;\n    // build dac3 box\n    const bsid = data[start + 5] >> 3;\n    const bsmod = data[start + 5] & 7;\n    const config = new Uint8Array([\n        samplingRateCode << 6 | bsid << 1 | bsmod >> 2,\n        (bsmod & 3) << 6 | channelMode << 3 | lfeon << 2 | frameSizeCode >> 4,\n        frameSizeCode << 4 & 0xe0\n    ]);\n    const frameDuration = 1536 / sampleRate * 90000;\n    const stamp = pts + frameIndex * frameDuration;\n    const unit = data.subarray(start, start + frameLength);\n    track.config = config;\n    track.channelCount = channelCount;\n    track.samplerate = sampleRate;\n    track.samples.push({\n        unit,\n        pts: stamp\n    });\n    return frameLength;\n}\nclass BaseVideoParser {\n    constructor(){\n        this.VideoSample = null;\n    }\n    createVideoSample(key, pts, dts, debug) {\n        return {\n            key,\n            frame: false,\n            pts,\n            dts,\n            units: [],\n            debug,\n            length: 0\n        };\n    }\n    getLastNalUnit(samples) {\n        var _VideoSample;\n        let VideoSample = this.VideoSample;\n        let lastUnit;\n        // try to fallback to previous sample if current one is empty\n        if (!VideoSample || VideoSample.units.length === 0) {\n            VideoSample = samples[samples.length - 1];\n        }\n        if ((_VideoSample = VideoSample) != null && _VideoSample.units) {\n            const units = VideoSample.units;\n            lastUnit = units[units.length - 1];\n        }\n        return lastUnit;\n    }\n    pushAccessUnit(VideoSample, videoTrack) {\n        if (VideoSample.units.length && VideoSample.frame) {\n            // if sample does not have PTS/DTS, patch with last sample PTS/DTS\n            if (VideoSample.pts === undefined) {\n                const samples = videoTrack.samples;\n                const nbSamples = samples.length;\n                if (nbSamples) {\n                    const lastSample = samples[nbSamples - 1];\n                    VideoSample.pts = lastSample.pts;\n                    VideoSample.dts = lastSample.dts;\n                } else {\n                    // dropping samples, no timestamp found\n                    videoTrack.dropped++;\n                    return;\n                }\n            }\n            videoTrack.samples.push(VideoSample);\n        }\n        if (VideoSample.debug.length) {\n            logger.log(VideoSample.pts + \"/\" + VideoSample.dts + \":\" + VideoSample.debug);\n        }\n    }\n}\n/**\n * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.\n */ class ExpGolomb {\n    constructor(data){\n        this.data = void 0;\n        this.bytesAvailable = void 0;\n        this.word = void 0;\n        this.bitsAvailable = void 0;\n        this.data = data;\n        // the number of bytes left to examine in this.data\n        this.bytesAvailable = data.byteLength;\n        // the current word being examined\n        this.word = 0; // :uint\n        // the number of bits left to examine in the current word\n        this.bitsAvailable = 0; // :uint\n    }\n    // ():void\n    loadWord() {\n        const data = this.data;\n        const bytesAvailable = this.bytesAvailable;\n        const position = data.byteLength - bytesAvailable;\n        const workingBytes = new Uint8Array(4);\n        const availableBytes = Math.min(4, bytesAvailable);\n        if (availableBytes === 0) {\n            throw new Error(\"no bytes available\");\n        }\n        workingBytes.set(data.subarray(position, position + availableBytes));\n        this.word = new DataView(workingBytes.buffer).getUint32(0);\n        // track the amount of this.data that has been processed\n        this.bitsAvailable = availableBytes * 8;\n        this.bytesAvailable -= availableBytes;\n    }\n    // (count:int):void\n    skipBits(count) {\n        let skipBytes; // :int\n        count = Math.min(count, this.bytesAvailable * 8 + this.bitsAvailable);\n        if (this.bitsAvailable > count) {\n            this.word <<= count;\n            this.bitsAvailable -= count;\n        } else {\n            count -= this.bitsAvailable;\n            skipBytes = count >> 3;\n            count -= skipBytes << 3;\n            this.bytesAvailable -= skipBytes;\n            this.loadWord();\n            this.word <<= count;\n            this.bitsAvailable -= count;\n        }\n    }\n    // (size:int):uint\n    readBits(size) {\n        let bits = Math.min(this.bitsAvailable, size); // :uint\n        const valu = this.word >>> 32 - bits; // :uint\n        if (size > 32) {\n            logger.error(\"Cannot read more than 32 bits at a time\");\n        }\n        this.bitsAvailable -= bits;\n        if (this.bitsAvailable > 0) {\n            this.word <<= bits;\n        } else if (this.bytesAvailable > 0) {\n            this.loadWord();\n        } else {\n            throw new Error(\"no bits available\");\n        }\n        bits = size - bits;\n        if (bits > 0 && this.bitsAvailable) {\n            return valu << bits | this.readBits(bits);\n        } else {\n            return valu;\n        }\n    }\n    // ():uint\n    skipLZ() {\n        let leadingZeroCount; // :uint\n        for(leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount){\n            if ((this.word & 0x80000000 >>> leadingZeroCount) !== 0) {\n                // the first bit of working word is 1\n                this.word <<= leadingZeroCount;\n                this.bitsAvailable -= leadingZeroCount;\n                return leadingZeroCount;\n            }\n        }\n        // we exhausted word and still have not found a 1\n        this.loadWord();\n        return leadingZeroCount + this.skipLZ();\n    }\n    // ():void\n    skipUEG() {\n        this.skipBits(1 + this.skipLZ());\n    }\n    // ():void\n    skipEG() {\n        this.skipBits(1 + this.skipLZ());\n    }\n    // ():uint\n    readUEG() {\n        const clz = this.skipLZ(); // :uint\n        return this.readBits(clz + 1) - 1;\n    }\n    // ():int\n    readEG() {\n        const valu = this.readUEG(); // :int\n        if (0x01 & valu) {\n            // the number is odd if the low order bit is set\n            return 1 + valu >>> 1; // add 1 to make it even, and divide by 2\n        } else {\n            return -1 * (valu >>> 1); // divide by two then make it negative\n        }\n    }\n    // Some convenience functions\n    // :Boolean\n    readBoolean() {\n        return this.readBits(1) === 1;\n    }\n    // ():int\n    readUByte() {\n        return this.readBits(8);\n    }\n    // ():int\n    readUShort() {\n        return this.readBits(16);\n    }\n    // ():int\n    readUInt() {\n        return this.readBits(32);\n    }\n    /**\n   * Advance the ExpGolomb decoder past a scaling list. The scaling\n   * list is optionally transmitted as part of a sequence parameter\n   * set and is not relevant to transmuxing.\n   * @param count the number of entries in this scaling list\n   * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1\n   */ skipScalingList(count) {\n        let lastScale = 8;\n        let nextScale = 8;\n        let deltaScale;\n        for(let j = 0; j < count; j++){\n            if (nextScale !== 0) {\n                deltaScale = this.readEG();\n                nextScale = (lastScale + deltaScale + 256) % 256;\n            }\n            lastScale = nextScale === 0 ? lastScale : nextScale;\n        }\n    }\n    /**\n   * Read a sequence parameter set and return some interesting video\n   * properties. A sequence parameter set is the H264 metadata that\n   * describes the properties of upcoming video frames.\n   * @returns an object with configuration parsed from the\n   * sequence parameter set, including the dimensions of the\n   * associated video frames.\n   */ readSPS() {\n        let frameCropLeftOffset = 0;\n        let frameCropRightOffset = 0;\n        let frameCropTopOffset = 0;\n        let frameCropBottomOffset = 0;\n        let numRefFramesInPicOrderCntCycle;\n        let scalingListCount;\n        let i;\n        const readUByte = this.readUByte.bind(this);\n        const readBits = this.readBits.bind(this);\n        const readUEG = this.readUEG.bind(this);\n        const readBoolean = this.readBoolean.bind(this);\n        const skipBits = this.skipBits.bind(this);\n        const skipEG = this.skipEG.bind(this);\n        const skipUEG = this.skipUEG.bind(this);\n        const skipScalingList = this.skipScalingList.bind(this);\n        readUByte();\n        const profileIdc = readUByte(); // profile_idc\n        readBits(5); // profileCompat constraint_set[0-4]_flag, u(5)\n        skipBits(3); // reserved_zero_3bits u(3),\n        readUByte(); // level_idc u(8)\n        skipUEG(); // seq_parameter_set_id\n        // some profiles have more optional data we don't need\n        if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {\n            const chromaFormatIdc = readUEG();\n            if (chromaFormatIdc === 3) {\n                skipBits(1);\n            } // separate_colour_plane_flag\n            skipUEG(); // bit_depth_luma_minus8\n            skipUEG(); // bit_depth_chroma_minus8\n            skipBits(1); // qpprime_y_zero_transform_bypass_flag\n            if (readBoolean()) {\n                // seq_scaling_matrix_present_flag\n                scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;\n                for(i = 0; i < scalingListCount; i++){\n                    if (readBoolean()) {\n                        // seq_scaling_list_present_flag[ i ]\n                        if (i < 6) {\n                            skipScalingList(16);\n                        } else {\n                            skipScalingList(64);\n                        }\n                    }\n                }\n            }\n        }\n        skipUEG(); // log2_max_frame_num_minus4\n        const picOrderCntType = readUEG();\n        if (picOrderCntType === 0) {\n            readUEG(); // log2_max_pic_order_cnt_lsb_minus4\n        } else if (picOrderCntType === 1) {\n            skipBits(1); // delta_pic_order_always_zero_flag\n            skipEG(); // offset_for_non_ref_pic\n            skipEG(); // offset_for_top_to_bottom_field\n            numRefFramesInPicOrderCntCycle = readUEG();\n            for(i = 0; i < numRefFramesInPicOrderCntCycle; i++){\n                skipEG();\n            } // offset_for_ref_frame[ i ]\n        }\n        skipUEG(); // max_num_ref_frames\n        skipBits(1); // gaps_in_frame_num_value_allowed_flag\n        const picWidthInMbsMinus1 = readUEG();\n        const picHeightInMapUnitsMinus1 = readUEG();\n        const frameMbsOnlyFlag = readBits(1);\n        if (frameMbsOnlyFlag === 0) {\n            skipBits(1);\n        } // mb_adaptive_frame_field_flag\n        skipBits(1); // direct_8x8_inference_flag\n        if (readBoolean()) {\n            // frame_cropping_flag\n            frameCropLeftOffset = readUEG();\n            frameCropRightOffset = readUEG();\n            frameCropTopOffset = readUEG();\n            frameCropBottomOffset = readUEG();\n        }\n        let pixelRatio = [\n            1,\n            1\n        ];\n        if (readBoolean()) {\n            // vui_parameters_present_flag\n            if (readBoolean()) {\n                // aspect_ratio_info_present_flag\n                const aspectRatioIdc = readUByte();\n                switch(aspectRatioIdc){\n                    case 1:\n                        pixelRatio = [\n                            1,\n                            1\n                        ];\n                        break;\n                    case 2:\n                        pixelRatio = [\n                            12,\n                            11\n                        ];\n                        break;\n                    case 3:\n                        pixelRatio = [\n                            10,\n                            11\n                        ];\n                        break;\n                    case 4:\n                        pixelRatio = [\n                            16,\n                            11\n                        ];\n                        break;\n                    case 5:\n                        pixelRatio = [\n                            40,\n                            33\n                        ];\n                        break;\n                    case 6:\n                        pixelRatio = [\n                            24,\n                            11\n                        ];\n                        break;\n                    case 7:\n                        pixelRatio = [\n                            20,\n                            11\n                        ];\n                        break;\n                    case 8:\n                        pixelRatio = [\n                            32,\n                            11\n                        ];\n                        break;\n                    case 9:\n                        pixelRatio = [\n                            80,\n                            33\n                        ];\n                        break;\n                    case 10:\n                        pixelRatio = [\n                            18,\n                            11\n                        ];\n                        break;\n                    case 11:\n                        pixelRatio = [\n                            15,\n                            11\n                        ];\n                        break;\n                    case 12:\n                        pixelRatio = [\n                            64,\n                            33\n                        ];\n                        break;\n                    case 13:\n                        pixelRatio = [\n                            160,\n                            99\n                        ];\n                        break;\n                    case 14:\n                        pixelRatio = [\n                            4,\n                            3\n                        ];\n                        break;\n                    case 15:\n                        pixelRatio = [\n                            3,\n                            2\n                        ];\n                        break;\n                    case 16:\n                        pixelRatio = [\n                            2,\n                            1\n                        ];\n                        break;\n                    case 255:\n                        {\n                            pixelRatio = [\n                                readUByte() << 8 | readUByte(),\n                                readUByte() << 8 | readUByte()\n                            ];\n                            break;\n                        }\n                }\n            }\n        }\n        return {\n            width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),\n            height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),\n            pixelRatio: pixelRatio\n        };\n    }\n    readSliceType() {\n        // skip NALu type\n        this.readUByte();\n        // discard first_mb_in_slice\n        this.readUEG();\n        // return slice_type\n        return this.readUEG();\n    }\n}\nclass AvcVideoParser extends BaseVideoParser {\n    parseAVCPES(track, textTrack, pes, last, duration) {\n        const units = this.parseAVCNALu(track, pes.data);\n        let VideoSample = this.VideoSample;\n        let push;\n        let spsfound = false;\n        // free pes.data to save up some memory\n        pes.data = null;\n        // if new NAL units found and last sample still there, let's push ...\n        // this helps parsing streams with missing AUD (only do this if AUD never found)\n        if (VideoSample && units.length && !track.audFound) {\n            this.pushAccessUnit(VideoSample, track);\n            VideoSample = this.VideoSample = this.createVideoSample(false, pes.pts, pes.dts, \"\");\n        }\n        units.forEach((unit)=>{\n            var _VideoSample2;\n            switch(unit.type){\n                // NDR\n                case 1:\n                    {\n                        let iskey = false;\n                        push = true;\n                        const data = unit.data;\n                        // only check slice type to detect KF in case SPS found in same packet (any keyframe is preceded by SPS ...)\n                        if (spsfound && data.length > 4) {\n                            // retrieve slice type by parsing beginning of NAL unit (follow H264 spec, slice_header definition) to detect keyframe embedded in NDR\n                            const sliceType = new ExpGolomb(data).readSliceType();\n                            // 2 : I slice, 4 : SI slice, 7 : I slice, 9: SI slice\n                            // SI slice : A slice that is coded using intra prediction only and using quantisation of the prediction samples.\n                            // An SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.\n                            // I slice: A slice that is not an SI slice that is decoded using intra prediction only.\n                            // if (sliceType === 2 || sliceType === 7) {\n                            if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {\n                                iskey = true;\n                            }\n                        }\n                        if (iskey) {\n                            var _VideoSample;\n                            // if we have non-keyframe data already, that cannot belong to the same frame as a keyframe, so force a push\n                            if ((_VideoSample = VideoSample) != null && _VideoSample.frame && !VideoSample.key) {\n                                this.pushAccessUnit(VideoSample, track);\n                                VideoSample = this.VideoSample = null;\n                            }\n                        }\n                        if (!VideoSample) {\n                            VideoSample = this.VideoSample = this.createVideoSample(true, pes.pts, pes.dts, \"\");\n                        }\n                        VideoSample.frame = true;\n                        VideoSample.key = iskey;\n                        break;\n                    // IDR\n                    }\n                case 5:\n                    push = true;\n                    // handle PES not starting with AUD\n                    // if we have frame data already, that cannot belong to the same frame, so force a push\n                    if ((_VideoSample2 = VideoSample) != null && _VideoSample2.frame && !VideoSample.key) {\n                        this.pushAccessUnit(VideoSample, track);\n                        VideoSample = this.VideoSample = null;\n                    }\n                    if (!VideoSample) {\n                        VideoSample = this.VideoSample = this.createVideoSample(true, pes.pts, pes.dts, \"\");\n                    }\n                    VideoSample.key = true;\n                    VideoSample.frame = true;\n                    break;\n                // SEI\n                case 6:\n                    {\n                        push = true;\n                        parseSEIMessageFromNALu(unit.data, 1, pes.pts, textTrack.samples);\n                        break;\n                    // SPS\n                    }\n                case 7:\n                    {\n                        var _track$pixelRatio, _track$pixelRatio2;\n                        push = true;\n                        spsfound = true;\n                        const sps = unit.data;\n                        const expGolombDecoder = new ExpGolomb(sps);\n                        const config = expGolombDecoder.readSPS();\n                        if (!track.sps || track.width !== config.width || track.height !== config.height || ((_track$pixelRatio = track.pixelRatio) == null ? void 0 : _track$pixelRatio[0]) !== config.pixelRatio[0] || ((_track$pixelRatio2 = track.pixelRatio) == null ? void 0 : _track$pixelRatio2[1]) !== config.pixelRatio[1]) {\n                            track.width = config.width;\n                            track.height = config.height;\n                            track.pixelRatio = config.pixelRatio;\n                            track.sps = [\n                                sps\n                            ];\n                            track.duration = duration;\n                            const codecarray = sps.subarray(1, 4);\n                            let codecstring = \"avc1.\";\n                            for(let i = 0; i < 3; i++){\n                                let h = codecarray[i].toString(16);\n                                if (h.length < 2) {\n                                    h = \"0\" + h;\n                                }\n                                codecstring += h;\n                            }\n                            track.codec = codecstring;\n                        }\n                        break;\n                    }\n                // PPS\n                case 8:\n                    push = true;\n                    track.pps = [\n                        unit.data\n                    ];\n                    break;\n                // AUD\n                case 9:\n                    push = true;\n                    track.audFound = true;\n                    if (VideoSample) {\n                        this.pushAccessUnit(VideoSample, track);\n                    }\n                    VideoSample = this.VideoSample = this.createVideoSample(false, pes.pts, pes.dts, \"\");\n                    break;\n                // Filler Data\n                case 12:\n                    push = true;\n                    break;\n                default:\n                    push = false;\n                    if (VideoSample) {\n                        VideoSample.debug += \"unknown NAL \" + unit.type + \" \";\n                    }\n                    break;\n            }\n            if (VideoSample && push) {\n                const units = VideoSample.units;\n                units.push(unit);\n            }\n        });\n        // if last PES packet, push samples\n        if (last && VideoSample) {\n            this.pushAccessUnit(VideoSample, track);\n            this.VideoSample = null;\n        }\n    }\n    parseAVCNALu(track, array) {\n        const len = array.byteLength;\n        let state = track.naluState || 0;\n        const lastState = state;\n        const units = [];\n        let i = 0;\n        let value;\n        let overflow;\n        let unitType;\n        let lastUnitStart = -1;\n        let lastUnitType = 0;\n        // logger.log('PES:' + Hex.hexDump(array));\n        if (state === -1) {\n            // special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet\n            lastUnitStart = 0;\n            // NALu type is value read from offset 0\n            lastUnitType = array[0] & 0x1f;\n            state = 0;\n            i = 1;\n        }\n        while(i < len){\n            value = array[i++];\n            // optimization. state 0 and 1 are the predominant case. let's handle them outside of the switch/case\n            if (!state) {\n                state = value ? 0 : 1;\n                continue;\n            }\n            if (state === 1) {\n                state = value ? 0 : 2;\n                continue;\n            }\n            // here we have state either equal to 2 or 3\n            if (!value) {\n                state = 3;\n            } else if (value === 1) {\n                overflow = i - state - 1;\n                if (lastUnitStart >= 0) {\n                    const unit = {\n                        data: array.subarray(lastUnitStart, overflow),\n                        type: lastUnitType\n                    };\n                    // logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);\n                    units.push(unit);\n                } else {\n                    // lastUnitStart is undefined => this is the first start code found in this PES packet\n                    // first check if start code delimiter is overlapping between 2 PES packets,\n                    // ie it started in last packet (lastState not zero)\n                    // and ended at the beginning of this PES packet (i <= 4 - lastState)\n                    const lastUnit = this.getLastNalUnit(track.samples);\n                    if (lastUnit) {\n                        if (lastState && i <= 4 - lastState) {\n                            // start delimiter overlapping between PES packets\n                            // strip start delimiter bytes from the end of last NAL unit\n                            // check if lastUnit had a state different from zero\n                            if (lastUnit.state) {\n                                // strip last bytes\n                                lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);\n                            }\n                        }\n                        // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.\n                        if (overflow > 0) {\n                            // logger.log('first NALU found with overflow:' + overflow);\n                            lastUnit.data = appendUint8Array(lastUnit.data, array.subarray(0, overflow));\n                            lastUnit.state = 0;\n                        }\n                    }\n                }\n                // check if we can read unit type\n                if (i < len) {\n                    unitType = array[i] & 0x1f;\n                    // logger.log('find NALU @ offset:' + i + ',type:' + unitType);\n                    lastUnitStart = i;\n                    lastUnitType = unitType;\n                    state = 0;\n                } else {\n                    // not enough byte to read unit type. let's read it on next PES parsing\n                    state = -1;\n                }\n            } else {\n                state = 0;\n            }\n        }\n        if (lastUnitStart >= 0 && state >= 0) {\n            const unit = {\n                data: array.subarray(lastUnitStart, len),\n                type: lastUnitType,\n                state: state\n            };\n            units.push(unit);\n        // logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);\n        }\n        // no NALu found\n        if (units.length === 0) {\n            // append pes.data to previous NAL unit\n            const lastUnit = this.getLastNalUnit(track.samples);\n            if (lastUnit) {\n                lastUnit.data = appendUint8Array(lastUnit.data, array);\n            }\n        }\n        track.naluState = state;\n        return units;\n    }\n}\n/**\n * SAMPLE-AES decrypter\n */ class SampleAesDecrypter {\n    constructor(observer, config, keyData){\n        this.keyData = void 0;\n        this.decrypter = void 0;\n        this.keyData = keyData;\n        this.decrypter = new Decrypter(config, {\n            removePKCS7Padding: false\n        });\n    }\n    decryptBuffer(encryptedData) {\n        return this.decrypter.decrypt(encryptedData, this.keyData.key.buffer, this.keyData.iv.buffer);\n    }\n    // AAC - encrypt all full 16 bytes blocks starting from offset 16\n    decryptAacSample(samples, sampleIndex, callback) {\n        const curUnit = samples[sampleIndex].unit;\n        if (curUnit.length <= 16) {\n            // No encrypted portion in this sample (first 16 bytes is not\n            // encrypted, see https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/HLS_Sample_Encryption/Encryption/Encryption.html),\n            return;\n        }\n        const encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);\n        const encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);\n        this.decryptBuffer(encryptedBuffer).then((decryptedBuffer)=>{\n            const decryptedData = new Uint8Array(decryptedBuffer);\n            curUnit.set(decryptedData, 16);\n            if (!this.decrypter.isSync()) {\n                this.decryptAacSamples(samples, sampleIndex + 1, callback);\n            }\n        });\n    }\n    decryptAacSamples(samples, sampleIndex, callback) {\n        for(;; sampleIndex++){\n            if (sampleIndex >= samples.length) {\n                callback();\n                return;\n            }\n            if (samples[sampleIndex].unit.length < 32) {\n                continue;\n            }\n            this.decryptAacSample(samples, sampleIndex, callback);\n            if (!this.decrypter.isSync()) {\n                return;\n            }\n        }\n    }\n    // AVC - encrypt one 16 bytes block out of ten, starting from offset 32\n    getAvcEncryptedData(decodedData) {\n        const encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;\n        const encryptedData = new Int8Array(encryptedDataLen);\n        let outputPos = 0;\n        for(let inputPos = 32; inputPos < decodedData.length - 16; inputPos += 160, outputPos += 16){\n            encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);\n        }\n        return encryptedData;\n    }\n    getAvcDecryptedUnit(decodedData, decryptedData) {\n        const uint8DecryptedData = new Uint8Array(decryptedData);\n        let inputPos = 0;\n        for(let outputPos = 32; outputPos < decodedData.length - 16; outputPos += 160, inputPos += 16){\n            decodedData.set(uint8DecryptedData.subarray(inputPos, inputPos + 16), outputPos);\n        }\n        return decodedData;\n    }\n    decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit) {\n        const decodedData = discardEPB(curUnit.data);\n        const encryptedData = this.getAvcEncryptedData(decodedData);\n        this.decryptBuffer(encryptedData.buffer).then((decryptedBuffer)=>{\n            curUnit.data = this.getAvcDecryptedUnit(decodedData, decryptedBuffer);\n            if (!this.decrypter.isSync()) {\n                this.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);\n            }\n        });\n    }\n    decryptAvcSamples(samples, sampleIndex, unitIndex, callback) {\n        if (samples instanceof Uint8Array) {\n            throw new Error(\"Cannot decrypt samples of type Uint8Array\");\n        }\n        for(;; sampleIndex++, unitIndex = 0){\n            if (sampleIndex >= samples.length) {\n                callback();\n                return;\n            }\n            const curUnits = samples[sampleIndex].units;\n            for(;; unitIndex++){\n                if (unitIndex >= curUnits.length) {\n                    break;\n                }\n                const curUnit = curUnits[unitIndex];\n                if (curUnit.data.length <= 48 || curUnit.type !== 1 && curUnit.type !== 5) {\n                    continue;\n                }\n                this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit);\n                if (!this.decrypter.isSync()) {\n                    return;\n                }\n            }\n        }\n    }\n}\nconst PACKET_LENGTH = 188;\nclass TSDemuxer {\n    constructor(observer, config, typeSupported){\n        this.observer = void 0;\n        this.config = void 0;\n        this.typeSupported = void 0;\n        this.sampleAes = null;\n        this.pmtParsed = false;\n        this.audioCodec = void 0;\n        this.videoCodec = void 0;\n        this._duration = 0;\n        this._pmtId = -1;\n        this._videoTrack = void 0;\n        this._audioTrack = void 0;\n        this._id3Track = void 0;\n        this._txtTrack = void 0;\n        this.aacOverFlow = null;\n        this.remainderData = null;\n        this.videoParser = void 0;\n        this.observer = observer;\n        this.config = config;\n        this.typeSupported = typeSupported;\n        this.videoParser = new AvcVideoParser();\n    }\n    static probe(data) {\n        const syncOffset = TSDemuxer.syncOffset(data);\n        if (syncOffset > 0) {\n            logger.warn(`MPEG2-TS detected but first sync word found @ offset ${syncOffset}`);\n        }\n        return syncOffset !== -1;\n    }\n    static syncOffset(data) {\n        const length = data.length;\n        let scanwindow = Math.min(PACKET_LENGTH * 5, length - PACKET_LENGTH) + 1;\n        let i = 0;\n        while(i < scanwindow){\n            // a TS init segment should contain at least 2 TS packets: PAT and PMT, each starting with 0x47\n            let foundPat = false;\n            let packetStart = -1;\n            let tsPackets = 0;\n            for(let j = i; j < length; j += PACKET_LENGTH){\n                if (data[j] === 0x47 && (length - j === PACKET_LENGTH || data[j + PACKET_LENGTH] === 0x47)) {\n                    tsPackets++;\n                    if (packetStart === -1) {\n                        packetStart = j;\n                        // First sync word found at offset, increase scan length (#5251)\n                        if (packetStart !== 0) {\n                            scanwindow = Math.min(packetStart + PACKET_LENGTH * 99, data.length - PACKET_LENGTH) + 1;\n                        }\n                    }\n                    if (!foundPat) {\n                        foundPat = parsePID(data, j) === 0;\n                    }\n                    // Sync word found at 0 with 3 packets, or found at offset least 2 packets up to scanwindow (#5501)\n                    if (foundPat && tsPackets > 1 && (packetStart === 0 && tsPackets > 2 || j + PACKET_LENGTH > scanwindow)) {\n                        return packetStart;\n                    }\n                } else if (tsPackets) {\n                    // Exit if sync word found, but does not contain contiguous packets\n                    return -1;\n                } else {\n                    break;\n                }\n            }\n            i++;\n        }\n        return -1;\n    }\n    /**\n   * Creates a track model internal to demuxer used to drive remuxing input\n   */ static createTrack(type, duration) {\n        return {\n            container: type === \"video\" || type === \"audio\" ? \"video/mp2t\" : undefined,\n            type,\n            id: RemuxerTrackIdConfig[type],\n            pid: -1,\n            inputTimeScale: 90000,\n            sequenceNumber: 0,\n            samples: [],\n            dropped: 0,\n            duration: type === \"audio\" ? duration : undefined\n        };\n    }\n    /**\n   * Initializes a new init segment on the demuxer/remuxer interface. Needed for discontinuities/track-switches (or at stream start)\n   * Resets all internal track instances of the demuxer.\n   */ resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n        this.pmtParsed = false;\n        this._pmtId = -1;\n        this._videoTrack = TSDemuxer.createTrack(\"video\");\n        this._audioTrack = TSDemuxer.createTrack(\"audio\", trackDuration);\n        this._id3Track = TSDemuxer.createTrack(\"id3\");\n        this._txtTrack = TSDemuxer.createTrack(\"text\");\n        this._audioTrack.segmentCodec = \"aac\";\n        // flush any partial content\n        this.aacOverFlow = null;\n        this.remainderData = null;\n        this.audioCodec = audioCodec;\n        this.videoCodec = videoCodec;\n        this._duration = trackDuration;\n    }\n    resetTimeStamp() {}\n    resetContiguity() {\n        const { _audioTrack, _videoTrack, _id3Track } = this;\n        if (_audioTrack) {\n            _audioTrack.pesData = null;\n        }\n        if (_videoTrack) {\n            _videoTrack.pesData = null;\n        }\n        if (_id3Track) {\n            _id3Track.pesData = null;\n        }\n        this.aacOverFlow = null;\n        this.remainderData = null;\n    }\n    demux(data, timeOffset, isSampleAes = false, flush = false) {\n        if (!isSampleAes) {\n            this.sampleAes = null;\n        }\n        let pes;\n        const videoTrack = this._videoTrack;\n        const audioTrack = this._audioTrack;\n        const id3Track = this._id3Track;\n        const textTrack = this._txtTrack;\n        let videoPid = videoTrack.pid;\n        let videoData = videoTrack.pesData;\n        let audioPid = audioTrack.pid;\n        let id3Pid = id3Track.pid;\n        let audioData = audioTrack.pesData;\n        let id3Data = id3Track.pesData;\n        let unknownPID = null;\n        let pmtParsed = this.pmtParsed;\n        let pmtId = this._pmtId;\n        let len = data.length;\n        if (this.remainderData) {\n            data = appendUint8Array(this.remainderData, data);\n            len = data.length;\n            this.remainderData = null;\n        }\n        if (len < PACKET_LENGTH && !flush) {\n            this.remainderData = data;\n            return {\n                audioTrack,\n                videoTrack,\n                id3Track,\n                textTrack\n            };\n        }\n        const syncOffset = Math.max(0, TSDemuxer.syncOffset(data));\n        len -= (len - syncOffset) % PACKET_LENGTH;\n        if (len < data.byteLength && !flush) {\n            this.remainderData = new Uint8Array(data.buffer, len, data.buffer.byteLength - len);\n        }\n        // loop through TS packets\n        let tsPacketErrors = 0;\n        for(let start = syncOffset; start < len; start += PACKET_LENGTH){\n            if (data[start] === 0x47) {\n                const stt = !!(data[start + 1] & 0x40);\n                const pid = parsePID(data, start);\n                const atf = (data[start + 3] & 0x30) >> 4;\n                // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.\n                let offset;\n                if (atf > 1) {\n                    offset = start + 5 + data[start + 4];\n                    // continue if there is only adaptation field\n                    if (offset === start + PACKET_LENGTH) {\n                        continue;\n                    }\n                } else {\n                    offset = start + 4;\n                }\n                switch(pid){\n                    case videoPid:\n                        if (stt) {\n                            if (videoData && (pes = parsePES(videoData))) {\n                                this.videoParser.parseAVCPES(videoTrack, textTrack, pes, false, this._duration);\n                            }\n                            videoData = {\n                                data: [],\n                                size: 0\n                            };\n                        }\n                        if (videoData) {\n                            videoData.data.push(data.subarray(offset, start + PACKET_LENGTH));\n                            videoData.size += start + PACKET_LENGTH - offset;\n                        }\n                        break;\n                    case audioPid:\n                        if (stt) {\n                            if (audioData && (pes = parsePES(audioData))) {\n                                switch(audioTrack.segmentCodec){\n                                    case \"aac\":\n                                        this.parseAACPES(audioTrack, pes);\n                                        break;\n                                    case \"mp3\":\n                                        this.parseMPEGPES(audioTrack, pes);\n                                        break;\n                                    case \"ac3\":\n                                        {\n                                            this.parseAC3PES(audioTrack, pes);\n                                        }\n                                        break;\n                                }\n                            }\n                            audioData = {\n                                data: [],\n                                size: 0\n                            };\n                        }\n                        if (audioData) {\n                            audioData.data.push(data.subarray(offset, start + PACKET_LENGTH));\n                            audioData.size += start + PACKET_LENGTH - offset;\n                        }\n                        break;\n                    case id3Pid:\n                        if (stt) {\n                            if (id3Data && (pes = parsePES(id3Data))) {\n                                this.parseID3PES(id3Track, pes);\n                            }\n                            id3Data = {\n                                data: [],\n                                size: 0\n                            };\n                        }\n                        if (id3Data) {\n                            id3Data.data.push(data.subarray(offset, start + PACKET_LENGTH));\n                            id3Data.size += start + PACKET_LENGTH - offset;\n                        }\n                        break;\n                    case 0:\n                        if (stt) {\n                            offset += data[offset] + 1;\n                        }\n                        pmtId = this._pmtId = parsePAT(data, offset);\n                        break;\n                    case pmtId:\n                        {\n                            if (stt) {\n                                offset += data[offset] + 1;\n                            }\n                            const parsedPIDs = parsePMT(data, offset, this.typeSupported, isSampleAes);\n                            // only update track id if track PID found while parsing PMT\n                            // this is to avoid resetting the PID to -1 in case\n                            // track PID transiently disappears from the stream\n                            // this could happen in case of transient missing audio samples for example\n                            // NOTE this is only the PID of the track as found in TS,\n                            // but we are not using this for MP4 track IDs.\n                            videoPid = parsedPIDs.videoPid;\n                            if (videoPid > 0) {\n                                videoTrack.pid = videoPid;\n                                videoTrack.segmentCodec = parsedPIDs.segmentVideoCodec;\n                            }\n                            audioPid = parsedPIDs.audioPid;\n                            if (audioPid > 0) {\n                                audioTrack.pid = audioPid;\n                                audioTrack.segmentCodec = parsedPIDs.segmentAudioCodec;\n                            }\n                            id3Pid = parsedPIDs.id3Pid;\n                            if (id3Pid > 0) {\n                                id3Track.pid = id3Pid;\n                            }\n                            if (unknownPID !== null && !pmtParsed) {\n                                logger.warn(`MPEG-TS PMT found at ${start} after unknown PID '${unknownPID}'. Backtracking to sync byte @${syncOffset} to parse all TS packets.`);\n                                unknownPID = null;\n                                // we set it to -188, the += 188 in the for loop will reset start to 0\n                                start = syncOffset - 188;\n                            }\n                            pmtParsed = this.pmtParsed = true;\n                            break;\n                        }\n                    case 0x11:\n                    case 0x1fff:\n                        break;\n                    default:\n                        unknownPID = pid;\n                        break;\n                }\n            } else {\n                tsPacketErrors++;\n            }\n        }\n        if (tsPacketErrors > 0) {\n            const error = new Error(`Found ${tsPacketErrors} TS packet/s that do not start with 0x47`);\n            this.observer.emit(Events.ERROR, Events.ERROR, {\n                type: ErrorTypes.MEDIA_ERROR,\n                details: ErrorDetails.FRAG_PARSING_ERROR,\n                fatal: false,\n                error,\n                reason: error.message\n            });\n        }\n        videoTrack.pesData = videoData;\n        audioTrack.pesData = audioData;\n        id3Track.pesData = id3Data;\n        const demuxResult = {\n            audioTrack,\n            videoTrack,\n            id3Track,\n            textTrack\n        };\n        if (flush) {\n            this.extractRemainingSamples(demuxResult);\n        }\n        return demuxResult;\n    }\n    flush() {\n        const { remainderData } = this;\n        this.remainderData = null;\n        let result;\n        if (remainderData) {\n            result = this.demux(remainderData, -1, false, true);\n        } else {\n            result = {\n                videoTrack: this._videoTrack,\n                audioTrack: this._audioTrack,\n                id3Track: this._id3Track,\n                textTrack: this._txtTrack\n            };\n        }\n        this.extractRemainingSamples(result);\n        if (this.sampleAes) {\n            return this.decrypt(result, this.sampleAes);\n        }\n        return result;\n    }\n    extractRemainingSamples(demuxResult) {\n        const { audioTrack, videoTrack, id3Track, textTrack } = demuxResult;\n        const videoData = videoTrack.pesData;\n        const audioData = audioTrack.pesData;\n        const id3Data = id3Track.pesData;\n        // try to parse last PES packets\n        let pes;\n        if (videoData && (pes = parsePES(videoData))) {\n            this.videoParser.parseAVCPES(videoTrack, textTrack, pes, true, this._duration);\n            videoTrack.pesData = null;\n        } else {\n            // either avcData null or PES truncated, keep it for next frag parsing\n            videoTrack.pesData = videoData;\n        }\n        if (audioData && (pes = parsePES(audioData))) {\n            switch(audioTrack.segmentCodec){\n                case \"aac\":\n                    this.parseAACPES(audioTrack, pes);\n                    break;\n                case \"mp3\":\n                    this.parseMPEGPES(audioTrack, pes);\n                    break;\n                case \"ac3\":\n                    {\n                        this.parseAC3PES(audioTrack, pes);\n                    }\n                    break;\n            }\n            audioTrack.pesData = null;\n        } else {\n            if (audioData != null && audioData.size) {\n                logger.log(\"last AAC PES packet truncated,might overlap between fragments\");\n            }\n            // either audioData null or PES truncated, keep it for next frag parsing\n            audioTrack.pesData = audioData;\n        }\n        if (id3Data && (pes = parsePES(id3Data))) {\n            this.parseID3PES(id3Track, pes);\n            id3Track.pesData = null;\n        } else {\n            // either id3Data null or PES truncated, keep it for next frag parsing\n            id3Track.pesData = id3Data;\n        }\n    }\n    demuxSampleAes(data, keyData, timeOffset) {\n        const demuxResult = this.demux(data, timeOffset, true, !this.config.progressive);\n        const sampleAes = this.sampleAes = new SampleAesDecrypter(this.observer, this.config, keyData);\n        return this.decrypt(demuxResult, sampleAes);\n    }\n    decrypt(demuxResult, sampleAes) {\n        return new Promise((resolve)=>{\n            const { audioTrack, videoTrack } = demuxResult;\n            if (audioTrack.samples && audioTrack.segmentCodec === \"aac\") {\n                sampleAes.decryptAacSamples(audioTrack.samples, 0, ()=>{\n                    if (videoTrack.samples) {\n                        sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, ()=>{\n                            resolve(demuxResult);\n                        });\n                    } else {\n                        resolve(demuxResult);\n                    }\n                });\n            } else if (videoTrack.samples) {\n                sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, ()=>{\n                    resolve(demuxResult);\n                });\n            }\n        });\n    }\n    destroy() {\n        this._duration = 0;\n    }\n    parseAACPES(track, pes) {\n        let startOffset = 0;\n        const aacOverFlow = this.aacOverFlow;\n        let data = pes.data;\n        if (aacOverFlow) {\n            this.aacOverFlow = null;\n            const frameMissingBytes = aacOverFlow.missing;\n            const sampleLength = aacOverFlow.sample.unit.byteLength;\n            // logger.log(`AAC: append overflowing ${sampleLength} bytes to beginning of new PES`);\n            if (frameMissingBytes === -1) {\n                data = appendUint8Array(aacOverFlow.sample.unit, data);\n            } else {\n                const frameOverflowBytes = sampleLength - frameMissingBytes;\n                aacOverFlow.sample.unit.set(data.subarray(0, frameMissingBytes), frameOverflowBytes);\n                track.samples.push(aacOverFlow.sample);\n                startOffset = aacOverFlow.missing;\n            }\n        }\n        // look for ADTS header (0xFFFx)\n        let offset;\n        let len;\n        for(offset = startOffset, len = data.length; offset < len - 1; offset++){\n            if (isHeader$1(data, offset)) {\n                break;\n            }\n        }\n        // if ADTS header does not start straight from the beginning of the PES payload, raise an error\n        if (offset !== startOffset) {\n            let reason;\n            const recoverable = offset < len - 1;\n            if (recoverable) {\n                reason = `AAC PES did not start with ADTS header,offset:${offset}`;\n            } else {\n                reason = \"No ADTS header found in AAC PES\";\n            }\n            const error = new Error(reason);\n            logger.warn(`parsing error: ${reason}`);\n            this.observer.emit(Events.ERROR, Events.ERROR, {\n                type: ErrorTypes.MEDIA_ERROR,\n                details: ErrorDetails.FRAG_PARSING_ERROR,\n                fatal: false,\n                levelRetry: recoverable,\n                error,\n                reason\n            });\n            if (!recoverable) {\n                return;\n            }\n        }\n        initTrackConfig(track, this.observer, data, offset, this.audioCodec);\n        let pts;\n        if (pes.pts !== undefined) {\n            pts = pes.pts;\n        } else if (aacOverFlow) {\n            // if last AAC frame is overflowing, we should ensure timestamps are contiguous:\n            // first sample PTS should be equal to last sample PTS + frameDuration\n            const frameDuration = getFrameDuration(track.samplerate);\n            pts = aacOverFlow.sample.pts + frameDuration;\n        } else {\n            logger.warn(\"[tsdemuxer]: AAC PES unknown PTS\");\n            return;\n        }\n        // scan for aac samples\n        let frameIndex = 0;\n        let frame;\n        while(offset < len){\n            frame = appendFrame$2(track, data, offset, pts, frameIndex);\n            offset += frame.length;\n            if (!frame.missing) {\n                frameIndex++;\n                for(; offset < len - 1; offset++){\n                    if (isHeader$1(data, offset)) {\n                        break;\n                    }\n                }\n            } else {\n                this.aacOverFlow = frame;\n                break;\n            }\n        }\n    }\n    parseMPEGPES(track, pes) {\n        const data = pes.data;\n        const length = data.length;\n        let frameIndex = 0;\n        let offset = 0;\n        const pts = pes.pts;\n        if (pts === undefined) {\n            logger.warn(\"[tsdemuxer]: MPEG PES unknown PTS\");\n            return;\n        }\n        while(offset < length){\n            if (isHeader(data, offset)) {\n                const frame = appendFrame$1(track, data, offset, pts, frameIndex);\n                if (frame) {\n                    offset += frame.length;\n                    frameIndex++;\n                } else {\n                    break;\n                }\n            } else {\n                // nothing found, keep looking\n                offset++;\n            }\n        }\n    }\n    parseAC3PES(track, pes) {\n        {\n            const data = pes.data;\n            const pts = pes.pts;\n            if (pts === undefined) {\n                logger.warn(\"[tsdemuxer]: AC3 PES unknown PTS\");\n                return;\n            }\n            const length = data.length;\n            let frameIndex = 0;\n            let offset = 0;\n            let parsed;\n            while(offset < length && (parsed = appendFrame(track, data, offset, pts, frameIndex++)) > 0){\n                offset += parsed;\n            }\n        }\n    }\n    parseID3PES(id3Track, pes) {\n        if (pes.pts === undefined) {\n            logger.warn(\"[tsdemuxer]: ID3 PES unknown PTS\");\n            return;\n        }\n        const id3Sample = _extends({}, pes, {\n            type: this._videoTrack ? MetadataSchema.emsg : MetadataSchema.audioId3,\n            duration: Number.POSITIVE_INFINITY\n        });\n        id3Track.samples.push(id3Sample);\n    }\n}\nfunction parsePID(data, offset) {\n    // pid is a 13-bit field starting at the last bit of TS[1]\n    return ((data[offset + 1] & 0x1f) << 8) + data[offset + 2];\n}\nfunction parsePAT(data, offset) {\n    // skip the PSI header and parse the first PMT entry\n    return (data[offset + 10] & 0x1f) << 8 | data[offset + 11];\n}\nfunction parsePMT(data, offset, typeSupported, isSampleAes) {\n    const result = {\n        audioPid: -1,\n        videoPid: -1,\n        id3Pid: -1,\n        segmentVideoCodec: \"avc\",\n        segmentAudioCodec: \"aac\"\n    };\n    const sectionLength = (data[offset + 1] & 0x0f) << 8 | data[offset + 2];\n    const tableEnd = offset + 3 + sectionLength - 4;\n    // to determine where the table is, we have to figure out how\n    // long the program info descriptors are\n    const programInfoLength = (data[offset + 10] & 0x0f) << 8 | data[offset + 11];\n    // advance the offset to the first entry in the mapping table\n    offset += 12 + programInfoLength;\n    while(offset < tableEnd){\n        const pid = parsePID(data, offset);\n        const esInfoLength = (data[offset + 3] & 0x0f) << 8 | data[offset + 4];\n        switch(data[offset]){\n            case 0xcf:\n                // SAMPLE-AES AAC\n                if (!isSampleAes) {\n                    logEncryptedSamplesFoundInUnencryptedStream(\"ADTS AAC\");\n                    break;\n                }\n            /* falls through */ case 0x0f:\n                // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)\n                // logger.log('AAC PID:'  + pid);\n                if (result.audioPid === -1) {\n                    result.audioPid = pid;\n                }\n                break;\n            // Packetized metadata (ID3)\n            case 0x15:\n                // logger.log('ID3 PID:'  + pid);\n                if (result.id3Pid === -1) {\n                    result.id3Pid = pid;\n                }\n                break;\n            case 0xdb:\n                // SAMPLE-AES AVC\n                if (!isSampleAes) {\n                    logEncryptedSamplesFoundInUnencryptedStream(\"H.264\");\n                    break;\n                }\n            /* falls through */ case 0x1b:\n                // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)\n                // logger.log('AVC PID:'  + pid);\n                if (result.videoPid === -1) {\n                    result.videoPid = pid;\n                    result.segmentVideoCodec = \"avc\";\n                }\n                break;\n            // ISO/IEC 11172-3 (MPEG-1 audio)\n            // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)\n            case 0x03:\n            case 0x04:\n                // logger.log('MPEG PID:'  + pid);\n                if (!typeSupported.mpeg && !typeSupported.mp3) {\n                    logger.log(\"MPEG audio found, not supported in this browser\");\n                } else if (result.audioPid === -1) {\n                    result.audioPid = pid;\n                    result.segmentAudioCodec = \"mp3\";\n                }\n                break;\n            case 0xc1:\n                // SAMPLE-AES AC3\n                if (!isSampleAes) {\n                    logEncryptedSamplesFoundInUnencryptedStream(\"AC-3\");\n                    break;\n                }\n            /* falls through */ case 0x81:\n                {\n                    if (!typeSupported.ac3) {\n                        logger.log(\"AC-3 audio found, not supported in this browser\");\n                    } else if (result.audioPid === -1) {\n                        result.audioPid = pid;\n                        result.segmentAudioCodec = \"ac3\";\n                    }\n                }\n                break;\n            case 0x06:\n                // stream_type 6 can mean a lot of different things in case of DVB.\n                // We need to look at the descriptors. Right now, we're only interested\n                // in AC-3 audio, so we do the descriptor parsing only when we don't have\n                // an audio PID yet.\n                if (result.audioPid === -1 && esInfoLength > 0) {\n                    let parsePos = offset + 5;\n                    let remaining = esInfoLength;\n                    while(remaining > 2){\n                        const descriptorId = data[parsePos];\n                        switch(descriptorId){\n                            case 0x6a:\n                                // DVB Descriptor for AC-3\n                                {\n                                    if (typeSupported.ac3 !== true) {\n                                        logger.log(\"AC-3 audio found, not supported in this browser for now\");\n                                    } else {\n                                        result.audioPid = pid;\n                                        result.segmentAudioCodec = \"ac3\";\n                                    }\n                                }\n                                break;\n                        }\n                        const descriptorLen = data[parsePos + 1] + 2;\n                        parsePos += descriptorLen;\n                        remaining -= descriptorLen;\n                    }\n                }\n                break;\n            case 0xc2:\n            /* falls through */ case 0x87:\n                logger.warn(\"Unsupported EC-3 in M2TS found\");\n                break;\n            case 0x24:\n                logger.warn(\"Unsupported HEVC in M2TS found\");\n                break;\n        }\n        // move to the next table entry\n        // skip past the elementary stream descriptors, if present\n        offset += esInfoLength + 5;\n    }\n    return result;\n}\nfunction logEncryptedSamplesFoundInUnencryptedStream(type) {\n    logger.log(`${type} with AES-128-CBC encryption found in unencrypted stream`);\n}\nfunction parsePES(stream) {\n    let i = 0;\n    let frag;\n    let pesLen;\n    let pesHdrLen;\n    let pesPts;\n    let pesDts;\n    const data = stream.data;\n    // safety check\n    if (!stream || stream.size === 0) {\n        return null;\n    }\n    // we might need up to 19 bytes to read PES header\n    // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes\n    // usually only one merge is needed (and this is rare ...)\n    while(data[0].length < 19 && data.length > 1){\n        data[0] = appendUint8Array(data[0], data[1]);\n        data.splice(1, 1);\n    }\n    // retrieve PTS/DTS from first fragment\n    frag = data[0];\n    const pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];\n    if (pesPrefix === 1) {\n        pesLen = (frag[4] << 8) + frag[5];\n        // if PES parsed length is not zero and greater than total received length, stop parsing. PES might be truncated\n        // minus 6 : PES header size\n        if (pesLen && pesLen > stream.size - 6) {\n            return null;\n        }\n        const pesFlags = frag[7];\n        if (pesFlags & 0xc0) {\n            /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n          as PTS / DTS is 33 bit we cannot use bitwise operator in JS,\n          as Bitwise operators treat their operands as a sequence of 32 bits */ pesPts = (frag[9] & 0x0e) * 536870912 + // 1 << 29\n            (frag[10] & 0xff) * 4194304 + // 1 << 22\n            (frag[11] & 0xfe) * 16384 + // 1 << 14\n            (frag[12] & 0xff) * 128 + // 1 << 7\n            (frag[13] & 0xfe) / 2;\n            if (pesFlags & 0x40) {\n                pesDts = (frag[14] & 0x0e) * 536870912 + // 1 << 29\n                (frag[15] & 0xff) * 4194304 + // 1 << 22\n                (frag[16] & 0xfe) * 16384 + // 1 << 14\n                (frag[17] & 0xff) * 128 + // 1 << 7\n                (frag[18] & 0xfe) / 2;\n                if (pesPts - pesDts > 60 * 90000) {\n                    logger.warn(`${Math.round((pesPts - pesDts) / 90000)}s delta between PTS and DTS, align them`);\n                    pesPts = pesDts;\n                }\n            } else {\n                pesDts = pesPts;\n            }\n        }\n        pesHdrLen = frag[8];\n        // 9 bytes : 6 bytes for PES header + 3 bytes for PES extension\n        let payloadStartOffset = pesHdrLen + 9;\n        if (stream.size <= payloadStartOffset) {\n            return null;\n        }\n        stream.size -= payloadStartOffset;\n        // reassemble PES packet\n        const pesData = new Uint8Array(stream.size);\n        for(let j = 0, dataLen = data.length; j < dataLen; j++){\n            frag = data[j];\n            let len = frag.byteLength;\n            if (payloadStartOffset) {\n                if (payloadStartOffset > len) {\n                    // trim full frag if PES header bigger than frag\n                    payloadStartOffset -= len;\n                    continue;\n                } else {\n                    // trim partial frag if PES header smaller than frag\n                    frag = frag.subarray(payloadStartOffset);\n                    len -= payloadStartOffset;\n                    payloadStartOffset = 0;\n                }\n            }\n            pesData.set(frag, i);\n            i += len;\n        }\n        if (pesLen) {\n            // payload size : remove PES header + PES extension\n            pesLen -= pesHdrLen + 3;\n        }\n        return {\n            data: pesData,\n            pts: pesPts,\n            dts: pesDts,\n            len: pesLen\n        };\n    }\n    return null;\n}\n/**\n * MP3 demuxer\n */ class MP3Demuxer extends BaseAudioDemuxer {\n    resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n        super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);\n        this._audioTrack = {\n            container: \"audio/mpeg\",\n            type: \"audio\",\n            id: 2,\n            pid: -1,\n            sequenceNumber: 0,\n            segmentCodec: \"mp3\",\n            samples: [],\n            manifestCodec: audioCodec,\n            duration: trackDuration,\n            inputTimeScale: 90000,\n            dropped: 0\n        };\n    }\n    static probe(data) {\n        if (!data) {\n            return false;\n        }\n        // check if data contains ID3 timestamp and MPEG sync word\n        // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1\n        // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)\n        // More info http://www.mp3-tech.org/programmer/frame_header.html\n        const id3Data = getID3Data(data, 0);\n        let offset = (id3Data == null ? void 0 : id3Data.length) || 0;\n        // Check for ac-3|ec-3 sync bytes and return false if present\n        if (id3Data && data[offset] === 0x0b && data[offset + 1] === 0x77 && getTimeStamp(id3Data) !== undefined && // check the bsid to confirm ac-3 or ec-3 (not mp3)\n        getAudioBSID(data, offset) <= 16) {\n            return false;\n        }\n        for(let length = data.length; offset < length; offset++){\n            if (probe(data, offset)) {\n                logger.log(\"MPEG Audio sync word found !\");\n                return true;\n            }\n        }\n        return false;\n    }\n    canParse(data, offset) {\n        return canParse(data, offset);\n    }\n    appendFrame(track, data, offset) {\n        if (this.basePTS === null) {\n            return;\n        }\n        return appendFrame$1(track, data, offset, this.basePTS, this.frameIndex);\n    }\n}\n/**\n *  AAC helper\n */ class AAC {\n    static getSilentFrame(codec, channelCount) {\n        switch(codec){\n            case \"mp4a.40.2\":\n                if (channelCount === 1) {\n                    return new Uint8Array([\n                        0x00,\n                        0xc8,\n                        0x00,\n                        0x80,\n                        0x23,\n                        0x80\n                    ]);\n                } else if (channelCount === 2) {\n                    return new Uint8Array([\n                        0x21,\n                        0x00,\n                        0x49,\n                        0x90,\n                        0x02,\n                        0x19,\n                        0x00,\n                        0x23,\n                        0x80\n                    ]);\n                } else if (channelCount === 3) {\n                    return new Uint8Array([\n                        0x00,\n                        0xc8,\n                        0x00,\n                        0x80,\n                        0x20,\n                        0x84,\n                        0x01,\n                        0x26,\n                        0x40,\n                        0x08,\n                        0x64,\n                        0x00,\n                        0x8e\n                    ]);\n                } else if (channelCount === 4) {\n                    return new Uint8Array([\n                        0x00,\n                        0xc8,\n                        0x00,\n                        0x80,\n                        0x20,\n                        0x84,\n                        0x01,\n                        0x26,\n                        0x40,\n                        0x08,\n                        0x64,\n                        0x00,\n                        0x80,\n                        0x2c,\n                        0x80,\n                        0x08,\n                        0x02,\n                        0x38\n                    ]);\n                } else if (channelCount === 5) {\n                    return new Uint8Array([\n                        0x00,\n                        0xc8,\n                        0x00,\n                        0x80,\n                        0x20,\n                        0x84,\n                        0x01,\n                        0x26,\n                        0x40,\n                        0x08,\n                        0x64,\n                        0x00,\n                        0x82,\n                        0x30,\n                        0x04,\n                        0x99,\n                        0x00,\n                        0x21,\n                        0x90,\n                        0x02,\n                        0x38\n                    ]);\n                } else if (channelCount === 6) {\n                    return new Uint8Array([\n                        0x00,\n                        0xc8,\n                        0x00,\n                        0x80,\n                        0x20,\n                        0x84,\n                        0x01,\n                        0x26,\n                        0x40,\n                        0x08,\n                        0x64,\n                        0x00,\n                        0x82,\n                        0x30,\n                        0x04,\n                        0x99,\n                        0x00,\n                        0x21,\n                        0x90,\n                        0x02,\n                        0x00,\n                        0xb2,\n                        0x00,\n                        0x20,\n                        0x08,\n                        0xe0\n                    ]);\n                }\n                break;\n            // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)\n            default:\n                if (channelCount === 1) {\n                    // ffmpeg -y -f lavfi -i \"aevalsrc=0:d=0.05\" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n                    return new Uint8Array([\n                        0x1,\n                        0x40,\n                        0x22,\n                        0x80,\n                        0xa3,\n                        0x4e,\n                        0xe6,\n                        0x80,\n                        0xba,\n                        0x8,\n                        0x0,\n                        0x0,\n                        0x0,\n                        0x1c,\n                        0x6,\n                        0xf1,\n                        0xc1,\n                        0xa,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5e\n                    ]);\n                } else if (channelCount === 2) {\n                    // ffmpeg -y -f lavfi -i \"aevalsrc=0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n                    return new Uint8Array([\n                        0x1,\n                        0x40,\n                        0x22,\n                        0x80,\n                        0xa3,\n                        0x5e,\n                        0xe6,\n                        0x80,\n                        0xba,\n                        0x8,\n                        0x0,\n                        0x0,\n                        0x0,\n                        0x0,\n                        0x95,\n                        0x0,\n                        0x6,\n                        0xf1,\n                        0xa1,\n                        0xa,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5e\n                    ]);\n                } else if (channelCount === 3) {\n                    // ffmpeg -y -f lavfi -i \"aevalsrc=0|0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n                    return new Uint8Array([\n                        0x1,\n                        0x40,\n                        0x22,\n                        0x80,\n                        0xa3,\n                        0x5e,\n                        0xe6,\n                        0x80,\n                        0xba,\n                        0x8,\n                        0x0,\n                        0x0,\n                        0x0,\n                        0x0,\n                        0x95,\n                        0x0,\n                        0x6,\n                        0xf1,\n                        0xa1,\n                        0xa,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5e\n                    ]);\n                }\n                break;\n        }\n        return undefined;\n    }\n}\n/**\n * Generate MP4 Box\n */ const UINT32_MAX = Math.pow(2, 32) - 1;\nclass MP4 {\n    static init() {\n        MP4.types = {\n            avc1: [],\n            // codingname\n            avcC: [],\n            btrt: [],\n            dinf: [],\n            dref: [],\n            esds: [],\n            ftyp: [],\n            hdlr: [],\n            mdat: [],\n            mdhd: [],\n            mdia: [],\n            mfhd: [],\n            minf: [],\n            moof: [],\n            moov: [],\n            mp4a: [],\n            \".mp3\": [],\n            dac3: [],\n            \"ac-3\": [],\n            mvex: [],\n            mvhd: [],\n            pasp: [],\n            sdtp: [],\n            stbl: [],\n            stco: [],\n            stsc: [],\n            stsd: [],\n            stsz: [],\n            stts: [],\n            tfdt: [],\n            tfhd: [],\n            traf: [],\n            trak: [],\n            trun: [],\n            trex: [],\n            tkhd: [],\n            vmhd: [],\n            smhd: []\n        };\n        let i;\n        for(i in MP4.types){\n            if (MP4.types.hasOwnProperty(i)) {\n                MP4.types[i] = [\n                    i.charCodeAt(0),\n                    i.charCodeAt(1),\n                    i.charCodeAt(2),\n                    i.charCodeAt(3)\n                ];\n            }\n        }\n        const videoHdlr = new Uint8Array([\n            0x00,\n            // version 0\n            0x00,\n            0x00,\n            0x00,\n            // flags\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // pre_defined\n            0x76,\n            0x69,\n            0x64,\n            0x65,\n            // handler_type: 'vide'\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // reserved\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // reserved\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // reserved\n            0x56,\n            0x69,\n            0x64,\n            0x65,\n            0x6f,\n            0x48,\n            0x61,\n            0x6e,\n            0x64,\n            0x6c,\n            0x65,\n            0x72,\n            0x00 // name: 'VideoHandler'\n        ]);\n        const audioHdlr = new Uint8Array([\n            0x00,\n            // version 0\n            0x00,\n            0x00,\n            0x00,\n            // flags\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // pre_defined\n            0x73,\n            0x6f,\n            0x75,\n            0x6e,\n            // handler_type: 'soun'\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // reserved\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // reserved\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // reserved\n            0x53,\n            0x6f,\n            0x75,\n            0x6e,\n            0x64,\n            0x48,\n            0x61,\n            0x6e,\n            0x64,\n            0x6c,\n            0x65,\n            0x72,\n            0x00 // name: 'SoundHandler'\n        ]);\n        MP4.HDLR_TYPES = {\n            video: videoHdlr,\n            audio: audioHdlr\n        };\n        const dref = new Uint8Array([\n            0x00,\n            // version 0\n            0x00,\n            0x00,\n            0x00,\n            // flags\n            0x00,\n            0x00,\n            0x00,\n            0x01,\n            // entry_count\n            0x00,\n            0x00,\n            0x00,\n            0x0c,\n            // entry_size\n            0x75,\n            0x72,\n            0x6c,\n            0x20,\n            // 'url' type\n            0x00,\n            // version 0\n            0x00,\n            0x00,\n            0x01 // entry_flags\n        ]);\n        const stco = new Uint8Array([\n            0x00,\n            // version\n            0x00,\n            0x00,\n            0x00,\n            // flags\n            0x00,\n            0x00,\n            0x00,\n            0x00 // entry_count\n        ]);\n        MP4.STTS = MP4.STSC = MP4.STCO = stco;\n        MP4.STSZ = new Uint8Array([\n            0x00,\n            // version\n            0x00,\n            0x00,\n            0x00,\n            // flags\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // sample_size\n            0x00,\n            0x00,\n            0x00,\n            0x00 // sample_count\n        ]);\n        MP4.VMHD = new Uint8Array([\n            0x00,\n            // version\n            0x00,\n            0x00,\n            0x01,\n            // flags\n            0x00,\n            0x00,\n            // graphicsmode\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00 // opcolor\n        ]);\n        MP4.SMHD = new Uint8Array([\n            0x00,\n            // version\n            0x00,\n            0x00,\n            0x00,\n            // flags\n            0x00,\n            0x00,\n            // balance\n            0x00,\n            0x00 // reserved\n        ]);\n        MP4.STSD = new Uint8Array([\n            0x00,\n            // version 0\n            0x00,\n            0x00,\n            0x00,\n            // flags\n            0x00,\n            0x00,\n            0x00,\n            0x01\n        ]); // entry_count\n        const majorBrand = new Uint8Array([\n            105,\n            115,\n            111,\n            109\n        ]); // isom\n        const avc1Brand = new Uint8Array([\n            97,\n            118,\n            99,\n            49\n        ]); // avc1\n        const minorVersion = new Uint8Array([\n            0,\n            0,\n            0,\n            1\n        ]);\n        MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);\n        MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));\n    }\n    static box(type, ...payload) {\n        let size = 8;\n        let i = payload.length;\n        const len = i;\n        // calculate the total size we need to allocate\n        while(i--){\n            size += payload[i].byteLength;\n        }\n        const result = new Uint8Array(size);\n        result[0] = size >> 24 & 0xff;\n        result[1] = size >> 16 & 0xff;\n        result[2] = size >> 8 & 0xff;\n        result[3] = size & 0xff;\n        result.set(type, 4);\n        // copy the payload into the result\n        for(i = 0, size = 8; i < len; i++){\n            // copy payload[i] array @ offset size\n            result.set(payload[i], size);\n            size += payload[i].byteLength;\n        }\n        return result;\n    }\n    static hdlr(type) {\n        return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);\n    }\n    static mdat(data) {\n        return MP4.box(MP4.types.mdat, data);\n    }\n    static mdhd(timescale, duration) {\n        duration *= timescale;\n        const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n        const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n        return MP4.box(MP4.types.mdhd, new Uint8Array([\n            0x01,\n            // version 1\n            0x00,\n            0x00,\n            0x00,\n            // flags\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x02,\n            // creation_time\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x03,\n            // modification_time\n            timescale >> 24 & 0xff,\n            timescale >> 16 & 0xff,\n            timescale >> 8 & 0xff,\n            timescale & 0xff,\n            // timescale\n            upperWordDuration >> 24,\n            upperWordDuration >> 16 & 0xff,\n            upperWordDuration >> 8 & 0xff,\n            upperWordDuration & 0xff,\n            lowerWordDuration >> 24,\n            lowerWordDuration >> 16 & 0xff,\n            lowerWordDuration >> 8 & 0xff,\n            lowerWordDuration & 0xff,\n            0x55,\n            0xc4,\n            // 'und' language (undetermined)\n            0x00,\n            0x00\n        ]));\n    }\n    static mdia(track) {\n        return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale, track.duration), MP4.hdlr(track.type), MP4.minf(track));\n    }\n    static mfhd(sequenceNumber) {\n        return MP4.box(MP4.types.mfhd, new Uint8Array([\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // flags\n            sequenceNumber >> 24,\n            sequenceNumber >> 16 & 0xff,\n            sequenceNumber >> 8 & 0xff,\n            sequenceNumber & 0xff // sequence_number\n        ]));\n    }\n    static minf(track) {\n        if (track.type === \"audio\") {\n            return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));\n        } else {\n            return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));\n        }\n    }\n    static moof(sn, baseMediaDecodeTime, track) {\n        return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));\n    }\n    static moov(tracks) {\n        let i = tracks.length;\n        const boxes = [];\n        while(i--){\n            boxes[i] = MP4.trak(tracks[i]);\n        }\n        return MP4.box.apply(null, [\n            MP4.types.moov,\n            MP4.mvhd(tracks[0].timescale, tracks[0].duration)\n        ].concat(boxes).concat(MP4.mvex(tracks)));\n    }\n    static mvex(tracks) {\n        let i = tracks.length;\n        const boxes = [];\n        while(i--){\n            boxes[i] = MP4.trex(tracks[i]);\n        }\n        return MP4.box.apply(null, [\n            MP4.types.mvex,\n            ...boxes\n        ]);\n    }\n    static mvhd(timescale, duration) {\n        duration *= timescale;\n        const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n        const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n        const bytes = new Uint8Array([\n            0x01,\n            // version 1\n            0x00,\n            0x00,\n            0x00,\n            // flags\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x02,\n            // creation_time\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x03,\n            // modification_time\n            timescale >> 24 & 0xff,\n            timescale >> 16 & 0xff,\n            timescale >> 8 & 0xff,\n            timescale & 0xff,\n            // timescale\n            upperWordDuration >> 24,\n            upperWordDuration >> 16 & 0xff,\n            upperWordDuration >> 8 & 0xff,\n            upperWordDuration & 0xff,\n            lowerWordDuration >> 24,\n            lowerWordDuration >> 16 & 0xff,\n            lowerWordDuration >> 8 & 0xff,\n            lowerWordDuration & 0xff,\n            0x00,\n            0x01,\n            0x00,\n            0x00,\n            // 1.0 rate\n            0x01,\n            0x00,\n            // 1.0 volume\n            0x00,\n            0x00,\n            // reserved\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // reserved\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // reserved\n            0x00,\n            0x01,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x01,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x40,\n            0x00,\n            0x00,\n            0x00,\n            // transformation: unity matrix\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // pre_defined\n            0xff,\n            0xff,\n            0xff,\n            0xff // next_track_ID\n        ]);\n        return MP4.box(MP4.types.mvhd, bytes);\n    }\n    static sdtp(track) {\n        const samples = track.samples || [];\n        const bytes = new Uint8Array(4 + samples.length);\n        let i;\n        let flags;\n        // leave the full box header (4 bytes) all zero\n        // write the sample table\n        for(i = 0; i < samples.length; i++){\n            flags = samples[i].flags;\n            bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;\n        }\n        return MP4.box(MP4.types.sdtp, bytes);\n    }\n    static stbl(track) {\n        return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));\n    }\n    static avc1(track) {\n        let sps = [];\n        let pps = [];\n        let i;\n        let data;\n        let len;\n        // assemble the SPSs\n        for(i = 0; i < track.sps.length; i++){\n            data = track.sps[i];\n            len = data.byteLength;\n            sps.push(len >>> 8 & 0xff);\n            sps.push(len & 0xff);\n            // SPS\n            sps = sps.concat(Array.prototype.slice.call(data));\n        }\n        // assemble the PPSs\n        for(i = 0; i < track.pps.length; i++){\n            data = track.pps[i];\n            len = data.byteLength;\n            pps.push(len >>> 8 & 0xff);\n            pps.push(len & 0xff);\n            pps = pps.concat(Array.prototype.slice.call(data));\n        }\n        const avcc = MP4.box(MP4.types.avcC, new Uint8Array([\n            0x01,\n            // version\n            sps[3],\n            // profile\n            sps[4],\n            // profile compat\n            sps[5],\n            // level\n            0xfc | 3,\n            // lengthSizeMinusOne, hard-coded to 4 bytes\n            0xe0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets\n        ].concat(sps).concat([\n            track.pps.length // numOfPictureParameterSets\n        ]).concat(pps))); // \"PPS\"\n        const width = track.width;\n        const height = track.height;\n        const hSpacing = track.pixelRatio[0];\n        const vSpacing = track.pixelRatio[1];\n        return MP4.box(MP4.types.avc1, new Uint8Array([\n            0x00,\n            0x00,\n            0x00,\n            // reserved\n            0x00,\n            0x00,\n            0x00,\n            // reserved\n            0x00,\n            0x01,\n            // data_reference_index\n            0x00,\n            0x00,\n            // pre_defined\n            0x00,\n            0x00,\n            // reserved\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // pre_defined\n            width >> 8 & 0xff,\n            width & 0xff,\n            // width\n            height >> 8 & 0xff,\n            height & 0xff,\n            // height\n            0x00,\n            0x48,\n            0x00,\n            0x00,\n            // horizresolution\n            0x00,\n            0x48,\n            0x00,\n            0x00,\n            // vertresolution\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // reserved\n            0x00,\n            0x01,\n            // frame_count\n            0x12,\n            0x64,\n            0x61,\n            0x69,\n            0x6c,\n            // dailymotion/hls.js\n            0x79,\n            0x6d,\n            0x6f,\n            0x74,\n            0x69,\n            0x6f,\n            0x6e,\n            0x2f,\n            0x68,\n            0x6c,\n            0x73,\n            0x2e,\n            0x6a,\n            0x73,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // compressorname\n            0x00,\n            0x18,\n            // depth = 24\n            0x11,\n            0x11\n        ]), // pre_defined = -1\n        avcc, MP4.box(MP4.types.btrt, new Uint8Array([\n            0x00,\n            0x1c,\n            0x9c,\n            0x80,\n            // bufferSizeDB\n            0x00,\n            0x2d,\n            0xc6,\n            0xc0,\n            // maxBitrate\n            0x00,\n            0x2d,\n            0xc6,\n            0xc0\n        ])), // avgBitrate\n        MP4.box(MP4.types.pasp, new Uint8Array([\n            hSpacing >> 24,\n            // hSpacing\n            hSpacing >> 16 & 0xff,\n            hSpacing >> 8 & 0xff,\n            hSpacing & 0xff,\n            vSpacing >> 24,\n            // vSpacing\n            vSpacing >> 16 & 0xff,\n            vSpacing >> 8 & 0xff,\n            vSpacing & 0xff\n        ])));\n    }\n    static esds(track) {\n        const configlen = track.config.length;\n        return new Uint8Array([\n            0x00,\n            // version 0\n            0x00,\n            0x00,\n            0x00,\n            // flags\n            0x03,\n            // descriptor_type\n            0x17 + configlen,\n            // length\n            0x00,\n            0x01,\n            // es_id\n            0x00,\n            // stream_priority\n            0x04,\n            // descriptor_type\n            0x0f + configlen,\n            // length\n            0x40,\n            // codec : mpeg4_audio\n            0x15,\n            // stream_type\n            0x00,\n            0x00,\n            0x00,\n            // buffer_size\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // maxBitrate\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // avgBitrate\n            0x05 // descriptor_type\n        ].concat([\n            configlen\n        ]).concat(track.config).concat([\n            0x06,\n            0x01,\n            0x02\n        ])); // GASpecificConfig)); // length + audio config descriptor\n    }\n    static audioStsd(track) {\n        const samplerate = track.samplerate;\n        return new Uint8Array([\n            0x00,\n            0x00,\n            0x00,\n            // reserved\n            0x00,\n            0x00,\n            0x00,\n            // reserved\n            0x00,\n            0x01,\n            // data_reference_index\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // reserved\n            0x00,\n            track.channelCount,\n            // channelcount\n            0x00,\n            0x10,\n            // sampleSize:16bits\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // reserved2\n            samplerate >> 8 & 0xff,\n            samplerate & 0xff,\n            //\n            0x00,\n            0x00\n        ]);\n    }\n    static mp4a(track) {\n        return MP4.box(MP4.types.mp4a, MP4.audioStsd(track), MP4.box(MP4.types.esds, MP4.esds(track)));\n    }\n    static mp3(track) {\n        return MP4.box(MP4.types[\".mp3\"], MP4.audioStsd(track));\n    }\n    static ac3(track) {\n        return MP4.box(MP4.types[\"ac-3\"], MP4.audioStsd(track), MP4.box(MP4.types.dac3, track.config));\n    }\n    static stsd(track) {\n        if (track.type === \"audio\") {\n            if (track.segmentCodec === \"mp3\" && track.codec === \"mp3\") {\n                return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));\n            }\n            if (track.segmentCodec === \"ac3\") {\n                return MP4.box(MP4.types.stsd, MP4.STSD, MP4.ac3(track));\n            }\n            return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));\n        } else {\n            return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));\n        }\n    }\n    static tkhd(track) {\n        const id = track.id;\n        const duration = track.duration * track.timescale;\n        const width = track.width;\n        const height = track.height;\n        const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n        const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n        return MP4.box(MP4.types.tkhd, new Uint8Array([\n            0x01,\n            // version 1\n            0x00,\n            0x00,\n            0x07,\n            // flags\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x02,\n            // creation_time\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x03,\n            // modification_time\n            id >> 24 & 0xff,\n            id >> 16 & 0xff,\n            id >> 8 & 0xff,\n            id & 0xff,\n            // track_ID\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // reserved\n            upperWordDuration >> 24,\n            upperWordDuration >> 16 & 0xff,\n            upperWordDuration >> 8 & 0xff,\n            upperWordDuration & 0xff,\n            lowerWordDuration >> 24,\n            lowerWordDuration >> 16 & 0xff,\n            lowerWordDuration >> 8 & 0xff,\n            lowerWordDuration & 0xff,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // reserved\n            0x00,\n            0x00,\n            // layer\n            0x00,\n            0x00,\n            // alternate_group\n            0x00,\n            0x00,\n            // non-audio track volume\n            0x00,\n            0x00,\n            // reserved\n            0x00,\n            0x01,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x01,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x40,\n            0x00,\n            0x00,\n            0x00,\n            // transformation: unity matrix\n            width >> 8 & 0xff,\n            width & 0xff,\n            0x00,\n            0x00,\n            // width\n            height >> 8 & 0xff,\n            height & 0xff,\n            0x00,\n            0x00 // height\n        ]));\n    }\n    static traf(track, baseMediaDecodeTime) {\n        const sampleDependencyTable = MP4.sdtp(track);\n        const id = track.id;\n        const upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));\n        const lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));\n        return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([\n            0x00,\n            // version 0\n            0x00,\n            0x00,\n            0x00,\n            // flags\n            id >> 24,\n            id >> 16 & 0xff,\n            id >> 8 & 0xff,\n            id & 0xff // track_ID\n        ])), MP4.box(MP4.types.tfdt, new Uint8Array([\n            0x01,\n            // version 1\n            0x00,\n            0x00,\n            0x00,\n            // flags\n            upperWordBaseMediaDecodeTime >> 24,\n            upperWordBaseMediaDecodeTime >> 16 & 0xff,\n            upperWordBaseMediaDecodeTime >> 8 & 0xff,\n            upperWordBaseMediaDecodeTime & 0xff,\n            lowerWordBaseMediaDecodeTime >> 24,\n            lowerWordBaseMediaDecodeTime >> 16 & 0xff,\n            lowerWordBaseMediaDecodeTime >> 8 & 0xff,\n            lowerWordBaseMediaDecodeTime & 0xff\n        ])), MP4.trun(track, sampleDependencyTable.length + 16 + // tfhd\n        20 + // tfdt\n        8 + // traf header\n        16 + // mfhd\n        8 + // moof header\n        8), // mdat header\n        sampleDependencyTable);\n    }\n    /**\n   * Generate a track box.\n   * @param track a track definition\n   */ static trak(track) {\n        track.duration = track.duration || 0xffffffff;\n        return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));\n    }\n    static trex(track) {\n        const id = track.id;\n        return MP4.box(MP4.types.trex, new Uint8Array([\n            0x00,\n            // version 0\n            0x00,\n            0x00,\n            0x00,\n            // flags\n            id >> 24,\n            id >> 16 & 0xff,\n            id >> 8 & 0xff,\n            id & 0xff,\n            // track_ID\n            0x00,\n            0x00,\n            0x00,\n            0x01,\n            // default_sample_description_index\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // default_sample_duration\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // default_sample_size\n            0x00,\n            0x01,\n            0x00,\n            0x01 // default_sample_flags\n        ]));\n    }\n    static trun(track, offset) {\n        const samples = track.samples || [];\n        const len = samples.length;\n        const arraylen = 12 + 16 * len;\n        const array = new Uint8Array(arraylen);\n        let i;\n        let sample;\n        let duration;\n        let size;\n        let flags;\n        let cts;\n        offset += 8 + arraylen;\n        array.set([\n            track.type === \"video\" ? 0x01 : 0x00,\n            // version 1 for video with signed-int sample_composition_time_offset\n            0x00,\n            0x0f,\n            0x01,\n            // flags\n            len >>> 24 & 0xff,\n            len >>> 16 & 0xff,\n            len >>> 8 & 0xff,\n            len & 0xff,\n            // sample_count\n            offset >>> 24 & 0xff,\n            offset >>> 16 & 0xff,\n            offset >>> 8 & 0xff,\n            offset & 0xff // data_offset\n        ], 0);\n        for(i = 0; i < len; i++){\n            sample = samples[i];\n            duration = sample.duration;\n            size = sample.size;\n            flags = sample.flags;\n            cts = sample.cts;\n            array.set([\n                duration >>> 24 & 0xff,\n                duration >>> 16 & 0xff,\n                duration >>> 8 & 0xff,\n                duration & 0xff,\n                // sample_duration\n                size >>> 24 & 0xff,\n                size >>> 16 & 0xff,\n                size >>> 8 & 0xff,\n                size & 0xff,\n                // sample_size\n                flags.isLeading << 2 | flags.dependsOn,\n                flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync,\n                flags.degradPrio & 0xf0 << 8,\n                flags.degradPrio & 0x0f,\n                // sample_flags\n                cts >>> 24 & 0xff,\n                cts >>> 16 & 0xff,\n                cts >>> 8 & 0xff,\n                cts & 0xff // sample_composition_time_offset\n            ], 12 + 16 * i);\n        }\n        return MP4.box(MP4.types.trun, array);\n    }\n    static initSegment(tracks) {\n        if (!MP4.types) {\n            MP4.init();\n        }\n        const movie = MP4.moov(tracks);\n        const result = appendUint8Array(MP4.FTYP, movie);\n        return result;\n    }\n}\nMP4.types = void 0;\nMP4.HDLR_TYPES = void 0;\nMP4.STTS = void 0;\nMP4.STSC = void 0;\nMP4.STCO = void 0;\nMP4.STSZ = void 0;\nMP4.VMHD = void 0;\nMP4.SMHD = void 0;\nMP4.STSD = void 0;\nMP4.FTYP = void 0;\nMP4.DINF = void 0;\nconst MPEG_TS_CLOCK_FREQ_HZ = 90000;\nfunction toTimescaleFromBase(baseTime, destScale, srcBase = 1, round = false) {\n    const result = baseTime * destScale * srcBase; // equivalent to `(value * scale) / (1 / base)`\n    return round ? Math.round(result) : result;\n}\nfunction toTimescaleFromScale(baseTime, destScale, srcScale = 1, round = false) {\n    return toTimescaleFromBase(baseTime, destScale, 1 / srcScale, round);\n}\nfunction toMsFromMpegTsClock(baseTime, round = false) {\n    return toTimescaleFromBase(baseTime, 1000, 1 / MPEG_TS_CLOCK_FREQ_HZ, round);\n}\nfunction toMpegTsClockFromTimescale(baseTime, srcScale = 1) {\n    return toTimescaleFromBase(baseTime, MPEG_TS_CLOCK_FREQ_HZ, 1 / srcScale);\n}\nconst MAX_SILENT_FRAME_DURATION = 10 * 1000; // 10 seconds\nconst AAC_SAMPLES_PER_FRAME = 1024;\nconst MPEG_AUDIO_SAMPLE_PER_FRAME = 1152;\nconst AC3_SAMPLES_PER_FRAME = 1536;\nlet chromeVersion = null;\nlet safariWebkitVersion = null;\nclass MP4Remuxer {\n    constructor(observer, config, typeSupported, vendor = \"\"){\n        this.observer = void 0;\n        this.config = void 0;\n        this.typeSupported = void 0;\n        this.ISGenerated = false;\n        this._initPTS = null;\n        this._initDTS = null;\n        this.nextAvcDts = null;\n        this.nextAudioPts = null;\n        this.videoSampleDuration = null;\n        this.isAudioContiguous = false;\n        this.isVideoContiguous = false;\n        this.videoTrackConfig = void 0;\n        this.observer = observer;\n        this.config = config;\n        this.typeSupported = typeSupported;\n        this.ISGenerated = false;\n        if (chromeVersion === null) {\n            const userAgent = navigator.userAgent || \"\";\n            const result = userAgent.match(/Chrome\\/(\\d+)/i);\n            chromeVersion = result ? parseInt(result[1]) : 0;\n        }\n        if (safariWebkitVersion === null) {\n            const result = navigator.userAgent.match(/Safari\\/(\\d+)/i);\n            safariWebkitVersion = result ? parseInt(result[1]) : 0;\n        }\n    }\n    destroy() {\n        // @ts-ignore\n        this.config = this.videoTrackConfig = this._initPTS = this._initDTS = null;\n    }\n    resetTimeStamp(defaultTimeStamp) {\n        logger.log(\"[mp4-remuxer]: initPTS & initDTS reset\");\n        this._initPTS = this._initDTS = defaultTimeStamp;\n    }\n    resetNextTimestamp() {\n        logger.log(\"[mp4-remuxer]: reset next timestamp\");\n        this.isVideoContiguous = false;\n        this.isAudioContiguous = false;\n    }\n    resetInitSegment() {\n        logger.log(\"[mp4-remuxer]: ISGenerated flag reset\");\n        this.ISGenerated = false;\n        this.videoTrackConfig = undefined;\n    }\n    getVideoStartPts(videoSamples) {\n        let rolloverDetected = false;\n        const startPTS = videoSamples.reduce((minPTS, sample)=>{\n            const delta = sample.pts - minPTS;\n            if (delta < -4294967296) {\n                // 2^32, see PTSNormalize for reasoning, but we're hitting a rollover here, and we don't want that to impact the timeOffset calculation\n                rolloverDetected = true;\n                return normalizePts(minPTS, sample.pts);\n            } else if (delta > 0) {\n                return minPTS;\n            } else {\n                return sample.pts;\n            }\n        }, videoSamples[0].pts);\n        if (rolloverDetected) {\n            logger.debug(\"PTS rollover detected\");\n        }\n        return startPTS;\n    }\n    remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, flush, playlistType) {\n        let video;\n        let audio;\n        let initSegment;\n        let text;\n        let id3;\n        let independent;\n        let audioTimeOffset = timeOffset;\n        let videoTimeOffset = timeOffset;\n        // If we're remuxing audio and video progressively, wait until we've received enough samples for each track before proceeding.\n        // This is done to synchronize the audio and video streams. We know if the current segment will have samples if the \"pid\"\n        // parameter is greater than -1. The pid is set when the PMT is parsed, which contains the tracks list.\n        // However, if the initSegment has already been generated, or we've reached the end of a segment (flush),\n        // then we can remux one track without waiting for the other.\n        const hasAudio = audioTrack.pid > -1;\n        const hasVideo = videoTrack.pid > -1;\n        const length = videoTrack.samples.length;\n        const enoughAudioSamples = audioTrack.samples.length > 0;\n        const enoughVideoSamples = flush && length > 0 || length > 1;\n        const canRemuxAvc = (!hasAudio || enoughAudioSamples) && (!hasVideo || enoughVideoSamples) || this.ISGenerated || flush;\n        if (canRemuxAvc) {\n            if (this.ISGenerated) {\n                var _videoTrack$pixelRati, _config$pixelRatio, _videoTrack$pixelRati2, _config$pixelRatio2;\n                const config = this.videoTrackConfig;\n                if (config && (videoTrack.width !== config.width || videoTrack.height !== config.height || ((_videoTrack$pixelRati = videoTrack.pixelRatio) == null ? void 0 : _videoTrack$pixelRati[0]) !== ((_config$pixelRatio = config.pixelRatio) == null ? void 0 : _config$pixelRatio[0]) || ((_videoTrack$pixelRati2 = videoTrack.pixelRatio) == null ? void 0 : _videoTrack$pixelRati2[1]) !== ((_config$pixelRatio2 = config.pixelRatio) == null ? void 0 : _config$pixelRatio2[1]))) {\n                    this.resetInitSegment();\n                }\n            } else {\n                initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);\n            }\n            const isVideoContiguous = this.isVideoContiguous;\n            let firstKeyFrameIndex = -1;\n            let firstKeyFramePTS;\n            if (enoughVideoSamples) {\n                firstKeyFrameIndex = findKeyframeIndex(videoTrack.samples);\n                if (!isVideoContiguous && this.config.forceKeyFrameOnDiscontinuity) {\n                    independent = true;\n                    if (firstKeyFrameIndex > 0) {\n                        logger.warn(`[mp4-remuxer]: Dropped ${firstKeyFrameIndex} out of ${length} video samples due to a missing keyframe`);\n                        const startPTS = this.getVideoStartPts(videoTrack.samples);\n                        videoTrack.samples = videoTrack.samples.slice(firstKeyFrameIndex);\n                        videoTrack.dropped += firstKeyFrameIndex;\n                        videoTimeOffset += (videoTrack.samples[0].pts - startPTS) / videoTrack.inputTimeScale;\n                        firstKeyFramePTS = videoTimeOffset;\n                    } else if (firstKeyFrameIndex === -1) {\n                        logger.warn(`[mp4-remuxer]: No keyframe found out of ${length} video samples`);\n                        independent = false;\n                    }\n                }\n            }\n            if (this.ISGenerated) {\n                if (enoughAudioSamples && enoughVideoSamples) {\n                    // timeOffset is expected to be the offset of the first timestamp of this fragment (first DTS)\n                    // if first audio DTS is not aligned with first video DTS then we need to take that into account\n                    // when providing timeOffset to remuxAudio / remuxVideo. if we don't do that, there might be a permanent / small\n                    // drift between audio and video streams\n                    const startPTS = this.getVideoStartPts(videoTrack.samples);\n                    const tsDelta = normalizePts(audioTrack.samples[0].pts, startPTS) - startPTS;\n                    const audiovideoTimestampDelta = tsDelta / videoTrack.inputTimeScale;\n                    audioTimeOffset += Math.max(0, audiovideoTimestampDelta);\n                    videoTimeOffset += Math.max(0, -audiovideoTimestampDelta);\n                }\n                // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is calculated in remuxAudio.\n                if (enoughAudioSamples) {\n                    // if initSegment was generated without audio samples, regenerate it again\n                    if (!audioTrack.samplerate) {\n                        logger.warn(\"[mp4-remuxer]: regenerate InitSegment as audio detected\");\n                        initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);\n                    }\n                    audio = this.remuxAudio(audioTrack, audioTimeOffset, this.isAudioContiguous, accurateTimeOffset, hasVideo || enoughVideoSamples || playlistType === PlaylistLevelType.AUDIO ? videoTimeOffset : undefined);\n                    if (enoughVideoSamples) {\n                        const audioTrackLength = audio ? audio.endPTS - audio.startPTS : 0;\n                        // if initSegment was generated without video samples, regenerate it again\n                        if (!videoTrack.inputTimeScale) {\n                            logger.warn(\"[mp4-remuxer]: regenerate InitSegment as video detected\");\n                            initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);\n                        }\n                        video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, audioTrackLength);\n                    }\n                } else if (enoughVideoSamples) {\n                    video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, 0);\n                }\n                if (video) {\n                    video.firstKeyFrame = firstKeyFrameIndex;\n                    video.independent = firstKeyFrameIndex !== -1;\n                    video.firstKeyFramePTS = firstKeyFramePTS;\n                }\n            }\n        }\n        // Allow ID3 and text to remux, even if more audio/video samples are required\n        if (this.ISGenerated && this._initPTS && this._initDTS) {\n            if (id3Track.samples.length) {\n                id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, this._initPTS, this._initDTS);\n            }\n            if (textTrack.samples.length) {\n                text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, this._initPTS);\n            }\n        }\n        return {\n            audio,\n            video,\n            initSegment,\n            independent,\n            text,\n            id3\n        };\n    }\n    generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset) {\n        const audioSamples = audioTrack.samples;\n        const videoSamples = videoTrack.samples;\n        const typeSupported = this.typeSupported;\n        const tracks = {};\n        const _initPTS = this._initPTS;\n        let computePTSDTS = !_initPTS || accurateTimeOffset;\n        let container = \"audio/mp4\";\n        let initPTS;\n        let initDTS;\n        let timescale;\n        if (computePTSDTS) {\n            initPTS = initDTS = Infinity;\n        }\n        if (audioTrack.config && audioSamples.length) {\n            // let's use audio sampling rate as MP4 time scale.\n            // rationale is that there is a integer nb of audio frames per audio sample (1024 for AAC)\n            // using audio sampling rate here helps having an integer MP4 frame duration\n            // this avoids potential rounding issue and AV sync issue\n            audioTrack.timescale = audioTrack.samplerate;\n            switch(audioTrack.segmentCodec){\n                case \"mp3\":\n                    if (typeSupported.mpeg) {\n                        // Chrome and Safari\n                        container = \"audio/mpeg\";\n                        audioTrack.codec = \"\";\n                    } else if (typeSupported.mp3) {\n                        // Firefox\n                        audioTrack.codec = \"mp3\";\n                    }\n                    break;\n                case \"ac3\":\n                    audioTrack.codec = \"ac-3\";\n                    break;\n            }\n            tracks.audio = {\n                id: \"audio\",\n                container: container,\n                codec: audioTrack.codec,\n                initSegment: audioTrack.segmentCodec === \"mp3\" && typeSupported.mpeg ? new Uint8Array(0) : MP4.initSegment([\n                    audioTrack\n                ]),\n                metadata: {\n                    channelCount: audioTrack.channelCount\n                }\n            };\n            if (computePTSDTS) {\n                timescale = audioTrack.inputTimeScale;\n                if (!_initPTS || timescale !== _initPTS.timescale) {\n                    // remember first PTS of this demuxing context. for audio, PTS = DTS\n                    initPTS = initDTS = audioSamples[0].pts - Math.round(timescale * timeOffset);\n                } else {\n                    computePTSDTS = false;\n                }\n            }\n        }\n        if (videoTrack.sps && videoTrack.pps && videoSamples.length) {\n            // let's use input time scale as MP4 video timescale\n            // we use input time scale straight away to avoid rounding issues on frame duration / cts computation\n            videoTrack.timescale = videoTrack.inputTimeScale;\n            tracks.video = {\n                id: \"main\",\n                container: \"video/mp4\",\n                codec: videoTrack.codec,\n                initSegment: MP4.initSegment([\n                    videoTrack\n                ]),\n                metadata: {\n                    width: videoTrack.width,\n                    height: videoTrack.height\n                }\n            };\n            if (computePTSDTS) {\n                timescale = videoTrack.inputTimeScale;\n                if (!_initPTS || timescale !== _initPTS.timescale) {\n                    const startPTS = this.getVideoStartPts(videoSamples);\n                    const startOffset = Math.round(timescale * timeOffset);\n                    initDTS = Math.min(initDTS, normalizePts(videoSamples[0].dts, startPTS) - startOffset);\n                    initPTS = Math.min(initPTS, startPTS - startOffset);\n                } else {\n                    computePTSDTS = false;\n                }\n            }\n            this.videoTrackConfig = {\n                width: videoTrack.width,\n                height: videoTrack.height,\n                pixelRatio: videoTrack.pixelRatio\n            };\n        }\n        if (Object.keys(tracks).length) {\n            this.ISGenerated = true;\n            if (computePTSDTS) {\n                this._initPTS = {\n                    baseTime: initPTS,\n                    timescale: timescale\n                };\n                this._initDTS = {\n                    baseTime: initDTS,\n                    timescale: timescale\n                };\n            } else {\n                initPTS = timescale = undefined;\n            }\n            return {\n                tracks,\n                initPTS,\n                timescale\n            };\n        }\n    }\n    remuxVideo(track, timeOffset, contiguous, audioTrackLength) {\n        const timeScale = track.inputTimeScale;\n        const inputSamples = track.samples;\n        const outputSamples = [];\n        const nbSamples = inputSamples.length;\n        const initPTS = this._initPTS;\n        let nextAvcDts = this.nextAvcDts;\n        let offset = 8;\n        let mp4SampleDuration = this.videoSampleDuration;\n        let firstDTS;\n        let lastDTS;\n        let minPTS = Number.POSITIVE_INFINITY;\n        let maxPTS = Number.NEGATIVE_INFINITY;\n        let sortSamples = false;\n        // if parsed fragment is contiguous with last one, let's use last DTS value as reference\n        if (!contiguous || nextAvcDts === null) {\n            const pts = timeOffset * timeScale;\n            const cts = inputSamples[0].pts - normalizePts(inputSamples[0].dts, inputSamples[0].pts);\n            if (chromeVersion && nextAvcDts !== null && Math.abs(pts - cts - nextAvcDts) < 15000) {\n                // treat as contigous to adjust samples that would otherwise produce video buffer gaps in Chrome\n                contiguous = true;\n            } else {\n                // if not contiguous, let's use target timeOffset\n                nextAvcDts = pts - cts;\n            }\n        }\n        // PTS is coded on 33bits, and can loop from -2^32 to 2^32\n        // PTSNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value\n        const initTime = initPTS.baseTime * timeScale / initPTS.timescale;\n        for(let i = 0; i < nbSamples; i++){\n            const sample = inputSamples[i];\n            sample.pts = normalizePts(sample.pts - initTime, nextAvcDts);\n            sample.dts = normalizePts(sample.dts - initTime, nextAvcDts);\n            if (sample.dts < inputSamples[i > 0 ? i - 1 : i].dts) {\n                sortSamples = true;\n            }\n        }\n        // sort video samples by DTS then PTS then demux id order\n        if (sortSamples) {\n            inputSamples.sort(function(a, b) {\n                const deltadts = a.dts - b.dts;\n                const deltapts = a.pts - b.pts;\n                return deltadts || deltapts;\n            });\n        }\n        // Get first/last DTS\n        firstDTS = inputSamples[0].dts;\n        lastDTS = inputSamples[inputSamples.length - 1].dts;\n        // Sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS\n        // set this constant duration as being the avg delta between consecutive DTS.\n        const inputDuration = lastDTS - firstDTS;\n        const averageSampleDuration = inputDuration ? Math.round(inputDuration / (nbSamples - 1)) : mp4SampleDuration || track.inputTimeScale / 30;\n        // if fragment are contiguous, detect hole/overlapping between fragments\n        if (contiguous) {\n            // check timestamp continuity across consecutive fragments (this is to remove inter-fragment gap/hole)\n            const delta = firstDTS - nextAvcDts;\n            const foundHole = delta > averageSampleDuration;\n            const foundOverlap = delta < -1;\n            if (foundHole || foundOverlap) {\n                if (foundHole) {\n                    logger.warn(`AVC: ${toMsFromMpegTsClock(delta, true)} ms (${delta}dts) hole between fragments detected at ${timeOffset.toFixed(3)}`);\n                } else {\n                    logger.warn(`AVC: ${toMsFromMpegTsClock(-delta, true)} ms (${delta}dts) overlapping between fragments detected at ${timeOffset.toFixed(3)}`);\n                }\n                if (!foundOverlap || nextAvcDts >= inputSamples[0].pts || chromeVersion) {\n                    firstDTS = nextAvcDts;\n                    const firstPTS = inputSamples[0].pts - delta;\n                    if (foundHole) {\n                        inputSamples[0].dts = firstDTS;\n                        inputSamples[0].pts = firstPTS;\n                    } else {\n                        for(let i = 0; i < inputSamples.length; i++){\n                            if (inputSamples[i].dts > firstPTS) {\n                                break;\n                            }\n                            inputSamples[i].dts -= delta;\n                            inputSamples[i].pts -= delta;\n                        }\n                    }\n                    logger.log(`Video: Initial PTS/DTS adjusted: ${toMsFromMpegTsClock(firstPTS, true)}/${toMsFromMpegTsClock(firstDTS, true)}, delta: ${toMsFromMpegTsClock(delta, true)} ms`);\n                }\n            }\n        }\n        firstDTS = Math.max(0, firstDTS);\n        let nbNalu = 0;\n        let naluLen = 0;\n        let dtsStep = firstDTS;\n        for(let i = 0; i < nbSamples; i++){\n            // compute total/avc sample length and nb of NAL units\n            const sample = inputSamples[i];\n            const units = sample.units;\n            const nbUnits = units.length;\n            let sampleLen = 0;\n            for(let j = 0; j < nbUnits; j++){\n                sampleLen += units[j].data.length;\n            }\n            naluLen += sampleLen;\n            nbNalu += nbUnits;\n            sample.length = sampleLen;\n            // ensure sample monotonic DTS\n            if (sample.dts < dtsStep) {\n                sample.dts = dtsStep;\n                dtsStep += averageSampleDuration / 4 | 0 || 1;\n            } else {\n                dtsStep = sample.dts;\n            }\n            minPTS = Math.min(sample.pts, minPTS);\n            maxPTS = Math.max(sample.pts, maxPTS);\n        }\n        lastDTS = inputSamples[nbSamples - 1].dts;\n        /* concatenate the video data and construct the mdat in place\n      (need 8 more bytes to fill length and mpdat type) */ const mdatSize = naluLen + 4 * nbNalu + 8;\n        let mdat;\n        try {\n            mdat = new Uint8Array(mdatSize);\n        } catch (err) {\n            this.observer.emit(Events.ERROR, Events.ERROR, {\n                type: ErrorTypes.MUX_ERROR,\n                details: ErrorDetails.REMUX_ALLOC_ERROR,\n                fatal: false,\n                error: err,\n                bytes: mdatSize,\n                reason: `fail allocating video mdat ${mdatSize}`\n            });\n            return;\n        }\n        const view = new DataView(mdat.buffer);\n        view.setUint32(0, mdatSize);\n        mdat.set(MP4.types.mdat, 4);\n        let stretchedLastFrame = false;\n        let minDtsDelta = Number.POSITIVE_INFINITY;\n        let minPtsDelta = Number.POSITIVE_INFINITY;\n        let maxDtsDelta = Number.NEGATIVE_INFINITY;\n        let maxPtsDelta = Number.NEGATIVE_INFINITY;\n        for(let i = 0; i < nbSamples; i++){\n            const VideoSample = inputSamples[i];\n            const VideoSampleUnits = VideoSample.units;\n            let mp4SampleLength = 0;\n            // convert NALU bitstream to MP4 format (prepend NALU with size field)\n            for(let j = 0, nbUnits = VideoSampleUnits.length; j < nbUnits; j++){\n                const unit = VideoSampleUnits[j];\n                const unitData = unit.data;\n                const unitDataLen = unit.data.byteLength;\n                view.setUint32(offset, unitDataLen);\n                offset += 4;\n                mdat.set(unitData, offset);\n                offset += unitDataLen;\n                mp4SampleLength += 4 + unitDataLen;\n            }\n            // expected sample duration is the Decoding Timestamp diff of consecutive samples\n            let ptsDelta;\n            if (i < nbSamples - 1) {\n                mp4SampleDuration = inputSamples[i + 1].dts - VideoSample.dts;\n                ptsDelta = inputSamples[i + 1].pts - VideoSample.pts;\n            } else {\n                const config = this.config;\n                const lastFrameDuration = i > 0 ? VideoSample.dts - inputSamples[i - 1].dts : averageSampleDuration;\n                ptsDelta = i > 0 ? VideoSample.pts - inputSamples[i - 1].pts : averageSampleDuration;\n                if (config.stretchShortVideoTrack && this.nextAudioPts !== null) {\n                    // In some cases, a segment's audio track duration may exceed the video track duration.\n                    // Since we've already remuxed audio, and we know how long the audio track is, we look to\n                    // see if the delta to the next segment is longer than maxBufferHole.\n                    // If so, playback would potentially get stuck, so we artificially inflate\n                    // the duration of the last frame to minimize any potential gap between segments.\n                    const gapTolerance = Math.floor(config.maxBufferHole * timeScale);\n                    const deltaToFrameEnd = (audioTrackLength ? minPTS + audioTrackLength * timeScale : this.nextAudioPts) - VideoSample.pts;\n                    if (deltaToFrameEnd > gapTolerance) {\n                        // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video\n                        // frame overlap. maxBufferHole should be >> lastFrameDuration anyway.\n                        mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;\n                        if (mp4SampleDuration < 0) {\n                            mp4SampleDuration = lastFrameDuration;\n                        } else {\n                            stretchedLastFrame = true;\n                        }\n                        logger.log(`[mp4-remuxer]: It is approximately ${deltaToFrameEnd / 90} ms to the next segment; using duration ${mp4SampleDuration / 90} ms for the last video frame.`);\n                    } else {\n                        mp4SampleDuration = lastFrameDuration;\n                    }\n                } else {\n                    mp4SampleDuration = lastFrameDuration;\n                }\n            }\n            const compositionTimeOffset = Math.round(VideoSample.pts - VideoSample.dts);\n            minDtsDelta = Math.min(minDtsDelta, mp4SampleDuration);\n            maxDtsDelta = Math.max(maxDtsDelta, mp4SampleDuration);\n            minPtsDelta = Math.min(minPtsDelta, ptsDelta);\n            maxPtsDelta = Math.max(maxPtsDelta, ptsDelta);\n            outputSamples.push(new Mp4Sample(VideoSample.key, mp4SampleDuration, mp4SampleLength, compositionTimeOffset));\n        }\n        if (outputSamples.length) {\n            if (chromeVersion) {\n                if (chromeVersion < 70) {\n                    // Chrome workaround, mark first sample as being a Random Access Point (keyframe) to avoid sourcebuffer append issue\n                    // https://code.google.com/p/chromium/issues/detail?id=229412\n                    const flags = outputSamples[0].flags;\n                    flags.dependsOn = 2;\n                    flags.isNonSync = 0;\n                }\n            } else if (safariWebkitVersion) {\n                // Fix for \"CNN special report, with CC\" in test-streams (Safari browser only)\n                // Ignore DTS when frame durations are irregular. Safari MSE does not handle this leading to gaps.\n                if (maxPtsDelta - minPtsDelta < maxDtsDelta - minDtsDelta && averageSampleDuration / maxDtsDelta < 0.025 && outputSamples[0].cts === 0) {\n                    logger.warn(\"Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.\");\n                    let dts = firstDTS;\n                    for(let i = 0, len = outputSamples.length; i < len; i++){\n                        const nextDts = dts + outputSamples[i].duration;\n                        const pts = dts + outputSamples[i].cts;\n                        if (i < len - 1) {\n                            const nextPts = nextDts + outputSamples[i + 1].cts;\n                            outputSamples[i].duration = nextPts - pts;\n                        } else {\n                            outputSamples[i].duration = i ? outputSamples[i - 1].duration : averageSampleDuration;\n                        }\n                        outputSamples[i].cts = 0;\n                        dts = nextDts;\n                    }\n                }\n            }\n        }\n        // next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)\n        mp4SampleDuration = stretchedLastFrame || !mp4SampleDuration ? averageSampleDuration : mp4SampleDuration;\n        this.nextAvcDts = nextAvcDts = lastDTS + mp4SampleDuration;\n        this.videoSampleDuration = mp4SampleDuration;\n        this.isVideoContiguous = true;\n        const moof = MP4.moof(track.sequenceNumber++, firstDTS, _extends({}, track, {\n            samples: outputSamples\n        }));\n        const type = \"video\";\n        const data = {\n            data1: moof,\n            data2: mdat,\n            startPTS: minPTS / timeScale,\n            endPTS: (maxPTS + mp4SampleDuration) / timeScale,\n            startDTS: firstDTS / timeScale,\n            endDTS: nextAvcDts / timeScale,\n            type,\n            hasAudio: false,\n            hasVideo: true,\n            nb: outputSamples.length,\n            dropped: track.dropped\n        };\n        track.samples = [];\n        track.dropped = 0;\n        return data;\n    }\n    getSamplesPerFrame(track) {\n        switch(track.segmentCodec){\n            case \"mp3\":\n                return MPEG_AUDIO_SAMPLE_PER_FRAME;\n            case \"ac3\":\n                return AC3_SAMPLES_PER_FRAME;\n            default:\n                return AAC_SAMPLES_PER_FRAME;\n        }\n    }\n    remuxAudio(track, timeOffset, contiguous, accurateTimeOffset, videoTimeOffset) {\n        const inputTimeScale = track.inputTimeScale;\n        const mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;\n        const scaleFactor = inputTimeScale / mp4timeScale;\n        const mp4SampleDuration = this.getSamplesPerFrame(track);\n        const inputSampleDuration = mp4SampleDuration * scaleFactor;\n        const initPTS = this._initPTS;\n        const rawMPEG = track.segmentCodec === \"mp3\" && this.typeSupported.mpeg;\n        const outputSamples = [];\n        const alignedWithVideo = videoTimeOffset !== undefined;\n        let inputSamples = track.samples;\n        let offset = rawMPEG ? 0 : 8;\n        let nextAudioPts = this.nextAudioPts || -1;\n        // window.audioSamples ? window.audioSamples.push(inputSamples.map(s => s.pts)) : (window.audioSamples = [inputSamples.map(s => s.pts)]);\n        // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),\n        // for sake of clarity:\n        // consecutive fragments are frags with\n        //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR\n        //  - less than 20 audio frames distance\n        // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)\n        // this helps ensuring audio continuity\n        // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame\n        const timeOffsetMpegTS = timeOffset * inputTimeScale;\n        const initTime = initPTS.baseTime * inputTimeScale / initPTS.timescale;\n        this.isAudioContiguous = contiguous = contiguous || inputSamples.length && nextAudioPts > 0 && (accurateTimeOffset && Math.abs(timeOffsetMpegTS - nextAudioPts) < 9000 || Math.abs(normalizePts(inputSamples[0].pts - initTime, timeOffsetMpegTS) - nextAudioPts) < 20 * inputSampleDuration);\n        // compute normalized PTS\n        inputSamples.forEach(function(sample) {\n            sample.pts = normalizePts(sample.pts - initTime, timeOffsetMpegTS);\n        });\n        if (!contiguous || nextAudioPts < 0) {\n            // filter out sample with negative PTS that are not playable anyway\n            // if we don't remove these negative samples, they will shift all audio samples forward.\n            // leading to audio overlap between current / next fragment\n            inputSamples = inputSamples.filter((sample)=>sample.pts >= 0);\n            // in case all samples have negative PTS, and have been filtered out, return now\n            if (!inputSamples.length) {\n                return;\n            }\n            if (videoTimeOffset === 0) {\n                // Set the start to 0 to match video so that start gaps larger than inputSampleDuration are filled with silence\n                nextAudioPts = 0;\n            } else if (accurateTimeOffset && !alignedWithVideo) {\n                // When not seeking, not live, and LevelDetails.PTSKnown, use fragment start as predicted next audio PTS\n                nextAudioPts = Math.max(0, timeOffsetMpegTS);\n            } else {\n                // if frags are not contiguous and if we cant trust time offset, let's use first sample PTS as next audio PTS\n                nextAudioPts = inputSamples[0].pts;\n            }\n        }\n        // If the audio track is missing samples, the frames seem to get \"left-shifted\" within the\n        // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.\n        // In an effort to prevent this from happening, we inject frames here where there are gaps.\n        // When possible, we inject a silent frame; when that's not possible, we duplicate the last\n        // frame.\n        if (track.segmentCodec === \"aac\") {\n            const maxAudioFramesDrift = this.config.maxAudioFramesDrift;\n            for(let i = 0, nextPts = nextAudioPts; i < inputSamples.length; i++){\n                // First, let's see how far off this frame is from where we expect it to be\n                const sample = inputSamples[i];\n                const pts = sample.pts;\n                const delta = pts - nextPts;\n                const duration = Math.abs(1000 * delta / inputTimeScale);\n                // When remuxing with video, if we're overlapping by more than a duration, drop this sample to stay in sync\n                if (delta <= -maxAudioFramesDrift * inputSampleDuration && alignedWithVideo) {\n                    if (i === 0) {\n                        logger.warn(`Audio frame @ ${(pts / inputTimeScale).toFixed(3)}s overlaps nextAudioPts by ${Math.round(1000 * delta / inputTimeScale)} ms.`);\n                        this.nextAudioPts = nextAudioPts = nextPts = pts;\n                    }\n                } else if (delta >= maxAudioFramesDrift * inputSampleDuration && duration < MAX_SILENT_FRAME_DURATION && alignedWithVideo) {\n                    let missing = Math.round(delta / inputSampleDuration);\n                    // Adjust nextPts so that silent samples are aligned with media pts. This will prevent media samples from\n                    // later being shifted if nextPts is based on timeOffset and delta is not a multiple of inputSampleDuration.\n                    nextPts = pts - missing * inputSampleDuration;\n                    if (nextPts < 0) {\n                        missing--;\n                        nextPts += inputSampleDuration;\n                    }\n                    if (i === 0) {\n                        this.nextAudioPts = nextAudioPts = nextPts;\n                    }\n                    logger.warn(`[mp4-remuxer]: Injecting ${missing} audio frame @ ${(nextPts / inputTimeScale).toFixed(3)}s due to ${Math.round(1000 * delta / inputTimeScale)} ms gap.`);\n                    for(let j = 0; j < missing; j++){\n                        const newStamp = Math.max(nextPts, 0);\n                        let fillFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n                        if (!fillFrame) {\n                            logger.log(\"[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead.\");\n                            fillFrame = sample.unit.subarray();\n                        }\n                        inputSamples.splice(i, 0, {\n                            unit: fillFrame,\n                            pts: newStamp\n                        });\n                        nextPts += inputSampleDuration;\n                        i++;\n                    }\n                }\n                sample.pts = nextPts;\n                nextPts += inputSampleDuration;\n            }\n        }\n        let firstPTS = null;\n        let lastPTS = null;\n        let mdat;\n        let mdatSize = 0;\n        let sampleLength = inputSamples.length;\n        while(sampleLength--){\n            mdatSize += inputSamples[sampleLength].unit.byteLength;\n        }\n        for(let j = 0, _nbSamples = inputSamples.length; j < _nbSamples; j++){\n            const audioSample = inputSamples[j];\n            const unit = audioSample.unit;\n            let pts = audioSample.pts;\n            if (lastPTS !== null) {\n                // If we have more than one sample, set the duration of the sample to the \"real\" duration; the PTS diff with\n                // the previous sample\n                const prevSample = outputSamples[j - 1];\n                prevSample.duration = Math.round((pts - lastPTS) / scaleFactor);\n            } else {\n                if (contiguous && track.segmentCodec === \"aac\") {\n                    // set PTS/DTS to expected PTS/DTS\n                    pts = nextAudioPts;\n                }\n                // remember first PTS of our audioSamples\n                firstPTS = pts;\n                if (mdatSize > 0) {\n                    /* concatenate the audio data and construct the mdat in place\n            (need 8 more bytes to fill length and mdat type) */ mdatSize += offset;\n                    try {\n                        mdat = new Uint8Array(mdatSize);\n                    } catch (err) {\n                        this.observer.emit(Events.ERROR, Events.ERROR, {\n                            type: ErrorTypes.MUX_ERROR,\n                            details: ErrorDetails.REMUX_ALLOC_ERROR,\n                            fatal: false,\n                            error: err,\n                            bytes: mdatSize,\n                            reason: `fail allocating audio mdat ${mdatSize}`\n                        });\n                        return;\n                    }\n                    if (!rawMPEG) {\n                        const view = new DataView(mdat.buffer);\n                        view.setUint32(0, mdatSize);\n                        mdat.set(MP4.types.mdat, 4);\n                    }\n                } else {\n                    // no audio samples\n                    return;\n                }\n            }\n            mdat.set(unit, offset);\n            const unitLen = unit.byteLength;\n            offset += unitLen;\n            // Default the sample's duration to the computed mp4SampleDuration, which will either be 1024 for AAC or 1152 for MPEG\n            // In the case that we have 1 sample, this will be the duration. If we have more than one sample, the duration\n            // becomes the PTS diff with the previous sample\n            outputSamples.push(new Mp4Sample(true, mp4SampleDuration, unitLen, 0));\n            lastPTS = pts;\n        }\n        // We could end up with no audio samples if all input samples were overlapping with the previously remuxed ones\n        const nbSamples = outputSamples.length;\n        if (!nbSamples) {\n            return;\n        }\n        // The next audio sample PTS should be equal to last sample PTS + duration\n        const lastSample = outputSamples[outputSamples.length - 1];\n        this.nextAudioPts = nextAudioPts = lastPTS + scaleFactor * lastSample.duration;\n        // Set the track samples from inputSamples to outputSamples before remuxing\n        const moof = rawMPEG ? new Uint8Array(0) : MP4.moof(track.sequenceNumber++, firstPTS / scaleFactor, _extends({}, track, {\n            samples: outputSamples\n        }));\n        // Clear the track samples. This also clears the samples array in the demuxer, since the reference is shared\n        track.samples = [];\n        const start = firstPTS / inputTimeScale;\n        const end = nextAudioPts / inputTimeScale;\n        const type = \"audio\";\n        const audioData = {\n            data1: moof,\n            data2: mdat,\n            startPTS: start,\n            endPTS: end,\n            startDTS: start,\n            endDTS: end,\n            type,\n            hasAudio: true,\n            hasVideo: false,\n            nb: nbSamples\n        };\n        this.isAudioContiguous = true;\n        return audioData;\n    }\n    remuxEmptyAudio(track, timeOffset, contiguous, videoData) {\n        const inputTimeScale = track.inputTimeScale;\n        const mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;\n        const scaleFactor = inputTimeScale / mp4timeScale;\n        const nextAudioPts = this.nextAudioPts;\n        // sync with video's timestamp\n        const initDTS = this._initDTS;\n        const init90kHz = initDTS.baseTime * 90000 / initDTS.timescale;\n        const startDTS = (nextAudioPts !== null ? nextAudioPts : videoData.startDTS * inputTimeScale) + init90kHz;\n        const endDTS = videoData.endDTS * inputTimeScale + init90kHz;\n        // one sample's duration value\n        const frameDuration = scaleFactor * AAC_SAMPLES_PER_FRAME;\n        // samples count of this segment's duration\n        const nbSamples = Math.ceil((endDTS - startDTS) / frameDuration);\n        // silent frame\n        const silentFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n        logger.warn(\"[mp4-remuxer]: remux empty Audio\");\n        // Can't remux if we can't generate a silent frame...\n        if (!silentFrame) {\n            logger.trace(\"[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec\");\n            return;\n        }\n        const samples = [];\n        for(let i = 0; i < nbSamples; i++){\n            const stamp = startDTS + i * frameDuration;\n            samples.push({\n                unit: silentFrame,\n                pts: stamp,\n                dts: stamp\n            });\n        }\n        track.samples = samples;\n        return this.remuxAudio(track, timeOffset, contiguous, false);\n    }\n}\nfunction normalizePts(value, reference) {\n    let offset;\n    if (reference === null) {\n        return value;\n    }\n    if (reference < value) {\n        // - 2^33\n        offset = -8589934592;\n    } else {\n        // + 2^33\n        offset = 8589934592;\n    }\n    /* PTS is 33bit (from 0 to 2^33 -1)\n    if diff between value and reference is bigger than half of the amplitude (2^32) then it means that\n    PTS looping occured. fill the gap */ while(Math.abs(value - reference) > 4294967296){\n        value += offset;\n    }\n    return value;\n}\nfunction findKeyframeIndex(samples) {\n    for(let i = 0; i < samples.length; i++){\n        if (samples[i].key) {\n            return i;\n        }\n    }\n    return -1;\n}\nfunction flushTextTrackMetadataCueSamples(track, timeOffset, initPTS, initDTS) {\n    const length = track.samples.length;\n    if (!length) {\n        return;\n    }\n    const inputTimeScale = track.inputTimeScale;\n    for(let index = 0; index < length; index++){\n        const sample = track.samples[index];\n        // setting id3 pts, dts to relative time\n        // using this._initPTS and this._initDTS to calculate relative time\n        sample.pts = normalizePts(sample.pts - initPTS.baseTime * inputTimeScale / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;\n        sample.dts = normalizePts(sample.dts - initDTS.baseTime * inputTimeScale / initDTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;\n    }\n    const samples = track.samples;\n    track.samples = [];\n    return {\n        samples\n    };\n}\nfunction flushTextTrackUserdataCueSamples(track, timeOffset, initPTS) {\n    const length = track.samples.length;\n    if (!length) {\n        return;\n    }\n    const inputTimeScale = track.inputTimeScale;\n    for(let index = 0; index < length; index++){\n        const sample = track.samples[index];\n        // setting text pts, dts to relative time\n        // using this._initPTS and this._initDTS to calculate relative time\n        sample.pts = normalizePts(sample.pts - initPTS.baseTime * inputTimeScale / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;\n    }\n    track.samples.sort((a, b)=>a.pts - b.pts);\n    const samples = track.samples;\n    track.samples = [];\n    return {\n        samples\n    };\n}\nclass Mp4Sample {\n    constructor(isKeyframe, duration, size, cts){\n        this.size = void 0;\n        this.duration = void 0;\n        this.cts = void 0;\n        this.flags = void 0;\n        this.duration = duration;\n        this.size = size;\n        this.cts = cts;\n        this.flags = {\n            isLeading: 0,\n            isDependedOn: 0,\n            hasRedundancy: 0,\n            degradPrio: 0,\n            dependsOn: isKeyframe ? 2 : 1,\n            isNonSync: isKeyframe ? 0 : 1\n        };\n    }\n}\nclass PassThroughRemuxer {\n    constructor(){\n        this.emitInitSegment = false;\n        this.audioCodec = void 0;\n        this.videoCodec = void 0;\n        this.initData = void 0;\n        this.initPTS = null;\n        this.initTracks = void 0;\n        this.lastEndTime = null;\n    }\n    destroy() {}\n    resetTimeStamp(defaultInitPTS) {\n        this.initPTS = defaultInitPTS;\n        this.lastEndTime = null;\n    }\n    resetNextTimestamp() {\n        this.lastEndTime = null;\n    }\n    resetInitSegment(initSegment, audioCodec, videoCodec, decryptdata) {\n        this.audioCodec = audioCodec;\n        this.videoCodec = videoCodec;\n        this.generateInitSegment(patchEncyptionData(initSegment, decryptdata));\n        this.emitInitSegment = true;\n    }\n    generateInitSegment(initSegment) {\n        let { audioCodec, videoCodec } = this;\n        if (!(initSegment != null && initSegment.byteLength)) {\n            this.initTracks = undefined;\n            this.initData = undefined;\n            return;\n        }\n        const initData = this.initData = parseInitSegment(initSegment);\n        // Get codec from initSegment or fallback to default\n        if (initData.audio) {\n            audioCodec = getParsedTrackCodec(initData.audio, ElementaryStreamTypes.AUDIO);\n        }\n        if (initData.video) {\n            videoCodec = getParsedTrackCodec(initData.video, ElementaryStreamTypes.VIDEO);\n        }\n        const tracks = {};\n        if (initData.audio && initData.video) {\n            tracks.audiovideo = {\n                container: \"video/mp4\",\n                codec: audioCodec + \",\" + videoCodec,\n                initSegment,\n                id: \"main\"\n            };\n        } else if (initData.audio) {\n            tracks.audio = {\n                container: \"audio/mp4\",\n                codec: audioCodec,\n                initSegment,\n                id: \"audio\"\n            };\n        } else if (initData.video) {\n            tracks.video = {\n                container: \"video/mp4\",\n                codec: videoCodec,\n                initSegment,\n                id: \"main\"\n            };\n        } else {\n            logger.warn(\"[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes.\");\n        }\n        this.initTracks = tracks;\n    }\n    remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset) {\n        var _initData, _initData2;\n        let { initPTS, lastEndTime } = this;\n        const result = {\n            audio: undefined,\n            video: undefined,\n            text: textTrack,\n            id3: id3Track,\n            initSegment: undefined\n        };\n        // If we haven't yet set a lastEndDTS, or it was reset, set it to the provided timeOffset. We want to use the\n        // lastEndDTS over timeOffset whenever possible; during progressive playback, the media source will not update\n        // the media duration (which is what timeOffset is provided as) before we need to process the next chunk.\n        if (!isFiniteNumber(lastEndTime)) {\n            lastEndTime = this.lastEndTime = timeOffset || 0;\n        }\n        // The binary segment data is added to the videoTrack in the mp4demuxer. We don't check to see if the data is only\n        // audio or video (or both); adding it to video was an arbitrary choice.\n        const data = videoTrack.samples;\n        if (!(data != null && data.length)) {\n            return result;\n        }\n        const initSegment = {\n            initPTS: undefined,\n            timescale: 1\n        };\n        let initData = this.initData;\n        if (!((_initData = initData) != null && _initData.length)) {\n            this.generateInitSegment(data);\n            initData = this.initData;\n        }\n        if (!((_initData2 = initData) != null && _initData2.length)) {\n            // We can't remux if the initSegment could not be generated\n            logger.warn(\"[passthrough-remuxer.ts]: Failed to generate initSegment.\");\n            return result;\n        }\n        if (this.emitInitSegment) {\n            initSegment.tracks = this.initTracks;\n            this.emitInitSegment = false;\n        }\n        const duration = getDuration(data, initData);\n        const startDTS = getStartDTS(initData, data);\n        const decodeTime = startDTS === null ? timeOffset : startDTS;\n        if (isInvalidInitPts(initPTS, decodeTime, timeOffset, duration) || initSegment.timescale !== initPTS.timescale && accurateTimeOffset) {\n            initSegment.initPTS = decodeTime - timeOffset;\n            if (initPTS && initPTS.timescale === 1) {\n                logger.warn(`Adjusting initPTS by ${initSegment.initPTS - initPTS.baseTime}`);\n            }\n            this.initPTS = initPTS = {\n                baseTime: initSegment.initPTS,\n                timescale: 1\n            };\n        }\n        const startTime = audioTrack ? decodeTime - initPTS.baseTime / initPTS.timescale : lastEndTime;\n        const endTime = startTime + duration;\n        offsetStartDTS(initData, data, initPTS.baseTime / initPTS.timescale);\n        if (duration > 0) {\n            this.lastEndTime = endTime;\n        } else {\n            logger.warn(\"Duration parsed from mp4 should be greater than zero\");\n            this.resetNextTimestamp();\n        }\n        const hasAudio = !!initData.audio;\n        const hasVideo = !!initData.video;\n        let type = \"\";\n        if (hasAudio) {\n            type += \"audio\";\n        }\n        if (hasVideo) {\n            type += \"video\";\n        }\n        const track = {\n            data1: data,\n            startPTS: startTime,\n            startDTS: startTime,\n            endPTS: endTime,\n            endDTS: endTime,\n            type,\n            hasAudio,\n            hasVideo,\n            nb: 1,\n            dropped: 0\n        };\n        result.audio = track.type === \"audio\" ? track : undefined;\n        result.video = track.type !== \"audio\" ? track : undefined;\n        result.initSegment = initSegment;\n        result.id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, initPTS, initPTS);\n        if (textTrack.samples.length) {\n            result.text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, initPTS);\n        }\n        return result;\n    }\n}\nfunction isInvalidInitPts(initPTS, startDTS, timeOffset, duration) {\n    if (initPTS === null) {\n        return true;\n    }\n    // InitPTS is invalid when distance from program would be more than segment duration or a minimum of one second\n    const minDuration = Math.max(duration, 1);\n    const startTime = startDTS - initPTS.baseTime / initPTS.timescale;\n    return Math.abs(startTime - timeOffset) > minDuration;\n}\nfunction getParsedTrackCodec(track, type) {\n    const parsedCodec = track == null ? void 0 : track.codec;\n    if (parsedCodec && parsedCodec.length > 4) {\n        return parsedCodec;\n    }\n    if (type === ElementaryStreamTypes.AUDIO) {\n        if (parsedCodec === \"ec-3\" || parsedCodec === \"ac-3\" || parsedCodec === \"alac\") {\n            return parsedCodec;\n        }\n        if (parsedCodec === \"fLaC\" || parsedCodec === \"Opus\") {\n            // Opting not to get `preferManagedMediaSource` from player config for isSupported() check for simplicity\n            const preferManagedMediaSource = false;\n            return getCodecCompatibleName(parsedCodec, preferManagedMediaSource);\n        }\n        const result = \"mp4a.40.5\";\n        logger.info(`Parsed audio codec \"${parsedCodec}\" or audio object type not handled. Using \"${result}\"`);\n        return result;\n    }\n    // Provide defaults based on codec type\n    // This allows for some playback of some fmp4 playlists without CODECS defined in manifest\n    logger.warn(`Unhandled video codec \"${parsedCodec}\"`);\n    if (parsedCodec === \"hvc1\" || parsedCodec === \"hev1\") {\n        return \"hvc1.1.6.L120.90\";\n    }\n    if (parsedCodec === \"av01\") {\n        return \"av01.0.04M.08\";\n    }\n    return \"avc1.42e01e\";\n}\nlet now;\n// performance.now() not available on WebWorker, at least on Safari Desktop\ntry {\n    now = self.performance.now.bind(self.performance);\n} catch (err) {\n    logger.debug(\"Unable to use Performance API on this environment\");\n    now = optionalSelf == null ? void 0 : optionalSelf.Date.now;\n}\nconst muxConfig = [\n    {\n        demux: MP4Demuxer,\n        remux: PassThroughRemuxer\n    },\n    {\n        demux: TSDemuxer,\n        remux: MP4Remuxer\n    },\n    {\n        demux: AACDemuxer,\n        remux: MP4Remuxer\n    },\n    {\n        demux: MP3Demuxer,\n        remux: MP4Remuxer\n    }\n];\n{\n    muxConfig.splice(2, 0, {\n        demux: AC3Demuxer,\n        remux: MP4Remuxer\n    });\n}class Transmuxer {\n    constructor(observer, typeSupported, config, vendor, id){\n        this.async = false;\n        this.observer = void 0;\n        this.typeSupported = void 0;\n        this.config = void 0;\n        this.vendor = void 0;\n        this.id = void 0;\n        this.demuxer = void 0;\n        this.remuxer = void 0;\n        this.decrypter = void 0;\n        this.probe = void 0;\n        this.decryptionPromise = null;\n        this.transmuxConfig = void 0;\n        this.currentTransmuxState = void 0;\n        this.observer = observer;\n        this.typeSupported = typeSupported;\n        this.config = config;\n        this.vendor = vendor;\n        this.id = id;\n    }\n    configure(transmuxConfig) {\n        this.transmuxConfig = transmuxConfig;\n        if (this.decrypter) {\n            this.decrypter.reset();\n        }\n    }\n    push(data, decryptdata, chunkMeta, state) {\n        const stats = chunkMeta.transmuxing;\n        stats.executeStart = now();\n        let uintData = new Uint8Array(data);\n        const { currentTransmuxState, transmuxConfig } = this;\n        if (state) {\n            this.currentTransmuxState = state;\n        }\n        const { contiguous, discontinuity, trackSwitch, accurateTimeOffset, timeOffset, initSegmentChange } = state || currentTransmuxState;\n        const { audioCodec, videoCodec, defaultInitPts, duration, initSegmentData } = transmuxConfig;\n        const keyData = getEncryptionType(uintData, decryptdata);\n        if (keyData && keyData.method === \"AES-128\") {\n            const decrypter = this.getDecrypter();\n            // Software decryption is synchronous; webCrypto is not\n            if (decrypter.isSync()) {\n                // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached\n                // data is handled in the flush() call\n                let decryptedData = decrypter.softwareDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer);\n                // For Low-Latency HLS Parts, decrypt in place, since part parsing is expected on push progress\n                const loadingParts = chunkMeta.part > -1;\n                if (loadingParts) {\n                    decryptedData = decrypter.flush();\n                }\n                if (!decryptedData) {\n                    stats.executeEnd = now();\n                    return emptyResult(chunkMeta);\n                }\n                uintData = new Uint8Array(decryptedData);\n            } else {\n                this.decryptionPromise = decrypter.webCryptoDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer).then((decryptedData)=>{\n                    // Calling push here is important; if flush() is called while this is still resolving, this ensures that\n                    // the decrypted data has been transmuxed\n                    const result = this.push(decryptedData, null, chunkMeta);\n                    this.decryptionPromise = null;\n                    return result;\n                });\n                return this.decryptionPromise;\n            }\n        }\n        const resetMuxers = this.needsProbing(discontinuity, trackSwitch);\n        if (resetMuxers) {\n            const error = this.configureTransmuxer(uintData);\n            if (error) {\n                logger.warn(`[transmuxer] ${error.message}`);\n                this.observer.emit(Events.ERROR, Events.ERROR, {\n                    type: ErrorTypes.MEDIA_ERROR,\n                    details: ErrorDetails.FRAG_PARSING_ERROR,\n                    fatal: false,\n                    error,\n                    reason: error.message\n                });\n                stats.executeEnd = now();\n                return emptyResult(chunkMeta);\n            }\n        }\n        if (discontinuity || trackSwitch || initSegmentChange || resetMuxers) {\n            this.resetInitSegment(initSegmentData, audioCodec, videoCodec, duration, decryptdata);\n        }\n        if (discontinuity || initSegmentChange || resetMuxers) {\n            this.resetInitialTimestamp(defaultInitPts);\n        }\n        if (!contiguous) {\n            this.resetContiguity();\n        }\n        const result = this.transmux(uintData, keyData, timeOffset, accurateTimeOffset, chunkMeta);\n        const currentState = this.currentTransmuxState;\n        currentState.contiguous = true;\n        currentState.discontinuity = false;\n        currentState.trackSwitch = false;\n        stats.executeEnd = now();\n        return result;\n    }\n    // Due to data caching, flush calls can produce more than one TransmuxerResult (hence the Array type)\n    flush(chunkMeta) {\n        const stats = chunkMeta.transmuxing;\n        stats.executeStart = now();\n        const { decrypter, currentTransmuxState, decryptionPromise } = this;\n        if (decryptionPromise) {\n            // Upon resolution, the decryption promise calls push() and returns its TransmuxerResult up the stack. Therefore\n            // only flushing is required for async decryption\n            return decryptionPromise.then(()=>{\n                return this.flush(chunkMeta);\n            });\n        }\n        const transmuxResults = [];\n        const { timeOffset } = currentTransmuxState;\n        if (decrypter) {\n            // The decrypter may have data cached, which needs to be demuxed. In this case we'll have two TransmuxResults\n            // This happens in the case that we receive only 1 push call for a segment (either for non-progressive downloads,\n            // or for progressive downloads with small segments)\n            const decryptedData = decrypter.flush();\n            if (decryptedData) {\n                // Push always returns a TransmuxerResult if decryptdata is null\n                transmuxResults.push(this.push(decryptedData, null, chunkMeta));\n            }\n        }\n        const { demuxer, remuxer } = this;\n        if (!demuxer || !remuxer) {\n            // If probing failed, then Hls.js has been given content its not able to handle\n            stats.executeEnd = now();\n            return [\n                emptyResult(chunkMeta)\n            ];\n        }\n        const demuxResultOrPromise = demuxer.flush(timeOffset);\n        if (isPromise(demuxResultOrPromise)) {\n            // Decrypt final SAMPLE-AES samples\n            return demuxResultOrPromise.then((demuxResult)=>{\n                this.flushRemux(transmuxResults, demuxResult, chunkMeta);\n                return transmuxResults;\n            });\n        }\n        this.flushRemux(transmuxResults, demuxResultOrPromise, chunkMeta);\n        return transmuxResults;\n    }\n    flushRemux(transmuxResults, demuxResult, chunkMeta) {\n        const { audioTrack, videoTrack, id3Track, textTrack } = demuxResult;\n        const { accurateTimeOffset, timeOffset } = this.currentTransmuxState;\n        logger.log(`[transmuxer.ts]: Flushed fragment ${chunkMeta.sn}${chunkMeta.part > -1 ? \" p: \" + chunkMeta.part : \"\"} of level ${chunkMeta.level}`);\n        const remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, true, this.id);\n        transmuxResults.push({\n            remuxResult,\n            chunkMeta\n        });\n        chunkMeta.transmuxing.executeEnd = now();\n    }\n    resetInitialTimestamp(defaultInitPts) {\n        const { demuxer, remuxer } = this;\n        if (!demuxer || !remuxer) {\n            return;\n        }\n        demuxer.resetTimeStamp(defaultInitPts);\n        remuxer.resetTimeStamp(defaultInitPts);\n    }\n    resetContiguity() {\n        const { demuxer, remuxer } = this;\n        if (!demuxer || !remuxer) {\n            return;\n        }\n        demuxer.resetContiguity();\n        remuxer.resetNextTimestamp();\n    }\n    resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration, decryptdata) {\n        const { demuxer, remuxer } = this;\n        if (!demuxer || !remuxer) {\n            return;\n        }\n        demuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration);\n        remuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, decryptdata);\n    }\n    destroy() {\n        if (this.demuxer) {\n            this.demuxer.destroy();\n            this.demuxer = undefined;\n        }\n        if (this.remuxer) {\n            this.remuxer.destroy();\n            this.remuxer = undefined;\n        }\n    }\n    transmux(data, keyData, timeOffset, accurateTimeOffset, chunkMeta) {\n        let result;\n        if (keyData && keyData.method === \"SAMPLE-AES\") {\n            result = this.transmuxSampleAes(data, keyData, timeOffset, accurateTimeOffset, chunkMeta);\n        } else {\n            result = this.transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta);\n        }\n        return result;\n    }\n    transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta) {\n        const { audioTrack, videoTrack, id3Track, textTrack } = this.demuxer.demux(data, timeOffset, false, !this.config.progressive);\n        const remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, false, this.id);\n        return {\n            remuxResult,\n            chunkMeta\n        };\n    }\n    transmuxSampleAes(data, decryptData, timeOffset, accurateTimeOffset, chunkMeta) {\n        return this.demuxer.demuxSampleAes(data, decryptData, timeOffset).then((demuxResult)=>{\n            const remuxResult = this.remuxer.remux(demuxResult.audioTrack, demuxResult.videoTrack, demuxResult.id3Track, demuxResult.textTrack, timeOffset, accurateTimeOffset, false, this.id);\n            return {\n                remuxResult,\n                chunkMeta\n            };\n        });\n    }\n    configureTransmuxer(data) {\n        const { config, observer, typeSupported, vendor } = this;\n        // probe for content type\n        let mux;\n        for(let i = 0, len = muxConfig.length; i < len; i++){\n            var _muxConfig$i$demux;\n            if ((_muxConfig$i$demux = muxConfig[i].demux) != null && _muxConfig$i$demux.probe(data)) {\n                mux = muxConfig[i];\n                break;\n            }\n        }\n        if (!mux) {\n            return new Error(\"Failed to find demuxer by probing fragment data\");\n        }\n        // so let's check that current remuxer and demuxer are still valid\n        const demuxer = this.demuxer;\n        const remuxer = this.remuxer;\n        const Remuxer = mux.remux;\n        const Demuxer = mux.demux;\n        if (!remuxer || !(remuxer instanceof Remuxer)) {\n            this.remuxer = new Remuxer(observer, config, typeSupported, vendor);\n        }\n        if (!demuxer || !(demuxer instanceof Demuxer)) {\n            this.demuxer = new Demuxer(observer, config, typeSupported);\n            this.probe = Demuxer.probe;\n        }\n    }\n    needsProbing(discontinuity, trackSwitch) {\n        // in case of continuity change, or track switch\n        // we might switch from content type (AAC container to TS container, or TS to fmp4 for example)\n        return !this.demuxer || !this.remuxer || discontinuity || trackSwitch;\n    }\n    getDecrypter() {\n        let decrypter = this.decrypter;\n        if (!decrypter) {\n            decrypter = this.decrypter = new Decrypter(this.config);\n        }\n        return decrypter;\n    }\n}\nfunction getEncryptionType(data, decryptData) {\n    let encryptionType = null;\n    if (data.byteLength > 0 && (decryptData == null ? void 0 : decryptData.key) != null && decryptData.iv !== null && decryptData.method != null) {\n        encryptionType = decryptData;\n    }\n    return encryptionType;\n}\nconst emptyResult = (chunkMeta)=>({\n        remuxResult: {},\n        chunkMeta\n    });\nfunction isPromise(p) {\n    return \"then\" in p && p.then instanceof Function;\n}\nclass TransmuxConfig {\n    constructor(audioCodec, videoCodec, initSegmentData, duration, defaultInitPts){\n        this.audioCodec = void 0;\n        this.videoCodec = void 0;\n        this.initSegmentData = void 0;\n        this.duration = void 0;\n        this.defaultInitPts = void 0;\n        this.audioCodec = audioCodec;\n        this.videoCodec = videoCodec;\n        this.initSegmentData = initSegmentData;\n        this.duration = duration;\n        this.defaultInitPts = defaultInitPts || null;\n    }\n}\nclass TransmuxState {\n    constructor(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange){\n        this.discontinuity = void 0;\n        this.contiguous = void 0;\n        this.accurateTimeOffset = void 0;\n        this.trackSwitch = void 0;\n        this.timeOffset = void 0;\n        this.initSegmentChange = void 0;\n        this.discontinuity = discontinuity;\n        this.contiguous = contiguous;\n        this.accurateTimeOffset = accurateTimeOffset;\n        this.trackSwitch = trackSwitch;\n        this.timeOffset = timeOffset;\n        this.initSegmentChange = initSegmentChange;\n    }\n}\nvar eventemitter3 = {\n    exports: {}\n};\n(function(module) {\n    var has = Object.prototype.hasOwnProperty, prefix = \"~\";\n    /**\n\t * Constructor to create a storage for our `EE` objects.\n\t * An `Events` instance is a plain object whose properties are event names.\n\t *\n\t * @constructor\n\t * @private\n\t */ function Events() {}\n    //\n    // We try to not inherit from `Object.prototype`. In some engines creating an\n    // instance in this way is faster than calling `Object.create(null)` directly.\n    // If `Object.create(null)` is not supported we prefix the event names with a\n    // character to make sure that the built-in object properties are not\n    // overridden or used as an attack vector.\n    //\n    if (Object.create) {\n        Events.prototype = Object.create(null);\n        //\n        // This hack is needed because the `__proto__` property is still inherited in\n        // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n        //\n        if (!new Events().__proto__) prefix = false;\n    }\n    /**\n\t * Representation of a single event listener.\n\t *\n\t * @param {Function} fn The listener function.\n\t * @param {*} context The context to invoke the listener with.\n\t * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n\t * @constructor\n\t * @private\n\t */ function EE(fn, context, once) {\n        this.fn = fn;\n        this.context = context;\n        this.once = once || false;\n    }\n    /**\n\t * Add a listener for a given event.\n\t *\n\t * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n\t * @param {(String|Symbol)} event The event name.\n\t * @param {Function} fn The listener function.\n\t * @param {*} context The context to invoke the listener with.\n\t * @param {Boolean} once Specify if the listener is a one-time listener.\n\t * @returns {EventEmitter}\n\t * @private\n\t */ function addListener(emitter, event, fn, context, once) {\n        if (typeof fn !== \"function\") {\n            throw new TypeError(\"The listener must be a function\");\n        }\n        var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;\n        if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n        else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n        else emitter._events[evt] = [\n            emitter._events[evt],\n            listener\n        ];\n        return emitter;\n    }\n    /**\n\t * Clear event by name.\n\t *\n\t * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n\t * @param {(String|Symbol)} evt The Event name.\n\t * @private\n\t */ function clearEvent(emitter, evt) {\n        if (--emitter._eventsCount === 0) emitter._events = new Events();\n        else delete emitter._events[evt];\n    }\n    /**\n\t * Minimal `EventEmitter` interface that is molded against the Node.js\n\t * `EventEmitter` interface.\n\t *\n\t * @constructor\n\t * @public\n\t */ function EventEmitter() {\n        this._events = new Events();\n        this._eventsCount = 0;\n    }\n    /**\n\t * Return an array listing the events for which the emitter has registered\n\t * listeners.\n\t *\n\t * @returns {Array}\n\t * @public\n\t */ EventEmitter.prototype.eventNames = function eventNames() {\n        var names = [], events, name;\n        if (this._eventsCount === 0) return names;\n        for(name in events = this._events){\n            if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n        }\n        if (Object.getOwnPropertySymbols) {\n            return names.concat(Object.getOwnPropertySymbols(events));\n        }\n        return names;\n    };\n    /**\n\t * Return the listeners registered for a given event.\n\t *\n\t * @param {(String|Symbol)} event The event name.\n\t * @returns {Array} The registered listeners.\n\t * @public\n\t */ EventEmitter.prototype.listeners = function listeners(event) {\n        var evt = prefix ? prefix + event : event, handlers = this._events[evt];\n        if (!handlers) return [];\n        if (handlers.fn) return [\n            handlers.fn\n        ];\n        for(var i = 0, l = handlers.length, ee = new Array(l); i < l; i++){\n            ee[i] = handlers[i].fn;\n        }\n        return ee;\n    };\n    /**\n\t * Return the number of listeners listening to a given event.\n\t *\n\t * @param {(String|Symbol)} event The event name.\n\t * @returns {Number} The number of listeners.\n\t * @public\n\t */ EventEmitter.prototype.listenerCount = function listenerCount(event) {\n        var evt = prefix ? prefix + event : event, listeners = this._events[evt];\n        if (!listeners) return 0;\n        if (listeners.fn) return 1;\n        return listeners.length;\n    };\n    /**\n\t * Calls each of the listeners registered for a given event.\n\t *\n\t * @param {(String|Symbol)} event The event name.\n\t * @returns {Boolean} `true` if the event had listeners, else `false`.\n\t * @public\n\t */ EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n        var evt = prefix ? prefix + event : event;\n        if (!this._events[evt]) return false;\n        var listeners = this._events[evt], len = arguments.length, args, i;\n        if (listeners.fn) {\n            if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n            switch(len){\n                case 1:\n                    return listeners.fn.call(listeners.context), true;\n                case 2:\n                    return listeners.fn.call(listeners.context, a1), true;\n                case 3:\n                    return listeners.fn.call(listeners.context, a1, a2), true;\n                case 4:\n                    return listeners.fn.call(listeners.context, a1, a2, a3), true;\n                case 5:\n                    return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n                case 6:\n                    return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n            }\n            for(i = 1, args = new Array(len - 1); i < len; i++){\n                args[i - 1] = arguments[i];\n            }\n            listeners.fn.apply(listeners.context, args);\n        } else {\n            var length = listeners.length, j;\n            for(i = 0; i < length; i++){\n                if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n                switch(len){\n                    case 1:\n                        listeners[i].fn.call(listeners[i].context);\n                        break;\n                    case 2:\n                        listeners[i].fn.call(listeners[i].context, a1);\n                        break;\n                    case 3:\n                        listeners[i].fn.call(listeners[i].context, a1, a2);\n                        break;\n                    case 4:\n                        listeners[i].fn.call(listeners[i].context, a1, a2, a3);\n                        break;\n                    default:\n                        if (!args) for(j = 1, args = new Array(len - 1); j < len; j++){\n                            args[j - 1] = arguments[j];\n                        }\n                        listeners[i].fn.apply(listeners[i].context, args);\n                }\n            }\n        }\n        return true;\n    };\n    /**\n\t * Add a listener for a given event.\n\t *\n\t * @param {(String|Symbol)} event The event name.\n\t * @param {Function} fn The listener function.\n\t * @param {*} [context=this] The context to invoke the listener with.\n\t * @returns {EventEmitter} `this`.\n\t * @public\n\t */ EventEmitter.prototype.on = function on(event, fn, context) {\n        return addListener(this, event, fn, context, false);\n    };\n    /**\n\t * Add a one-time listener for a given event.\n\t *\n\t * @param {(String|Symbol)} event The event name.\n\t * @param {Function} fn The listener function.\n\t * @param {*} [context=this] The context to invoke the listener with.\n\t * @returns {EventEmitter} `this`.\n\t * @public\n\t */ EventEmitter.prototype.once = function once(event, fn, context) {\n        return addListener(this, event, fn, context, true);\n    };\n    /**\n\t * Remove the listeners of a given event.\n\t *\n\t * @param {(String|Symbol)} event The event name.\n\t * @param {Function} fn Only remove the listeners that match this function.\n\t * @param {*} context Only remove the listeners that have this context.\n\t * @param {Boolean} once Only remove one-time listeners.\n\t * @returns {EventEmitter} `this`.\n\t * @public\n\t */ EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n        var evt = prefix ? prefix + event : event;\n        if (!this._events[evt]) return this;\n        if (!fn) {\n            clearEvent(this, evt);\n            return this;\n        }\n        var listeners = this._events[evt];\n        if (listeners.fn) {\n            if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {\n                clearEvent(this, evt);\n            }\n        } else {\n            for(var i = 0, events = [], length = listeners.length; i < length; i++){\n                if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {\n                    events.push(listeners[i]);\n                }\n            }\n            //\n            // Reset the array, or remove it completely if we have no more listeners.\n            //\n            if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n            else clearEvent(this, evt);\n        }\n        return this;\n    };\n    /**\n\t * Remove all listeners, or those of the specified event.\n\t *\n\t * @param {(String|Symbol)} [event] The event name.\n\t * @returns {EventEmitter} `this`.\n\t * @public\n\t */ EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n        var evt;\n        if (event) {\n            evt = prefix ? prefix + event : event;\n            if (this._events[evt]) clearEvent(this, evt);\n        } else {\n            this._events = new Events();\n            this._eventsCount = 0;\n        }\n        return this;\n    };\n    //\n    // Alias methods names because people roll like that.\n    //\n    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n    EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n    //\n    // Expose the prefix.\n    //\n    EventEmitter.prefixed = prefix;\n    //\n    // Allow `EventEmitter` to be imported as module namespace.\n    //\n    EventEmitter.EventEmitter = EventEmitter;\n    //\n    // Expose the module.\n    //\n    {\n        module.exports = EventEmitter;\n    }\n})(eventemitter3);\nvar eventemitter3Exports = eventemitter3.exports;\nvar EventEmitter = /*@__PURE__*/ getDefaultExportFromCjs(eventemitter3Exports);\nclass TransmuxerInterface {\n    constructor(hls, id, onTransmuxComplete, onFlush){\n        this.error = null;\n        this.hls = void 0;\n        this.id = void 0;\n        this.observer = void 0;\n        this.frag = null;\n        this.part = null;\n        this.useWorker = void 0;\n        this.workerContext = null;\n        this.onwmsg = void 0;\n        this.transmuxer = null;\n        this.onTransmuxComplete = void 0;\n        this.onFlush = void 0;\n        const config = hls.config;\n        this.hls = hls;\n        this.id = id;\n        this.useWorker = !!config.enableWorker;\n        this.onTransmuxComplete = onTransmuxComplete;\n        this.onFlush = onFlush;\n        const forwardMessage = (ev, data)=>{\n            data = data || {};\n            data.frag = this.frag;\n            data.id = this.id;\n            if (ev === Events.ERROR) {\n                this.error = data.error;\n            }\n            this.hls.trigger(ev, data);\n        };\n        // forward events to main thread\n        this.observer = new EventEmitter();\n        this.observer.on(Events.FRAG_DECRYPTED, forwardMessage);\n        this.observer.on(Events.ERROR, forwardMessage);\n        const MediaSource = getMediaSource(config.preferManagedMediaSource) || {\n            isTypeSupported: ()=>false\n        };\n        const m2tsTypeSupported = {\n            mpeg: MediaSource.isTypeSupported(\"audio/mpeg\"),\n            mp3: MediaSource.isTypeSupported('audio/mp4; codecs=\"mp3\"'),\n            ac3: MediaSource.isTypeSupported('audio/mp4; codecs=\"ac-3\"')\n        };\n        // navigator.vendor is not always available in Web Worker\n        // refer to https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/navigator\n        const vendor = navigator.vendor;\n        if (this.useWorker && typeof Worker !== \"undefined\") {\n            const canCreateWorker = config.workerPath || hasUMDWorker();\n            if (canCreateWorker) {\n                try {\n                    if (config.workerPath) {\n                        logger.log(`loading Web Worker ${config.workerPath} for \"${id}\"`);\n                        this.workerContext = loadWorker(config.workerPath);\n                    } else {\n                        logger.log(`injecting Web Worker for \"${id}\"`);\n                        this.workerContext = injectWorker();\n                    }\n                    this.onwmsg = (ev)=>this.onWorkerMessage(ev);\n                    const { worker } = this.workerContext;\n                    worker.addEventListener(\"message\", this.onwmsg);\n                    worker.onerror = (event)=>{\n                        const error = new Error(`${event.message}  (${event.filename}:${event.lineno})`);\n                        config.enableWorker = false;\n                        logger.warn(`Error in \"${id}\" Web Worker, fallback to inline`);\n                        this.hls.trigger(Events.ERROR, {\n                            type: ErrorTypes.OTHER_ERROR,\n                            details: ErrorDetails.INTERNAL_EXCEPTION,\n                            fatal: false,\n                            event: \"demuxerWorker\",\n                            error\n                        });\n                    };\n                    worker.postMessage({\n                        cmd: \"init\",\n                        typeSupported: m2tsTypeSupported,\n                        vendor: vendor,\n                        id: id,\n                        config: JSON.stringify(config)\n                    });\n                } catch (err) {\n                    logger.warn(`Error setting up \"${id}\" Web Worker, fallback to inline`, err);\n                    this.resetWorker();\n                    this.error = null;\n                    this.transmuxer = new Transmuxer(this.observer, m2tsTypeSupported, config, vendor, id);\n                }\n                return;\n            }\n        }\n        this.transmuxer = new Transmuxer(this.observer, m2tsTypeSupported, config, vendor, id);\n    }\n    resetWorker() {\n        if (this.workerContext) {\n            const { worker, objectURL } = this.workerContext;\n            if (objectURL) {\n                // revoke the Object URL that was used to create transmuxer worker, so as not to leak it\n                self.URL.revokeObjectURL(objectURL);\n            }\n            worker.removeEventListener(\"message\", this.onwmsg);\n            worker.onerror = null;\n            worker.terminate();\n            this.workerContext = null;\n        }\n    }\n    destroy() {\n        if (this.workerContext) {\n            this.resetWorker();\n            this.onwmsg = undefined;\n        } else {\n            const transmuxer = this.transmuxer;\n            if (transmuxer) {\n                transmuxer.destroy();\n                this.transmuxer = null;\n            }\n        }\n        const observer = this.observer;\n        if (observer) {\n            observer.removeAllListeners();\n        }\n        this.frag = null;\n        // @ts-ignore\n        this.observer = null;\n        // @ts-ignore\n        this.hls = null;\n    }\n    push(data, initSegmentData, audioCodec, videoCodec, frag, part, duration, accurateTimeOffset, chunkMeta, defaultInitPTS) {\n        var _frag$initSegment, _lastFrag$initSegment;\n        chunkMeta.transmuxing.start = self.performance.now();\n        const { transmuxer } = this;\n        const timeOffset = part ? part.start : frag.start;\n        // TODO: push \"clear-lead\" decrypt data for unencrypted fragments in streams with encrypted ones\n        const decryptdata = frag.decryptdata;\n        const lastFrag = this.frag;\n        const discontinuity = !(lastFrag && frag.cc === lastFrag.cc);\n        const trackSwitch = !(lastFrag && chunkMeta.level === lastFrag.level);\n        const snDiff = lastFrag ? chunkMeta.sn - lastFrag.sn : -1;\n        const partDiff = this.part ? chunkMeta.part - this.part.index : -1;\n        const progressive = snDiff === 0 && chunkMeta.id > 1 && chunkMeta.id === (lastFrag == null ? void 0 : lastFrag.stats.chunkCount);\n        const contiguous = !trackSwitch && (snDiff === 1 || snDiff === 0 && (partDiff === 1 || progressive && partDiff <= 0));\n        const now = self.performance.now();\n        if (trackSwitch || snDiff || frag.stats.parsing.start === 0) {\n            frag.stats.parsing.start = now;\n        }\n        if (part && (partDiff || !contiguous)) {\n            part.stats.parsing.start = now;\n        }\n        const initSegmentChange = !(lastFrag && ((_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.url) === ((_lastFrag$initSegment = lastFrag.initSegment) == null ? void 0 : _lastFrag$initSegment.url));\n        const state = new TransmuxState(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange);\n        if (!contiguous || discontinuity || initSegmentChange) {\n            logger.log(`[transmuxer-interface, ${frag.type}]: Starting new transmux session for sn: ${chunkMeta.sn} p: ${chunkMeta.part} level: ${chunkMeta.level} id: ${chunkMeta.id}\n        discontinuity: ${discontinuity}\n        trackSwitch: ${trackSwitch}\n        contiguous: ${contiguous}\n        accurateTimeOffset: ${accurateTimeOffset}\n        timeOffset: ${timeOffset}\n        initSegmentChange: ${initSegmentChange}`);\n            const config = new TransmuxConfig(audioCodec, videoCodec, initSegmentData, duration, defaultInitPTS);\n            this.configureTransmuxer(config);\n        }\n        this.frag = frag;\n        this.part = part;\n        // Frags with sn of 'initSegment' are not transmuxed\n        if (this.workerContext) {\n            // post fragment payload as transferable objects for ArrayBuffer (no copy)\n            this.workerContext.worker.postMessage({\n                cmd: \"demux\",\n                data,\n                decryptdata,\n                chunkMeta,\n                state\n            }, data instanceof ArrayBuffer ? [\n                data\n            ] : []);\n        } else if (transmuxer) {\n            const transmuxResult = transmuxer.push(data, decryptdata, chunkMeta, state);\n            if (isPromise(transmuxResult)) {\n                transmuxer.async = true;\n                transmuxResult.then((data)=>{\n                    this.handleTransmuxComplete(data);\n                }).catch((error)=>{\n                    this.transmuxerError(error, chunkMeta, \"transmuxer-interface push error\");\n                });\n            } else {\n                transmuxer.async = false;\n                this.handleTransmuxComplete(transmuxResult);\n            }\n        }\n    }\n    flush(chunkMeta) {\n        chunkMeta.transmuxing.start = self.performance.now();\n        const { transmuxer } = this;\n        if (this.workerContext) {\n            this.workerContext.worker.postMessage({\n                cmd: \"flush\",\n                chunkMeta\n            });\n        } else if (transmuxer) {\n            let transmuxResult = transmuxer.flush(chunkMeta);\n            const asyncFlush = isPromise(transmuxResult);\n            if (asyncFlush || transmuxer.async) {\n                if (!isPromise(transmuxResult)) {\n                    transmuxResult = Promise.resolve(transmuxResult);\n                }\n                transmuxResult.then((data)=>{\n                    this.handleFlushResult(data, chunkMeta);\n                }).catch((error)=>{\n                    this.transmuxerError(error, chunkMeta, \"transmuxer-interface flush error\");\n                });\n            } else {\n                this.handleFlushResult(transmuxResult, chunkMeta);\n            }\n        }\n    }\n    transmuxerError(error, chunkMeta, reason) {\n        if (!this.hls) {\n            return;\n        }\n        this.error = error;\n        this.hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.FRAG_PARSING_ERROR,\n            chunkMeta,\n            fatal: false,\n            error,\n            err: error,\n            reason\n        });\n    }\n    handleFlushResult(results, chunkMeta) {\n        results.forEach((result)=>{\n            this.handleTransmuxComplete(result);\n        });\n        this.onFlush(chunkMeta);\n    }\n    onWorkerMessage(ev) {\n        const data = ev.data;\n        const hls = this.hls;\n        switch(data.event){\n            case \"init\":\n                {\n                    var _this$workerContext;\n                    const objectURL = (_this$workerContext = this.workerContext) == null ? void 0 : _this$workerContext.objectURL;\n                    if (objectURL) {\n                        // revoke the Object URL that was used to create transmuxer worker, so as not to leak it\n                        self.URL.revokeObjectURL(objectURL);\n                    }\n                    break;\n                }\n            case \"transmuxComplete\":\n                {\n                    this.handleTransmuxComplete(data.data);\n                    break;\n                }\n            case \"flush\":\n                {\n                    this.onFlush(data.data);\n                    break;\n                }\n            // pass logs from the worker thread to the main logger\n            case \"workerLog\":\n                if (logger[data.data.logType]) {\n                    logger[data.data.logType](data.data.message);\n                }\n                break;\n            default:\n                {\n                    data.data = data.data || {};\n                    data.data.frag = this.frag;\n                    data.data.id = this.id;\n                    hls.trigger(data.event, data.data);\n                    break;\n                }\n        }\n    }\n    configureTransmuxer(config) {\n        const { transmuxer } = this;\n        if (this.workerContext) {\n            this.workerContext.worker.postMessage({\n                cmd: \"configure\",\n                config\n            });\n        } else if (transmuxer) {\n            transmuxer.configure(config);\n        }\n    }\n    handleTransmuxComplete(result) {\n        result.chunkMeta.transmuxing.end = self.performance.now();\n        this.onTransmuxComplete(result);\n    }\n}\nfunction subtitleOptionsIdentical(trackList1, trackList2) {\n    if (trackList1.length !== trackList2.length) {\n        return false;\n    }\n    for(let i = 0; i < trackList1.length; i++){\n        if (!mediaAttributesIdentical(trackList1[i].attrs, trackList2[i].attrs)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction mediaAttributesIdentical(attrs1, attrs2, customAttributes) {\n    // Media options with the same rendition ID must be bit identical\n    const stableRenditionId = attrs1[\"STABLE-RENDITION-ID\"];\n    if (stableRenditionId && !customAttributes) {\n        return stableRenditionId === attrs2[\"STABLE-RENDITION-ID\"];\n    }\n    // When rendition ID is not present, compare attributes\n    return !(customAttributes || [\n        \"LANGUAGE\",\n        \"NAME\",\n        \"CHARACTERISTICS\",\n        \"AUTOSELECT\",\n        \"DEFAULT\",\n        \"FORCED\",\n        \"ASSOC-LANGUAGE\"\n    ]).some((subtitleAttribute)=>attrs1[subtitleAttribute] !== attrs2[subtitleAttribute]);\n}\nfunction subtitleTrackMatchesTextTrack(subtitleTrack, textTrack) {\n    return textTrack.label.toLowerCase() === subtitleTrack.name.toLowerCase() && (!textTrack.language || textTrack.language.toLowerCase() === (subtitleTrack.lang || \"\").toLowerCase());\n}\nconst TICK_INTERVAL$2 = 100; // how often to tick in ms\nclass AudioStreamController extends BaseStreamController {\n    constructor(hls, fragmentTracker, keyLoader){\n        super(hls, fragmentTracker, keyLoader, \"[audio-stream-controller]\", PlaylistLevelType.AUDIO);\n        this.videoBuffer = null;\n        this.videoTrackCC = -1;\n        this.waitingVideoCC = -1;\n        this.bufferedTrack = null;\n        this.switchingTrack = null;\n        this.trackId = -1;\n        this.waitingData = null;\n        this.mainDetails = null;\n        this.flushing = false;\n        this.bufferFlushed = false;\n        this.cachedTrackLoadedData = null;\n        this._registerListeners();\n    }\n    onHandlerDestroying() {\n        this._unregisterListeners();\n        super.onHandlerDestroying();\n        this.mainDetails = null;\n        this.bufferedTrack = null;\n        this.switchingTrack = null;\n    }\n    _registerListeners() {\n        const { hls } = this;\n        hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n        hls.on(Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);\n        hls.on(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n        hls.on(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n        hls.on(Events.ERROR, this.onError, this);\n        hls.on(Events.BUFFER_RESET, this.onBufferReset, this);\n        hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);\n        hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n        hls.on(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n        hls.on(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n        hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    }\n    _unregisterListeners() {\n        const { hls } = this;\n        hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n        hls.off(Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);\n        hls.off(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n        hls.off(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n        hls.off(Events.ERROR, this.onError, this);\n        hls.off(Events.BUFFER_RESET, this.onBufferReset, this);\n        hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);\n        hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n        hls.off(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n        hls.off(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n        hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    }\n    // INIT_PTS_FOUND is triggered when the video track parsed in the stream-controller has a new PTS value\n    onInitPtsFound(event, { frag, id, initPTS, timescale }) {\n        // Always update the new INIT PTS\n        // Can change due level switch\n        if (id === \"main\") {\n            const cc = frag.cc;\n            this.initPTS[frag.cc] = {\n                baseTime: initPTS,\n                timescale\n            };\n            this.log(`InitPTS for cc: ${cc} found from main: ${initPTS}`);\n            this.videoTrackCC = cc;\n            // If we are waiting, tick immediately to unblock audio fragment transmuxing\n            if (this.state === State.WAITING_INIT_PTS) {\n                this.tick();\n            }\n        }\n    }\n    startLoad(startPosition) {\n        if (!this.levels) {\n            this.startPosition = startPosition;\n            this.state = State.STOPPED;\n            return;\n        }\n        const lastCurrentTime = this.lastCurrentTime;\n        this.stopLoad();\n        this.setInterval(TICK_INTERVAL$2);\n        if (lastCurrentTime > 0 && startPosition === -1) {\n            this.log(`Override startPosition with lastCurrentTime @${lastCurrentTime.toFixed(3)}`);\n            startPosition = lastCurrentTime;\n            this.state = State.IDLE;\n        } else {\n            this.loadedmetadata = false;\n            this.state = State.WAITING_TRACK;\n        }\n        this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;\n        this.tick();\n    }\n    doTick() {\n        switch(this.state){\n            case State.IDLE:\n                this.doTickIdle();\n                break;\n            case State.WAITING_TRACK:\n                {\n                    var _levels$trackId;\n                    const { levels, trackId } = this;\n                    const details = levels == null ? void 0 : (_levels$trackId = levels[trackId]) == null ? void 0 : _levels$trackId.details;\n                    if (details) {\n                        if (this.waitForCdnTuneIn(details)) {\n                            break;\n                        }\n                        this.state = State.WAITING_INIT_PTS;\n                    }\n                    break;\n                }\n            case State.FRAG_LOADING_WAITING_RETRY:\n                {\n                    var _this$media;\n                    const now = performance.now();\n                    const retryDate = this.retryDate;\n                    // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading\n                    if (!retryDate || now >= retryDate || (_this$media = this.media) != null && _this$media.seeking) {\n                        const { levels, trackId } = this;\n                        this.log(\"RetryDate reached, switch back to IDLE state\");\n                        this.resetStartWhenNotLoaded((levels == null ? void 0 : levels[trackId]) || null);\n                        this.state = State.IDLE;\n                    }\n                    break;\n                }\n            case State.WAITING_INIT_PTS:\n                {\n                    // Ensure we don't get stuck in the WAITING_INIT_PTS state if the waiting frag CC doesn't match any initPTS\n                    const waitingData = this.waitingData;\n                    if (waitingData) {\n                        const { frag, part, cache, complete } = waitingData;\n                        if (this.initPTS[frag.cc] !== undefined) {\n                            this.waitingData = null;\n                            this.waitingVideoCC = -1;\n                            this.state = State.FRAG_LOADING;\n                            const payload = cache.flush();\n                            const data = {\n                                frag,\n                                part,\n                                payload,\n                                networkDetails: null\n                            };\n                            this._handleFragmentLoadProgress(data);\n                            if (complete) {\n                                super._handleFragmentLoadComplete(data);\n                            }\n                        } else if (this.videoTrackCC !== this.waitingVideoCC) {\n                            // Drop waiting fragment if videoTrackCC has changed since waitingFragment was set and initPTS was not found\n                            this.log(`Waiting fragment cc (${frag.cc}) cancelled because video is at cc ${this.videoTrackCC}`);\n                            this.clearWaitingFragment();\n                        } else {\n                            // Drop waiting fragment if an earlier fragment is needed\n                            const pos = this.getLoadPosition();\n                            const bufferInfo = BufferHelper.bufferInfo(this.mediaBuffer, pos, this.config.maxBufferHole);\n                            const waitingFragmentAtPosition = fragmentWithinToleranceTest(bufferInfo.end, this.config.maxFragLookUpTolerance, frag);\n                            if (waitingFragmentAtPosition < 0) {\n                                this.log(`Waiting fragment cc (${frag.cc}) @ ${frag.start} cancelled because another fragment at ${bufferInfo.end} is needed`);\n                                this.clearWaitingFragment();\n                            }\n                        }\n                    } else {\n                        this.state = State.IDLE;\n                    }\n                }\n        }\n        this.onTickEnd();\n    }\n    clearWaitingFragment() {\n        const waitingData = this.waitingData;\n        if (waitingData) {\n            this.fragmentTracker.removeFragment(waitingData.frag);\n            this.waitingData = null;\n            this.waitingVideoCC = -1;\n            this.state = State.IDLE;\n        }\n    }\n    resetLoadingState() {\n        this.clearWaitingFragment();\n        super.resetLoadingState();\n    }\n    onTickEnd() {\n        const { media } = this;\n        if (!(media != null && media.readyState)) {\n            // Exit early if we don't have media or if the media hasn't buffered anything yet (readyState 0)\n            return;\n        }\n        this.lastCurrentTime = media.currentTime;\n    }\n    doTickIdle() {\n        const { hls, levels, media, trackId } = this;\n        const config = hls.config;\n        // 1. if video not attached AND\n        //    start fragment already requested OR start frag prefetch not enabled\n        // 2. if tracks or track not loaded and selected\n        // then exit loop\n        // => if media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop\n        if (!media && (this.startFragRequested || !config.startFragPrefetch) || !(levels != null && levels[trackId])) {\n            return;\n        }\n        const levelInfo = levels[trackId];\n        const trackDetails = levelInfo.details;\n        if (!trackDetails || trackDetails.live && this.levelLastLoaded !== levelInfo || this.waitForCdnTuneIn(trackDetails)) {\n            this.state = State.WAITING_TRACK;\n            return;\n        }\n        const bufferable = this.mediaBuffer ? this.mediaBuffer : this.media;\n        if (this.bufferFlushed && bufferable) {\n            this.bufferFlushed = false;\n            this.afterBufferFlushed(bufferable, ElementaryStreamTypes.AUDIO, PlaylistLevelType.AUDIO);\n        }\n        const bufferInfo = this.getFwdBufferInfo(bufferable, PlaylistLevelType.AUDIO);\n        if (bufferInfo === null) {\n            return;\n        }\n        const { bufferedTrack, switchingTrack } = this;\n        if (!switchingTrack && this._streamEnded(bufferInfo, trackDetails)) {\n            hls.trigger(Events.BUFFER_EOS, {\n                type: \"audio\"\n            });\n            this.state = State.ENDED;\n            return;\n        }\n        const mainBufferInfo = this.getFwdBufferInfo(this.videoBuffer ? this.videoBuffer : this.media, PlaylistLevelType.MAIN);\n        const bufferLen = bufferInfo.len;\n        const maxBufLen = this.getMaxBufferLength(mainBufferInfo == null ? void 0 : mainBufferInfo.len);\n        const fragments = trackDetails.fragments;\n        const start = fragments[0].start;\n        let targetBufferTime = this.flushing ? this.getLoadPosition() : bufferInfo.end;\n        if (switchingTrack && media) {\n            const pos = this.getLoadPosition();\n            // STABLE\n            if (bufferedTrack && !mediaAttributesIdentical(switchingTrack.attrs, bufferedTrack.attrs)) {\n                targetBufferTime = pos;\n            }\n            // if currentTime (pos) is less than alt audio playlist start time, it means that alt audio is ahead of currentTime\n            if (trackDetails.PTSKnown && pos < start) {\n                // if everything is buffered from pos to start or if audio buffer upfront, let's seek to start\n                if (bufferInfo.end > start || bufferInfo.nextStart) {\n                    this.log(\"Alt audio track ahead of main track, seek to start of alt audio track\");\n                    media.currentTime = start + 0.05;\n                }\n            }\n        }\n        // if buffer length is less than maxBufLen, or near the end, find a fragment to load\n        if (bufferLen >= maxBufLen && !switchingTrack && targetBufferTime < fragments[fragments.length - 1].start) {\n            return;\n        }\n        let frag = this.getNextFragment(targetBufferTime, trackDetails);\n        let atGap = false;\n        // Avoid loop loading by using nextLoadPosition set for backtracking and skipping consecutive GAP tags\n        if (frag && this.isLoopLoading(frag, targetBufferTime)) {\n            atGap = !!frag.gap;\n            frag = this.getNextFragmentLoopLoading(frag, trackDetails, bufferInfo, PlaylistLevelType.MAIN, maxBufLen);\n        }\n        if (!frag) {\n            this.bufferFlushed = true;\n            return;\n        }\n        // Buffer audio up to one target duration ahead of main buffer\n        const atBufferSyncLimit = mainBufferInfo && frag.start > mainBufferInfo.end + trackDetails.targetduration;\n        if (atBufferSyncLimit || // Or wait for main buffer after buffing some audio\n        !(mainBufferInfo != null && mainBufferInfo.len) && bufferInfo.len) {\n            // Check fragment-tracker for main fragments since GAP segments do not show up in bufferInfo\n            const mainFrag = this.getAppendedFrag(frag.start, PlaylistLevelType.MAIN);\n            if (mainFrag === null) {\n                return;\n            }\n            // Bridge gaps in main buffer\n            atGap || (atGap = !!mainFrag.gap || !!atBufferSyncLimit && mainBufferInfo.len === 0);\n            if (atBufferSyncLimit && !atGap || atGap && bufferInfo.nextStart && bufferInfo.nextStart < mainFrag.end) {\n                return;\n            }\n        }\n        this.loadFragment(frag, levelInfo, targetBufferTime);\n    }\n    getMaxBufferLength(mainBufferLength) {\n        const maxConfigBuffer = super.getMaxBufferLength();\n        if (!mainBufferLength) {\n            return maxConfigBuffer;\n        }\n        return Math.min(Math.max(maxConfigBuffer, mainBufferLength), this.config.maxMaxBufferLength);\n    }\n    onMediaDetaching() {\n        this.videoBuffer = null;\n        this.bufferFlushed = this.flushing = false;\n        super.onMediaDetaching();\n    }\n    onAudioTracksUpdated(event, { audioTracks }) {\n        // Reset tranxmuxer is essential for large context switches (Content Steering)\n        this.resetTransmuxer();\n        this.levels = audioTracks.map((mediaPlaylist)=>new Level(mediaPlaylist));\n    }\n    onAudioTrackSwitching(event, data) {\n        // if any URL found on new audio track, it is an alternate audio track\n        const altAudio = !!data.url;\n        this.trackId = data.id;\n        const { fragCurrent } = this;\n        if (fragCurrent) {\n            fragCurrent.abortRequests();\n            this.removeUnbufferedFrags(fragCurrent.start);\n        }\n        this.resetLoadingState();\n        // destroy useless transmuxer when switching audio to main\n        if (!altAudio) {\n            this.resetTransmuxer();\n        } else {\n            // switching to audio track, start timer if not already started\n            this.setInterval(TICK_INTERVAL$2);\n        }\n        // should we switch tracks ?\n        if (altAudio) {\n            this.switchingTrack = data;\n            // main audio track are handled by stream-controller, just do something if switching to alt audio track\n            this.state = State.IDLE;\n            this.flushAudioIfNeeded(data);\n        } else {\n            this.switchingTrack = null;\n            this.bufferedTrack = data;\n            this.state = State.STOPPED;\n        }\n        this.tick();\n    }\n    onManifestLoading() {\n        this.fragmentTracker.removeAllFragments();\n        this.startPosition = this.lastCurrentTime = 0;\n        this.bufferFlushed = this.flushing = false;\n        this.levels = this.mainDetails = this.waitingData = this.bufferedTrack = this.cachedTrackLoadedData = this.switchingTrack = null;\n        this.startFragRequested = false;\n        this.trackId = this.videoTrackCC = this.waitingVideoCC = -1;\n    }\n    onLevelLoaded(event, data) {\n        this.mainDetails = data.details;\n        if (this.cachedTrackLoadedData !== null) {\n            this.hls.trigger(Events.AUDIO_TRACK_LOADED, this.cachedTrackLoadedData);\n            this.cachedTrackLoadedData = null;\n        }\n    }\n    onAudioTrackLoaded(event, data) {\n        var _track$details;\n        if (this.mainDetails == null) {\n            this.cachedTrackLoadedData = data;\n            return;\n        }\n        const { levels } = this;\n        const { details: newDetails, id: trackId } = data;\n        if (!levels) {\n            this.warn(`Audio tracks were reset while loading level ${trackId}`);\n            return;\n        }\n        this.log(`Audio track ${trackId} loaded [${newDetails.startSN},${newDetails.endSN}]${newDetails.lastPartSn ? `[part-${newDetails.lastPartSn}-${newDetails.lastPartIndex}]` : \"\"},duration:${newDetails.totalduration}`);\n        const track = levels[trackId];\n        let sliding = 0;\n        if (newDetails.live || (_track$details = track.details) != null && _track$details.live) {\n            this.checkLiveUpdate(newDetails);\n            const mainDetails = this.mainDetails;\n            if (newDetails.deltaUpdateFailed || !mainDetails) {\n                return;\n            }\n            if (!track.details && newDetails.hasProgramDateTime && mainDetails.hasProgramDateTime) {\n                // Make sure our audio rendition is aligned with the \"main\" rendition, using\n                // pdt as our reference times.\n                alignMediaPlaylistByPDT(newDetails, mainDetails);\n                sliding = newDetails.fragments[0].start;\n            } else {\n                var _this$levelLastLoaded;\n                sliding = this.alignPlaylists(newDetails, track.details, (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details);\n            }\n        }\n        track.details = newDetails;\n        this.levelLastLoaded = track;\n        // compute start position if we are aligned with the main playlist\n        if (!this.startFragRequested && (this.mainDetails || !newDetails.live)) {\n            this.setStartPosition(this.mainDetails || newDetails, sliding);\n        }\n        // only switch back to IDLE state if we were waiting for track to start downloading a new fragment\n        if (this.state === State.WAITING_TRACK && !this.waitForCdnTuneIn(newDetails)) {\n            this.state = State.IDLE;\n        }\n        // trigger handler right now\n        this.tick();\n    }\n    _handleFragmentLoadProgress(data) {\n        var _frag$initSegment;\n        const { frag, part, payload } = data;\n        const { config, trackId, levels } = this;\n        if (!levels) {\n            this.warn(`Audio tracks were reset while fragment load was in progress. Fragment ${frag.sn} of level ${frag.level} will not be buffered`);\n            return;\n        }\n        const track = levels[trackId];\n        if (!track) {\n            this.warn(\"Audio track is undefined on fragment load progress\");\n            return;\n        }\n        const details = track.details;\n        if (!details) {\n            this.warn(\"Audio track details undefined on fragment load progress\");\n            this.removeUnbufferedFrags(frag.start);\n            return;\n        }\n        const audioCodec = config.defaultAudioCodec || track.audioCodec || \"mp4a.40.2\";\n        let transmuxer = this.transmuxer;\n        if (!transmuxer) {\n            transmuxer = this.transmuxer = new TransmuxerInterface(this.hls, PlaylistLevelType.AUDIO, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));\n        }\n        // Check if we have video initPTS\n        // If not we need to wait for it\n        const initPTS = this.initPTS[frag.cc];\n        const initSegmentData = (_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.data;\n        if (initPTS !== undefined) {\n            // this.log(`Transmuxing ${sn} of [${details.startSN} ,${details.endSN}],track ${trackId}`);\n            // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)\n            const accurateTimeOffset = false; // details.PTSKnown || !details.live;\n            const partIndex = part ? part.index : -1;\n            const partial = partIndex !== -1;\n            const chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);\n            transmuxer.push(payload, initSegmentData, audioCodec, \"\", frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);\n        } else {\n            this.log(`Unknown video PTS for cc ${frag.cc}, waiting for video PTS before demuxing audio frag ${frag.sn} of [${details.startSN} ,${details.endSN}],track ${trackId}`);\n            const { cache } = this.waitingData = this.waitingData || {\n                frag,\n                part,\n                cache: new ChunkCache(),\n                complete: false\n            };\n            cache.push(new Uint8Array(payload));\n            this.waitingVideoCC = this.videoTrackCC;\n            this.state = State.WAITING_INIT_PTS;\n        }\n    }\n    _handleFragmentLoadComplete(fragLoadedData) {\n        if (this.waitingData) {\n            this.waitingData.complete = true;\n            return;\n        }\n        super._handleFragmentLoadComplete(fragLoadedData);\n    }\n    onBufferReset() {\n        // reset reference to sourcebuffers\n        this.mediaBuffer = this.videoBuffer = null;\n        this.loadedmetadata = false;\n    }\n    onBufferCreated(event, data) {\n        const audioTrack = data.tracks.audio;\n        if (audioTrack) {\n            this.mediaBuffer = audioTrack.buffer || null;\n        }\n        if (data.tracks.video) {\n            this.videoBuffer = data.tracks.video.buffer || null;\n        }\n    }\n    onFragBuffered(event, data) {\n        const { frag, part } = data;\n        if (frag.type !== PlaylistLevelType.AUDIO) {\n            if (!this.loadedmetadata && frag.type === PlaylistLevelType.MAIN) {\n                const bufferable = this.videoBuffer || this.media;\n                if (bufferable) {\n                    const bufferedTimeRanges = BufferHelper.getBuffered(bufferable);\n                    if (bufferedTimeRanges.length) {\n                        this.loadedmetadata = true;\n                    }\n                }\n            }\n            return;\n        }\n        if (this.fragContextChanged(frag)) {\n            // If a level switch was requested while a fragment was buffering, it will emit the FRAG_BUFFERED event upon completion\n            // Avoid setting state back to IDLE or concluding the audio switch; otherwise, the switched-to track will not buffer\n            this.warn(`Fragment ${frag.sn}${part ? \" p: \" + part.index : \"\"} of level ${frag.level} finished buffering, but was aborted. state: ${this.state}, audioSwitch: ${this.switchingTrack ? this.switchingTrack.name : \"false\"}`);\n            return;\n        }\n        if (frag.sn !== \"initSegment\") {\n            this.fragPrevious = frag;\n            const track = this.switchingTrack;\n            if (track) {\n                this.bufferedTrack = track;\n                this.switchingTrack = null;\n                this.hls.trigger(Events.AUDIO_TRACK_SWITCHED, _objectSpread2({}, track));\n            }\n        }\n        this.fragBufferedComplete(frag, part);\n    }\n    onError(event, data) {\n        var _data$context;\n        if (data.fatal) {\n            this.state = State.ERROR;\n            return;\n        }\n        switch(data.details){\n            case ErrorDetails.FRAG_GAP:\n            case ErrorDetails.FRAG_PARSING_ERROR:\n            case ErrorDetails.FRAG_DECRYPT_ERROR:\n            case ErrorDetails.FRAG_LOAD_ERROR:\n            case ErrorDetails.FRAG_LOAD_TIMEOUT:\n            case ErrorDetails.KEY_LOAD_ERROR:\n            case ErrorDetails.KEY_LOAD_TIMEOUT:\n                this.onFragmentOrKeyLoadError(PlaylistLevelType.AUDIO, data);\n                break;\n            case ErrorDetails.AUDIO_TRACK_LOAD_ERROR:\n            case ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:\n            case ErrorDetails.LEVEL_PARSING_ERROR:\n                // in case of non fatal error while loading track, if not retrying to load track, switch back to IDLE\n                if (!data.levelRetry && this.state === State.WAITING_TRACK && ((_data$context = data.context) == null ? void 0 : _data$context.type) === PlaylistContextType.AUDIO_TRACK) {\n                    this.state = State.IDLE;\n                }\n                break;\n            case ErrorDetails.BUFFER_APPEND_ERROR:\n            case ErrorDetails.BUFFER_FULL_ERROR:\n                if (!data.parent || data.parent !== \"audio\") {\n                    return;\n                }\n                if (data.details === ErrorDetails.BUFFER_APPEND_ERROR) {\n                    this.resetLoadingState();\n                    return;\n                }\n                if (this.reduceLengthAndFlushBuffer(data)) {\n                    this.bufferedTrack = null;\n                    super.flushMainBuffer(0, Number.POSITIVE_INFINITY, \"audio\");\n                }\n                break;\n            case ErrorDetails.INTERNAL_EXCEPTION:\n                this.recoverWorkerError(data);\n                break;\n        }\n    }\n    onBufferFlushing(event, { type }) {\n        if (type !== ElementaryStreamTypes.VIDEO) {\n            this.flushing = true;\n        }\n    }\n    onBufferFlushed(event, { type }) {\n        if (type !== ElementaryStreamTypes.VIDEO) {\n            this.flushing = false;\n            this.bufferFlushed = true;\n            if (this.state === State.ENDED) {\n                this.state = State.IDLE;\n            }\n            const mediaBuffer = this.mediaBuffer || this.media;\n            if (mediaBuffer) {\n                this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.AUDIO);\n                this.tick();\n            }\n        }\n    }\n    _handleTransmuxComplete(transmuxResult) {\n        var _id3$samples;\n        const id = \"audio\";\n        const { hls } = this;\n        const { remuxResult, chunkMeta } = transmuxResult;\n        const context = this.getCurrentContext(chunkMeta);\n        if (!context) {\n            this.resetWhenMissingContext(chunkMeta);\n            return;\n        }\n        const { frag, part, level } = context;\n        const { details } = level;\n        const { audio, text, id3, initSegment } = remuxResult;\n        // Check if the current fragment has been aborted. We check this by first seeing if we're still playing the current level.\n        // If we are, subsequently check if the currently loading fragment (fragCurrent) has changed.\n        if (this.fragContextChanged(frag) || !details) {\n            this.fragmentTracker.removeFragment(frag);\n            return;\n        }\n        this.state = State.PARSING;\n        if (this.switchingTrack && audio) {\n            this.completeAudioSwitch(this.switchingTrack);\n        }\n        if (initSegment != null && initSegment.tracks) {\n            const mapFragment = frag.initSegment || frag;\n            this._bufferInitSegment(level, initSegment.tracks, mapFragment, chunkMeta);\n            hls.trigger(Events.FRAG_PARSING_INIT_SEGMENT, {\n                frag: mapFragment,\n                id,\n                tracks: initSegment.tracks\n            });\n        // Only flush audio from old audio tracks when PTS is known on new audio track\n        }\n        if (audio) {\n            const { startPTS, endPTS, startDTS, endDTS } = audio;\n            if (part) {\n                part.elementaryStreams[ElementaryStreamTypes.AUDIO] = {\n                    startPTS,\n                    endPTS,\n                    startDTS,\n                    endDTS\n                };\n            }\n            frag.setElementaryStreamInfo(ElementaryStreamTypes.AUDIO, startPTS, endPTS, startDTS, endDTS);\n            this.bufferFragmentData(audio, frag, part, chunkMeta);\n        }\n        if (id3 != null && (_id3$samples = id3.samples) != null && _id3$samples.length) {\n            const emittedID3 = _extends({\n                id,\n                frag,\n                details\n            }, id3);\n            hls.trigger(Events.FRAG_PARSING_METADATA, emittedID3);\n        }\n        if (text) {\n            const emittedText = _extends({\n                id,\n                frag,\n                details\n            }, text);\n            hls.trigger(Events.FRAG_PARSING_USERDATA, emittedText);\n        }\n    }\n    _bufferInitSegment(currentLevel, tracks, frag, chunkMeta) {\n        if (this.state !== State.PARSING) {\n            return;\n        }\n        // delete any video track found on audio transmuxer\n        if (tracks.video) {\n            delete tracks.video;\n        }\n        // include levelCodec in audio and video tracks\n        const track = tracks.audio;\n        if (!track) {\n            return;\n        }\n        track.id = \"audio\";\n        const variantAudioCodecs = currentLevel.audioCodec;\n        this.log(`Init audio buffer, container:${track.container}, codecs[level/parsed]=[${variantAudioCodecs}/${track.codec}]`);\n        // SourceBuffer will use track.levelCodec if defined\n        if (variantAudioCodecs && variantAudioCodecs.split(\",\").length === 1) {\n            track.levelCodec = variantAudioCodecs;\n        }\n        this.hls.trigger(Events.BUFFER_CODECS, tracks);\n        const initSegment = track.initSegment;\n        if (initSegment != null && initSegment.byteLength) {\n            const segment = {\n                type: \"audio\",\n                frag,\n                part: null,\n                chunkMeta,\n                parent: frag.type,\n                data: initSegment\n            };\n            this.hls.trigger(Events.BUFFER_APPENDING, segment);\n        }\n        // trigger handler right now\n        this.tickImmediate();\n    }\n    loadFragment(frag, track, targetBufferTime) {\n        // only load if fragment is not loaded or if in audio switch\n        const fragState = this.fragmentTracker.getState(frag);\n        this.fragCurrent = frag;\n        // we force a frag loading in audio switch as fragment tracker might not have evicted previous frags in case of quick audio switch\n        if (this.switchingTrack || fragState === FragmentState.NOT_LOADED || fragState === FragmentState.PARTIAL) {\n            var _track$details2;\n            if (frag.sn === \"initSegment\") {\n                this._loadInitSegment(frag, track);\n            } else if ((_track$details2 = track.details) != null && _track$details2.live && !this.initPTS[frag.cc]) {\n                this.log(`Waiting for video PTS in continuity counter ${frag.cc} of live stream before loading audio fragment ${frag.sn} of level ${this.trackId}`);\n                this.state = State.WAITING_INIT_PTS;\n                const mainDetails = this.mainDetails;\n                if (mainDetails && mainDetails.fragments[0].start !== track.details.fragments[0].start) {\n                    alignMediaPlaylistByPDT(track.details, mainDetails);\n                }\n            } else {\n                this.startFragRequested = true;\n                super.loadFragment(frag, track, targetBufferTime);\n            }\n        } else {\n            this.clearTrackerIfNeeded(frag);\n        }\n    }\n    flushAudioIfNeeded(switchingTrack) {\n        const { media, bufferedTrack } = this;\n        const bufferedAttributes = bufferedTrack == null ? void 0 : bufferedTrack.attrs;\n        const switchAttributes = switchingTrack.attrs;\n        if (media && bufferedAttributes && (bufferedAttributes.CHANNELS !== switchAttributes.CHANNELS || bufferedTrack.name !== switchingTrack.name || bufferedTrack.lang !== switchingTrack.lang)) {\n            this.log(\"Switching audio track : flushing all audio\");\n            super.flushMainBuffer(0, Number.POSITIVE_INFINITY, \"audio\");\n            this.bufferedTrack = null;\n        }\n    }\n    completeAudioSwitch(switchingTrack) {\n        const { hls } = this;\n        this.flushAudioIfNeeded(switchingTrack);\n        this.bufferedTrack = switchingTrack;\n        this.switchingTrack = null;\n        hls.trigger(Events.AUDIO_TRACK_SWITCHED, _objectSpread2({}, switchingTrack));\n    }\n}\nclass AudioTrackController extends BasePlaylistController {\n    constructor(hls){\n        super(hls, \"[audio-track-controller]\");\n        this.tracks = [];\n        this.groupIds = null;\n        this.tracksInGroup = [];\n        this.trackId = -1;\n        this.currentTrack = null;\n        this.selectDefaultTrack = true;\n        this.registerListeners();\n    }\n    registerListeners() {\n        const { hls } = this;\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n        hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n        hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n        hls.on(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n        hls.on(Events.ERROR, this.onError, this);\n    }\n    unregisterListeners() {\n        const { hls } = this;\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n        hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);\n        hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n        hls.off(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n        hls.off(Events.ERROR, this.onError, this);\n    }\n    destroy() {\n        this.unregisterListeners();\n        this.tracks.length = 0;\n        this.tracksInGroup.length = 0;\n        this.currentTrack = null;\n        super.destroy();\n    }\n    onManifestLoading() {\n        this.tracks = [];\n        this.tracksInGroup = [];\n        this.groupIds = null;\n        this.currentTrack = null;\n        this.trackId = -1;\n        this.selectDefaultTrack = true;\n    }\n    onManifestParsed(event, data) {\n        this.tracks = data.audioTracks || [];\n    }\n    onAudioTrackLoaded(event, data) {\n        const { id, groupId, details } = data;\n        const trackInActiveGroup = this.tracksInGroup[id];\n        if (!trackInActiveGroup || trackInActiveGroup.groupId !== groupId) {\n            this.warn(`Audio track with id:${id} and group:${groupId} not found in active group ${trackInActiveGroup == null ? void 0 : trackInActiveGroup.groupId}`);\n            return;\n        }\n        const curDetails = trackInActiveGroup.details;\n        trackInActiveGroup.details = data.details;\n        this.log(`Audio track ${id} \"${trackInActiveGroup.name}\" lang:${trackInActiveGroup.lang} group:${groupId} loaded [${details.startSN}-${details.endSN}]`);\n        if (id === this.trackId) {\n            this.playlistLoaded(id, data, curDetails);\n        }\n    }\n    onLevelLoading(event, data) {\n        this.switchLevel(data.level);\n    }\n    onLevelSwitching(event, data) {\n        this.switchLevel(data.level);\n    }\n    switchLevel(levelIndex) {\n        const levelInfo = this.hls.levels[levelIndex];\n        if (!levelInfo) {\n            return;\n        }\n        const audioGroups = levelInfo.audioGroups || null;\n        const currentGroups = this.groupIds;\n        let currentTrack = this.currentTrack;\n        if (!audioGroups || (currentGroups == null ? void 0 : currentGroups.length) !== (audioGroups == null ? void 0 : audioGroups.length) || audioGroups != null && audioGroups.some((groupId)=>(currentGroups == null ? void 0 : currentGroups.indexOf(groupId)) === -1)) {\n            this.groupIds = audioGroups;\n            this.trackId = -1;\n            this.currentTrack = null;\n            const audioTracks = this.tracks.filter((track)=>!audioGroups || audioGroups.indexOf(track.groupId) !== -1);\n            if (audioTracks.length) {\n                // Disable selectDefaultTrack if there are no default tracks\n                if (this.selectDefaultTrack && !audioTracks.some((track)=>track.default)) {\n                    this.selectDefaultTrack = false;\n                }\n                // track.id should match hls.audioTracks index\n                audioTracks.forEach((track, i)=>{\n                    track.id = i;\n                });\n            } else if (!currentTrack && !this.tracksInGroup.length) {\n                // Do not dispatch AUDIO_TRACKS_UPDATED when there were and are no tracks\n                return;\n            }\n            this.tracksInGroup = audioTracks;\n            // Find preferred track\n            const audioPreference = this.hls.config.audioPreference;\n            if (!currentTrack && audioPreference) {\n                const groupIndex = findMatchingOption(audioPreference, audioTracks, audioMatchPredicate);\n                if (groupIndex > -1) {\n                    currentTrack = audioTracks[groupIndex];\n                } else {\n                    const allIndex = findMatchingOption(audioPreference, this.tracks);\n                    currentTrack = this.tracks[allIndex];\n                }\n            }\n            // Select initial track\n            let trackId = this.findTrackId(currentTrack);\n            if (trackId === -1 && currentTrack) {\n                trackId = this.findTrackId(null);\n            }\n            // Dispatch events and load track if needed\n            const audioTracksUpdated = {\n                audioTracks\n            };\n            this.log(`Updating audio tracks, ${audioTracks.length} track(s) found in group(s): ${audioGroups == null ? void 0 : audioGroups.join(\",\")}`);\n            this.hls.trigger(Events.AUDIO_TRACKS_UPDATED, audioTracksUpdated);\n            const selectedTrackId = this.trackId;\n            if (trackId !== -1 && selectedTrackId === -1) {\n                this.setAudioTrack(trackId);\n            } else if (audioTracks.length && selectedTrackId === -1) {\n                var _this$groupIds;\n                const error = new Error(`No audio track selected for current audio group-ID(s): ${(_this$groupIds = this.groupIds) == null ? void 0 : _this$groupIds.join(\",\")} track count: ${audioTracks.length}`);\n                this.warn(error.message);\n                this.hls.trigger(Events.ERROR, {\n                    type: ErrorTypes.MEDIA_ERROR,\n                    details: ErrorDetails.AUDIO_TRACK_LOAD_ERROR,\n                    fatal: true,\n                    error\n                });\n            }\n        } else if (this.shouldReloadPlaylist(currentTrack)) {\n            // Retry playlist loading if no playlist is or has been loaded yet\n            this.setAudioTrack(this.trackId);\n        }\n    }\n    onError(event, data) {\n        if (data.fatal || !data.context) {\n            return;\n        }\n        if (data.context.type === PlaylistContextType.AUDIO_TRACK && data.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(data.context.groupId) !== -1)) {\n            this.requestScheduled = -1;\n            this.checkRetry(data);\n        }\n    }\n    get allAudioTracks() {\n        return this.tracks;\n    }\n    get audioTracks() {\n        return this.tracksInGroup;\n    }\n    get audioTrack() {\n        return this.trackId;\n    }\n    set audioTrack(newId) {\n        // If audio track is selected from API then don't choose from the manifest default track\n        this.selectDefaultTrack = false;\n        this.setAudioTrack(newId);\n    }\n    setAudioOption(audioOption) {\n        const hls = this.hls;\n        hls.config.audioPreference = audioOption;\n        if (audioOption) {\n            const allAudioTracks = this.allAudioTracks;\n            this.selectDefaultTrack = false;\n            if (allAudioTracks.length) {\n                // First see if current option matches (no switch op)\n                const currentTrack = this.currentTrack;\n                if (currentTrack && matchesOption(audioOption, currentTrack, audioMatchPredicate)) {\n                    return currentTrack;\n                }\n                // Find option in available tracks (tracksInGroup)\n                const groupIndex = findMatchingOption(audioOption, this.tracksInGroup, audioMatchPredicate);\n                if (groupIndex > -1) {\n                    const track = this.tracksInGroup[groupIndex];\n                    this.setAudioTrack(groupIndex);\n                    return track;\n                } else if (currentTrack) {\n                    // Find option in nearest level audio group\n                    let searchIndex = hls.loadLevel;\n                    if (searchIndex === -1) {\n                        searchIndex = hls.firstAutoLevel;\n                    }\n                    const switchIndex = findClosestLevelWithAudioGroup(audioOption, hls.levels, allAudioTracks, searchIndex, audioMatchPredicate);\n                    if (switchIndex === -1) {\n                        // could not find matching variant\n                        return null;\n                    }\n                    // and switch level to acheive the audio group switch\n                    hls.nextLoadLevel = switchIndex;\n                }\n                if (audioOption.channels || audioOption.audioCodec) {\n                    // Could not find a match with codec / channels predicate\n                    // Find a match without channels or codec\n                    const withoutCodecAndChannelsMatch = findMatchingOption(audioOption, allAudioTracks);\n                    if (withoutCodecAndChannelsMatch > -1) {\n                        return allAudioTracks[withoutCodecAndChannelsMatch];\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    setAudioTrack(newId) {\n        const tracks = this.tracksInGroup;\n        // check if level idx is valid\n        if (newId < 0 || newId >= tracks.length) {\n            this.warn(`Invalid audio track id: ${newId}`);\n            return;\n        }\n        // stopping live reloading timer if any\n        this.clearTimer();\n        this.selectDefaultTrack = false;\n        const lastTrack = this.currentTrack;\n        const track = tracks[newId];\n        const trackLoaded = track.details && !track.details.live;\n        if (newId === this.trackId && track === lastTrack && trackLoaded) {\n            return;\n        }\n        this.log(`Switching to audio-track ${newId} \"${track.name}\" lang:${track.lang} group:${track.groupId} channels:${track.channels}`);\n        this.trackId = newId;\n        this.currentTrack = track;\n        this.hls.trigger(Events.AUDIO_TRACK_SWITCHING, _objectSpread2({}, track));\n        // Do not reload track unless live\n        if (trackLoaded) {\n            return;\n        }\n        const hlsUrlParameters = this.switchParams(track.url, lastTrack == null ? void 0 : lastTrack.details);\n        this.loadPlaylist(hlsUrlParameters);\n    }\n    findTrackId(currentTrack) {\n        const audioTracks = this.tracksInGroup;\n        for(let i = 0; i < audioTracks.length; i++){\n            const track = audioTracks[i];\n            if (this.selectDefaultTrack && !track.default) {\n                continue;\n            }\n            if (!currentTrack || matchesOption(currentTrack, track, audioMatchPredicate)) {\n                return i;\n            }\n        }\n        if (currentTrack) {\n            const { name, lang, assocLang, characteristics, audioCodec, channels } = currentTrack;\n            for(let i = 0; i < audioTracks.length; i++){\n                const track = audioTracks[i];\n                if (matchesOption({\n                    name,\n                    lang,\n                    assocLang,\n                    characteristics,\n                    audioCodec,\n                    channels\n                }, track, audioMatchPredicate)) {\n                    return i;\n                }\n            }\n            for(let i = 0; i < audioTracks.length; i++){\n                const track = audioTracks[i];\n                if (mediaAttributesIdentical(currentTrack.attrs, track.attrs, [\n                    \"LANGUAGE\",\n                    \"ASSOC-LANGUAGE\",\n                    \"CHARACTERISTICS\"\n                ])) {\n                    return i;\n                }\n            }\n            for(let i = 0; i < audioTracks.length; i++){\n                const track = audioTracks[i];\n                if (mediaAttributesIdentical(currentTrack.attrs, track.attrs, [\n                    \"LANGUAGE\"\n                ])) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n    loadPlaylist(hlsUrlParameters) {\n        const audioTrack = this.currentTrack;\n        if (this.shouldLoadPlaylist(audioTrack) && audioTrack) {\n            super.loadPlaylist();\n            const id = audioTrack.id;\n            const groupId = audioTrack.groupId;\n            let url = audioTrack.url;\n            if (hlsUrlParameters) {\n                try {\n                    url = hlsUrlParameters.addDirectives(url);\n                } catch (error) {\n                    this.warn(`Could not construct new URL with HLS Delivery Directives: ${error}`);\n                }\n            }\n            // track not retrieved yet, or live playlist we need to (re)load it\n            this.log(`loading audio-track playlist ${id} \"${audioTrack.name}\" lang:${audioTrack.lang} group:${groupId}`);\n            this.clearTimer();\n            this.hls.trigger(Events.AUDIO_TRACK_LOADING, {\n                url,\n                id,\n                groupId,\n                deliveryDirectives: hlsUrlParameters || null\n            });\n        }\n    }\n}\nconst TICK_INTERVAL$1 = 500; // how often to tick in ms\nclass SubtitleStreamController extends BaseStreamController {\n    constructor(hls, fragmentTracker, keyLoader){\n        super(hls, fragmentTracker, keyLoader, \"[subtitle-stream-controller]\", PlaylistLevelType.SUBTITLE);\n        this.currentTrackId = -1;\n        this.tracksBuffered = [];\n        this.mainDetails = null;\n        this._registerListeners();\n    }\n    onHandlerDestroying() {\n        this._unregisterListeners();\n        super.onHandlerDestroying();\n        this.mainDetails = null;\n    }\n    _registerListeners() {\n        const { hls } = this;\n        hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n        hls.on(Events.ERROR, this.onError, this);\n        hls.on(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n        hls.on(Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);\n        hls.on(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n        hls.on(Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);\n        hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n        hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    }\n    _unregisterListeners() {\n        const { hls } = this;\n        hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n        hls.off(Events.ERROR, this.onError, this);\n        hls.off(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n        hls.off(Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);\n        hls.off(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n        hls.off(Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);\n        hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n        hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    }\n    startLoad(startPosition) {\n        this.stopLoad();\n        this.state = State.IDLE;\n        this.setInterval(TICK_INTERVAL$1);\n        this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;\n        this.tick();\n    }\n    onManifestLoading() {\n        this.mainDetails = null;\n        this.fragmentTracker.removeAllFragments();\n    }\n    onMediaDetaching() {\n        this.tracksBuffered = [];\n        super.onMediaDetaching();\n    }\n    onLevelLoaded(event, data) {\n        this.mainDetails = data.details;\n    }\n    onSubtitleFragProcessed(event, data) {\n        const { frag, success } = data;\n        this.fragPrevious = frag;\n        this.state = State.IDLE;\n        if (!success) {\n            return;\n        }\n        const buffered = this.tracksBuffered[this.currentTrackId];\n        if (!buffered) {\n            return;\n        }\n        // Create/update a buffered array matching the interface used by BufferHelper.bufferedInfo\n        // so we can re-use the logic used to detect how much has been buffered\n        let timeRange;\n        const fragStart = frag.start;\n        for(let i = 0; i < buffered.length; i++){\n            if (fragStart >= buffered[i].start && fragStart <= buffered[i].end) {\n                timeRange = buffered[i];\n                break;\n            }\n        }\n        const fragEnd = frag.start + frag.duration;\n        if (timeRange) {\n            timeRange.end = fragEnd;\n        } else {\n            timeRange = {\n                start: fragStart,\n                end: fragEnd\n            };\n            buffered.push(timeRange);\n        }\n        this.fragmentTracker.fragBuffered(frag);\n        this.fragBufferedComplete(frag, null);\n    }\n    onBufferFlushing(event, data) {\n        const { startOffset, endOffset } = data;\n        if (startOffset === 0 && endOffset !== Number.POSITIVE_INFINITY) {\n            const endOffsetSubtitles = endOffset - 1;\n            if (endOffsetSubtitles <= 0) {\n                return;\n            }\n            data.endOffsetSubtitles = Math.max(0, endOffsetSubtitles);\n            this.tracksBuffered.forEach((buffered)=>{\n                for(let i = 0; i < buffered.length;){\n                    if (buffered[i].end <= endOffsetSubtitles) {\n                        buffered.shift();\n                        continue;\n                    } else if (buffered[i].start < endOffsetSubtitles) {\n                        buffered[i].start = endOffsetSubtitles;\n                    } else {\n                        break;\n                    }\n                    i++;\n                }\n            });\n            this.fragmentTracker.removeFragmentsInRange(startOffset, endOffsetSubtitles, PlaylistLevelType.SUBTITLE);\n        }\n    }\n    onFragBuffered(event, data) {\n        if (!this.loadedmetadata && data.frag.type === PlaylistLevelType.MAIN) {\n            var _this$media;\n            if ((_this$media = this.media) != null && _this$media.buffered.length) {\n                this.loadedmetadata = true;\n            }\n        }\n    }\n    // If something goes wrong, proceed to next frag, if we were processing one.\n    onError(event, data) {\n        const frag = data.frag;\n        if ((frag == null ? void 0 : frag.type) === PlaylistLevelType.SUBTITLE) {\n            if (this.fragCurrent) {\n                this.fragCurrent.abortRequests();\n            }\n            if (this.state !== State.STOPPED) {\n                this.state = State.IDLE;\n            }\n        }\n    }\n    // Got all new subtitle levels.\n    onSubtitleTracksUpdated(event, { subtitleTracks }) {\n        if (this.levels && subtitleOptionsIdentical(this.levels, subtitleTracks)) {\n            this.levels = subtitleTracks.map((mediaPlaylist)=>new Level(mediaPlaylist));\n            return;\n        }\n        this.tracksBuffered = [];\n        this.levels = subtitleTracks.map((mediaPlaylist)=>{\n            const level = new Level(mediaPlaylist);\n            this.tracksBuffered[level.id] = [];\n            return level;\n        });\n        this.fragmentTracker.removeFragmentsInRange(0, Number.POSITIVE_INFINITY, PlaylistLevelType.SUBTITLE);\n        this.fragPrevious = null;\n        this.mediaBuffer = null;\n    }\n    onSubtitleTrackSwitch(event, data) {\n        var _this$levels;\n        this.currentTrackId = data.id;\n        if (!((_this$levels = this.levels) != null && _this$levels.length) || this.currentTrackId === -1) {\n            this.clearInterval();\n            return;\n        }\n        // Check if track has the necessary details to load fragments\n        const currentTrack = this.levels[this.currentTrackId];\n        if (currentTrack != null && currentTrack.details) {\n            this.mediaBuffer = this.mediaBufferTimeRanges;\n        } else {\n            this.mediaBuffer = null;\n        }\n        if (currentTrack) {\n            this.setInterval(TICK_INTERVAL$1);\n        }\n    }\n    // Got a new set of subtitle fragments.\n    onSubtitleTrackLoaded(event, data) {\n        var _track$details;\n        const { currentTrackId, levels } = this;\n        const { details: newDetails, id: trackId } = data;\n        if (!levels) {\n            this.warn(`Subtitle tracks were reset while loading level ${trackId}`);\n            return;\n        }\n        const track = levels[currentTrackId];\n        if (trackId >= levels.length || trackId !== currentTrackId || !track) {\n            return;\n        }\n        this.log(`Subtitle track ${trackId} loaded [${newDetails.startSN},${newDetails.endSN}]${newDetails.lastPartSn ? `[part-${newDetails.lastPartSn}-${newDetails.lastPartIndex}]` : \"\"},duration:${newDetails.totalduration}`);\n        this.mediaBuffer = this.mediaBufferTimeRanges;\n        let sliding = 0;\n        if (newDetails.live || (_track$details = track.details) != null && _track$details.live) {\n            const mainDetails = this.mainDetails;\n            if (newDetails.deltaUpdateFailed || !mainDetails) {\n                return;\n            }\n            const mainSlidingStartFragment = mainDetails.fragments[0];\n            if (!track.details) {\n                if (newDetails.hasProgramDateTime && mainDetails.hasProgramDateTime) {\n                    alignMediaPlaylistByPDT(newDetails, mainDetails);\n                    sliding = newDetails.fragments[0].start;\n                } else if (mainSlidingStartFragment) {\n                    // line up live playlist with main so that fragments in range are loaded\n                    sliding = mainSlidingStartFragment.start;\n                    addSliding(newDetails, sliding);\n                }\n            } else {\n                var _this$levelLastLoaded;\n                sliding = this.alignPlaylists(newDetails, track.details, (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details);\n                if (sliding === 0 && mainSlidingStartFragment) {\n                    // realign with main when there is no overlap with last refresh\n                    sliding = mainSlidingStartFragment.start;\n                    addSliding(newDetails, sliding);\n                }\n            }\n        }\n        track.details = newDetails;\n        this.levelLastLoaded = track;\n        if (!this.startFragRequested && (this.mainDetails || !newDetails.live)) {\n            this.setStartPosition(this.mainDetails || newDetails, sliding);\n        }\n        // trigger handler right now\n        this.tick();\n        // If playlist is misaligned because of bad PDT or drift, delete details to resync with main on reload\n        if (newDetails.live && !this.fragCurrent && this.media && this.state === State.IDLE) {\n            const foundFrag = findFragmentByPTS(null, newDetails.fragments, this.media.currentTime, 0);\n            if (!foundFrag) {\n                this.warn(\"Subtitle playlist not aligned with playback\");\n                track.details = undefined;\n            }\n        }\n    }\n    _handleFragmentLoadComplete(fragLoadedData) {\n        const { frag, payload } = fragLoadedData;\n        const decryptData = frag.decryptdata;\n        const hls = this.hls;\n        if (this.fragContextChanged(frag)) {\n            return;\n        }\n        // check to see if the payload needs to be decrypted\n        if (payload && payload.byteLength > 0 && decryptData != null && decryptData.key && decryptData.iv && decryptData.method === \"AES-128\") {\n            const startTime = performance.now();\n            // decrypt the subtitles\n            this.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).catch((err)=>{\n                hls.trigger(Events.ERROR, {\n                    type: ErrorTypes.MEDIA_ERROR,\n                    details: ErrorDetails.FRAG_DECRYPT_ERROR,\n                    fatal: false,\n                    error: err,\n                    reason: err.message,\n                    frag\n                });\n                throw err;\n            }).then((decryptedData)=>{\n                const endTime = performance.now();\n                hls.trigger(Events.FRAG_DECRYPTED, {\n                    frag,\n                    payload: decryptedData,\n                    stats: {\n                        tstart: startTime,\n                        tdecrypt: endTime\n                    }\n                });\n            }).catch((err)=>{\n                this.warn(`${err.name}: ${err.message}`);\n                this.state = State.IDLE;\n            });\n        }\n    }\n    doTick() {\n        if (!this.media) {\n            this.state = State.IDLE;\n            return;\n        }\n        if (this.state === State.IDLE) {\n            const { currentTrackId, levels } = this;\n            const track = levels == null ? void 0 : levels[currentTrackId];\n            if (!track || !levels.length || !track.details) {\n                return;\n            }\n            const { config } = this;\n            const currentTime = this.getLoadPosition();\n            const bufferedInfo = BufferHelper.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], currentTime, config.maxBufferHole);\n            const { end: targetBufferTime, len: bufferLen } = bufferedInfo;\n            const mainBufferInfo = this.getFwdBufferInfo(this.media, PlaylistLevelType.MAIN);\n            const trackDetails = track.details;\n            const maxBufLen = this.getMaxBufferLength(mainBufferInfo == null ? void 0 : mainBufferInfo.len) + trackDetails.levelTargetDuration;\n            if (bufferLen > maxBufLen) {\n                return;\n            }\n            const fragments = trackDetails.fragments;\n            const fragLen = fragments.length;\n            const end = trackDetails.edge;\n            let foundFrag = null;\n            const fragPrevious = this.fragPrevious;\n            if (targetBufferTime < end) {\n                const tolerance = config.maxFragLookUpTolerance;\n                const lookupTolerance = targetBufferTime > end - tolerance ? 0 : tolerance;\n                foundFrag = findFragmentByPTS(fragPrevious, fragments, Math.max(fragments[0].start, targetBufferTime), lookupTolerance);\n                if (!foundFrag && fragPrevious && fragPrevious.start < fragments[0].start) {\n                    foundFrag = fragments[0];\n                }\n            } else {\n                foundFrag = fragments[fragLen - 1];\n            }\n            if (!foundFrag) {\n                return;\n            }\n            foundFrag = this.mapToInitFragWhenRequired(foundFrag);\n            if (foundFrag.sn !== \"initSegment\") {\n                // Load earlier fragment in same discontinuity to make up for misaligned playlists and cues that extend beyond end of segment\n                const curSNIdx = foundFrag.sn - trackDetails.startSN;\n                const prevFrag = fragments[curSNIdx - 1];\n                if (prevFrag && prevFrag.cc === foundFrag.cc && this.fragmentTracker.getState(prevFrag) === FragmentState.NOT_LOADED) {\n                    foundFrag = prevFrag;\n                }\n            }\n            if (this.fragmentTracker.getState(foundFrag) === FragmentState.NOT_LOADED) {\n                // only load if fragment is not loaded\n                this.loadFragment(foundFrag, track, targetBufferTime);\n            }\n        }\n    }\n    getMaxBufferLength(mainBufferLength) {\n        const maxConfigBuffer = super.getMaxBufferLength();\n        if (!mainBufferLength) {\n            return maxConfigBuffer;\n        }\n        return Math.max(maxConfigBuffer, mainBufferLength);\n    }\n    loadFragment(frag, level, targetBufferTime) {\n        this.fragCurrent = frag;\n        if (frag.sn === \"initSegment\") {\n            this._loadInitSegment(frag, level);\n        } else {\n            this.startFragRequested = true;\n            super.loadFragment(frag, level, targetBufferTime);\n        }\n    }\n    get mediaBufferTimeRanges() {\n        return new BufferableInstance(this.tracksBuffered[this.currentTrackId] || []);\n    }\n}\nclass BufferableInstance {\n    constructor(timeranges){\n        this.buffered = void 0;\n        const getRange = (name, index, length)=>{\n            index = index >>> 0;\n            if (index > length - 1) {\n                throw new DOMException(`Failed to execute '${name}' on 'TimeRanges': The index provided (${index}) is greater than the maximum bound (${length})`);\n            }\n            return timeranges[index][name];\n        };\n        this.buffered = {\n            get length () {\n                return timeranges.length;\n            },\n            end (index) {\n                return getRange(\"end\", index, timeranges.length);\n            },\n            start (index) {\n                return getRange(\"start\", index, timeranges.length);\n            }\n        };\n    }\n}\nclass SubtitleTrackController extends BasePlaylistController {\n    constructor(hls){\n        super(hls, \"[subtitle-track-controller]\");\n        this.media = null;\n        this.tracks = [];\n        this.groupIds = null;\n        this.tracksInGroup = [];\n        this.trackId = -1;\n        this.currentTrack = null;\n        this.selectDefaultTrack = true;\n        this.queuedDefaultTrack = -1;\n        this.asyncPollTrackChange = ()=>this.pollTrackChange(0);\n        this.useTextTrackPolling = false;\n        this.subtitlePollingInterval = -1;\n        this._subtitleDisplay = true;\n        this.onTextTracksChanged = ()=>{\n            if (!this.useTextTrackPolling) {\n                self.clearInterval(this.subtitlePollingInterval);\n            }\n            // Media is undefined when switching streams via loadSource()\n            if (!this.media || !this.hls.config.renderTextTracksNatively) {\n                return;\n            }\n            let textTrack = null;\n            const tracks = filterSubtitleTracks(this.media.textTracks);\n            for(let i = 0; i < tracks.length; i++){\n                if (tracks[i].mode === \"hidden\") {\n                    // Do not break in case there is a following track with showing.\n                    textTrack = tracks[i];\n                } else if (tracks[i].mode === \"showing\") {\n                    textTrack = tracks[i];\n                    break;\n                }\n            }\n            // Find internal track index for TextTrack\n            const trackId = this.findTrackForTextTrack(textTrack);\n            if (this.subtitleTrack !== trackId) {\n                this.setSubtitleTrack(trackId);\n            }\n        };\n        this.registerListeners();\n    }\n    destroy() {\n        this.unregisterListeners();\n        this.tracks.length = 0;\n        this.tracksInGroup.length = 0;\n        this.currentTrack = null;\n        this.onTextTracksChanged = this.asyncPollTrackChange = null;\n        super.destroy();\n    }\n    get subtitleDisplay() {\n        return this._subtitleDisplay;\n    }\n    set subtitleDisplay(value) {\n        this._subtitleDisplay = value;\n        if (this.trackId > -1) {\n            this.toggleTrackModes();\n        }\n    }\n    registerListeners() {\n        const { hls } = this;\n        hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n        hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n        hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n        hls.on(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n        hls.on(Events.ERROR, this.onError, this);\n    }\n    unregisterListeners() {\n        const { hls } = this;\n        hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n        hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);\n        hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n        hls.off(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n        hls.off(Events.ERROR, this.onError, this);\n    }\n    // Listen for subtitle track change, then extract the current track ID.\n    onMediaAttached(event, data) {\n        this.media = data.media;\n        if (!this.media) {\n            return;\n        }\n        if (this.queuedDefaultTrack > -1) {\n            this.subtitleTrack = this.queuedDefaultTrack;\n            this.queuedDefaultTrack = -1;\n        }\n        this.useTextTrackPolling = !(this.media.textTracks && \"onchange\" in this.media.textTracks);\n        if (this.useTextTrackPolling) {\n            this.pollTrackChange(500);\n        } else {\n            this.media.textTracks.addEventListener(\"change\", this.asyncPollTrackChange);\n        }\n    }\n    pollTrackChange(timeout) {\n        self.clearInterval(this.subtitlePollingInterval);\n        this.subtitlePollingInterval = self.setInterval(this.onTextTracksChanged, timeout);\n    }\n    onMediaDetaching() {\n        if (!this.media) {\n            return;\n        }\n        self.clearInterval(this.subtitlePollingInterval);\n        if (!this.useTextTrackPolling) {\n            this.media.textTracks.removeEventListener(\"change\", this.asyncPollTrackChange);\n        }\n        if (this.trackId > -1) {\n            this.queuedDefaultTrack = this.trackId;\n        }\n        const textTracks = filterSubtitleTracks(this.media.textTracks);\n        // Clear loaded cues on media detachment from tracks\n        textTracks.forEach((track)=>{\n            clearCurrentCues(track);\n        });\n        // Disable all subtitle tracks before detachment so when reattached only tracks in that content are enabled.\n        this.subtitleTrack = -1;\n        this.media = null;\n    }\n    onManifestLoading() {\n        this.tracks = [];\n        this.groupIds = null;\n        this.tracksInGroup = [];\n        this.trackId = -1;\n        this.currentTrack = null;\n        this.selectDefaultTrack = true;\n    }\n    // Fired whenever a new manifest is loaded.\n    onManifestParsed(event, data) {\n        this.tracks = data.subtitleTracks;\n    }\n    onSubtitleTrackLoaded(event, data) {\n        const { id, groupId, details } = data;\n        const trackInActiveGroup = this.tracksInGroup[id];\n        if (!trackInActiveGroup || trackInActiveGroup.groupId !== groupId) {\n            this.warn(`Subtitle track with id:${id} and group:${groupId} not found in active group ${trackInActiveGroup == null ? void 0 : trackInActiveGroup.groupId}`);\n            return;\n        }\n        const curDetails = trackInActiveGroup.details;\n        trackInActiveGroup.details = data.details;\n        this.log(`Subtitle track ${id} \"${trackInActiveGroup.name}\" lang:${trackInActiveGroup.lang} group:${groupId} loaded [${details.startSN}-${details.endSN}]`);\n        if (id === this.trackId) {\n            this.playlistLoaded(id, data, curDetails);\n        }\n    }\n    onLevelLoading(event, data) {\n        this.switchLevel(data.level);\n    }\n    onLevelSwitching(event, data) {\n        this.switchLevel(data.level);\n    }\n    switchLevel(levelIndex) {\n        const levelInfo = this.hls.levels[levelIndex];\n        if (!levelInfo) {\n            return;\n        }\n        const subtitleGroups = levelInfo.subtitleGroups || null;\n        const currentGroups = this.groupIds;\n        let currentTrack = this.currentTrack;\n        if (!subtitleGroups || (currentGroups == null ? void 0 : currentGroups.length) !== (subtitleGroups == null ? void 0 : subtitleGroups.length) || subtitleGroups != null && subtitleGroups.some((groupId)=>(currentGroups == null ? void 0 : currentGroups.indexOf(groupId)) === -1)) {\n            this.groupIds = subtitleGroups;\n            this.trackId = -1;\n            this.currentTrack = null;\n            const subtitleTracks = this.tracks.filter((track)=>!subtitleGroups || subtitleGroups.indexOf(track.groupId) !== -1);\n            if (subtitleTracks.length) {\n                // Disable selectDefaultTrack if there are no default tracks\n                if (this.selectDefaultTrack && !subtitleTracks.some((track)=>track.default)) {\n                    this.selectDefaultTrack = false;\n                }\n                // track.id should match hls.audioTracks index\n                subtitleTracks.forEach((track, i)=>{\n                    track.id = i;\n                });\n            } else if (!currentTrack && !this.tracksInGroup.length) {\n                // Do not dispatch SUBTITLE_TRACKS_UPDATED when there were and are no tracks\n                return;\n            }\n            this.tracksInGroup = subtitleTracks;\n            // Find preferred track\n            const subtitlePreference = this.hls.config.subtitlePreference;\n            if (!currentTrack && subtitlePreference) {\n                this.selectDefaultTrack = false;\n                const groupIndex = findMatchingOption(subtitlePreference, subtitleTracks);\n                if (groupIndex > -1) {\n                    currentTrack = subtitleTracks[groupIndex];\n                } else {\n                    const allIndex = findMatchingOption(subtitlePreference, this.tracks);\n                    currentTrack = this.tracks[allIndex];\n                }\n            }\n            // Select initial track\n            let trackId = this.findTrackId(currentTrack);\n            if (trackId === -1 && currentTrack) {\n                trackId = this.findTrackId(null);\n            }\n            // Dispatch events and load track if needed\n            const subtitleTracksUpdated = {\n                subtitleTracks\n            };\n            this.log(`Updating subtitle tracks, ${subtitleTracks.length} track(s) found in \"${subtitleGroups == null ? void 0 : subtitleGroups.join(\",\")}\" group-id`);\n            this.hls.trigger(Events.SUBTITLE_TRACKS_UPDATED, subtitleTracksUpdated);\n            if (trackId !== -1 && this.trackId === -1) {\n                this.setSubtitleTrack(trackId);\n            }\n        } else if (this.shouldReloadPlaylist(currentTrack)) {\n            // Retry playlist loading if no playlist is or has been loaded yet\n            this.setSubtitleTrack(this.trackId);\n        }\n    }\n    findTrackId(currentTrack) {\n        const tracks = this.tracksInGroup;\n        const selectDefault = this.selectDefaultTrack;\n        for(let i = 0; i < tracks.length; i++){\n            const track = tracks[i];\n            if (selectDefault && !track.default || !selectDefault && !currentTrack) {\n                continue;\n            }\n            if (!currentTrack || matchesOption(track, currentTrack)) {\n                return i;\n            }\n        }\n        if (currentTrack) {\n            for(let i = 0; i < tracks.length; i++){\n                const track = tracks[i];\n                if (mediaAttributesIdentical(currentTrack.attrs, track.attrs, [\n                    \"LANGUAGE\",\n                    \"ASSOC-LANGUAGE\",\n                    \"CHARACTERISTICS\"\n                ])) {\n                    return i;\n                }\n            }\n            for(let i = 0; i < tracks.length; i++){\n                const track = tracks[i];\n                if (mediaAttributesIdentical(currentTrack.attrs, track.attrs, [\n                    \"LANGUAGE\"\n                ])) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n    findTrackForTextTrack(textTrack) {\n        if (textTrack) {\n            const tracks = this.tracksInGroup;\n            for(let i = 0; i < tracks.length; i++){\n                const track = tracks[i];\n                if (subtitleTrackMatchesTextTrack(track, textTrack)) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n    onError(event, data) {\n        if (data.fatal || !data.context) {\n            return;\n        }\n        if (data.context.type === PlaylistContextType.SUBTITLE_TRACK && data.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(data.context.groupId) !== -1)) {\n            this.checkRetry(data);\n        }\n    }\n    get allSubtitleTracks() {\n        return this.tracks;\n    }\n    /** get alternate subtitle tracks list from playlist **/ get subtitleTracks() {\n        return this.tracksInGroup;\n    }\n    /** get/set index of the selected subtitle track (based on index in subtitle track lists) **/ get subtitleTrack() {\n        return this.trackId;\n    }\n    set subtitleTrack(newId) {\n        this.selectDefaultTrack = false;\n        this.setSubtitleTrack(newId);\n    }\n    setSubtitleOption(subtitleOption) {\n        this.hls.config.subtitlePreference = subtitleOption;\n        if (subtitleOption) {\n            const allSubtitleTracks = this.allSubtitleTracks;\n            this.selectDefaultTrack = false;\n            if (allSubtitleTracks.length) {\n                // First see if current option matches (no switch op)\n                const currentTrack = this.currentTrack;\n                if (currentTrack && matchesOption(subtitleOption, currentTrack)) {\n                    return currentTrack;\n                }\n                // Find option in current group\n                const groupIndex = findMatchingOption(subtitleOption, this.tracksInGroup);\n                if (groupIndex > -1) {\n                    const track = this.tracksInGroup[groupIndex];\n                    this.setSubtitleTrack(groupIndex);\n                    return track;\n                } else if (currentTrack) {\n                    // If this is not the initial selection return null\n                    // option should have matched one in active group\n                    return null;\n                } else {\n                    // Find the option in all tracks for initial selection\n                    const allIndex = findMatchingOption(subtitleOption, allSubtitleTracks);\n                    if (allIndex > -1) {\n                        return allSubtitleTracks[allIndex];\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    loadPlaylist(hlsUrlParameters) {\n        super.loadPlaylist();\n        const currentTrack = this.currentTrack;\n        if (this.shouldLoadPlaylist(currentTrack) && currentTrack) {\n            const id = currentTrack.id;\n            const groupId = currentTrack.groupId;\n            let url = currentTrack.url;\n            if (hlsUrlParameters) {\n                try {\n                    url = hlsUrlParameters.addDirectives(url);\n                } catch (error) {\n                    this.warn(`Could not construct new URL with HLS Delivery Directives: ${error}`);\n                }\n            }\n            this.log(`Loading subtitle playlist for id ${id}`);\n            this.hls.trigger(Events.SUBTITLE_TRACK_LOADING, {\n                url,\n                id,\n                groupId,\n                deliveryDirectives: hlsUrlParameters || null\n            });\n        }\n    }\n    /**\n   * Disables the old subtitleTrack and sets current mode on the next subtitleTrack.\n   * This operates on the DOM textTracks.\n   * A value of -1 will disable all subtitle tracks.\n   */ toggleTrackModes() {\n        const { media } = this;\n        if (!media) {\n            return;\n        }\n        const textTracks = filterSubtitleTracks(media.textTracks);\n        const currentTrack = this.currentTrack;\n        let nextTrack;\n        if (currentTrack) {\n            nextTrack = textTracks.filter((textTrack)=>subtitleTrackMatchesTextTrack(currentTrack, textTrack))[0];\n            if (!nextTrack) {\n                this.warn(`Unable to find subtitle TextTrack with name \"${currentTrack.name}\" and language \"${currentTrack.lang}\"`);\n            }\n        }\n        [].slice.call(textTracks).forEach((track)=>{\n            if (track.mode !== \"disabled\" && track !== nextTrack) {\n                track.mode = \"disabled\";\n            }\n        });\n        if (nextTrack) {\n            const mode = this.subtitleDisplay ? \"showing\" : \"hidden\";\n            if (nextTrack.mode !== mode) {\n                nextTrack.mode = mode;\n            }\n        }\n    }\n    /**\n   * This method is responsible for validating the subtitle index and periodically reloading if live.\n   * Dispatches the SUBTITLE_TRACK_SWITCH event, which instructs the subtitle-stream-controller to load the selected track.\n   */ setSubtitleTrack(newId) {\n        const tracks = this.tracksInGroup;\n        // setting this.subtitleTrack will trigger internal logic\n        // if media has not been attached yet, it will fail\n        // we keep a reference to the default track id\n        // and we'll set subtitleTrack when onMediaAttached is triggered\n        if (!this.media) {\n            this.queuedDefaultTrack = newId;\n            return;\n        }\n        // exit if track id as already set or invalid\n        if (newId < -1 || newId >= tracks.length || !isFiniteNumber(newId)) {\n            this.warn(`Invalid subtitle track id: ${newId}`);\n            return;\n        }\n        // stopping live reloading timer if any\n        this.clearTimer();\n        this.selectDefaultTrack = false;\n        const lastTrack = this.currentTrack;\n        const track = tracks[newId] || null;\n        this.trackId = newId;\n        this.currentTrack = track;\n        this.toggleTrackModes();\n        if (!track) {\n            // switch to -1\n            this.hls.trigger(Events.SUBTITLE_TRACK_SWITCH, {\n                id: newId\n            });\n            return;\n        }\n        const trackLoaded = !!track.details && !track.details.live;\n        if (newId === this.trackId && track === lastTrack && trackLoaded) {\n            return;\n        }\n        this.log(`Switching to subtitle-track ${newId}` + (track ? ` \"${track.name}\" lang:${track.lang} group:${track.groupId}` : \"\"));\n        const { id, groupId = \"\", name, type, url } = track;\n        this.hls.trigger(Events.SUBTITLE_TRACK_SWITCH, {\n            id,\n            groupId,\n            name,\n            type,\n            url\n        });\n        const hlsUrlParameters = this.switchParams(track.url, lastTrack == null ? void 0 : lastTrack.details);\n        this.loadPlaylist(hlsUrlParameters);\n    }\n}\nclass BufferOperationQueue {\n    constructor(sourceBufferReference){\n        this.buffers = void 0;\n        this.queues = {\n            video: [],\n            audio: [],\n            audiovideo: []\n        };\n        this.buffers = sourceBufferReference;\n    }\n    append(operation, type, pending) {\n        const queue = this.queues[type];\n        queue.push(operation);\n        if (queue.length === 1 && !pending) {\n            this.executeNext(type);\n        }\n    }\n    insertAbort(operation, type) {\n        const queue = this.queues[type];\n        queue.unshift(operation);\n        this.executeNext(type);\n    }\n    appendBlocker(type) {\n        let execute;\n        const promise = new Promise((resolve)=>{\n            execute = resolve;\n        });\n        const operation = {\n            execute,\n            onStart: ()=>{},\n            onComplete: ()=>{},\n            onError: ()=>{}\n        };\n        this.append(operation, type);\n        return promise;\n    }\n    executeNext(type) {\n        const queue = this.queues[type];\n        if (queue.length) {\n            const operation = queue[0];\n            try {\n                // Operations are expected to result in an 'updateend' event being fired. If not, the queue will lock. Operations\n                // which do not end with this event must call _onSBUpdateEnd manually\n                operation.execute();\n            } catch (error) {\n                logger.warn(`[buffer-operation-queue]: Exception executing \"${type}\" SourceBuffer operation: ${error}`);\n                operation.onError(error);\n                // Only shift the current operation off, otherwise the updateend handler will do this for us\n                const sb = this.buffers[type];\n                if (!(sb != null && sb.updating)) {\n                    this.shiftAndExecuteNext(type);\n                }\n            }\n        }\n    }\n    shiftAndExecuteNext(type) {\n        this.queues[type].shift();\n        this.executeNext(type);\n    }\n    current(type) {\n        return this.queues[type][0];\n    }\n}\nconst VIDEO_CODEC_PROFILE_REPLACE = /(avc[1234]|hvc1|hev1|dvh[1e]|vp09|av01)(?:\\.[^.,]+)+/;\nclass BufferController {\n    constructor(hls){\n        // The level details used to determine duration, target-duration and live\n        this.details = null;\n        // cache the self generated object url to detect hijack of video tag\n        this._objectUrl = null;\n        // A queue of buffer operations which require the SourceBuffer to not be updating upon execution\n        this.operationQueue = void 0;\n        // References to event listeners for each SourceBuffer, so that they can be referenced for event removal\n        this.listeners = void 0;\n        this.hls = void 0;\n        // The number of BUFFER_CODEC events received before any sourceBuffers are created\n        this.bufferCodecEventsExpected = 0;\n        // The total number of BUFFER_CODEC events received\n        this._bufferCodecEventsTotal = 0;\n        // A reference to the attached media element\n        this.media = null;\n        // A reference to the active media source\n        this.mediaSource = null;\n        // Last MP3 audio chunk appended\n        this.lastMpegAudioChunk = null;\n        this.appendSource = void 0;\n        // counters\n        this.appendErrors = {\n            audio: 0,\n            video: 0,\n            audiovideo: 0\n        };\n        this.tracks = {};\n        this.pendingTracks = {};\n        this.sourceBuffer = void 0;\n        this.log = void 0;\n        this.warn = void 0;\n        this.error = void 0;\n        this._onEndStreaming = (event)=>{\n            if (!this.hls) {\n                return;\n            }\n            this.hls.pauseBuffering();\n        };\n        this._onStartStreaming = (event)=>{\n            if (!this.hls) {\n                return;\n            }\n            this.hls.resumeBuffering();\n        };\n        // Keep as arrow functions so that we can directly reference these functions directly as event listeners\n        this._onMediaSourceOpen = ()=>{\n            const { media, mediaSource } = this;\n            this.log(\"Media source opened\");\n            if (media) {\n                media.removeEventListener(\"emptied\", this._onMediaEmptied);\n                this.updateMediaElementDuration();\n                this.hls.trigger(Events.MEDIA_ATTACHED, {\n                    media,\n                    mediaSource: mediaSource\n                });\n            }\n            if (mediaSource) {\n                // once received, don't listen anymore to sourceopen event\n                mediaSource.removeEventListener(\"sourceopen\", this._onMediaSourceOpen);\n            }\n            this.checkPendingTracks();\n        };\n        this._onMediaSourceClose = ()=>{\n            this.log(\"Media source closed\");\n        };\n        this._onMediaSourceEnded = ()=>{\n            this.log(\"Media source ended\");\n        };\n        this._onMediaEmptied = ()=>{\n            const { mediaSrc, _objectUrl } = this;\n            if (mediaSrc !== _objectUrl) {\n                logger.error(`Media element src was set while attaching MediaSource (${_objectUrl} > ${mediaSrc})`);\n            }\n        };\n        this.hls = hls;\n        const logPrefix = \"[buffer-controller]\";\n        this.appendSource = hls.config.preferManagedMediaSource;\n        this.log = logger.log.bind(logger, logPrefix);\n        this.warn = logger.warn.bind(logger, logPrefix);\n        this.error = logger.error.bind(logger, logPrefix);\n        this._initSourceBuffer();\n        this.registerListeners();\n    }\n    hasSourceTypes() {\n        return this.getSourceBufferTypes().length > 0 || Object.keys(this.pendingTracks).length > 0;\n    }\n    destroy() {\n        this.unregisterListeners();\n        this.details = null;\n        this.lastMpegAudioChunk = null;\n        // @ts-ignore\n        this.hls = null;\n    }\n    registerListeners() {\n        const { hls } = this;\n        hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n        hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n        hls.on(Events.BUFFER_RESET, this.onBufferReset, this);\n        hls.on(Events.BUFFER_APPENDING, this.onBufferAppending, this);\n        hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n        hls.on(Events.BUFFER_EOS, this.onBufferEos, this);\n        hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n        hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n        hls.on(Events.FRAG_PARSED, this.onFragParsed, this);\n        hls.on(Events.FRAG_CHANGED, this.onFragChanged, this);\n    }\n    unregisterListeners() {\n        const { hls } = this;\n        hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n        hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n        hls.off(Events.BUFFER_RESET, this.onBufferReset, this);\n        hls.off(Events.BUFFER_APPENDING, this.onBufferAppending, this);\n        hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n        hls.off(Events.BUFFER_EOS, this.onBufferEos, this);\n        hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n        hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n        hls.off(Events.FRAG_PARSED, this.onFragParsed, this);\n        hls.off(Events.FRAG_CHANGED, this.onFragChanged, this);\n    }\n    _initSourceBuffer() {\n        this.sourceBuffer = {};\n        this.operationQueue = new BufferOperationQueue(this.sourceBuffer);\n        this.listeners = {\n            audio: [],\n            video: [],\n            audiovideo: []\n        };\n        this.appendErrors = {\n            audio: 0,\n            video: 0,\n            audiovideo: 0\n        };\n        this.lastMpegAudioChunk = null;\n    }\n    onManifestLoading() {\n        this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = 0;\n        this.details = null;\n    }\n    onManifestParsed(event, data) {\n        // in case of alt audio 2 BUFFER_CODECS events will be triggered, one per stream controller\n        // sourcebuffers will be created all at once when the expected nb of tracks will be reached\n        // in case alt audio is not used, only one BUFFER_CODEC event will be fired from main stream controller\n        // it will contain the expected nb of source buffers, no need to compute it\n        let codecEvents = 2;\n        if (data.audio && !data.video || !data.altAudio || !true) {\n            codecEvents = 1;\n        }\n        this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = codecEvents;\n        this.log(`${this.bufferCodecEventsExpected} bufferCodec event(s) expected`);\n    }\n    onMediaAttaching(event, data) {\n        const media = this.media = data.media;\n        const MediaSource = getMediaSource(this.appendSource);\n        if (media && MediaSource) {\n            var _ms$constructor;\n            const ms = this.mediaSource = new MediaSource();\n            this.log(`created media source: ${(_ms$constructor = ms.constructor) == null ? void 0 : _ms$constructor.name}`);\n            // MediaSource listeners are arrow functions with a lexical scope, and do not need to be bound\n            ms.addEventListener(\"sourceopen\", this._onMediaSourceOpen);\n            ms.addEventListener(\"sourceended\", this._onMediaSourceEnded);\n            ms.addEventListener(\"sourceclose\", this._onMediaSourceClose);\n            ms.addEventListener(\"startstreaming\", this._onStartStreaming);\n            ms.addEventListener(\"endstreaming\", this._onEndStreaming);\n            // cache the locally generated object url\n            const objectUrl = this._objectUrl = self.URL.createObjectURL(ms);\n            // link video and media Source\n            if (this.appendSource) {\n                try {\n                    media.removeAttribute(\"src\");\n                    // ManagedMediaSource will not open without disableRemotePlayback set to false or source alternatives\n                    const MMS = self.ManagedMediaSource;\n                    media.disableRemotePlayback = media.disableRemotePlayback || MMS && ms instanceof MMS;\n                    removeSourceChildren(media);\n                    addSource(media, objectUrl);\n                    media.load();\n                } catch (error) {\n                    media.src = objectUrl;\n                }\n            } else {\n                media.src = objectUrl;\n            }\n            media.addEventListener(\"emptied\", this._onMediaEmptied);\n        }\n    }\n    onMediaDetaching() {\n        const { media, mediaSource, _objectUrl } = this;\n        if (mediaSource) {\n            this.log(\"media source detaching\");\n            if (mediaSource.readyState === \"open\") {\n                try {\n                    // endOfStream could trigger exception if any sourcebuffer is in updating state\n                    // we don't really care about checking sourcebuffer state here,\n                    // as we are anyway detaching the MediaSource\n                    // let's just avoid this exception to propagate\n                    mediaSource.endOfStream();\n                } catch (err) {\n                    this.warn(`onMediaDetaching: ${err.message} while calling endOfStream`);\n                }\n            }\n            // Clean up the SourceBuffers by invoking onBufferReset\n            this.onBufferReset();\n            mediaSource.removeEventListener(\"sourceopen\", this._onMediaSourceOpen);\n            mediaSource.removeEventListener(\"sourceended\", this._onMediaSourceEnded);\n            mediaSource.removeEventListener(\"sourceclose\", this._onMediaSourceClose);\n            mediaSource.removeEventListener(\"startstreaming\", this._onStartStreaming);\n            mediaSource.removeEventListener(\"endstreaming\", this._onEndStreaming);\n            // Detach properly the MediaSource from the HTMLMediaElement as\n            // suggested in https://github.com/w3c/media-source/issues/53.\n            if (media) {\n                media.removeEventListener(\"emptied\", this._onMediaEmptied);\n                if (_objectUrl) {\n                    self.URL.revokeObjectURL(_objectUrl);\n                }\n                // clean up video tag src only if it's our own url. some external libraries might\n                // hijack the video tag and change its 'src' without destroying the Hls instance first\n                if (this.mediaSrc === _objectUrl) {\n                    media.removeAttribute(\"src\");\n                    if (this.appendSource) {\n                        removeSourceChildren(media);\n                    }\n                    media.load();\n                } else {\n                    this.warn(\"media|source.src was changed by a third party - skip cleanup\");\n                }\n            }\n            this.mediaSource = null;\n            this.media = null;\n            this._objectUrl = null;\n            this.bufferCodecEventsExpected = this._bufferCodecEventsTotal;\n            this.pendingTracks = {};\n            this.tracks = {};\n        }\n        this.hls.trigger(Events.MEDIA_DETACHED, undefined);\n    }\n    onBufferReset() {\n        this.getSourceBufferTypes().forEach((type)=>{\n            this.resetBuffer(type);\n        });\n        this._initSourceBuffer();\n    }\n    resetBuffer(type) {\n        const sb = this.sourceBuffer[type];\n        try {\n            if (sb) {\n                var _this$mediaSource;\n                this.removeBufferListeners(type);\n                // Synchronously remove the SB from the map before the next call in order to prevent an async function from\n                // accessing it\n                this.sourceBuffer[type] = undefined;\n                if ((_this$mediaSource = this.mediaSource) != null && _this$mediaSource.sourceBuffers.length) {\n                    this.mediaSource.removeSourceBuffer(sb);\n                }\n            }\n        } catch (err) {\n            this.warn(`onBufferReset ${type}`, err);\n        }\n    }\n    onBufferCodecs(event, data) {\n        const sourceBufferCount = this.getSourceBufferTypes().length;\n        const trackNames = Object.keys(data);\n        trackNames.forEach((trackName)=>{\n            if (sourceBufferCount) {\n                // check if SourceBuffer codec needs to change\n                const track = this.tracks[trackName];\n                if (track && typeof track.buffer.changeType === \"function\") {\n                    var _trackCodec;\n                    const { id, codec, levelCodec, container, metadata } = data[trackName];\n                    const currentCodecFull = pickMostCompleteCodecName(track.codec, track.levelCodec);\n                    const currentCodec = currentCodecFull == null ? void 0 : currentCodecFull.replace(VIDEO_CODEC_PROFILE_REPLACE, \"$1\");\n                    let trackCodec = pickMostCompleteCodecName(codec, levelCodec);\n                    const nextCodec = (_trackCodec = trackCodec) == null ? void 0 : _trackCodec.replace(VIDEO_CODEC_PROFILE_REPLACE, \"$1\");\n                    if (trackCodec && currentCodec !== nextCodec) {\n                        if (trackName.slice(0, 5) === \"audio\") {\n                            trackCodec = getCodecCompatibleName(trackCodec, this.hls.config.preferManagedMediaSource);\n                        }\n                        const mimeType = `${container};codecs=${trackCodec}`;\n                        this.appendChangeType(trackName, mimeType);\n                        this.log(`switching codec ${currentCodecFull} to ${trackCodec}`);\n                        this.tracks[trackName] = {\n                            buffer: track.buffer,\n                            codec,\n                            container,\n                            levelCodec,\n                            metadata,\n                            id\n                        };\n                    }\n                }\n            } else {\n                // if source buffer(s) not created yet, appended buffer tracks in this.pendingTracks\n                this.pendingTracks[trackName] = data[trackName];\n            }\n        });\n        // if sourcebuffers already created, do nothing ...\n        if (sourceBufferCount) {\n            return;\n        }\n        const bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0);\n        if (this.bufferCodecEventsExpected !== bufferCodecEventsExpected) {\n            this.log(`${bufferCodecEventsExpected} bufferCodec event(s) expected ${trackNames.join(\",\")}`);\n            this.bufferCodecEventsExpected = bufferCodecEventsExpected;\n        }\n        if (this.mediaSource && this.mediaSource.readyState === \"open\") {\n            this.checkPendingTracks();\n        }\n    }\n    appendChangeType(type, mimeType) {\n        const { operationQueue } = this;\n        const operation = {\n            execute: ()=>{\n                const sb = this.sourceBuffer[type];\n                if (sb) {\n                    this.log(`changing ${type} sourceBuffer type to ${mimeType}`);\n                    sb.changeType(mimeType);\n                }\n                operationQueue.shiftAndExecuteNext(type);\n            },\n            onStart: ()=>{},\n            onComplete: ()=>{},\n            onError: (error)=>{\n                this.warn(`Failed to change ${type} SourceBuffer type`, error);\n            }\n        };\n        operationQueue.append(operation, type, !!this.pendingTracks[type]);\n    }\n    onBufferAppending(event, eventData) {\n        const { hls, operationQueue, tracks } = this;\n        const { data, type, frag, part, chunkMeta } = eventData;\n        const chunkStats = chunkMeta.buffering[type];\n        const bufferAppendingStart = self.performance.now();\n        chunkStats.start = bufferAppendingStart;\n        const fragBuffering = frag.stats.buffering;\n        const partBuffering = part ? part.stats.buffering : null;\n        if (fragBuffering.start === 0) {\n            fragBuffering.start = bufferAppendingStart;\n        }\n        if (partBuffering && partBuffering.start === 0) {\n            partBuffering.start = bufferAppendingStart;\n        }\n        // TODO: Only update timestampOffset when audio/mpeg fragment or part is not contiguous with previously appended\n        // Adjusting `SourceBuffer.timestampOffset` (desired point in the timeline where the next frames should be appended)\n        // in Chrome browser when we detect MPEG audio container and time delta between level PTS and `SourceBuffer.timestampOffset`\n        // is greater than 100ms (this is enough to handle seek for VOD or level change for LIVE videos).\n        // More info here: https://github.com/video-dev/hls.js/issues/332#issuecomment-257986486\n        const audioTrack = tracks.audio;\n        let checkTimestampOffset = false;\n        if (type === \"audio\" && (audioTrack == null ? void 0 : audioTrack.container) === \"audio/mpeg\") {\n            checkTimestampOffset = !this.lastMpegAudioChunk || chunkMeta.id === 1 || this.lastMpegAudioChunk.sn !== chunkMeta.sn;\n            this.lastMpegAudioChunk = chunkMeta;\n        }\n        const fragStart = frag.start;\n        const operation = {\n            execute: ()=>{\n                chunkStats.executeStart = self.performance.now();\n                if (checkTimestampOffset) {\n                    const sb = this.sourceBuffer[type];\n                    if (sb) {\n                        const delta = fragStart - sb.timestampOffset;\n                        if (Math.abs(delta) >= 0.1) {\n                            this.log(`Updating audio SourceBuffer timestampOffset to ${fragStart} (delta: ${delta}) sn: ${frag.sn})`);\n                            sb.timestampOffset = fragStart;\n                        }\n                    }\n                }\n                this.appendExecutor(data, type);\n            },\n            onStart: ()=>{\n            // logger.debug(`[buffer-controller]: ${type} SourceBuffer updatestart`);\n            },\n            onComplete: ()=>{\n                // logger.debug(`[buffer-controller]: ${type} SourceBuffer updateend`);\n                const end = self.performance.now();\n                chunkStats.executeEnd = chunkStats.end = end;\n                if (fragBuffering.first === 0) {\n                    fragBuffering.first = end;\n                }\n                if (partBuffering && partBuffering.first === 0) {\n                    partBuffering.first = end;\n                }\n                const { sourceBuffer } = this;\n                const timeRanges = {};\n                for(const type in sourceBuffer){\n                    timeRanges[type] = BufferHelper.getBuffered(sourceBuffer[type]);\n                }\n                this.appendErrors[type] = 0;\n                if (type === \"audio\" || type === \"video\") {\n                    this.appendErrors.audiovideo = 0;\n                } else {\n                    this.appendErrors.audio = 0;\n                    this.appendErrors.video = 0;\n                }\n                this.hls.trigger(Events.BUFFER_APPENDED, {\n                    type,\n                    frag,\n                    part,\n                    chunkMeta,\n                    parent: frag.type,\n                    timeRanges\n                });\n            },\n            onError: (error)=>{\n                // in case any error occured while appending, put back segment in segments table\n                const event = {\n                    type: ErrorTypes.MEDIA_ERROR,\n                    parent: frag.type,\n                    details: ErrorDetails.BUFFER_APPEND_ERROR,\n                    sourceBufferName: type,\n                    frag,\n                    part,\n                    chunkMeta,\n                    error,\n                    err: error,\n                    fatal: false\n                };\n                if (error.code === DOMException.QUOTA_EXCEEDED_ERR) {\n                    // QuotaExceededError: http://www.w3.org/TR/html5/infrastructure.html#quotaexceedederror\n                    // let's stop appending any segments, and report BUFFER_FULL_ERROR error\n                    event.details = ErrorDetails.BUFFER_FULL_ERROR;\n                } else {\n                    const appendErrorCount = ++this.appendErrors[type];\n                    event.details = ErrorDetails.BUFFER_APPEND_ERROR;\n                    /* with UHD content, we could get loop of quota exceeded error until\n            browser is able to evict some data from sourcebuffer. Retrying can help recover.\n          */ this.warn(`Failed ${appendErrorCount}/${hls.config.appendErrorMaxRetry} times to append segment in \"${type}\" sourceBuffer`);\n                    if (appendErrorCount >= hls.config.appendErrorMaxRetry) {\n                        event.fatal = true;\n                    }\n                }\n                hls.trigger(Events.ERROR, event);\n            }\n        };\n        operationQueue.append(operation, type, !!this.pendingTracks[type]);\n    }\n    onBufferFlushing(event, data) {\n        const { operationQueue } = this;\n        const flushOperation = (type)=>({\n                execute: this.removeExecutor.bind(this, type, data.startOffset, data.endOffset),\n                onStart: ()=>{\n                // logger.debug(`[buffer-controller]: Started flushing ${data.startOffset} -> ${data.endOffset} for ${type} Source Buffer`);\n                },\n                onComplete: ()=>{\n                    // logger.debug(`[buffer-controller]: Finished flushing ${data.startOffset} -> ${data.endOffset} for ${type} Source Buffer`);\n                    this.hls.trigger(Events.BUFFER_FLUSHED, {\n                        type\n                    });\n                },\n                onError: (error)=>{\n                    this.warn(`Failed to remove from ${type} SourceBuffer`, error);\n                }\n            });\n        if (data.type) {\n            operationQueue.append(flushOperation(data.type), data.type);\n        } else {\n            this.getSourceBufferTypes().forEach((type)=>{\n                operationQueue.append(flushOperation(type), type);\n            });\n        }\n    }\n    onFragParsed(event, data) {\n        const { frag, part } = data;\n        const buffersAppendedTo = [];\n        const elementaryStreams = part ? part.elementaryStreams : frag.elementaryStreams;\n        if (elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO]) {\n            buffersAppendedTo.push(\"audiovideo\");\n        } else {\n            if (elementaryStreams[ElementaryStreamTypes.AUDIO]) {\n                buffersAppendedTo.push(\"audio\");\n            }\n            if (elementaryStreams[ElementaryStreamTypes.VIDEO]) {\n                buffersAppendedTo.push(\"video\");\n            }\n        }\n        const onUnblocked = ()=>{\n            const now = self.performance.now();\n            frag.stats.buffering.end = now;\n            if (part) {\n                part.stats.buffering.end = now;\n            }\n            const stats = part ? part.stats : frag.stats;\n            this.hls.trigger(Events.FRAG_BUFFERED, {\n                frag,\n                part,\n                stats,\n                id: frag.type\n            });\n        };\n        if (buffersAppendedTo.length === 0) {\n            this.warn(`Fragments must have at least one ElementaryStreamType set. type: ${frag.type} level: ${frag.level} sn: ${frag.sn}`);\n        }\n        this.blockBuffers(onUnblocked, buffersAppendedTo);\n    }\n    onFragChanged(event, data) {\n        this.trimBuffers();\n    }\n    // on BUFFER_EOS mark matching sourcebuffer(s) as ended and trigger checkEos()\n    // an undefined data.type will mark all buffers as EOS.\n    onBufferEos(event, data) {\n        const ended = this.getSourceBufferTypes().reduce((acc, type)=>{\n            const sb = this.sourceBuffer[type];\n            if (sb && (!data.type || data.type === type)) {\n                sb.ending = true;\n                if (!sb.ended) {\n                    sb.ended = true;\n                    this.log(`${type} sourceBuffer now EOS`);\n                }\n            }\n            return acc && !!(!sb || sb.ended);\n        }, true);\n        if (ended) {\n            this.log(`Queueing mediaSource.endOfStream()`);\n            this.blockBuffers(()=>{\n                this.getSourceBufferTypes().forEach((type)=>{\n                    const sb = this.sourceBuffer[type];\n                    if (sb) {\n                        sb.ending = false;\n                    }\n                });\n                const { mediaSource } = this;\n                if (!mediaSource || mediaSource.readyState !== \"open\") {\n                    if (mediaSource) {\n                        this.log(`Could not call mediaSource.endOfStream(). mediaSource.readyState: ${mediaSource.readyState}`);\n                    }\n                    return;\n                }\n                this.log(`Calling mediaSource.endOfStream()`);\n                // Allow this to throw and be caught by the enqueueing function\n                mediaSource.endOfStream();\n            });\n        }\n    }\n    onLevelUpdated(event, { details }) {\n        if (!details.fragments.length) {\n            return;\n        }\n        this.details = details;\n        if (this.getSourceBufferTypes().length) {\n            this.blockBuffers(this.updateMediaElementDuration.bind(this));\n        } else {\n            this.updateMediaElementDuration();\n        }\n    }\n    trimBuffers() {\n        const { hls, details, media } = this;\n        if (!media || details === null) {\n            return;\n        }\n        const sourceBufferTypes = this.getSourceBufferTypes();\n        if (!sourceBufferTypes.length) {\n            return;\n        }\n        const config = hls.config;\n        const currentTime = media.currentTime;\n        const targetDuration = details.levelTargetDuration;\n        // Support for deprecated liveBackBufferLength\n        const backBufferLength = details.live && config.liveBackBufferLength !== null ? config.liveBackBufferLength : config.backBufferLength;\n        if (isFiniteNumber(backBufferLength) && backBufferLength > 0) {\n            const maxBackBufferLength = Math.max(backBufferLength, targetDuration);\n            const targetBackBufferPosition = Math.floor(currentTime / targetDuration) * targetDuration - maxBackBufferLength;\n            this.flushBackBuffer(currentTime, targetDuration, targetBackBufferPosition);\n        }\n        if (isFiniteNumber(config.frontBufferFlushThreshold) && config.frontBufferFlushThreshold > 0) {\n            const frontBufferLength = Math.max(config.maxBufferLength, config.frontBufferFlushThreshold);\n            const maxFrontBufferLength = Math.max(frontBufferLength, targetDuration);\n            const targetFrontBufferPosition = Math.floor(currentTime / targetDuration) * targetDuration + maxFrontBufferLength;\n            this.flushFrontBuffer(currentTime, targetDuration, targetFrontBufferPosition);\n        }\n    }\n    flushBackBuffer(currentTime, targetDuration, targetBackBufferPosition) {\n        const { details, sourceBuffer } = this;\n        const sourceBufferTypes = this.getSourceBufferTypes();\n        sourceBufferTypes.forEach((type)=>{\n            const sb = sourceBuffer[type];\n            if (sb) {\n                const buffered = BufferHelper.getBuffered(sb);\n                // when target buffer start exceeds actual buffer start\n                if (buffered.length > 0 && targetBackBufferPosition > buffered.start(0)) {\n                    this.hls.trigger(Events.BACK_BUFFER_REACHED, {\n                        bufferEnd: targetBackBufferPosition\n                    });\n                    // Support for deprecated event:\n                    if (details != null && details.live) {\n                        this.hls.trigger(Events.LIVE_BACK_BUFFER_REACHED, {\n                            bufferEnd: targetBackBufferPosition\n                        });\n                    } else if (sb.ended && buffered.end(buffered.length - 1) - currentTime < targetDuration * 2) {\n                        this.log(`Cannot flush ${type} back buffer while SourceBuffer is in ended state`);\n                        return;\n                    }\n                    this.hls.trigger(Events.BUFFER_FLUSHING, {\n                        startOffset: 0,\n                        endOffset: targetBackBufferPosition,\n                        type\n                    });\n                }\n            }\n        });\n    }\n    flushFrontBuffer(currentTime, targetDuration, targetFrontBufferPosition) {\n        const { sourceBuffer } = this;\n        const sourceBufferTypes = this.getSourceBufferTypes();\n        sourceBufferTypes.forEach((type)=>{\n            const sb = sourceBuffer[type];\n            if (sb) {\n                const buffered = BufferHelper.getBuffered(sb);\n                const numBufferedRanges = buffered.length;\n                // The buffer is either empty or contiguous\n                if (numBufferedRanges < 2) {\n                    return;\n                }\n                const bufferStart = buffered.start(numBufferedRanges - 1);\n                const bufferEnd = buffered.end(numBufferedRanges - 1);\n                // No flush if we can tolerate the current buffer length or the current buffer range we would flush is contiguous with current position\n                if (targetFrontBufferPosition > bufferStart || currentTime >= bufferStart && currentTime <= bufferEnd) {\n                    return;\n                } else if (sb.ended && currentTime - bufferEnd < 2 * targetDuration) {\n                    this.log(`Cannot flush ${type} front buffer while SourceBuffer is in ended state`);\n                    return;\n                }\n                this.hls.trigger(Events.BUFFER_FLUSHING, {\n                    startOffset: bufferStart,\n                    endOffset: Infinity,\n                    type\n                });\n            }\n        });\n    }\n    /**\n   * Update Media Source duration to current level duration or override to Infinity if configuration parameter\n   * 'liveDurationInfinity` is set to `true`\n   * More details: https://github.com/video-dev/hls.js/issues/355\n   */ updateMediaElementDuration() {\n        if (!this.details || !this.media || !this.mediaSource || this.mediaSource.readyState !== \"open\") {\n            return;\n        }\n        const { details, hls, media, mediaSource } = this;\n        const levelDuration = details.fragments[0].start + details.totalduration;\n        const mediaDuration = media.duration;\n        const msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : 0;\n        if (details.live && hls.config.liveDurationInfinity) {\n            // Override duration to Infinity\n            mediaSource.duration = Infinity;\n            this.updateSeekableRange(details);\n        } else if (levelDuration > msDuration && levelDuration > mediaDuration || !isFiniteNumber(mediaDuration)) {\n            // levelDuration was the last value we set.\n            // not using mediaSource.duration as the browser may tweak this value\n            // only update Media Source duration if its value increase, this is to avoid\n            // flushing already buffered portion when switching between quality level\n            this.log(`Updating Media Source duration to ${levelDuration.toFixed(3)}`);\n            mediaSource.duration = levelDuration;\n        }\n    }\n    updateSeekableRange(levelDetails) {\n        const mediaSource = this.mediaSource;\n        const fragments = levelDetails.fragments;\n        const len = fragments.length;\n        if (len && levelDetails.live && mediaSource != null && mediaSource.setLiveSeekableRange) {\n            const start = Math.max(0, fragments[0].start);\n            const end = Math.max(start, start + levelDetails.totalduration);\n            this.log(`Media Source duration is set to ${mediaSource.duration}. Setting seekable range to ${start}-${end}.`);\n            mediaSource.setLiveSeekableRange(start, end);\n        }\n    }\n    checkPendingTracks() {\n        const { bufferCodecEventsExpected, operationQueue, pendingTracks } = this;\n        // Check if we've received all of the expected bufferCodec events. When none remain, create all the sourceBuffers at once.\n        // This is important because the MSE spec allows implementations to throw QuotaExceededErrors if creating new sourceBuffers after\n        // data has been appended to existing ones.\n        // 2 tracks is the max (one for audio, one for video). If we've reach this max go ahead and create the buffers.\n        const pendingTracksCount = Object.keys(pendingTracks).length;\n        if (pendingTracksCount && (!bufferCodecEventsExpected || pendingTracksCount === 2 || \"audiovideo\" in pendingTracks)) {\n            // ok, let's create them now !\n            this.createSourceBuffers(pendingTracks);\n            this.pendingTracks = {};\n            // append any pending segments now !\n            const buffers = this.getSourceBufferTypes();\n            if (buffers.length) {\n                this.hls.trigger(Events.BUFFER_CREATED, {\n                    tracks: this.tracks\n                });\n                buffers.forEach((type)=>{\n                    operationQueue.executeNext(type);\n                });\n            } else {\n                const error = new Error(\"could not create source buffer for media codec(s)\");\n                this.hls.trigger(Events.ERROR, {\n                    type: ErrorTypes.MEDIA_ERROR,\n                    details: ErrorDetails.BUFFER_INCOMPATIBLE_CODECS_ERROR,\n                    fatal: true,\n                    error,\n                    reason: error.message\n                });\n            }\n        }\n    }\n    createSourceBuffers(tracks) {\n        const { sourceBuffer, mediaSource } = this;\n        if (!mediaSource) {\n            throw Error(\"createSourceBuffers called when mediaSource was null\");\n        }\n        for(const trackName in tracks){\n            if (!sourceBuffer[trackName]) {\n                const track = tracks[trackName];\n                if (!track) {\n                    throw Error(`source buffer exists for track ${trackName}, however track does not`);\n                }\n                // use levelCodec as first priority\n                let codec = track.levelCodec || track.codec;\n                if (codec) {\n                    if (trackName.slice(0, 5) === \"audio\") {\n                        codec = getCodecCompatibleName(codec, this.hls.config.preferManagedMediaSource);\n                    }\n                }\n                const mimeType = `${track.container};codecs=${codec}`;\n                this.log(`creating sourceBuffer(${mimeType})`);\n                try {\n                    const sb = sourceBuffer[trackName] = mediaSource.addSourceBuffer(mimeType);\n                    const sbName = trackName;\n                    this.addBufferListener(sbName, \"updatestart\", this._onSBUpdateStart);\n                    this.addBufferListener(sbName, \"updateend\", this._onSBUpdateEnd);\n                    this.addBufferListener(sbName, \"error\", this._onSBUpdateError);\n                    // ManagedSourceBuffer bufferedchange event\n                    this.addBufferListener(sbName, \"bufferedchange\", (type, event)=>{\n                        // If media was ejected check for a change. Added ranges are redundant with changes on 'updateend' event.\n                        const removedRanges = event.removedRanges;\n                        if (removedRanges != null && removedRanges.length) {\n                            this.hls.trigger(Events.BUFFER_FLUSHED, {\n                                type: trackName\n                            });\n                        }\n                    });\n                    this.tracks[trackName] = {\n                        buffer: sb,\n                        codec: codec,\n                        container: track.container,\n                        levelCodec: track.levelCodec,\n                        metadata: track.metadata,\n                        id: track.id\n                    };\n                } catch (err) {\n                    this.error(`error while trying to add sourceBuffer: ${err.message}`);\n                    this.hls.trigger(Events.ERROR, {\n                        type: ErrorTypes.MEDIA_ERROR,\n                        details: ErrorDetails.BUFFER_ADD_CODEC_ERROR,\n                        fatal: false,\n                        error: err,\n                        sourceBufferName: trackName,\n                        mimeType: mimeType\n                    });\n                }\n            }\n        }\n    }\n    get mediaSrc() {\n        var _this$media;\n        const media = ((_this$media = this.media) == null ? void 0 : _this$media.firstChild) || this.media;\n        return media == null ? void 0 : media.src;\n    }\n    _onSBUpdateStart(type) {\n        const { operationQueue } = this;\n        const operation = operationQueue.current(type);\n        operation.onStart();\n    }\n    _onSBUpdateEnd(type) {\n        var _this$mediaSource2;\n        if (((_this$mediaSource2 = this.mediaSource) == null ? void 0 : _this$mediaSource2.readyState) === \"closed\") {\n            this.resetBuffer(type);\n            return;\n        }\n        const { operationQueue } = this;\n        const operation = operationQueue.current(type);\n        operation.onComplete();\n        operationQueue.shiftAndExecuteNext(type);\n    }\n    _onSBUpdateError(type, event) {\n        var _this$mediaSource3;\n        const error = new Error(`${type} SourceBuffer error. MediaSource readyState: ${(_this$mediaSource3 = this.mediaSource) == null ? void 0 : _this$mediaSource3.readyState}`);\n        this.error(`${error}`, event);\n        // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error\n        // SourceBuffer errors are not necessarily fatal; if so, the HTMLMediaElement will fire an error event\n        this.hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.BUFFER_APPENDING_ERROR,\n            sourceBufferName: type,\n            error,\n            fatal: false\n        });\n        // updateend is always fired after error, so we'll allow that to shift the current operation off of the queue\n        const operation = this.operationQueue.current(type);\n        if (operation) {\n            operation.onError(error);\n        }\n    }\n    // This method must result in an updateend event; if remove is not called, _onSBUpdateEnd must be called manually\n    removeExecutor(type, startOffset, endOffset) {\n        const { media, mediaSource, operationQueue, sourceBuffer } = this;\n        const sb = sourceBuffer[type];\n        if (!media || !mediaSource || !sb) {\n            this.warn(`Attempting to remove from the ${type} SourceBuffer, but it does not exist`);\n            operationQueue.shiftAndExecuteNext(type);\n            return;\n        }\n        const mediaDuration = isFiniteNumber(media.duration) ? media.duration : Infinity;\n        const msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : Infinity;\n        const removeStart = Math.max(0, startOffset);\n        const removeEnd = Math.min(endOffset, mediaDuration, msDuration);\n        if (removeEnd > removeStart && (!sb.ending || sb.ended)) {\n            sb.ended = false;\n            this.log(`Removing [${removeStart},${removeEnd}] from the ${type} SourceBuffer`);\n            sb.remove(removeStart, removeEnd);\n        } else {\n            // Cycle the queue\n            operationQueue.shiftAndExecuteNext(type);\n        }\n    }\n    // This method must result in an updateend event; if append is not called, _onSBUpdateEnd must be called manually\n    appendExecutor(data, type) {\n        const sb = this.sourceBuffer[type];\n        if (!sb) {\n            if (!this.pendingTracks[type]) {\n                throw new Error(`Attempting to append to the ${type} SourceBuffer, but it does not exist`);\n            }\n            return;\n        }\n        sb.ended = false;\n        sb.appendBuffer(data);\n    }\n    // Enqueues an operation to each SourceBuffer queue which, upon execution, resolves a promise. When all promises\n    // resolve, the onUnblocked function is executed. Functions calling this method do not need to unblock the queue\n    // upon completion, since we already do it here\n    blockBuffers(onUnblocked, buffers = this.getSourceBufferTypes()) {\n        if (!buffers.length) {\n            this.log(\"Blocking operation requested, but no SourceBuffers exist\");\n            Promise.resolve().then(onUnblocked);\n            return;\n        }\n        const { operationQueue } = this;\n        // logger.debug(`[buffer-controller]: Blocking ${buffers} SourceBuffer`);\n        const blockingOperations = buffers.map((type)=>operationQueue.appendBlocker(type));\n        Promise.all(blockingOperations).then(()=>{\n            // logger.debug(`[buffer-controller]: Blocking operation resolved; unblocking ${buffers} SourceBuffer`);\n            onUnblocked();\n            buffers.forEach((type)=>{\n                const sb = this.sourceBuffer[type];\n                // Only cycle the queue if the SB is not updating. There's a bug in Chrome which sets the SB updating flag to\n                // true when changing the MediaSource duration (https://bugs.chromium.org/p/chromium/issues/detail?id=959359&can=2&q=mediasource%20duration)\n                // While this is a workaround, it's probably useful to have around\n                if (!(sb != null && sb.updating)) {\n                    operationQueue.shiftAndExecuteNext(type);\n                }\n            });\n        });\n    }\n    getSourceBufferTypes() {\n        return Object.keys(this.sourceBuffer);\n    }\n    addBufferListener(type, event, fn) {\n        const buffer = this.sourceBuffer[type];\n        if (!buffer) {\n            return;\n        }\n        const listener = fn.bind(this, type);\n        this.listeners[type].push({\n            event,\n            listener\n        });\n        buffer.addEventListener(event, listener);\n    }\n    removeBufferListeners(type) {\n        const buffer = this.sourceBuffer[type];\n        if (!buffer) {\n            return;\n        }\n        this.listeners[type].forEach((l)=>{\n            buffer.removeEventListener(l.event, l.listener);\n        });\n    }\n}\nfunction removeSourceChildren(node) {\n    const sourceChildren = node.querySelectorAll(\"source\");\n    [].slice.call(sourceChildren).forEach((source)=>{\n        node.removeChild(source);\n    });\n}\nfunction addSource(media, url) {\n    const source = self.document.createElement(\"source\");\n    source.type = \"video/mp4\";\n    source.src = url;\n    media.appendChild(source);\n}\n/**\n *\n * This code was ported from the dash.js project at:\n *   https://github.com/Dash-Industry-Forum/dash.js/blob/development/externals/cea608-parser.js\n *   https://github.com/Dash-Industry-Forum/dash.js/commit/8269b26a761e0853bb21d78780ed945144ecdd4d#diff-71bc295a2d6b6b7093a1d3290d53a4b2\n *\n * The original copyright appears below:\n *\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2015-2016, DASH Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  1. Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  2. Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */ /**\n *  Exceptions from regular ASCII. CodePoints are mapped to UTF-16 codes\n */ const specialCea608CharsCodes = {\n    0x2a: 0xe1,\n    // lowercase a, acute accent\n    0x5c: 0xe9,\n    // lowercase e, acute accent\n    0x5e: 0xed,\n    // lowercase i, acute accent\n    0x5f: 0xf3,\n    // lowercase o, acute accent\n    0x60: 0xfa,\n    // lowercase u, acute accent\n    0x7b: 0xe7,\n    // lowercase c with cedilla\n    0x7c: 0xf7,\n    // division symbol\n    0x7d: 0xd1,\n    // uppercase N tilde\n    0x7e: 0xf1,\n    // lowercase n tilde\n    0x7f: 0x2588,\n    // Full block\n    // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n    // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F\n    // THIS MEANS THAT \\x50 MUST BE ADDED TO THE VALUES\n    0x80: 0xae,\n    // Registered symbol (R)\n    0x81: 0xb0,\n    // degree sign\n    0x82: 0xbd,\n    // 1/2 symbol\n    0x83: 0xbf,\n    // Inverted (open) question mark\n    0x84: 0x2122,\n    // Trademark symbol (TM)\n    0x85: 0xa2,\n    // Cents symbol\n    0x86: 0xa3,\n    // Pounds sterling\n    0x87: 0x266a,\n    // Music 8'th note\n    0x88: 0xe0,\n    // lowercase a, grave accent\n    0x89: 0x20,\n    // transparent space (regular)\n    0x8a: 0xe8,\n    // lowercase e, grave accent\n    0x8b: 0xe2,\n    // lowercase a, circumflex accent\n    0x8c: 0xea,\n    // lowercase e, circumflex accent\n    0x8d: 0xee,\n    // lowercase i, circumflex accent\n    0x8e: 0xf4,\n    // lowercase o, circumflex accent\n    0x8f: 0xfb,\n    // lowercase u, circumflex accent\n    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n    // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F\n    0x90: 0xc1,\n    // capital letter A with acute\n    0x91: 0xc9,\n    // capital letter E with acute\n    0x92: 0xd3,\n    // capital letter O with acute\n    0x93: 0xda,\n    // capital letter U with acute\n    0x94: 0xdc,\n    // capital letter U with diaresis\n    0x95: 0xfc,\n    // lowercase letter U with diaeresis\n    0x96: 0x2018,\n    // opening single quote\n    0x97: 0xa1,\n    // inverted exclamation mark\n    0x98: 0x2a,\n    // asterisk\n    0x99: 0x2019,\n    // closing single quote\n    0x9a: 0x2501,\n    // box drawings heavy horizontal\n    0x9b: 0xa9,\n    // copyright sign\n    0x9c: 0x2120,\n    // Service mark\n    0x9d: 0x2022,\n    // (round) bullet\n    0x9e: 0x201c,\n    // Left double quotation mark\n    0x9f: 0x201d,\n    // Right double quotation mark\n    0xa0: 0xc0,\n    // uppercase A, grave accent\n    0xa1: 0xc2,\n    // uppercase A, circumflex\n    0xa2: 0xc7,\n    // uppercase C with cedilla\n    0xa3: 0xc8,\n    // uppercase E, grave accent\n    0xa4: 0xca,\n    // uppercase E, circumflex\n    0xa5: 0xcb,\n    // capital letter E with diaresis\n    0xa6: 0xeb,\n    // lowercase letter e with diaresis\n    0xa7: 0xce,\n    // uppercase I, circumflex\n    0xa8: 0xcf,\n    // uppercase I, with diaresis\n    0xa9: 0xef,\n    // lowercase i, with diaresis\n    0xaa: 0xd4,\n    // uppercase O, circumflex\n    0xab: 0xd9,\n    // uppercase U, grave accent\n    0xac: 0xf9,\n    // lowercase u, grave accent\n    0xad: 0xdb,\n    // uppercase U, circumflex\n    0xae: 0xab,\n    // left-pointing double angle quotation mark\n    0xaf: 0xbb,\n    // right-pointing double angle quotation mark\n    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n    // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F\n    0xb0: 0xc3,\n    // Uppercase A, tilde\n    0xb1: 0xe3,\n    // Lowercase a, tilde\n    0xb2: 0xcd,\n    // Uppercase I, acute accent\n    0xb3: 0xcc,\n    // Uppercase I, grave accent\n    0xb4: 0xec,\n    // Lowercase i, grave accent\n    0xb5: 0xd2,\n    // Uppercase O, grave accent\n    0xb6: 0xf2,\n    // Lowercase o, grave accent\n    0xb7: 0xd5,\n    // Uppercase O, tilde\n    0xb8: 0xf5,\n    // Lowercase o, tilde\n    0xb9: 0x7b,\n    // Open curly brace\n    0xba: 0x7d,\n    // Closing curly brace\n    0xbb: 0x5c,\n    // Backslash\n    0xbc: 0x5e,\n    // Caret\n    0xbd: 0x5f,\n    // Underscore\n    0xbe: 0x7c,\n    // Pipe (vertical line)\n    0xbf: 0x223c,\n    // Tilde operator\n    0xc0: 0xc4,\n    // Uppercase A, umlaut\n    0xc1: 0xe4,\n    // Lowercase A, umlaut\n    0xc2: 0xd6,\n    // Uppercase O, umlaut\n    0xc3: 0xf6,\n    // Lowercase o, umlaut\n    0xc4: 0xdf,\n    // Esszett (sharp S)\n    0xc5: 0xa5,\n    // Yen symbol\n    0xc6: 0xa4,\n    // Generic currency sign\n    0xc7: 0x2503,\n    // Box drawings heavy vertical\n    0xc8: 0xc5,\n    // Uppercase A, ring\n    0xc9: 0xe5,\n    // Lowercase A, ring\n    0xca: 0xd8,\n    // Uppercase O, stroke\n    0xcb: 0xf8,\n    // Lowercase o, strok\n    0xcc: 0x250f,\n    // Box drawings heavy down and right\n    0xcd: 0x2513,\n    // Box drawings heavy down and left\n    0xce: 0x2517,\n    // Box drawings heavy up and right\n    0xcf: 0x251b // Box drawings heavy up and left\n};\n/**\n * Utils\n */ const getCharForByte = function getCharForByte(byte) {\n    let charCode = byte;\n    if (specialCea608CharsCodes.hasOwnProperty(byte)) {\n        charCode = specialCea608CharsCodes[byte];\n    }\n    return String.fromCharCode(charCode);\n};\nconst NR_ROWS = 15;\nconst NR_COLS = 100;\n// Tables to look up row from PAC data\nconst rowsLowCh1 = {\n    0x11: 1,\n    0x12: 3,\n    0x15: 5,\n    0x16: 7,\n    0x17: 9,\n    0x10: 11,\n    0x13: 12,\n    0x14: 14\n};\nconst rowsHighCh1 = {\n    0x11: 2,\n    0x12: 4,\n    0x15: 6,\n    0x16: 8,\n    0x17: 10,\n    0x13: 13,\n    0x14: 15\n};\nconst rowsLowCh2 = {\n    0x19: 1,\n    0x1a: 3,\n    0x1d: 5,\n    0x1e: 7,\n    0x1f: 9,\n    0x18: 11,\n    0x1b: 12,\n    0x1c: 14\n};\nconst rowsHighCh2 = {\n    0x19: 2,\n    0x1a: 4,\n    0x1d: 6,\n    0x1e: 8,\n    0x1f: 10,\n    0x1b: 13,\n    0x1c: 15\n};\nconst backgroundColors = [\n    \"white\",\n    \"green\",\n    \"blue\",\n    \"cyan\",\n    \"red\",\n    \"yellow\",\n    \"magenta\",\n    \"black\",\n    \"transparent\"\n];\nclass CaptionsLogger {\n    constructor(){\n        this.time = null;\n        this.verboseLevel = 0;\n    }\n    log(severity, msg) {\n        if (this.verboseLevel >= severity) {\n            const m = typeof msg === \"function\" ? msg() : msg;\n            logger.log(`${this.time} [${severity}] ${m}`);\n        }\n    }\n}\nconst numArrayToHexArray = function numArrayToHexArray(numArray) {\n    const hexArray = [];\n    for(let j = 0; j < numArray.length; j++){\n        hexArray.push(numArray[j].toString(16));\n    }\n    return hexArray;\n};\nclass PenState {\n    constructor(){\n        this.foreground = \"white\";\n        this.underline = false;\n        this.italics = false;\n        this.background = \"black\";\n        this.flash = false;\n    }\n    reset() {\n        this.foreground = \"white\";\n        this.underline = false;\n        this.italics = false;\n        this.background = \"black\";\n        this.flash = false;\n    }\n    setStyles(styles) {\n        const attribs = [\n            \"foreground\",\n            \"underline\",\n            \"italics\",\n            \"background\",\n            \"flash\"\n        ];\n        for(let i = 0; i < attribs.length; i++){\n            const style = attribs[i];\n            if (styles.hasOwnProperty(style)) {\n                this[style] = styles[style];\n            }\n        }\n    }\n    isDefault() {\n        return this.foreground === \"white\" && !this.underline && !this.italics && this.background === \"black\" && !this.flash;\n    }\n    equals(other) {\n        return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;\n    }\n    copy(newPenState) {\n        this.foreground = newPenState.foreground;\n        this.underline = newPenState.underline;\n        this.italics = newPenState.italics;\n        this.background = newPenState.background;\n        this.flash = newPenState.flash;\n    }\n    toString() {\n        return \"color=\" + this.foreground + \", underline=\" + this.underline + \", italics=\" + this.italics + \", background=\" + this.background + \", flash=\" + this.flash;\n    }\n}\n/**\n * Unicode character with styling and background.\n * @constructor\n */ class StyledUnicodeChar {\n    constructor(){\n        this.uchar = \" \";\n        this.penState = new PenState();\n    }\n    reset() {\n        this.uchar = \" \";\n        this.penState.reset();\n    }\n    setChar(uchar, newPenState) {\n        this.uchar = uchar;\n        this.penState.copy(newPenState);\n    }\n    setPenState(newPenState) {\n        this.penState.copy(newPenState);\n    }\n    equals(other) {\n        return this.uchar === other.uchar && this.penState.equals(other.penState);\n    }\n    copy(newChar) {\n        this.uchar = newChar.uchar;\n        this.penState.copy(newChar.penState);\n    }\n    isEmpty() {\n        return this.uchar === \" \" && this.penState.isDefault();\n    }\n}\n/**\n * CEA-608 row consisting of NR_COLS instances of StyledUnicodeChar.\n * @constructor\n */ class Row {\n    constructor(logger){\n        this.chars = [];\n        this.pos = 0;\n        this.currPenState = new PenState();\n        this.cueStartTime = null;\n        this.logger = void 0;\n        for(let i = 0; i < NR_COLS; i++){\n            this.chars.push(new StyledUnicodeChar());\n        }\n        this.logger = logger;\n    }\n    equals(other) {\n        for(let i = 0; i < NR_COLS; i++){\n            if (!this.chars[i].equals(other.chars[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    copy(other) {\n        for(let i = 0; i < NR_COLS; i++){\n            this.chars[i].copy(other.chars[i]);\n        }\n    }\n    isEmpty() {\n        let empty = true;\n        for(let i = 0; i < NR_COLS; i++){\n            if (!this.chars[i].isEmpty()) {\n                empty = false;\n                break;\n            }\n        }\n        return empty;\n    }\n    /**\n   *  Set the cursor to a valid column.\n   */ setCursor(absPos) {\n        if (this.pos !== absPos) {\n            this.pos = absPos;\n        }\n        if (this.pos < 0) {\n            this.logger.log(3, \"Negative cursor position \" + this.pos);\n            this.pos = 0;\n        } else if (this.pos > NR_COLS) {\n            this.logger.log(3, \"Too large cursor position \" + this.pos);\n            this.pos = NR_COLS;\n        }\n    }\n    /**\n   * Move the cursor relative to current position.\n   */ moveCursor(relPos) {\n        const newPos = this.pos + relPos;\n        if (relPos > 1) {\n            for(let i = this.pos + 1; i < newPos + 1; i++){\n                this.chars[i].setPenState(this.currPenState);\n            }\n        }\n        this.setCursor(newPos);\n    }\n    /**\n   * Backspace, move one step back and clear character.\n   */ backSpace() {\n        this.moveCursor(-1);\n        this.chars[this.pos].setChar(\" \", this.currPenState);\n    }\n    insertChar(byte) {\n        if (byte >= 0x90) {\n            // Extended char\n            this.backSpace();\n        }\n        const char = getCharForByte(byte);\n        if (this.pos >= NR_COLS) {\n            this.logger.log(0, ()=>\"Cannot insert \" + byte.toString(16) + \" (\" + char + \") at position \" + this.pos + \". Skipping it!\");\n            return;\n        }\n        this.chars[this.pos].setChar(char, this.currPenState);\n        this.moveCursor(1);\n    }\n    clearFromPos(startPos) {\n        let i;\n        for(i = startPos; i < NR_COLS; i++){\n            this.chars[i].reset();\n        }\n    }\n    clear() {\n        this.clearFromPos(0);\n        this.pos = 0;\n        this.currPenState.reset();\n    }\n    clearToEndOfRow() {\n        this.clearFromPos(this.pos);\n    }\n    getTextString() {\n        const chars = [];\n        let empty = true;\n        for(let i = 0; i < NR_COLS; i++){\n            const char = this.chars[i].uchar;\n            if (char !== \" \") {\n                empty = false;\n            }\n            chars.push(char);\n        }\n        if (empty) {\n            return \"\";\n        } else {\n            return chars.join(\"\");\n        }\n    }\n    setPenStyles(styles) {\n        this.currPenState.setStyles(styles);\n        const currChar = this.chars[this.pos];\n        currChar.setPenState(this.currPenState);\n    }\n}\n/**\n * Keep a CEA-608 screen of 32x15 styled characters\n * @constructor\n */ class CaptionScreen {\n    constructor(logger){\n        this.rows = [];\n        this.currRow = NR_ROWS - 1;\n        this.nrRollUpRows = null;\n        this.lastOutputScreen = null;\n        this.logger = void 0;\n        for(let i = 0; i < NR_ROWS; i++){\n            this.rows.push(new Row(logger));\n        }\n        this.logger = logger;\n    }\n    reset() {\n        for(let i = 0; i < NR_ROWS; i++){\n            this.rows[i].clear();\n        }\n        this.currRow = NR_ROWS - 1;\n    }\n    equals(other) {\n        let equal = true;\n        for(let i = 0; i < NR_ROWS; i++){\n            if (!this.rows[i].equals(other.rows[i])) {\n                equal = false;\n                break;\n            }\n        }\n        return equal;\n    }\n    copy(other) {\n        for(let i = 0; i < NR_ROWS; i++){\n            this.rows[i].copy(other.rows[i]);\n        }\n    }\n    isEmpty() {\n        let empty = true;\n        for(let i = 0; i < NR_ROWS; i++){\n            if (!this.rows[i].isEmpty()) {\n                empty = false;\n                break;\n            }\n        }\n        return empty;\n    }\n    backSpace() {\n        const row = this.rows[this.currRow];\n        row.backSpace();\n    }\n    clearToEndOfRow() {\n        const row = this.rows[this.currRow];\n        row.clearToEndOfRow();\n    }\n    /**\n   * Insert a character (without styling) in the current row.\n   */ insertChar(char) {\n        const row = this.rows[this.currRow];\n        row.insertChar(char);\n    }\n    setPen(styles) {\n        const row = this.rows[this.currRow];\n        row.setPenStyles(styles);\n    }\n    moveCursor(relPos) {\n        const row = this.rows[this.currRow];\n        row.moveCursor(relPos);\n    }\n    setCursor(absPos) {\n        this.logger.log(2, \"setCursor: \" + absPos);\n        const row = this.rows[this.currRow];\n        row.setCursor(absPos);\n    }\n    setPAC(pacData) {\n        this.logger.log(2, ()=>\"pacData = \" + JSON.stringify(pacData));\n        let newRow = pacData.row - 1;\n        if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {\n            newRow = this.nrRollUpRows - 1;\n        }\n        // Make sure this only affects Roll-up Captions by checking this.nrRollUpRows\n        if (this.nrRollUpRows && this.currRow !== newRow) {\n            // clear all rows first\n            for(let i = 0; i < NR_ROWS; i++){\n                this.rows[i].clear();\n            }\n            // Copy this.nrRollUpRows rows from lastOutputScreen and place it in the newRow location\n            // topRowIndex - the start of rows to copy (inclusive index)\n            const topRowIndex = this.currRow + 1 - this.nrRollUpRows;\n            // We only copy if the last position was already shown.\n            // We use the cueStartTime value to check this.\n            const lastOutputScreen = this.lastOutputScreen;\n            if (lastOutputScreen) {\n                const prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;\n                const time = this.logger.time;\n                if (prevLineTime !== null && time !== null && prevLineTime < time) {\n                    for(let i = 0; i < this.nrRollUpRows; i++){\n                        this.rows[newRow - this.nrRollUpRows + i + 1].copy(lastOutputScreen.rows[topRowIndex + i]);\n                    }\n                }\n            }\n        }\n        this.currRow = newRow;\n        const row = this.rows[this.currRow];\n        if (pacData.indent !== null) {\n            const indent = pacData.indent;\n            const prevPos = Math.max(indent - 1, 0);\n            row.setCursor(pacData.indent);\n            pacData.color = row.chars[prevPos].penState.foreground;\n        }\n        const styles = {\n            foreground: pacData.color,\n            underline: pacData.underline,\n            italics: pacData.italics,\n            background: \"black\",\n            flash: false\n        };\n        this.setPen(styles);\n    }\n    /**\n   * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).\n   */ setBkgData(bkgData) {\n        this.logger.log(2, ()=>\"bkgData = \" + JSON.stringify(bkgData));\n        this.backSpace();\n        this.setPen(bkgData);\n        this.insertChar(0x20); // Space\n    }\n    setRollUpRows(nrRows) {\n        this.nrRollUpRows = nrRows;\n    }\n    rollUp() {\n        if (this.nrRollUpRows === null) {\n            this.logger.log(3, \"roll_up but nrRollUpRows not set yet\");\n            return; // Not properly setup\n        }\n        this.logger.log(1, ()=>this.getDisplayText());\n        const topRowIndex = this.currRow + 1 - this.nrRollUpRows;\n        const topRow = this.rows.splice(topRowIndex, 1)[0];\n        topRow.clear();\n        this.rows.splice(this.currRow, 0, topRow);\n        this.logger.log(2, \"Rolling up\");\n    // this.logger.log(VerboseLevel.TEXT, this.get_display_text())\n    }\n    /**\n   * Get all non-empty rows with as unicode text.\n   */ getDisplayText(asOneRow) {\n        asOneRow = asOneRow || false;\n        const displayText = [];\n        let text = \"\";\n        let rowNr = -1;\n        for(let i = 0; i < NR_ROWS; i++){\n            const rowText = this.rows[i].getTextString();\n            if (rowText) {\n                rowNr = i + 1;\n                if (asOneRow) {\n                    displayText.push(\"Row \" + rowNr + \": '\" + rowText + \"'\");\n                } else {\n                    displayText.push(rowText.trim());\n                }\n            }\n        }\n        if (displayText.length > 0) {\n            if (asOneRow) {\n                text = \"[\" + displayText.join(\" | \") + \"]\";\n            } else {\n                text = displayText.join(\"\\n\");\n            }\n        }\n        return text;\n    }\n    getTextAndFormat() {\n        return this.rows;\n    }\n}\n// var modes = ['MODE_ROLL-UP', 'MODE_POP-ON', 'MODE_PAINT-ON', 'MODE_TEXT'];\nclass Cea608Channel {\n    constructor(channelNumber, outputFilter, logger){\n        this.chNr = void 0;\n        this.outputFilter = void 0;\n        this.mode = void 0;\n        this.verbose = void 0;\n        this.displayedMemory = void 0;\n        this.nonDisplayedMemory = void 0;\n        this.lastOutputScreen = void 0;\n        this.currRollUpRow = void 0;\n        this.writeScreen = void 0;\n        this.cueStartTime = void 0;\n        this.logger = void 0;\n        this.chNr = channelNumber;\n        this.outputFilter = outputFilter;\n        this.mode = null;\n        this.verbose = 0;\n        this.displayedMemory = new CaptionScreen(logger);\n        this.nonDisplayedMemory = new CaptionScreen(logger);\n        this.lastOutputScreen = new CaptionScreen(logger);\n        this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];\n        this.writeScreen = this.displayedMemory;\n        this.mode = null;\n        this.cueStartTime = null; // Keeps track of where a cue started.\n        this.logger = logger;\n    }\n    reset() {\n        this.mode = null;\n        this.displayedMemory.reset();\n        this.nonDisplayedMemory.reset();\n        this.lastOutputScreen.reset();\n        this.outputFilter.reset();\n        this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];\n        this.writeScreen = this.displayedMemory;\n        this.mode = null;\n        this.cueStartTime = null;\n    }\n    getHandler() {\n        return this.outputFilter;\n    }\n    setHandler(newHandler) {\n        this.outputFilter = newHandler;\n    }\n    setPAC(pacData) {\n        this.writeScreen.setPAC(pacData);\n    }\n    setBkgData(bkgData) {\n        this.writeScreen.setBkgData(bkgData);\n    }\n    setMode(newMode) {\n        if (newMode === this.mode) {\n            return;\n        }\n        this.mode = newMode;\n        this.logger.log(2, ()=>\"MODE=\" + newMode);\n        if (this.mode === \"MODE_POP-ON\") {\n            this.writeScreen = this.nonDisplayedMemory;\n        } else {\n            this.writeScreen = this.displayedMemory;\n            this.writeScreen.reset();\n        }\n        if (this.mode !== \"MODE_ROLL-UP\") {\n            this.displayedMemory.nrRollUpRows = null;\n            this.nonDisplayedMemory.nrRollUpRows = null;\n        }\n        this.mode = newMode;\n    }\n    insertChars(chars) {\n        for(let i = 0; i < chars.length; i++){\n            this.writeScreen.insertChar(chars[i]);\n        }\n        const screen = this.writeScreen === this.displayedMemory ? \"DISP\" : \"NON_DISP\";\n        this.logger.log(2, ()=>screen + \": \" + this.writeScreen.getDisplayText(true));\n        if (this.mode === \"MODE_PAINT-ON\" || this.mode === \"MODE_ROLL-UP\") {\n            this.logger.log(1, ()=>\"DISPLAYED: \" + this.displayedMemory.getDisplayText(true));\n            this.outputDataUpdate();\n        }\n    }\n    ccRCL() {\n        // Resume Caption Loading (switch mode to Pop On)\n        this.logger.log(2, \"RCL - Resume Caption Loading\");\n        this.setMode(\"MODE_POP-ON\");\n    }\n    ccBS() {\n        // BackSpace\n        this.logger.log(2, \"BS - BackSpace\");\n        if (this.mode === \"MODE_TEXT\") {\n            return;\n        }\n        this.writeScreen.backSpace();\n        if (this.writeScreen === this.displayedMemory) {\n            this.outputDataUpdate();\n        }\n    }\n    ccAOF() {\n    // Reserved (formerly Alarm Off)\n    }\n    ccAON() {\n    // Reserved (formerly Alarm On)\n    }\n    ccDER() {\n        // Delete to End of Row\n        this.logger.log(2, \"DER- Delete to End of Row\");\n        this.writeScreen.clearToEndOfRow();\n        this.outputDataUpdate();\n    }\n    ccRU(nrRows) {\n        // Roll-Up Captions-2,3,or 4 Rows\n        this.logger.log(2, \"RU(\" + nrRows + \") - Roll Up\");\n        this.writeScreen = this.displayedMemory;\n        this.setMode(\"MODE_ROLL-UP\");\n        this.writeScreen.setRollUpRows(nrRows);\n    }\n    ccFON() {\n        // Flash On\n        this.logger.log(2, \"FON - Flash On\");\n        this.writeScreen.setPen({\n            flash: true\n        });\n    }\n    ccRDC() {\n        // Resume Direct Captioning (switch mode to PaintOn)\n        this.logger.log(2, \"RDC - Resume Direct Captioning\");\n        this.setMode(\"MODE_PAINT-ON\");\n    }\n    ccTR() {\n        // Text Restart in text mode (not supported, however)\n        this.logger.log(2, \"TR\");\n        this.setMode(\"MODE_TEXT\");\n    }\n    ccRTD() {\n        // Resume Text Display in Text mode (not supported, however)\n        this.logger.log(2, \"RTD\");\n        this.setMode(\"MODE_TEXT\");\n    }\n    ccEDM() {\n        // Erase Displayed Memory\n        this.logger.log(2, \"EDM - Erase Displayed Memory\");\n        this.displayedMemory.reset();\n        this.outputDataUpdate(true);\n    }\n    ccCR() {\n        // Carriage Return\n        this.logger.log(2, \"CR - Carriage Return\");\n        this.writeScreen.rollUp();\n        this.outputDataUpdate(true);\n    }\n    ccENM() {\n        // Erase Non-Displayed Memory\n        this.logger.log(2, \"ENM - Erase Non-displayed Memory\");\n        this.nonDisplayedMemory.reset();\n    }\n    ccEOC() {\n        // End of Caption (Flip Memories)\n        this.logger.log(2, \"EOC - End Of Caption\");\n        if (this.mode === \"MODE_POP-ON\") {\n            const tmp = this.displayedMemory;\n            this.displayedMemory = this.nonDisplayedMemory;\n            this.nonDisplayedMemory = tmp;\n            this.writeScreen = this.nonDisplayedMemory;\n            this.logger.log(1, ()=>\"DISP: \" + this.displayedMemory.getDisplayText());\n        }\n        this.outputDataUpdate(true);\n    }\n    ccTO(nrCols) {\n        // Tab Offset 1,2, or 3 columns\n        this.logger.log(2, \"TO(\" + nrCols + \") - Tab Offset\");\n        this.writeScreen.moveCursor(nrCols);\n    }\n    ccMIDROW(secondByte) {\n        // Parse MIDROW command\n        const styles = {\n            flash: false\n        };\n        styles.underline = secondByte % 2 === 1;\n        styles.italics = secondByte >= 0x2e;\n        if (!styles.italics) {\n            const colorIndex = Math.floor(secondByte / 2) - 0x10;\n            const colors = [\n                \"white\",\n                \"green\",\n                \"blue\",\n                \"cyan\",\n                \"red\",\n                \"yellow\",\n                \"magenta\"\n            ];\n            styles.foreground = colors[colorIndex];\n        } else {\n            styles.foreground = \"white\";\n        }\n        this.logger.log(2, \"MIDROW: \" + JSON.stringify(styles));\n        this.writeScreen.setPen(styles);\n    }\n    outputDataUpdate(dispatch = false) {\n        const time = this.logger.time;\n        if (time === null) {\n            return;\n        }\n        if (this.outputFilter) {\n            if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {\n                // Start of a new cue\n                this.cueStartTime = time;\n            } else {\n                if (!this.displayedMemory.equals(this.lastOutputScreen)) {\n                    this.outputFilter.newCue(this.cueStartTime, time, this.lastOutputScreen);\n                    if (dispatch && this.outputFilter.dispatchCue) {\n                        this.outputFilter.dispatchCue();\n                    }\n                    this.cueStartTime = this.displayedMemory.isEmpty() ? null : time;\n                }\n            }\n            this.lastOutputScreen.copy(this.displayedMemory);\n        }\n    }\n    cueSplitAtTime(t) {\n        if (this.outputFilter) {\n            if (!this.displayedMemory.isEmpty()) {\n                if (this.outputFilter.newCue) {\n                    this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);\n                }\n                this.cueStartTime = t;\n            }\n        }\n    }\n}\n// Will be 1 or 2 when parsing captions\nclass Cea608Parser {\n    constructor(field, out1, out2){\n        this.channels = void 0;\n        this.currentChannel = 0;\n        this.cmdHistory = createCmdHistory();\n        this.logger = void 0;\n        const logger = this.logger = new CaptionsLogger();\n        this.channels = [\n            null,\n            new Cea608Channel(field, out1, logger),\n            new Cea608Channel(field + 1, out2, logger)\n        ];\n    }\n    getHandler(channel) {\n        return this.channels[channel].getHandler();\n    }\n    setHandler(channel, newHandler) {\n        this.channels[channel].setHandler(newHandler);\n    }\n    /**\n   * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.\n   */ addData(time, byteList) {\n        let cmdFound;\n        let a;\n        let b;\n        let charsFound = false;\n        this.logger.time = time;\n        for(let i = 0; i < byteList.length; i += 2){\n            a = byteList[i] & 0x7f;\n            b = byteList[i + 1] & 0x7f;\n            if (a === 0 && b === 0) {\n                continue;\n            } else {\n                this.logger.log(3, \"[\" + numArrayToHexArray([\n                    byteList[i],\n                    byteList[i + 1]\n                ]) + \"] -> (\" + numArrayToHexArray([\n                    a,\n                    b\n                ]) + \")\");\n            }\n            cmdFound = this.parseCmd(a, b);\n            if (!cmdFound) {\n                cmdFound = this.parseMidrow(a, b);\n            }\n            if (!cmdFound) {\n                cmdFound = this.parsePAC(a, b);\n            }\n            if (!cmdFound) {\n                cmdFound = this.parseBackgroundAttributes(a, b);\n            }\n            if (!cmdFound) {\n                charsFound = this.parseChars(a, b);\n                if (charsFound) {\n                    const currChNr = this.currentChannel;\n                    if (currChNr && currChNr > 0) {\n                        const channel = this.channels[currChNr];\n                        channel.insertChars(charsFound);\n                    } else {\n                        this.logger.log(2, \"No channel found yet. TEXT-MODE?\");\n                    }\n                }\n            }\n            if (!cmdFound && !charsFound) {\n                this.logger.log(2, \"Couldn't parse cleaned data \" + numArrayToHexArray([\n                    a,\n                    b\n                ]) + \" orig: \" + numArrayToHexArray([\n                    byteList[i],\n                    byteList[i + 1]\n                ]));\n            }\n        }\n    }\n    /**\n   * Parse Command.\n   * @returns True if a command was found\n   */ parseCmd(a, b) {\n        const { cmdHistory } = this;\n        const cond1 = (a === 0x14 || a === 0x1c || a === 0x15 || a === 0x1d) && b >= 0x20 && b <= 0x2f;\n        const cond2 = (a === 0x17 || a === 0x1f) && b >= 0x21 && b <= 0x23;\n        if (!(cond1 || cond2)) {\n            return false;\n        }\n        if (hasCmdRepeated(a, b, cmdHistory)) {\n            setLastCmd(null, null, cmdHistory);\n            this.logger.log(3, \"Repeated command (\" + numArrayToHexArray([\n                a,\n                b\n            ]) + \") is dropped\");\n            return true;\n        }\n        const chNr = a === 0x14 || a === 0x15 || a === 0x17 ? 1 : 2;\n        const channel = this.channels[chNr];\n        if (a === 0x14 || a === 0x15 || a === 0x1c || a === 0x1d) {\n            if (b === 0x20) {\n                channel.ccRCL();\n            } else if (b === 0x21) {\n                channel.ccBS();\n            } else if (b === 0x22) {\n                channel.ccAOF();\n            } else if (b === 0x23) {\n                channel.ccAON();\n            } else if (b === 0x24) {\n                channel.ccDER();\n            } else if (b === 0x25) {\n                channel.ccRU(2);\n            } else if (b === 0x26) {\n                channel.ccRU(3);\n            } else if (b === 0x27) {\n                channel.ccRU(4);\n            } else if (b === 0x28) {\n                channel.ccFON();\n            } else if (b === 0x29) {\n                channel.ccRDC();\n            } else if (b === 0x2a) {\n                channel.ccTR();\n            } else if (b === 0x2b) {\n                channel.ccRTD();\n            } else if (b === 0x2c) {\n                channel.ccEDM();\n            } else if (b === 0x2d) {\n                channel.ccCR();\n            } else if (b === 0x2e) {\n                channel.ccENM();\n            } else if (b === 0x2f) {\n                channel.ccEOC();\n            }\n        } else {\n            // a == 0x17 || a == 0x1F\n            channel.ccTO(b - 0x20);\n        }\n        setLastCmd(a, b, cmdHistory);\n        this.currentChannel = chNr;\n        return true;\n    }\n    /**\n   * Parse midrow styling command\n   */ parseMidrow(a, b) {\n        let chNr = 0;\n        if ((a === 0x11 || a === 0x19) && b >= 0x20 && b <= 0x2f) {\n            if (a === 0x11) {\n                chNr = 1;\n            } else {\n                chNr = 2;\n            }\n            if (chNr !== this.currentChannel) {\n                this.logger.log(0, \"Mismatch channel in midrow parsing\");\n                return false;\n            }\n            const channel = this.channels[chNr];\n            if (!channel) {\n                return false;\n            }\n            channel.ccMIDROW(b);\n            this.logger.log(3, \"MIDROW (\" + numArrayToHexArray([\n                a,\n                b\n            ]) + \")\");\n            return true;\n        }\n        return false;\n    }\n    /**\n   * Parse Preable Access Codes (Table 53).\n   * @returns {Boolean} Tells if PAC found\n   */ parsePAC(a, b) {\n        let row;\n        const cmdHistory = this.cmdHistory;\n        const case1 = (a >= 0x11 && a <= 0x17 || a >= 0x19 && a <= 0x1f) && b >= 0x40 && b <= 0x7f;\n        const case2 = (a === 0x10 || a === 0x18) && b >= 0x40 && b <= 0x5f;\n        if (!(case1 || case2)) {\n            return false;\n        }\n        if (hasCmdRepeated(a, b, cmdHistory)) {\n            setLastCmd(null, null, cmdHistory);\n            return true; // Repeated commands are dropped (once)\n        }\n        const chNr = a <= 0x17 ? 1 : 2;\n        if (b >= 0x40 && b <= 0x5f) {\n            row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];\n        } else {\n            // 0x60 <= b <= 0x7F\n            row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];\n        }\n        const channel = this.channels[chNr];\n        if (!channel) {\n            return false;\n        }\n        channel.setPAC(this.interpretPAC(row, b));\n        setLastCmd(a, b, cmdHistory);\n        this.currentChannel = chNr;\n        return true;\n    }\n    /**\n   * Interpret the second byte of the pac, and return the information.\n   * @returns pacData with style parameters\n   */ interpretPAC(row, byte) {\n        let pacIndex;\n        const pacData = {\n            color: null,\n            italics: false,\n            indent: null,\n            underline: false,\n            row: row\n        };\n        if (byte > 0x5f) {\n            pacIndex = byte - 0x60;\n        } else {\n            pacIndex = byte - 0x40;\n        }\n        pacData.underline = (pacIndex & 1) === 1;\n        if (pacIndex <= 0xd) {\n            pacData.color = [\n                \"white\",\n                \"green\",\n                \"blue\",\n                \"cyan\",\n                \"red\",\n                \"yellow\",\n                \"magenta\",\n                \"white\"\n            ][Math.floor(pacIndex / 2)];\n        } else if (pacIndex <= 0xf) {\n            pacData.italics = true;\n            pacData.color = \"white\";\n        } else {\n            pacData.indent = Math.floor((pacIndex - 0x10) / 2) * 4;\n        }\n        return pacData; // Note that row has zero offset. The spec uses 1.\n    }\n    /**\n   * Parse characters.\n   * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.\n   */ parseChars(a, b) {\n        let channelNr;\n        let charCodes = null;\n        let charCode1 = null;\n        if (a >= 0x19) {\n            channelNr = 2;\n            charCode1 = a - 8;\n        } else {\n            channelNr = 1;\n            charCode1 = a;\n        }\n        if (charCode1 >= 0x11 && charCode1 <= 0x13) {\n            // Special character\n            let oneCode;\n            if (charCode1 === 0x11) {\n                oneCode = b + 0x50;\n            } else if (charCode1 === 0x12) {\n                oneCode = b + 0x70;\n            } else {\n                oneCode = b + 0x90;\n            }\n            this.logger.log(2, \"Special char '\" + getCharForByte(oneCode) + \"' in channel \" + channelNr);\n            charCodes = [\n                oneCode\n            ];\n        } else if (a >= 0x20 && a <= 0x7f) {\n            charCodes = b === 0 ? [\n                a\n            ] : [\n                a,\n                b\n            ];\n        }\n        if (charCodes) {\n            const hexCodes = numArrayToHexArray(charCodes);\n            this.logger.log(3, \"Char codes =  \" + hexCodes.join(\",\"));\n            setLastCmd(a, b, this.cmdHistory);\n        }\n        return charCodes;\n    }\n    /**\n   * Parse extended background attributes as well as new foreground color black.\n   * @returns True if background attributes are found\n   */ parseBackgroundAttributes(a, b) {\n        const case1 = (a === 0x10 || a === 0x18) && b >= 0x20 && b <= 0x2f;\n        const case2 = (a === 0x17 || a === 0x1f) && b >= 0x2d && b <= 0x2f;\n        if (!(case1 || case2)) {\n            return false;\n        }\n        let index;\n        const bkgData = {};\n        if (a === 0x10 || a === 0x18) {\n            index = Math.floor((b - 0x20) / 2);\n            bkgData.background = backgroundColors[index];\n            if (b % 2 === 1) {\n                bkgData.background = bkgData.background + \"_semi\";\n            }\n        } else if (b === 0x2d) {\n            bkgData.background = \"transparent\";\n        } else {\n            bkgData.foreground = \"black\";\n            if (b === 0x2f) {\n                bkgData.underline = true;\n            }\n        }\n        const chNr = a <= 0x17 ? 1 : 2;\n        const channel = this.channels[chNr];\n        channel.setBkgData(bkgData);\n        setLastCmd(a, b, this.cmdHistory);\n        return true;\n    }\n    /**\n   * Reset state of parser and its channels.\n   */ reset() {\n        for(let i = 0; i < Object.keys(this.channels).length; i++){\n            const channel = this.channels[i];\n            if (channel) {\n                channel.reset();\n            }\n        }\n        this.cmdHistory = createCmdHistory();\n    }\n    /**\n   * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.\n   */ cueSplitAtTime(t) {\n        for(let i = 0; i < this.channels.length; i++){\n            const channel = this.channels[i];\n            if (channel) {\n                channel.cueSplitAtTime(t);\n            }\n        }\n    }\n}\nfunction setLastCmd(a, b, cmdHistory) {\n    cmdHistory.a = a;\n    cmdHistory.b = b;\n}\nfunction hasCmdRepeated(a, b, cmdHistory) {\n    return cmdHistory.a === a && cmdHistory.b === b;\n}\nfunction createCmdHistory() {\n    return {\n        a: null,\n        b: null\n    };\n}\nclass OutputFilter {\n    constructor(timelineController, trackName){\n        this.timelineController = void 0;\n        this.cueRanges = [];\n        this.trackName = void 0;\n        this.startTime = null;\n        this.endTime = null;\n        this.screen = null;\n        this.timelineController = timelineController;\n        this.trackName = trackName;\n    }\n    dispatchCue() {\n        if (this.startTime === null) {\n            return;\n        }\n        this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges);\n        this.startTime = null;\n    }\n    newCue(startTime, endTime, screen) {\n        if (this.startTime === null || this.startTime > startTime) {\n            this.startTime = startTime;\n        }\n        this.endTime = endTime;\n        this.screen = screen;\n        this.timelineController.createCaptionsTrack(this.trackName);\n    }\n    reset() {\n        this.cueRanges = [];\n        this.startTime = null;\n    }\n}\n/**\n * Copyright 2013 vtt.js Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var VTTCue = function() {\n    if (optionalSelf != null && optionalSelf.VTTCue) {\n        return self.VTTCue;\n    }\n    const AllowedDirections = [\n        \"\",\n        \"lr\",\n        \"rl\"\n    ];\n    const AllowedAlignments = [\n        \"start\",\n        \"middle\",\n        \"end\",\n        \"left\",\n        \"right\"\n    ];\n    function isAllowedValue(allowed, value) {\n        if (typeof value !== \"string\") {\n            return false;\n        }\n        // necessary for assuring the generic conforms to the Array interface\n        if (!Array.isArray(allowed)) {\n            return false;\n        }\n        // reset the type so that the next narrowing works well\n        const lcValue = value.toLowerCase();\n        // use the allow list to narrow the type to a specific subset of strings\n        if (~allowed.indexOf(lcValue)) {\n            return lcValue;\n        }\n        return false;\n    }\n    function findDirectionSetting(value) {\n        return isAllowedValue(AllowedDirections, value);\n    }\n    function findAlignSetting(value) {\n        return isAllowedValue(AllowedAlignments, value);\n    }\n    function extend(obj, ...rest) {\n        let i = 1;\n        for(; i < arguments.length; i++){\n            const cobj = arguments[i];\n            for(const p in cobj){\n                obj[p] = cobj[p];\n            }\n        }\n        return obj;\n    }\n    function VTTCue(startTime, endTime, text) {\n        const cue = this;\n        const baseObj = {\n            enumerable: true\n        };\n        /**\n     * Shim implementation specific properties. These properties are not in\n     * the spec.\n     */ // Lets us know when the VTTCue's data has changed in such a way that we need\n        // to recompute its display state. This lets us compute its display state\n        // lazily.\n        cue.hasBeenReset = false;\n        /**\n     * VTTCue and TextTrackCue properties\n     * http://dev.w3.org/html5/webvtt/#vttcue-interface\n     */ let _id = \"\";\n        let _pauseOnExit = false;\n        let _startTime = startTime;\n        let _endTime = endTime;\n        let _text = text;\n        let _region = null;\n        let _vertical = \"\";\n        let _snapToLines = true;\n        let _line = \"auto\";\n        let _lineAlign = \"start\";\n        let _position = 50;\n        let _positionAlign = \"middle\";\n        let _size = 50;\n        let _align = \"middle\";\n        Object.defineProperty(cue, \"id\", extend({}, baseObj, {\n            get: function() {\n                return _id;\n            },\n            set: function(value) {\n                _id = \"\" + value;\n            }\n        }));\n        Object.defineProperty(cue, \"pauseOnExit\", extend({}, baseObj, {\n            get: function() {\n                return _pauseOnExit;\n            },\n            set: function(value) {\n                _pauseOnExit = !!value;\n            }\n        }));\n        Object.defineProperty(cue, \"startTime\", extend({}, baseObj, {\n            get: function() {\n                return _startTime;\n            },\n            set: function(value) {\n                if (typeof value !== \"number\") {\n                    throw new TypeError(\"Start time must be set to a number.\");\n                }\n                _startTime = value;\n                this.hasBeenReset = true;\n            }\n        }));\n        Object.defineProperty(cue, \"endTime\", extend({}, baseObj, {\n            get: function() {\n                return _endTime;\n            },\n            set: function(value) {\n                if (typeof value !== \"number\") {\n                    throw new TypeError(\"End time must be set to a number.\");\n                }\n                _endTime = value;\n                this.hasBeenReset = true;\n            }\n        }));\n        Object.defineProperty(cue, \"text\", extend({}, baseObj, {\n            get: function() {\n                return _text;\n            },\n            set: function(value) {\n                _text = \"\" + value;\n                this.hasBeenReset = true;\n            }\n        }));\n        // todo: implement VTTRegion polyfill?\n        Object.defineProperty(cue, \"region\", extend({}, baseObj, {\n            get: function() {\n                return _region;\n            },\n            set: function(value) {\n                _region = value;\n                this.hasBeenReset = true;\n            }\n        }));\n        Object.defineProperty(cue, \"vertical\", extend({}, baseObj, {\n            get: function() {\n                return _vertical;\n            },\n            set: function(value) {\n                const setting = findDirectionSetting(value);\n                // Have to check for false because the setting an be an empty string.\n                if (setting === false) {\n                    throw new SyntaxError(\"An invalid or illegal string was specified.\");\n                }\n                _vertical = setting;\n                this.hasBeenReset = true;\n            }\n        }));\n        Object.defineProperty(cue, \"snapToLines\", extend({}, baseObj, {\n            get: function() {\n                return _snapToLines;\n            },\n            set: function(value) {\n                _snapToLines = !!value;\n                this.hasBeenReset = true;\n            }\n        }));\n        Object.defineProperty(cue, \"line\", extend({}, baseObj, {\n            get: function() {\n                return _line;\n            },\n            set: function(value) {\n                if (typeof value !== \"number\" && value !== \"auto\") {\n                    throw new SyntaxError(\"An invalid number or illegal string was specified.\");\n                }\n                _line = value;\n                this.hasBeenReset = true;\n            }\n        }));\n        Object.defineProperty(cue, \"lineAlign\", extend({}, baseObj, {\n            get: function() {\n                return _lineAlign;\n            },\n            set: function(value) {\n                const setting = findAlignSetting(value);\n                if (!setting) {\n                    throw new SyntaxError(\"An invalid or illegal string was specified.\");\n                }\n                _lineAlign = setting;\n                this.hasBeenReset = true;\n            }\n        }));\n        Object.defineProperty(cue, \"position\", extend({}, baseObj, {\n            get: function() {\n                return _position;\n            },\n            set: function(value) {\n                if (value < 0 || value > 100) {\n                    throw new Error(\"Position must be between 0 and 100.\");\n                }\n                _position = value;\n                this.hasBeenReset = true;\n            }\n        }));\n        Object.defineProperty(cue, \"positionAlign\", extend({}, baseObj, {\n            get: function() {\n                return _positionAlign;\n            },\n            set: function(value) {\n                const setting = findAlignSetting(value);\n                if (!setting) {\n                    throw new SyntaxError(\"An invalid or illegal string was specified.\");\n                }\n                _positionAlign = setting;\n                this.hasBeenReset = true;\n            }\n        }));\n        Object.defineProperty(cue, \"size\", extend({}, baseObj, {\n            get: function() {\n                return _size;\n            },\n            set: function(value) {\n                if (value < 0 || value > 100) {\n                    throw new Error(\"Size must be between 0 and 100.\");\n                }\n                _size = value;\n                this.hasBeenReset = true;\n            }\n        }));\n        Object.defineProperty(cue, \"align\", extend({}, baseObj, {\n            get: function() {\n                return _align;\n            },\n            set: function(value) {\n                const setting = findAlignSetting(value);\n                if (!setting) {\n                    throw new SyntaxError(\"An invalid or illegal string was specified.\");\n                }\n                _align = setting;\n                this.hasBeenReset = true;\n            }\n        }));\n        /**\n     * Other <track> spec defined properties\n     */ // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state\n        cue.displayState = undefined;\n    }\n    /**\n   * VTTCue methods\n   */ VTTCue.prototype.getCueAsHTML = function() {\n        // Assume WebVTT.convertCueToDOMTree is on the global.\n        const WebVTT = self.WebVTT;\n        return WebVTT.convertCueToDOMTree(self, this.text);\n    };\n    // this is a polyfill hack\n    return VTTCue;\n}();\n/*\n * Source: https://github.com/mozilla/vtt.js/blob/master/dist/vtt.js\n */ class StringDecoder {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    decode(data, options) {\n        if (!data) {\n            return \"\";\n        }\n        if (typeof data !== \"string\") {\n            throw new Error(\"Error - expected string data.\");\n        }\n        return decodeURIComponent(encodeURIComponent(data));\n    }\n}\n// Try to parse input as a time stamp.\nfunction parseTimeStamp(input) {\n    function computeSeconds(h, m, s, f) {\n        return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + parseFloat(f || 0);\n    }\n    const m = input.match(/^(?:(\\d+):)?(\\d{2}):(\\d{2})(\\.\\d+)?/);\n    if (!m) {\n        return null;\n    }\n    if (parseFloat(m[2]) > 59) {\n        // Timestamp takes the form of [hours]:[minutes].[milliseconds]\n        // First position is hours as it's over 59.\n        return computeSeconds(m[2], m[3], 0, m[4]);\n    }\n    // Timestamp takes the form of [hours (optional)]:[minutes]:[seconds].[milliseconds]\n    return computeSeconds(m[1], m[2], m[3], m[4]);\n}\n// A settings object holds key/value pairs and will ignore anything but the first\n// assignment to a specific key.\nclass Settings {\n    constructor(){\n        this.values = Object.create(null);\n    }\n    // Only accept the first assignment to any key.\n    set(k, v) {\n        if (!this.get(k) && v !== \"\") {\n            this.values[k] = v;\n        }\n    }\n    // Return the value for a key, or a default value.\n    // If 'defaultKey' is passed then 'dflt' is assumed to be an object with\n    // a number of possible default values as properties where 'defaultKey' is\n    // the key of the property that will be chosen; otherwise it's assumed to be\n    // a single value.\n    get(k, dflt, defaultKey) {\n        if (defaultKey) {\n            return this.has(k) ? this.values[k] : dflt[defaultKey];\n        }\n        return this.has(k) ? this.values[k] : dflt;\n    }\n    // Check whether we have a value for a key.\n    has(k) {\n        return k in this.values;\n    }\n    // Accept a setting if its one of the given alternatives.\n    alt(k, v, a) {\n        for(let n = 0; n < a.length; ++n){\n            if (v === a[n]) {\n                this.set(k, v);\n                break;\n            }\n        }\n    }\n    // Accept a setting if its a valid (signed) integer.\n    integer(k, v) {\n        if (/^-?\\d+$/.test(v)) {\n            // integer\n            this.set(k, parseInt(v, 10));\n        }\n    }\n    // Accept a setting if its a valid percentage.\n    percent(k, v) {\n        if (/^([\\d]{1,3})(\\.[\\d]*)?%$/.test(v)) {\n            const percent = parseFloat(v);\n            if (percent >= 0 && percent <= 100) {\n                this.set(k, percent);\n                return true;\n            }\n        }\n        return false;\n    }\n}\n// Helper function to parse input into groups separated by 'groupDelim', and\n// interpret each group as a key/value pair separated by 'keyValueDelim'.\nfunction parseOptions(input, callback, keyValueDelim, groupDelim) {\n    const groups = groupDelim ? input.split(groupDelim) : [\n        input\n    ];\n    for(const i in groups){\n        if (typeof groups[i] !== \"string\") {\n            continue;\n        }\n        const kv = groups[i].split(keyValueDelim);\n        if (kv.length !== 2) {\n            continue;\n        }\n        const k = kv[0];\n        const v = kv[1];\n        callback(k, v);\n    }\n}\nconst defaults = new VTTCue(0, 0, \"\");\n// 'middle' was changed to 'center' in the spec: https://github.com/w3c/webvtt/pull/244\n//  Safari doesn't yet support this change, but FF and Chrome do.\nconst center = defaults.align === \"middle\" ? \"middle\" : \"center\";\nfunction parseCue(input, cue, regionList) {\n    // Remember the original input if we need to throw an error.\n    const oInput = input;\n    // 4.1 WebVTT timestamp\n    function consumeTimeStamp() {\n        const ts = parseTimeStamp(input);\n        if (ts === null) {\n            throw new Error(\"Malformed timestamp: \" + oInput);\n        }\n        // Remove time stamp from input.\n        input = input.replace(/^[^\\sa-zA-Z-]+/, \"\");\n        return ts;\n    }\n    // 4.4.2 WebVTT cue settings\n    function consumeCueSettings(input, cue) {\n        const settings = new Settings();\n        parseOptions(input, function(k, v) {\n            let vals;\n            switch(k){\n                case \"region\":\n                    // Find the last region we parsed with the same region id.\n                    for(let i = regionList.length - 1; i >= 0; i--){\n                        if (regionList[i].id === v) {\n                            settings.set(k, regionList[i].region);\n                            break;\n                        }\n                    }\n                    break;\n                case \"vertical\":\n                    settings.alt(k, v, [\n                        \"rl\",\n                        \"lr\"\n                    ]);\n                    break;\n                case \"line\":\n                    vals = v.split(\",\");\n                    settings.integer(k, vals[0]);\n                    if (settings.percent(k, vals[0])) {\n                        settings.set(\"snapToLines\", false);\n                    }\n                    settings.alt(k, vals[0], [\n                        \"auto\"\n                    ]);\n                    if (vals.length === 2) {\n                        settings.alt(\"lineAlign\", vals[1], [\n                            \"start\",\n                            center,\n                            \"end\"\n                        ]);\n                    }\n                    break;\n                case \"position\":\n                    vals = v.split(\",\");\n                    settings.percent(k, vals[0]);\n                    if (vals.length === 2) {\n                        settings.alt(\"positionAlign\", vals[1], [\n                            \"start\",\n                            center,\n                            \"end\",\n                            \"line-left\",\n                            \"line-right\",\n                            \"auto\"\n                        ]);\n                    }\n                    break;\n                case \"size\":\n                    settings.percent(k, v);\n                    break;\n                case \"align\":\n                    settings.alt(k, v, [\n                        \"start\",\n                        center,\n                        \"end\",\n                        \"left\",\n                        \"right\"\n                    ]);\n                    break;\n            }\n        }, /:/, /\\s/);\n        // Apply default values for any missing fields.\n        cue.region = settings.get(\"region\", null);\n        cue.vertical = settings.get(\"vertical\", \"\");\n        let line = settings.get(\"line\", \"auto\");\n        if (line === \"auto\" && defaults.line === -1) {\n            // set numeric line number for Safari\n            line = -1;\n        }\n        cue.line = line;\n        cue.lineAlign = settings.get(\"lineAlign\", \"start\");\n        cue.snapToLines = settings.get(\"snapToLines\", true);\n        cue.size = settings.get(\"size\", 100);\n        cue.align = settings.get(\"align\", center);\n        let position = settings.get(\"position\", \"auto\");\n        if (position === \"auto\" && defaults.position === 50) {\n            // set numeric position for Safari\n            position = cue.align === \"start\" || cue.align === \"left\" ? 0 : cue.align === \"end\" || cue.align === \"right\" ? 100 : 50;\n        }\n        cue.position = position;\n    }\n    function skipWhitespace() {\n        input = input.replace(/^\\s+/, \"\");\n    }\n    // 4.1 WebVTT cue timings.\n    skipWhitespace();\n    cue.startTime = consumeTimeStamp(); // (1) collect cue start time\n    skipWhitespace();\n    if (input.slice(0, 3) !== \"-->\") {\n        // (3) next characters must match '-->'\n        throw new Error(\"Malformed time stamp (time stamps must be separated by '-->'): \" + oInput);\n    }\n    input = input.slice(3);\n    skipWhitespace();\n    cue.endTime = consumeTimeStamp(); // (5) collect cue end time\n    // 4.1 WebVTT cue settings list.\n    skipWhitespace();\n    consumeCueSettings(input, cue);\n}\nfunction fixLineBreaks(input) {\n    return input.replace(/<br(?: \\/)?>/gi, \"\\n\");\n}\nclass VTTParser {\n    constructor(){\n        this.state = \"INITIAL\";\n        this.buffer = \"\";\n        this.decoder = new StringDecoder();\n        this.regionList = [];\n        this.cue = null;\n        this.oncue = void 0;\n        this.onparsingerror = void 0;\n        this.onflush = void 0;\n    }\n    parse(data) {\n        const _this = this;\n        // If there is no data then we won't decode it, but will just try to parse\n        // whatever is in buffer already. This may occur in circumstances, for\n        // example when flush() is called.\n        if (data) {\n            // Try to decode the data that we received.\n            _this.buffer += _this.decoder.decode(data, {\n                stream: true\n            });\n        }\n        function collectNextLine() {\n            let buffer = _this.buffer;\n            let pos = 0;\n            buffer = fixLineBreaks(buffer);\n            while(pos < buffer.length && buffer[pos] !== \"\\r\" && buffer[pos] !== \"\\n\"){\n                ++pos;\n            }\n            const line = buffer.slice(0, pos);\n            // Advance the buffer early in case we fail below.\n            if (buffer[pos] === \"\\r\") {\n                ++pos;\n            }\n            if (buffer[pos] === \"\\n\") {\n                ++pos;\n            }\n            _this.buffer = buffer.slice(pos);\n            return line;\n        }\n        // 3.2 WebVTT metadata header syntax\n        function parseHeader(input) {\n            parseOptions(input, function(k, v) {\n            // switch (k) {\n            // case 'region':\n            // 3.3 WebVTT region metadata header syntax\n            // console.log('parse region', v);\n            // parseRegion(v);\n            // break;\n            // }\n            }, /:/);\n        }\n        // 5.1 WebVTT file parsing.\n        try {\n            let line = \"\";\n            if (_this.state === \"INITIAL\") {\n                // We can't start parsing until we have the first line.\n                if (!/\\r\\n|\\n/.test(_this.buffer)) {\n                    return this;\n                }\n                line = collectNextLine();\n                // strip of UTF-8 BOM if any\n                // https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8\n                const m = line.match(/^()?WEBVTT([ \\t].*)?$/);\n                if (!(m != null && m[0])) {\n                    throw new Error(\"Malformed WebVTT signature.\");\n                }\n                _this.state = \"HEADER\";\n            }\n            let alreadyCollectedLine = false;\n            while(_this.buffer){\n                // We can't parse a line until we have the full line.\n                if (!/\\r\\n|\\n/.test(_this.buffer)) {\n                    return this;\n                }\n                if (!alreadyCollectedLine) {\n                    line = collectNextLine();\n                } else {\n                    alreadyCollectedLine = false;\n                }\n                switch(_this.state){\n                    case \"HEADER\":\n                        // 13-18 - Allow a header (metadata) under the WEBVTT line.\n                        if (/:/.test(line)) {\n                            parseHeader(line);\n                        } else if (!line) {\n                            // An empty line terminates the header and starts the body (cues).\n                            _this.state = \"ID\";\n                        }\n                        continue;\n                    case \"NOTE\":\n                        // Ignore NOTE blocks.\n                        if (!line) {\n                            _this.state = \"ID\";\n                        }\n                        continue;\n                    case \"ID\":\n                        // Check for the start of NOTE blocks.\n                        if (/^NOTE($|[ \\t])/.test(line)) {\n                            _this.state = \"NOTE\";\n                            break;\n                        }\n                        // 19-29 - Allow any number of line terminators, then initialize new cue values.\n                        if (!line) {\n                            continue;\n                        }\n                        _this.cue = new VTTCue(0, 0, \"\");\n                        _this.state = \"CUE\";\n                        // 30-39 - Check if self line contains an optional identifier or timing data.\n                        if (line.indexOf(\"-->\") === -1) {\n                            _this.cue.id = line;\n                            continue;\n                        }\n                    // Process line as start of a cue.\n                    /* falls through */ case \"CUE\":\n                        // 40 - Collect cue timings and settings.\n                        if (!_this.cue) {\n                            _this.state = \"BADCUE\";\n                            continue;\n                        }\n                        try {\n                            parseCue(line, _this.cue, _this.regionList);\n                        } catch (e) {\n                            // In case of an error ignore rest of the cue.\n                            _this.cue = null;\n                            _this.state = \"BADCUE\";\n                            continue;\n                        }\n                        _this.state = \"CUETEXT\";\n                        continue;\n                    case \"CUETEXT\":\n                        {\n                            const hasSubstring = line.indexOf(\"-->\") !== -1;\n                            // 34 - If we have an empty line then report the cue.\n                            // 35 - If we have the special substring '-->' then report the cue,\n                            // but do not collect the line as we need to process the current\n                            // one as a new cue.\n                            if (!line || hasSubstring && (alreadyCollectedLine = true)) {\n                                // We are done parsing self cue.\n                                if (_this.oncue && _this.cue) {\n                                    _this.oncue(_this.cue);\n                                }\n                                _this.cue = null;\n                                _this.state = \"ID\";\n                                continue;\n                            }\n                            if (_this.cue === null) {\n                                continue;\n                            }\n                            if (_this.cue.text) {\n                                _this.cue.text += \"\\n\";\n                            }\n                            _this.cue.text += line;\n                        }\n                        continue;\n                    case \"BADCUE\":\n                        // 54-62 - Collect and discard the remaining cue.\n                        if (!line) {\n                            _this.state = \"ID\";\n                        }\n                }\n            }\n        } catch (e) {\n            // If we are currently parsing a cue, report what we have.\n            if (_this.state === \"CUETEXT\" && _this.cue && _this.oncue) {\n                _this.oncue(_this.cue);\n            }\n            _this.cue = null;\n            // Enter BADWEBVTT state if header was not parsed correctly otherwise\n            // another exception occurred so enter BADCUE state.\n            _this.state = _this.state === \"INITIAL\" ? \"BADWEBVTT\" : \"BADCUE\";\n        }\n        return this;\n    }\n    flush() {\n        const _this = this;\n        try {\n            // Finish decoding the stream.\n            // _this.buffer += _this.decoder.decode();\n            // Synthesize the end of the current cue or region.\n            if (_this.cue || _this.state === \"HEADER\") {\n                _this.buffer += \"\\n\\n\";\n                _this.parse();\n            }\n            // If we've flushed, parsed, and we're still on the INITIAL state then\n            // that means we don't have enough of the stream to parse the first\n            // line.\n            if (_this.state === \"INITIAL\" || _this.state === \"BADWEBVTT\") {\n                throw new Error(\"Malformed WebVTT signature.\");\n            }\n        } catch (e) {\n            if (_this.onparsingerror) {\n                _this.onparsingerror(e);\n            }\n        }\n        if (_this.onflush) {\n            _this.onflush();\n        }\n        return this;\n    }\n}\nconst LINEBREAKS = /\\r\\n|\\n\\r|\\n|\\r/g;\n// String.prototype.startsWith is not supported in IE11\nconst startsWith = function startsWith(inputString, searchString, position = 0) {\n    return inputString.slice(position, position + searchString.length) === searchString;\n};\nconst cueString2millis = function cueString2millis(timeString) {\n    let ts = parseInt(timeString.slice(-3));\n    const secs = parseInt(timeString.slice(-6, -4));\n    const mins = parseInt(timeString.slice(-9, -7));\n    const hours = timeString.length > 9 ? parseInt(timeString.substring(0, timeString.indexOf(\":\"))) : 0;\n    if (!isFiniteNumber(ts) || !isFiniteNumber(secs) || !isFiniteNumber(mins) || !isFiniteNumber(hours)) {\n        throw Error(`Malformed X-TIMESTAMP-MAP: Local:${timeString}`);\n    }\n    ts += 1000 * secs;\n    ts += 60 * 1000 * mins;\n    ts += 60 * 60 * 1000 * hours;\n    return ts;\n};\n// From https://github.com/darkskyapp/string-hash\nconst hash = function hash(text) {\n    let _hash = 5381;\n    let i = text.length;\n    while(i){\n        _hash = _hash * 33 ^ text.charCodeAt(--i);\n    }\n    return (_hash >>> 0).toString();\n};\n// Create a unique hash id for a cue based on start/end times and text.\n// This helps timeline-controller to avoid showing repeated captions.\nfunction generateCueId(startTime, endTime, text) {\n    return hash(startTime.toString()) + hash(endTime.toString()) + hash(text);\n}\nconst calculateOffset = function calculateOffset(vttCCs, cc, presentationTime) {\n    let currCC = vttCCs[cc];\n    let prevCC = vttCCs[currCC.prevCC];\n    // This is the first discontinuity or cues have been processed since the last discontinuity\n    // Offset = current discontinuity time\n    if (!prevCC || !prevCC.new && currCC.new) {\n        vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;\n        currCC.new = false;\n        return;\n    }\n    // There have been discontinuities since cues were last parsed.\n    // Offset = time elapsed\n    while((_prevCC = prevCC) != null && _prevCC.new){\n        var _prevCC;\n        vttCCs.ccOffset += currCC.start - prevCC.start;\n        currCC.new = false;\n        currCC = prevCC;\n        prevCC = vttCCs[currCC.prevCC];\n    }\n    vttCCs.presentationOffset = presentationTime;\n};\nfunction parseWebVTT(vttByteArray, initPTS, vttCCs, cc, timeOffset, callBack, errorCallBack) {\n    const parser = new VTTParser();\n    // Convert byteArray into string, replacing any somewhat exotic linefeeds with \"\\n\", then split on that character.\n    // Uint8Array.prototype.reduce is not implemented in IE11\n    const vttLines = utf8ArrayToStr(new Uint8Array(vttByteArray)).trim().replace(LINEBREAKS, \"\\n\").split(\"\\n\");\n    const cues = [];\n    const init90kHz = initPTS ? toMpegTsClockFromTimescale(initPTS.baseTime, initPTS.timescale) : 0;\n    let cueTime = \"00:00.000\";\n    let timestampMapMPEGTS = 0;\n    let timestampMapLOCAL = 0;\n    let parsingError;\n    let inHeader = true;\n    parser.oncue = function(cue) {\n        // Adjust cue timing; clamp cues to start no earlier than - and drop cues that don't end after - 0 on timeline.\n        const currCC = vttCCs[cc];\n        let cueOffset = vttCCs.ccOffset;\n        // Calculate subtitle PTS offset\n        const webVttMpegTsMapOffset = (timestampMapMPEGTS - init90kHz) / 90000;\n        // Update offsets for new discontinuities\n        if (currCC != null && currCC.new) {\n            if (timestampMapLOCAL !== undefined) {\n                // When local time is provided, offset = discontinuity start time - local time\n                cueOffset = vttCCs.ccOffset = currCC.start;\n            } else {\n                calculateOffset(vttCCs, cc, webVttMpegTsMapOffset);\n            }\n        }\n        if (webVttMpegTsMapOffset) {\n            if (!initPTS) {\n                parsingError = new Error(\"Missing initPTS for VTT MPEGTS\");\n                return;\n            }\n            // If we have MPEGTS, offset = presentation time + discontinuity offset\n            cueOffset = webVttMpegTsMapOffset - vttCCs.presentationOffset;\n        }\n        const duration = cue.endTime - cue.startTime;\n        const startTime = normalizePts((cue.startTime + cueOffset - timestampMapLOCAL) * 90000, timeOffset * 90000) / 90000;\n        cue.startTime = Math.max(startTime, 0);\n        cue.endTime = Math.max(startTime + duration, 0);\n        //trim trailing webvtt block whitespaces\n        const text = cue.text.trim();\n        // Fix encoding of special characters\n        cue.text = decodeURIComponent(encodeURIComponent(text));\n        // If the cue was not assigned an id from the VTT file (line above the content), create one.\n        if (!cue.id) {\n            cue.id = generateCueId(cue.startTime, cue.endTime, text);\n        }\n        if (cue.endTime > 0) {\n            cues.push(cue);\n        }\n    };\n    parser.onparsingerror = function(error) {\n        parsingError = error;\n    };\n    parser.onflush = function() {\n        if (parsingError) {\n            errorCallBack(parsingError);\n            return;\n        }\n        callBack(cues);\n    };\n    // Go through contents line by line.\n    vttLines.forEach((line)=>{\n        if (inHeader) {\n            // Look for X-TIMESTAMP-MAP in header.\n            if (startsWith(line, \"X-TIMESTAMP-MAP=\")) {\n                // Once found, no more are allowed anyway, so stop searching.\n                inHeader = false;\n                // Extract LOCAL and MPEGTS.\n                line.slice(16).split(\",\").forEach((timestamp)=>{\n                    if (startsWith(timestamp, \"LOCAL:\")) {\n                        cueTime = timestamp.slice(6);\n                    } else if (startsWith(timestamp, \"MPEGTS:\")) {\n                        timestampMapMPEGTS = parseInt(timestamp.slice(7));\n                    }\n                });\n                try {\n                    // Convert cue time to seconds\n                    timestampMapLOCAL = cueString2millis(cueTime) / 1000;\n                } catch (error) {\n                    parsingError = error;\n                }\n                // Return without parsing X-TIMESTAMP-MAP line.\n                return;\n            } else if (line === \"\") {\n                inHeader = false;\n            }\n        }\n        // Parse line by default.\n        parser.parse(line + \"\\n\");\n    });\n    parser.flush();\n}\nconst IMSC1_CODEC = \"stpp.ttml.im1t\";\n// Time format: h:m:s:frames(.subframes)\nconst HMSF_REGEX = /^(\\d{2,}):(\\d{2}):(\\d{2}):(\\d{2})\\.?(\\d+)?$/;\n// Time format: hours, minutes, seconds, milliseconds, frames, ticks\nconst TIME_UNIT_REGEX = /^(\\d*(?:\\.\\d*)?)(h|m|s|ms|f|t)$/;\nconst textAlignToLineAlign = {\n    left: \"start\",\n    center: \"center\",\n    right: \"end\",\n    start: \"start\",\n    end: \"end\"\n};\nfunction parseIMSC1(payload, initPTS, callBack, errorCallBack) {\n    const results = findBox(new Uint8Array(payload), [\n        \"mdat\"\n    ]);\n    if (results.length === 0) {\n        errorCallBack(new Error(\"Could not parse IMSC1 mdat\"));\n        return;\n    }\n    const ttmlList = results.map((mdat)=>utf8ArrayToStr(mdat));\n    const syncTime = toTimescaleFromScale(initPTS.baseTime, 1, initPTS.timescale);\n    try {\n        ttmlList.forEach((ttml)=>callBack(parseTTML(ttml, syncTime)));\n    } catch (error) {\n        errorCallBack(error);\n    }\n}\nfunction parseTTML(ttml, syncTime) {\n    const parser = new DOMParser();\n    const xmlDoc = parser.parseFromString(ttml, \"text/xml\");\n    const tt = xmlDoc.getElementsByTagName(\"tt\")[0];\n    if (!tt) {\n        throw new Error(\"Invalid ttml\");\n    }\n    const defaultRateInfo = {\n        frameRate: 30,\n        subFrameRate: 1,\n        frameRateMultiplier: 0,\n        tickRate: 0\n    };\n    const rateInfo = Object.keys(defaultRateInfo).reduce((result, key)=>{\n        result[key] = tt.getAttribute(`ttp:${key}`) || defaultRateInfo[key];\n        return result;\n    }, {});\n    const trim = tt.getAttribute(\"xml:space\") !== \"preserve\";\n    const styleElements = collectionToDictionary(getElementCollection(tt, \"styling\", \"style\"));\n    const regionElements = collectionToDictionary(getElementCollection(tt, \"layout\", \"region\"));\n    const cueElements = getElementCollection(tt, \"body\", \"[begin]\");\n    return [].map.call(cueElements, (cueElement)=>{\n        const cueText = getTextContent(cueElement, trim);\n        if (!cueText || !cueElement.hasAttribute(\"begin\")) {\n            return null;\n        }\n        const startTime = parseTtmlTime(cueElement.getAttribute(\"begin\"), rateInfo);\n        const duration = parseTtmlTime(cueElement.getAttribute(\"dur\"), rateInfo);\n        let endTime = parseTtmlTime(cueElement.getAttribute(\"end\"), rateInfo);\n        if (startTime === null) {\n            throw timestampParsingError(cueElement);\n        }\n        if (endTime === null) {\n            if (duration === null) {\n                throw timestampParsingError(cueElement);\n            }\n            endTime = startTime + duration;\n        }\n        const cue = new VTTCue(startTime - syncTime, endTime - syncTime, cueText);\n        cue.id = generateCueId(cue.startTime, cue.endTime, cue.text);\n        const region = regionElements[cueElement.getAttribute(\"region\")];\n        const style = styleElements[cueElement.getAttribute(\"style\")];\n        // Apply styles to cue\n        const styles = getTtmlStyles(region, style, styleElements);\n        const { textAlign } = styles;\n        if (textAlign) {\n            // cue.positionAlign not settable in FF~2016\n            const lineAlign = textAlignToLineAlign[textAlign];\n            if (lineAlign) {\n                cue.lineAlign = lineAlign;\n            }\n            cue.align = textAlign;\n        }\n        _extends(cue, styles);\n        return cue;\n    }).filter((cue)=>cue !== null);\n}\nfunction getElementCollection(fromElement, parentName, childName) {\n    const parent = fromElement.getElementsByTagName(parentName)[0];\n    if (parent) {\n        return [].slice.call(parent.querySelectorAll(childName));\n    }\n    return [];\n}\nfunction collectionToDictionary(elementsWithId) {\n    return elementsWithId.reduce((dict, element)=>{\n        const id = element.getAttribute(\"xml:id\");\n        if (id) {\n            dict[id] = element;\n        }\n        return dict;\n    }, {});\n}\nfunction getTextContent(element, trim) {\n    return [].slice.call(element.childNodes).reduce((str, node, i)=>{\n        var _node$childNodes;\n        if (node.nodeName === \"br\" && i) {\n            return str + \"\\n\";\n        }\n        if ((_node$childNodes = node.childNodes) != null && _node$childNodes.length) {\n            return getTextContent(node, trim);\n        } else if (trim) {\n            return str + node.textContent.trim().replace(/\\s+/g, \" \");\n        }\n        return str + node.textContent;\n    }, \"\");\n}\nfunction getTtmlStyles(region, style, styleElements) {\n    const ttsNs = \"http://www.w3.org/ns/ttml#styling\";\n    let regionStyle = null;\n    const styleAttributes = [\n        \"displayAlign\",\n        \"textAlign\",\n        \"color\",\n        \"backgroundColor\",\n        \"fontSize\",\n        \"fontFamily\"\n    ];\n    const regionStyleName = region != null && region.hasAttribute(\"style\") ? region.getAttribute(\"style\") : null;\n    if (regionStyleName && styleElements.hasOwnProperty(regionStyleName)) {\n        regionStyle = styleElements[regionStyleName];\n    }\n    return styleAttributes.reduce((styles, name)=>{\n        const value = getAttributeNS(style, ttsNs, name) || getAttributeNS(region, ttsNs, name) || getAttributeNS(regionStyle, ttsNs, name);\n        if (value) {\n            styles[name] = value;\n        }\n        return styles;\n    }, {});\n}\nfunction getAttributeNS(element, ns, name) {\n    if (!element) {\n        return null;\n    }\n    return element.hasAttributeNS(ns, name) ? element.getAttributeNS(ns, name) : null;\n}\nfunction timestampParsingError(node) {\n    return new Error(`Could not parse ttml timestamp ${node}`);\n}\nfunction parseTtmlTime(timeAttributeValue, rateInfo) {\n    if (!timeAttributeValue) {\n        return null;\n    }\n    let seconds = parseTimeStamp(timeAttributeValue);\n    if (seconds === null) {\n        if (HMSF_REGEX.test(timeAttributeValue)) {\n            seconds = parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo);\n        } else if (TIME_UNIT_REGEX.test(timeAttributeValue)) {\n            seconds = parseTimeUnits(timeAttributeValue, rateInfo);\n        }\n    }\n    return seconds;\n}\nfunction parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo) {\n    const m = HMSF_REGEX.exec(timeAttributeValue);\n    const frames = (m[4] | 0) + (m[5] | 0) / rateInfo.subFrameRate;\n    return (m[1] | 0) * 3600 + (m[2] | 0) * 60 + (m[3] | 0) + frames / rateInfo.frameRate;\n}\nfunction parseTimeUnits(timeAttributeValue, rateInfo) {\n    const m = TIME_UNIT_REGEX.exec(timeAttributeValue);\n    const value = Number(m[1]);\n    const unit = m[2];\n    switch(unit){\n        case \"h\":\n            return value * 3600;\n        case \"m\":\n            return value * 60;\n        case \"ms\":\n            return value * 1000;\n        case \"f\":\n            return value / rateInfo.frameRate;\n        case \"t\":\n            return value / rateInfo.tickRate;\n    }\n    return value;\n}\nclass TimelineController {\n    constructor(hls){\n        this.hls = void 0;\n        this.media = null;\n        this.config = void 0;\n        this.enabled = true;\n        this.Cues = void 0;\n        this.textTracks = [];\n        this.tracks = [];\n        this.initPTS = [];\n        this.unparsedVttFrags = [];\n        this.captionsTracks = {};\n        this.nonNativeCaptionsTracks = {};\n        this.cea608Parser1 = void 0;\n        this.cea608Parser2 = void 0;\n        this.lastCc = -1;\n        // Last video (CEA-608) fragment CC\n        this.lastSn = -1;\n        // Last video (CEA-608) fragment MSN\n        this.lastPartIndex = -1;\n        // Last video (CEA-608) fragment Part Index\n        this.prevCC = -1;\n        // Last subtitle fragment CC\n        this.vttCCs = newVTTCCs();\n        this.captionsProperties = void 0;\n        this.hls = hls;\n        this.config = hls.config;\n        this.Cues = hls.config.cueHandler;\n        this.captionsProperties = {\n            textTrack1: {\n                label: this.config.captionsTextTrack1Label,\n                languageCode: this.config.captionsTextTrack1LanguageCode\n            },\n            textTrack2: {\n                label: this.config.captionsTextTrack2Label,\n                languageCode: this.config.captionsTextTrack2LanguageCode\n            },\n            textTrack3: {\n                label: this.config.captionsTextTrack3Label,\n                languageCode: this.config.captionsTextTrack3LanguageCode\n            },\n            textTrack4: {\n                label: this.config.captionsTextTrack4Label,\n                languageCode: this.config.captionsTextTrack4LanguageCode\n            }\n        };\n        hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n        hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n        hls.on(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n        hls.on(Events.FRAG_LOADING, this.onFragLoading, this);\n        hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);\n        hls.on(Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);\n        hls.on(Events.FRAG_DECRYPTED, this.onFragDecrypted, this);\n        hls.on(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n        hls.on(Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);\n        hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    }\n    destroy() {\n        const { hls } = this;\n        hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n        hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n        hls.off(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n        hls.off(Events.FRAG_LOADING, this.onFragLoading, this);\n        hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);\n        hls.off(Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);\n        hls.off(Events.FRAG_DECRYPTED, this.onFragDecrypted, this);\n        hls.off(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n        hls.off(Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);\n        hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n        // @ts-ignore\n        this.hls = this.config = null;\n        this.cea608Parser1 = this.cea608Parser2 = undefined;\n    }\n    initCea608Parsers() {\n        if (this.config.enableCEA708Captions && (!this.cea608Parser1 || !this.cea608Parser2)) {\n            const channel1 = new OutputFilter(this, \"textTrack1\");\n            const channel2 = new OutputFilter(this, \"textTrack2\");\n            const channel3 = new OutputFilter(this, \"textTrack3\");\n            const channel4 = new OutputFilter(this, \"textTrack4\");\n            this.cea608Parser1 = new Cea608Parser(1, channel1, channel2);\n            this.cea608Parser2 = new Cea608Parser(3, channel3, channel4);\n        }\n    }\n    addCues(trackName, startTime, endTime, screen, cueRanges) {\n        // skip cues which overlap more than 50% with previously parsed time ranges\n        let merged = false;\n        for(let i = cueRanges.length; i--;){\n            const cueRange = cueRanges[i];\n            const overlap = intersection(cueRange[0], cueRange[1], startTime, endTime);\n            if (overlap >= 0) {\n                cueRange[0] = Math.min(cueRange[0], startTime);\n                cueRange[1] = Math.max(cueRange[1], endTime);\n                merged = true;\n                if (overlap / (endTime - startTime) > 0.5) {\n                    return;\n                }\n            }\n        }\n        if (!merged) {\n            cueRanges.push([\n                startTime,\n                endTime\n            ]);\n        }\n        if (this.config.renderTextTracksNatively) {\n            const track = this.captionsTracks[trackName];\n            this.Cues.newCue(track, startTime, endTime, screen);\n        } else {\n            const cues = this.Cues.newCue(null, startTime, endTime, screen);\n            this.hls.trigger(Events.CUES_PARSED, {\n                type: \"captions\",\n                cues,\n                track: trackName\n            });\n        }\n    }\n    // Triggered when an initial PTS is found; used for synchronisation of WebVTT.\n    onInitPtsFound(event, { frag, id, initPTS, timescale }) {\n        const { unparsedVttFrags } = this;\n        if (id === \"main\") {\n            this.initPTS[frag.cc] = {\n                baseTime: initPTS,\n                timescale\n            };\n        }\n        // Due to asynchronous processing, initial PTS may arrive later than the first VTT fragments are loaded.\n        // Parse any unparsed fragments upon receiving the initial PTS.\n        if (unparsedVttFrags.length) {\n            this.unparsedVttFrags = [];\n            unparsedVttFrags.forEach((frag)=>{\n                this.onFragLoaded(Events.FRAG_LOADED, frag);\n            });\n        }\n    }\n    getExistingTrack(label, language) {\n        const { media } = this;\n        if (media) {\n            for(let i = 0; i < media.textTracks.length; i++){\n                const textTrack = media.textTracks[i];\n                if (canReuseVttTextTrack(textTrack, {\n                    name: label,\n                    lang: language,\n                    attrs: {}\n                })) {\n                    return textTrack;\n                }\n            }\n        }\n        return null;\n    }\n    createCaptionsTrack(trackName) {\n        if (this.config.renderTextTracksNatively) {\n            this.createNativeTrack(trackName);\n        } else {\n            this.createNonNativeTrack(trackName);\n        }\n    }\n    createNativeTrack(trackName) {\n        if (this.captionsTracks[trackName]) {\n            return;\n        }\n        const { captionsProperties, captionsTracks, media } = this;\n        const { label, languageCode } = captionsProperties[trackName];\n        // Enable reuse of existing text track.\n        const existingTrack = this.getExistingTrack(label, languageCode);\n        if (!existingTrack) {\n            const textTrack = this.createTextTrack(\"captions\", label, languageCode);\n            if (textTrack) {\n                // Set a special property on the track so we know it's managed by Hls.js\n                textTrack[trackName] = true;\n                captionsTracks[trackName] = textTrack;\n            }\n        } else {\n            captionsTracks[trackName] = existingTrack;\n            clearCurrentCues(captionsTracks[trackName]);\n            sendAddTrackEvent(captionsTracks[trackName], media);\n        }\n    }\n    createNonNativeTrack(trackName) {\n        if (this.nonNativeCaptionsTracks[trackName]) {\n            return;\n        }\n        // Create a list of a single track for the provider to consume\n        const trackProperties = this.captionsProperties[trackName];\n        if (!trackProperties) {\n            return;\n        }\n        const label = trackProperties.label;\n        const track = {\n            _id: trackName,\n            label,\n            kind: \"captions\",\n            default: trackProperties.media ? !!trackProperties.media.default : false,\n            closedCaptions: trackProperties.media\n        };\n        this.nonNativeCaptionsTracks[trackName] = track;\n        this.hls.trigger(Events.NON_NATIVE_TEXT_TRACKS_FOUND, {\n            tracks: [\n                track\n            ]\n        });\n    }\n    createTextTrack(kind, label, lang) {\n        const media = this.media;\n        if (!media) {\n            return;\n        }\n        return media.addTextTrack(kind, label, lang);\n    }\n    onMediaAttaching(event, data) {\n        this.media = data.media;\n        this._cleanTracks();\n    }\n    onMediaDetaching() {\n        const { captionsTracks } = this;\n        Object.keys(captionsTracks).forEach((trackName)=>{\n            clearCurrentCues(captionsTracks[trackName]);\n            delete captionsTracks[trackName];\n        });\n        this.nonNativeCaptionsTracks = {};\n    }\n    onManifestLoading() {\n        // Detect discontinuity in video fragment (CEA-608) parsing\n        this.lastCc = -1;\n        this.lastSn = -1;\n        this.lastPartIndex = -1;\n        // Detect discontinuity in subtitle manifests\n        this.prevCC = -1;\n        this.vttCCs = newVTTCCs();\n        // Reset tracks\n        this._cleanTracks();\n        this.tracks = [];\n        this.captionsTracks = {};\n        this.nonNativeCaptionsTracks = {};\n        this.textTracks = [];\n        this.unparsedVttFrags = [];\n        this.initPTS = [];\n        if (this.cea608Parser1 && this.cea608Parser2) {\n            this.cea608Parser1.reset();\n            this.cea608Parser2.reset();\n        }\n    }\n    _cleanTracks() {\n        // clear outdated subtitles\n        const { media } = this;\n        if (!media) {\n            return;\n        }\n        const textTracks = media.textTracks;\n        if (textTracks) {\n            for(let i = 0; i < textTracks.length; i++){\n                clearCurrentCues(textTracks[i]);\n            }\n        }\n    }\n    onSubtitleTracksUpdated(event, data) {\n        const tracks = data.subtitleTracks || [];\n        const hasIMSC1 = tracks.some((track)=>track.textCodec === IMSC1_CODEC);\n        if (this.config.enableWebVTT || hasIMSC1 && this.config.enableIMSC1) {\n            const listIsIdentical = subtitleOptionsIdentical(this.tracks, tracks);\n            if (listIsIdentical) {\n                this.tracks = tracks;\n                return;\n            }\n            this.textTracks = [];\n            this.tracks = tracks;\n            if (this.config.renderTextTracksNatively) {\n                const media = this.media;\n                const inUseTracks = media ? filterSubtitleTracks(media.textTracks) : null;\n                this.tracks.forEach((track, index)=>{\n                    // Reuse tracks with the same label and lang, but do not reuse 608/708 tracks\n                    let textTrack;\n                    if (inUseTracks) {\n                        let inUseTrack = null;\n                        for(let i = 0; i < inUseTracks.length; i++){\n                            if (inUseTracks[i] && canReuseVttTextTrack(inUseTracks[i], track)) {\n                                inUseTrack = inUseTracks[i];\n                                inUseTracks[i] = null;\n                                break;\n                            }\n                        }\n                        if (inUseTrack) {\n                            textTrack = inUseTrack;\n                        }\n                    }\n                    if (textTrack) {\n                        clearCurrentCues(textTrack);\n                    } else {\n                        const textTrackKind = captionsOrSubtitlesFromCharacteristics(track);\n                        textTrack = this.createTextTrack(textTrackKind, track.name, track.lang);\n                        if (textTrack) {\n                            textTrack.mode = \"disabled\";\n                        }\n                    }\n                    if (textTrack) {\n                        this.textTracks.push(textTrack);\n                    }\n                });\n                // Warn when video element has captions or subtitle TextTracks carried over from another source\n                if (inUseTracks != null && inUseTracks.length) {\n                    const unusedTextTracks = inUseTracks.filter((t)=>t !== null).map((t)=>t.label);\n                    if (unusedTextTracks.length) {\n                        logger.warn(`Media element contains unused subtitle tracks: ${unusedTextTracks.join(\", \")}. Replace media element for each source to clear TextTracks and captions menu.`);\n                    }\n                }\n            } else if (this.tracks.length) {\n                // Create a list of tracks for the provider to consume\n                const tracksList = this.tracks.map((track)=>{\n                    return {\n                        label: track.name,\n                        kind: track.type.toLowerCase(),\n                        default: track.default,\n                        subtitleTrack: track\n                    };\n                });\n                this.hls.trigger(Events.NON_NATIVE_TEXT_TRACKS_FOUND, {\n                    tracks: tracksList\n                });\n            }\n        }\n    }\n    onManifestLoaded(event, data) {\n        if (this.config.enableCEA708Captions && data.captions) {\n            data.captions.forEach((captionsTrack)=>{\n                const instreamIdMatch = /(?:CC|SERVICE)([1-4])/.exec(captionsTrack.instreamId);\n                if (!instreamIdMatch) {\n                    return;\n                }\n                const trackName = `textTrack${instreamIdMatch[1]}`;\n                const trackProperties = this.captionsProperties[trackName];\n                if (!trackProperties) {\n                    return;\n                }\n                trackProperties.label = captionsTrack.name;\n                if (captionsTrack.lang) {\n                    // optional attribute\n                    trackProperties.languageCode = captionsTrack.lang;\n                }\n                trackProperties.media = captionsTrack;\n            });\n        }\n    }\n    closedCaptionsForLevel(frag) {\n        const level = this.hls.levels[frag.level];\n        return level == null ? void 0 : level.attrs[\"CLOSED-CAPTIONS\"];\n    }\n    onFragLoading(event, data) {\n        this.initCea608Parsers();\n        const { cea608Parser1, cea608Parser2, lastCc, lastSn, lastPartIndex } = this;\n        if (!this.enabled || !cea608Parser1 || !cea608Parser2) {\n            return;\n        }\n        // if this frag isn't contiguous, clear the parser so cues with bad start/end times aren't added to the textTrack\n        if (data.frag.type === PlaylistLevelType.MAIN) {\n            var _data$part$index, _data$part;\n            const { cc, sn } = data.frag;\n            const partIndex = (_data$part$index = data == null ? void 0 : (_data$part = data.part) == null ? void 0 : _data$part.index) != null ? _data$part$index : -1;\n            if (!(sn === lastSn + 1 || sn === lastSn && partIndex === lastPartIndex + 1 || cc === lastCc)) {\n                cea608Parser1.reset();\n                cea608Parser2.reset();\n            }\n            this.lastCc = cc;\n            this.lastSn = sn;\n            this.lastPartIndex = partIndex;\n        }\n    }\n    onFragLoaded(event, data) {\n        const { frag, payload } = data;\n        if (frag.type === PlaylistLevelType.SUBTITLE) {\n            // If fragment is subtitle type, parse as WebVTT.\n            if (payload.byteLength) {\n                const decryptData = frag.decryptdata;\n                // fragment after decryption has a stats object\n                const decrypted = \"stats\" in data;\n                // If the subtitles are not encrypted, parse VTTs now. Otherwise, we need to wait.\n                if (decryptData == null || !decryptData.encrypted || decrypted) {\n                    const trackPlaylistMedia = this.tracks[frag.level];\n                    const vttCCs = this.vttCCs;\n                    if (!vttCCs[frag.cc]) {\n                        vttCCs[frag.cc] = {\n                            start: frag.start,\n                            prevCC: this.prevCC,\n                            new: true\n                        };\n                        this.prevCC = frag.cc;\n                    }\n                    if (trackPlaylistMedia && trackPlaylistMedia.textCodec === IMSC1_CODEC) {\n                        this._parseIMSC1(frag, payload);\n                    } else {\n                        this._parseVTTs(data);\n                    }\n                }\n            } else {\n                // In case there is no payload, finish unsuccessfully.\n                this.hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n                    success: false,\n                    frag,\n                    error: new Error(\"Empty subtitle payload\")\n                });\n            }\n        }\n    }\n    _parseIMSC1(frag, payload) {\n        const hls = this.hls;\n        parseIMSC1(payload, this.initPTS[frag.cc], (cues)=>{\n            this._appendCues(cues, frag.level);\n            hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n                success: true,\n                frag: frag\n            });\n        }, (error)=>{\n            logger.log(`Failed to parse IMSC1: ${error}`);\n            hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n                success: false,\n                frag: frag,\n                error\n            });\n        });\n    }\n    _parseVTTs(data) {\n        var _frag$initSegment;\n        const { frag, payload } = data;\n        // We need an initial synchronisation PTS. Store fragments as long as none has arrived\n        const { initPTS, unparsedVttFrags } = this;\n        const maxAvCC = initPTS.length - 1;\n        if (!initPTS[frag.cc] && maxAvCC === -1) {\n            unparsedVttFrags.push(data);\n            return;\n        }\n        const hls = this.hls;\n        // Parse the WebVTT file contents.\n        const payloadWebVTT = (_frag$initSegment = frag.initSegment) != null && _frag$initSegment.data ? appendUint8Array(frag.initSegment.data, new Uint8Array(payload)) : payload;\n        parseWebVTT(payloadWebVTT, this.initPTS[frag.cc], this.vttCCs, frag.cc, frag.start, (cues)=>{\n            this._appendCues(cues, frag.level);\n            hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n                success: true,\n                frag: frag\n            });\n        }, (error)=>{\n            const missingInitPTS = error.message === \"Missing initPTS for VTT MPEGTS\";\n            if (missingInitPTS) {\n                unparsedVttFrags.push(data);\n            } else {\n                this._fallbackToIMSC1(frag, payload);\n            }\n            // Something went wrong while parsing. Trigger event with success false.\n            logger.log(`Failed to parse VTT cue: ${error}`);\n            if (missingInitPTS && maxAvCC > frag.cc) {\n                return;\n            }\n            hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n                success: false,\n                frag: frag,\n                error\n            });\n        });\n    }\n    _fallbackToIMSC1(frag, payload) {\n        // If textCodec is unknown, try parsing as IMSC1. Set textCodec based on the result\n        const trackPlaylistMedia = this.tracks[frag.level];\n        if (!trackPlaylistMedia.textCodec) {\n            parseIMSC1(payload, this.initPTS[frag.cc], ()=>{\n                trackPlaylistMedia.textCodec = IMSC1_CODEC;\n                this._parseIMSC1(frag, payload);\n            }, ()=>{\n                trackPlaylistMedia.textCodec = \"wvtt\";\n            });\n        }\n    }\n    _appendCues(cues, fragLevel) {\n        const hls = this.hls;\n        if (this.config.renderTextTracksNatively) {\n            const textTrack = this.textTracks[fragLevel];\n            // WebVTTParser.parse is an async method and if the currently selected text track mode is set to \"disabled\"\n            // before parsing is done then don't try to access currentTrack.cues.getCueById as cues will be null\n            // and trying to access getCueById method of cues will throw an exception\n            // Because we check if the mode is disabled, we can force check `cues` below. They can't be null.\n            if (!textTrack || textTrack.mode === \"disabled\") {\n                return;\n            }\n            cues.forEach((cue)=>addCueToTrack(textTrack, cue));\n        } else {\n            const currentTrack = this.tracks[fragLevel];\n            if (!currentTrack) {\n                return;\n            }\n            const track = currentTrack.default ? \"default\" : \"subtitles\" + fragLevel;\n            hls.trigger(Events.CUES_PARSED, {\n                type: \"subtitles\",\n                cues,\n                track\n            });\n        }\n    }\n    onFragDecrypted(event, data) {\n        const { frag } = data;\n        if (frag.type === PlaylistLevelType.SUBTITLE) {\n            this.onFragLoaded(Events.FRAG_LOADED, data);\n        }\n    }\n    onSubtitleTracksCleared() {\n        this.tracks = [];\n        this.captionsTracks = {};\n    }\n    onFragParsingUserdata(event, data) {\n        this.initCea608Parsers();\n        const { cea608Parser1, cea608Parser2 } = this;\n        if (!this.enabled || !cea608Parser1 || !cea608Parser2) {\n            return;\n        }\n        const { frag, samples } = data;\n        if (frag.type === PlaylistLevelType.MAIN && this.closedCaptionsForLevel(frag) === \"NONE\") {\n            return;\n        }\n        // If the event contains captions (found in the bytes property), push all bytes into the parser immediately\n        // It will create the proper timestamps based on the PTS value\n        for(let i = 0; i < samples.length; i++){\n            const ccBytes = samples[i].bytes;\n            if (ccBytes) {\n                const ccdatas = this.extractCea608Data(ccBytes);\n                cea608Parser1.addData(samples[i].pts, ccdatas[0]);\n                cea608Parser2.addData(samples[i].pts, ccdatas[1]);\n            }\n        }\n    }\n    onBufferFlushing(event, { startOffset, endOffset, endOffsetSubtitles, type }) {\n        const { media } = this;\n        if (!media || media.currentTime < endOffset) {\n            return;\n        }\n        // Clear 608 caption cues from the captions TextTracks when the video back buffer is flushed\n        // Forward cues are never removed because we can loose streamed 608 content from recent fragments\n        if (!type || type === \"video\") {\n            const { captionsTracks } = this;\n            Object.keys(captionsTracks).forEach((trackName)=>removeCuesInRange(captionsTracks[trackName], startOffset, endOffset));\n        }\n        if (this.config.renderTextTracksNatively) {\n            // Clear VTT/IMSC1 subtitle cues from the subtitle TextTracks when the back buffer is flushed\n            if (startOffset === 0 && endOffsetSubtitles !== undefined) {\n                const { textTracks } = this;\n                Object.keys(textTracks).forEach((trackName)=>removeCuesInRange(textTracks[trackName], startOffset, endOffsetSubtitles));\n            }\n        }\n    }\n    extractCea608Data(byteArray) {\n        const actualCCBytes = [\n            [],\n            []\n        ];\n        const count = byteArray[0] & 0x1f;\n        let position = 2;\n        for(let j = 0; j < count; j++){\n            const tmpByte = byteArray[position++];\n            const ccbyte1 = 0x7f & byteArray[position++];\n            const ccbyte2 = 0x7f & byteArray[position++];\n            if (ccbyte1 === 0 && ccbyte2 === 0) {\n                continue;\n            }\n            const ccValid = (0x04 & tmpByte) !== 0; // Support all four channels\n            if (ccValid) {\n                const ccType = 0x03 & tmpByte;\n                if (0x00 /* CEA608 field1*/  === ccType || 0x01 /* CEA608 field2*/  === ccType) {\n                    // Exclude CEA708 CC data.\n                    actualCCBytes[ccType].push(ccbyte1);\n                    actualCCBytes[ccType].push(ccbyte2);\n                }\n            }\n        }\n        return actualCCBytes;\n    }\n}\nfunction captionsOrSubtitlesFromCharacteristics(track) {\n    if (track.characteristics) {\n        if (/transcribes-spoken-dialog/gi.test(track.characteristics) && /describes-music-and-sound/gi.test(track.characteristics)) {\n            return \"captions\";\n        }\n    }\n    return \"subtitles\";\n}\nfunction canReuseVttTextTrack(inUseTrack, manifestTrack) {\n    return !!inUseTrack && inUseTrack.kind === captionsOrSubtitlesFromCharacteristics(manifestTrack) && subtitleTrackMatchesTextTrack(manifestTrack, inUseTrack);\n}\nfunction intersection(x1, x2, y1, y2) {\n    return Math.min(x2, y2) - Math.max(x1, y1);\n}\nfunction newVTTCCs() {\n    return {\n        ccOffset: 0,\n        presentationOffset: 0,\n        0: {\n            start: 0,\n            prevCC: -1,\n            new: true\n        }\n    };\n}\nclass CapLevelController {\n    constructor(hls){\n        this.hls = void 0;\n        this.autoLevelCapping = void 0;\n        this.firstLevel = void 0;\n        this.media = void 0;\n        this.restrictedLevels = void 0;\n        this.timer = void 0;\n        this.clientRect = void 0;\n        this.streamController = void 0;\n        this.hls = hls;\n        this.autoLevelCapping = Number.POSITIVE_INFINITY;\n        this.firstLevel = -1;\n        this.media = null;\n        this.restrictedLevels = [];\n        this.timer = undefined;\n        this.clientRect = null;\n        this.registerListeners();\n    }\n    setStreamController(streamController) {\n        this.streamController = streamController;\n    }\n    destroy() {\n        if (this.hls) {\n            this.unregisterListener();\n        }\n        if (this.timer) {\n            this.stopCapping();\n        }\n        this.media = null;\n        this.clientRect = null;\n        // @ts-ignore\n        this.hls = this.streamController = null;\n    }\n    registerListeners() {\n        const { hls } = this;\n        hls.on(Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);\n        hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n        hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n        hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n        hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n        hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    }\n    unregisterListener() {\n        const { hls } = this;\n        hls.off(Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);\n        hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n        hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n        hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n        hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n        hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    }\n    onFpsDropLevelCapping(event, data) {\n        // Don't add a restricted level more than once\n        const level = this.hls.levels[data.droppedLevel];\n        if (this.isLevelAllowed(level)) {\n            this.restrictedLevels.push({\n                bitrate: level.bitrate,\n                height: level.height,\n                width: level.width\n            });\n        }\n    }\n    onMediaAttaching(event, data) {\n        this.media = data.media instanceof HTMLVideoElement ? data.media : null;\n        this.clientRect = null;\n        if (this.timer && this.hls.levels.length) {\n            this.detectPlayerSize();\n        }\n    }\n    onManifestParsed(event, data) {\n        const hls = this.hls;\n        this.restrictedLevels = [];\n        this.firstLevel = data.firstLevel;\n        if (hls.config.capLevelToPlayerSize && data.video) {\n            // Start capping immediately if the manifest has signaled video codecs\n            this.startCapping();\n        }\n    }\n    onLevelsUpdated(event, data) {\n        if (this.timer && isFiniteNumber(this.autoLevelCapping)) {\n            this.detectPlayerSize();\n        }\n    }\n    // Only activate capping when playing a video stream; otherwise, multi-bitrate audio-only streams will be restricted\n    // to the first level\n    onBufferCodecs(event, data) {\n        const hls = this.hls;\n        if (hls.config.capLevelToPlayerSize && data.video) {\n            // If the manifest did not signal a video codec capping has been deferred until we're certain video is present\n            this.startCapping();\n        }\n    }\n    onMediaDetaching() {\n        this.stopCapping();\n    }\n    detectPlayerSize() {\n        if (this.media) {\n            if (this.mediaHeight <= 0 || this.mediaWidth <= 0) {\n                this.clientRect = null;\n                return;\n            }\n            const levels = this.hls.levels;\n            if (levels.length) {\n                const hls = this.hls;\n                const maxLevel = this.getMaxLevel(levels.length - 1);\n                if (maxLevel !== this.autoLevelCapping) {\n                    logger.log(`Setting autoLevelCapping to ${maxLevel}: ${levels[maxLevel].height}p@${levels[maxLevel].bitrate} for media ${this.mediaWidth}x${this.mediaHeight}`);\n                }\n                hls.autoLevelCapping = maxLevel;\n                if (hls.autoLevelCapping > this.autoLevelCapping && this.streamController) {\n                    // if auto level capping has a higher value for the previous one, flush the buffer using nextLevelSwitch\n                    // usually happen when the user go to the fullscreen mode.\n                    this.streamController.nextLevelSwitch();\n                }\n                this.autoLevelCapping = hls.autoLevelCapping;\n            }\n        }\n    }\n    /*\n   * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)\n   */ getMaxLevel(capLevelIndex) {\n        const levels = this.hls.levels;\n        if (!levels.length) {\n            return -1;\n        }\n        const validLevels = levels.filter((level, index)=>this.isLevelAllowed(level) && index <= capLevelIndex);\n        this.clientRect = null;\n        return CapLevelController.getMaxLevelByMediaSize(validLevels, this.mediaWidth, this.mediaHeight);\n    }\n    startCapping() {\n        if (this.timer) {\n            // Don't reset capping if started twice; this can happen if the manifest signals a video codec\n            return;\n        }\n        this.autoLevelCapping = Number.POSITIVE_INFINITY;\n        self.clearInterval(this.timer);\n        this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1000);\n        this.detectPlayerSize();\n    }\n    stopCapping() {\n        this.restrictedLevels = [];\n        this.firstLevel = -1;\n        this.autoLevelCapping = Number.POSITIVE_INFINITY;\n        if (this.timer) {\n            self.clearInterval(this.timer);\n            this.timer = undefined;\n        }\n    }\n    getDimensions() {\n        if (this.clientRect) {\n            return this.clientRect;\n        }\n        const media = this.media;\n        const boundsRect = {\n            width: 0,\n            height: 0\n        };\n        if (media) {\n            const clientRect = media.getBoundingClientRect();\n            boundsRect.width = clientRect.width;\n            boundsRect.height = clientRect.height;\n            if (!boundsRect.width && !boundsRect.height) {\n                // When the media element has no width or height (equivalent to not being in the DOM),\n                // then use its width and height attributes (media.width, media.height)\n                boundsRect.width = clientRect.right - clientRect.left || media.width || 0;\n                boundsRect.height = clientRect.bottom - clientRect.top || media.height || 0;\n            }\n        }\n        this.clientRect = boundsRect;\n        return boundsRect;\n    }\n    get mediaWidth() {\n        return this.getDimensions().width * this.contentScaleFactor;\n    }\n    get mediaHeight() {\n        return this.getDimensions().height * this.contentScaleFactor;\n    }\n    get contentScaleFactor() {\n        let pixelRatio = 1;\n        if (!this.hls.config.ignoreDevicePixelRatio) {\n            try {\n                pixelRatio = self.devicePixelRatio;\n            } catch (e) {\n            /* no-op */ }\n        }\n        return pixelRatio;\n    }\n    isLevelAllowed(level) {\n        const restrictedLevels = this.restrictedLevels;\n        return !restrictedLevels.some((restrictedLevel)=>{\n            return level.bitrate === restrictedLevel.bitrate && level.width === restrictedLevel.width && level.height === restrictedLevel.height;\n        });\n    }\n    static getMaxLevelByMediaSize(levels, width, height) {\n        if (!(levels != null && levels.length)) {\n            return -1;\n        }\n        // Levels can have the same dimensions but differing bandwidths - since levels are ordered, we can look to the next\n        // to determine whether we've chosen the greatest bandwidth for the media's dimensions\n        const atGreatestBandwidth = (curLevel, nextLevel)=>{\n            if (!nextLevel) {\n                return true;\n            }\n            return curLevel.width !== nextLevel.width || curLevel.height !== nextLevel.height;\n        };\n        // If we run through the loop without breaking, the media's dimensions are greater than every level, so default to\n        // the max level\n        let maxLevelIndex = levels.length - 1;\n        // Prevent changes in aspect-ratio from causing capping to toggle back and forth\n        const squareSize = Math.max(width, height);\n        for(let i = 0; i < levels.length; i += 1){\n            const level = levels[i];\n            if ((level.width >= squareSize || level.height >= squareSize) && atGreatestBandwidth(level, levels[i + 1])) {\n                maxLevelIndex = i;\n                break;\n            }\n        }\n        return maxLevelIndex;\n    }\n}\nclass FPSController {\n    constructor(hls){\n        this.hls = void 0;\n        this.isVideoPlaybackQualityAvailable = false;\n        this.timer = void 0;\n        this.media = null;\n        this.lastTime = void 0;\n        this.lastDroppedFrames = 0;\n        this.lastDecodedFrames = 0;\n        // stream controller must be provided as a dependency!\n        this.streamController = void 0;\n        this.hls = hls;\n        this.registerListeners();\n    }\n    setStreamController(streamController) {\n        this.streamController = streamController;\n    }\n    registerListeners() {\n        this.hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    }\n    unregisterListeners() {\n        this.hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    }\n    destroy() {\n        if (this.timer) {\n            clearInterval(this.timer);\n        }\n        this.unregisterListeners();\n        this.isVideoPlaybackQualityAvailable = false;\n        this.media = null;\n    }\n    onMediaAttaching(event, data) {\n        const config = this.hls.config;\n        if (config.capLevelOnFPSDrop) {\n            const media = data.media instanceof self.HTMLVideoElement ? data.media : null;\n            this.media = media;\n            if (media && typeof media.getVideoPlaybackQuality === \"function\") {\n                this.isVideoPlaybackQualityAvailable = true;\n            }\n            self.clearInterval(this.timer);\n            this.timer = self.setInterval(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);\n        }\n    }\n    checkFPS(video, decodedFrames, droppedFrames) {\n        const currentTime = performance.now();\n        if (decodedFrames) {\n            if (this.lastTime) {\n                const currentPeriod = currentTime - this.lastTime;\n                const currentDropped = droppedFrames - this.lastDroppedFrames;\n                const currentDecoded = decodedFrames - this.lastDecodedFrames;\n                const droppedFPS = 1000 * currentDropped / currentPeriod;\n                const hls = this.hls;\n                hls.trigger(Events.FPS_DROP, {\n                    currentDropped: currentDropped,\n                    currentDecoded: currentDecoded,\n                    totalDroppedFrames: droppedFrames\n                });\n                if (droppedFPS > 0) {\n                    // logger.log('checkFPS : droppedFPS/decodedFPS:' + droppedFPS/(1000 * currentDecoded / currentPeriod));\n                    if (currentDropped > hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {\n                        let currentLevel = hls.currentLevel;\n                        logger.warn(\"drop FPS ratio greater than max allowed value for currentLevel: \" + currentLevel);\n                        if (currentLevel > 0 && (hls.autoLevelCapping === -1 || hls.autoLevelCapping >= currentLevel)) {\n                            currentLevel = currentLevel - 1;\n                            hls.trigger(Events.FPS_DROP_LEVEL_CAPPING, {\n                                level: currentLevel,\n                                droppedLevel: hls.currentLevel\n                            });\n                            hls.autoLevelCapping = currentLevel;\n                            this.streamController.nextLevelSwitch();\n                        }\n                    }\n                }\n            }\n            this.lastTime = currentTime;\n            this.lastDroppedFrames = droppedFrames;\n            this.lastDecodedFrames = decodedFrames;\n        }\n    }\n    checkFPSInterval() {\n        const video = this.media;\n        if (video) {\n            if (this.isVideoPlaybackQualityAvailable) {\n                const videoPlaybackQuality = video.getVideoPlaybackQuality();\n                this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);\n            } else {\n                // HTMLVideoElement doesn't include the webkit types\n                this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);\n            }\n        }\n    }\n}\nconst LOGGER_PREFIX = \"[eme]\";\n/**\n * Controller to deal with encrypted media extensions (EME)\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API\n *\n * @class\n * @constructor\n */ class EMEController {\n    constructor(hls){\n        this.hls = void 0;\n        this.config = void 0;\n        this.media = null;\n        this.keyFormatPromise = null;\n        this.keySystemAccessPromises = {};\n        this._requestLicenseFailureCount = 0;\n        this.mediaKeySessions = [];\n        this.keyIdToKeySessionPromise = {};\n        this.setMediaKeysQueue = EMEController.CDMCleanupPromise ? [\n            EMEController.CDMCleanupPromise\n        ] : [];\n        this.onMediaEncrypted = this._onMediaEncrypted.bind(this);\n        this.onWaitingForKey = this._onWaitingForKey.bind(this);\n        this.debug = logger.debug.bind(logger, LOGGER_PREFIX);\n        this.log = logger.log.bind(logger, LOGGER_PREFIX);\n        this.warn = logger.warn.bind(logger, LOGGER_PREFIX);\n        this.error = logger.error.bind(logger, LOGGER_PREFIX);\n        this.hls = hls;\n        this.config = hls.config;\n        this.registerListeners();\n    }\n    destroy() {\n        this.unregisterListeners();\n        this.onMediaDetached();\n        // Remove any references that could be held in config options or callbacks\n        const config = this.config;\n        config.requestMediaKeySystemAccessFunc = null;\n        config.licenseXhrSetup = config.licenseResponseCallback = undefined;\n        config.drmSystems = config.drmSystemOptions = {};\n        // @ts-ignore\n        this.hls = this.onMediaEncrypted = this.onWaitingForKey = this.keyIdToKeySessionPromise = null;\n        // @ts-ignore\n        this.config = null;\n    }\n    registerListeners() {\n        this.hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        this.hls.on(Events.MEDIA_DETACHED, this.onMediaDetached, this);\n        this.hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        this.hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    }\n    unregisterListeners() {\n        this.hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        this.hls.off(Events.MEDIA_DETACHED, this.onMediaDetached, this);\n        this.hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        this.hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    }\n    getLicenseServerUrl(keySystem) {\n        const { drmSystems, widevineLicenseUrl } = this.config;\n        const keySystemConfiguration = drmSystems[keySystem];\n        if (keySystemConfiguration) {\n            return keySystemConfiguration.licenseUrl;\n        }\n        // For backward compatibility\n        if (keySystem === KeySystems.WIDEVINE && widevineLicenseUrl) {\n            return widevineLicenseUrl;\n        }\n        throw new Error(`no license server URL configured for key-system \"${keySystem}\"`);\n    }\n    getServerCertificateUrl(keySystem) {\n        const { drmSystems } = this.config;\n        const keySystemConfiguration = drmSystems[keySystem];\n        if (keySystemConfiguration) {\n            return keySystemConfiguration.serverCertificateUrl;\n        } else {\n            this.log(`No Server Certificate in config.drmSystems[\"${keySystem}\"]`);\n        }\n    }\n    attemptKeySystemAccess(keySystemsToAttempt) {\n        const levels = this.hls.levels;\n        const uniqueCodec = (value, i, a)=>!!value && a.indexOf(value) === i;\n        const audioCodecs = levels.map((level)=>level.audioCodec).filter(uniqueCodec);\n        const videoCodecs = levels.map((level)=>level.videoCodec).filter(uniqueCodec);\n        if (audioCodecs.length + videoCodecs.length === 0) {\n            videoCodecs.push(\"avc1.42e01e\");\n        }\n        return new Promise((resolve, reject)=>{\n            const attempt = (keySystems)=>{\n                const keySystem = keySystems.shift();\n                this.getMediaKeysPromise(keySystem, audioCodecs, videoCodecs).then((mediaKeys)=>resolve({\n                        keySystem,\n                        mediaKeys\n                    })).catch((error)=>{\n                    if (keySystems.length) {\n                        attempt(keySystems);\n                    } else if (error instanceof EMEKeyError) {\n                        reject(error);\n                    } else {\n                        reject(new EMEKeyError({\n                            type: ErrorTypes.KEY_SYSTEM_ERROR,\n                            details: ErrorDetails.KEY_SYSTEM_NO_ACCESS,\n                            error,\n                            fatal: true\n                        }, error.message));\n                    }\n                });\n            };\n            attempt(keySystemsToAttempt);\n        });\n    }\n    requestMediaKeySystemAccess(keySystem, supportedConfigurations) {\n        const { requestMediaKeySystemAccessFunc } = this.config;\n        if (!(typeof requestMediaKeySystemAccessFunc === \"function\")) {\n            let errMessage = `Configured requestMediaKeySystemAccess is not a function ${requestMediaKeySystemAccessFunc}`;\n            if (requestMediaKeySystemAccess === null && self.location.protocol === \"http:\") {\n                errMessage = `navigator.requestMediaKeySystemAccess is not available over insecure protocol ${location.protocol}`;\n            }\n            return Promise.reject(new Error(errMessage));\n        }\n        return requestMediaKeySystemAccessFunc(keySystem, supportedConfigurations);\n    }\n    getMediaKeysPromise(keySystem, audioCodecs, videoCodecs) {\n        // This can throw, but is caught in event handler callpath\n        const mediaKeySystemConfigs = getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, this.config.drmSystemOptions);\n        const keySystemAccessPromises = this.keySystemAccessPromises[keySystem];\n        let keySystemAccess = keySystemAccessPromises == null ? void 0 : keySystemAccessPromises.keySystemAccess;\n        if (!keySystemAccess) {\n            this.log(`Requesting encrypted media \"${keySystem}\" key-system access with config: ${JSON.stringify(mediaKeySystemConfigs)}`);\n            keySystemAccess = this.requestMediaKeySystemAccess(keySystem, mediaKeySystemConfigs);\n            const _keySystemAccessPromises = this.keySystemAccessPromises[keySystem] = {\n                keySystemAccess\n            };\n            keySystemAccess.catch((error)=>{\n                this.log(`Failed to obtain access to key-system \"${keySystem}\": ${error}`);\n            });\n            return keySystemAccess.then((mediaKeySystemAccess)=>{\n                this.log(`Access for key-system \"${mediaKeySystemAccess.keySystem}\" obtained`);\n                const certificateRequest = this.fetchServerCertificate(keySystem);\n                this.log(`Create media-keys for \"${keySystem}\"`);\n                _keySystemAccessPromises.mediaKeys = mediaKeySystemAccess.createMediaKeys().then((mediaKeys)=>{\n                    this.log(`Media-keys created for \"${keySystem}\"`);\n                    return certificateRequest.then((certificate)=>{\n                        if (certificate) {\n                            return this.setMediaKeysServerCertificate(mediaKeys, keySystem, certificate);\n                        }\n                        return mediaKeys;\n                    });\n                });\n                _keySystemAccessPromises.mediaKeys.catch((error)=>{\n                    this.error(`Failed to create media-keys for \"${keySystem}\"}: ${error}`);\n                });\n                return _keySystemAccessPromises.mediaKeys;\n            });\n        }\n        return keySystemAccess.then(()=>keySystemAccessPromises.mediaKeys);\n    }\n    createMediaKeySessionContext({ decryptdata, keySystem, mediaKeys }) {\n        this.log(`Creating key-system session \"${keySystem}\" keyId: ${Hex.hexDump(decryptdata.keyId || [])}`);\n        const mediaKeysSession = mediaKeys.createSession();\n        const mediaKeySessionContext = {\n            decryptdata,\n            keySystem,\n            mediaKeys,\n            mediaKeysSession,\n            keyStatus: \"status-pending\"\n        };\n        this.mediaKeySessions.push(mediaKeySessionContext);\n        return mediaKeySessionContext;\n    }\n    renewKeySession(mediaKeySessionContext) {\n        const decryptdata = mediaKeySessionContext.decryptdata;\n        if (decryptdata.pssh) {\n            const keySessionContext = this.createMediaKeySessionContext(mediaKeySessionContext);\n            const keyId = this.getKeyIdString(decryptdata);\n            const scheme = \"cenc\";\n            this.keyIdToKeySessionPromise[keyId] = this.generateRequestWithPreferredKeySession(keySessionContext, scheme, decryptdata.pssh, \"expired\");\n        } else {\n            this.warn(`Could not renew expired session. Missing pssh initData.`);\n        }\n        this.removeSession(mediaKeySessionContext);\n    }\n    getKeyIdString(decryptdata) {\n        if (!decryptdata) {\n            throw new Error(\"Could not read keyId of undefined decryptdata\");\n        }\n        if (decryptdata.keyId === null) {\n            throw new Error(\"keyId is null\");\n        }\n        return Hex.hexDump(decryptdata.keyId);\n    }\n    updateKeySession(mediaKeySessionContext, data) {\n        var _mediaKeySessionConte;\n        const keySession = mediaKeySessionContext.mediaKeysSession;\n        this.log(`Updating key-session \"${keySession.sessionId}\" for keyID ${Hex.hexDump(((_mediaKeySessionConte = mediaKeySessionContext.decryptdata) == null ? void 0 : _mediaKeySessionConte.keyId) || [])}\n      } (data length: ${data ? data.byteLength : data})`);\n        return keySession.update(data);\n    }\n    selectKeySystemFormat(frag) {\n        const keyFormats = Object.keys(frag.levelkeys || {});\n        if (!this.keyFormatPromise) {\n            this.log(`Selecting key-system from fragment (sn: ${frag.sn} ${frag.type}: ${frag.level}) key formats ${keyFormats.join(\", \")}`);\n            this.keyFormatPromise = this.getKeyFormatPromise(keyFormats);\n        }\n        return this.keyFormatPromise;\n    }\n    getKeyFormatPromise(keyFormats) {\n        return new Promise((resolve, reject)=>{\n            const keySystemsInConfig = getKeySystemsForConfig(this.config);\n            const keySystemsToAttempt = keyFormats.map(keySystemFormatToKeySystemDomain).filter((value)=>!!value && keySystemsInConfig.indexOf(value) !== -1);\n            return this.getKeySystemSelectionPromise(keySystemsToAttempt).then(({ keySystem })=>{\n                const keySystemFormat = keySystemDomainToKeySystemFormat(keySystem);\n                if (keySystemFormat) {\n                    resolve(keySystemFormat);\n                } else {\n                    reject(new Error(`Unable to find format for key-system \"${keySystem}\"`));\n                }\n            }).catch(reject);\n        });\n    }\n    loadKey(data) {\n        const decryptdata = data.keyInfo.decryptdata;\n        const keyId = this.getKeyIdString(decryptdata);\n        const keyDetails = `(keyId: ${keyId} format: \"${decryptdata.keyFormat}\" method: ${decryptdata.method} uri: ${decryptdata.uri})`;\n        this.log(`Starting session for key ${keyDetails}`);\n        let keySessionContextPromise = this.keyIdToKeySessionPromise[keyId];\n        if (!keySessionContextPromise) {\n            keySessionContextPromise = this.keyIdToKeySessionPromise[keyId] = this.getKeySystemForKeyPromise(decryptdata).then(({ keySystem, mediaKeys })=>{\n                this.throwIfDestroyed();\n                this.log(`Handle encrypted media sn: ${data.frag.sn} ${data.frag.type}: ${data.frag.level} using key ${keyDetails}`);\n                return this.attemptSetMediaKeys(keySystem, mediaKeys).then(()=>{\n                    this.throwIfDestroyed();\n                    const keySessionContext = this.createMediaKeySessionContext({\n                        keySystem,\n                        mediaKeys,\n                        decryptdata\n                    });\n                    const scheme = \"cenc\";\n                    return this.generateRequestWithPreferredKeySession(keySessionContext, scheme, decryptdata.pssh, \"playlist-key\");\n                });\n            });\n            keySessionContextPromise.catch((error)=>this.handleError(error));\n        }\n        return keySessionContextPromise;\n    }\n    throwIfDestroyed(message = \"Invalid state\") {\n        if (!this.hls) {\n            throw new Error(\"invalid state\");\n        }\n    }\n    handleError(error) {\n        if (!this.hls) {\n            return;\n        }\n        this.error(error.message);\n        if (error instanceof EMEKeyError) {\n            this.hls.trigger(Events.ERROR, error.data);\n        } else {\n            this.hls.trigger(Events.ERROR, {\n                type: ErrorTypes.KEY_SYSTEM_ERROR,\n                details: ErrorDetails.KEY_SYSTEM_NO_KEYS,\n                error,\n                fatal: true\n            });\n        }\n    }\n    getKeySystemForKeyPromise(decryptdata) {\n        const keyId = this.getKeyIdString(decryptdata);\n        const mediaKeySessionContext = this.keyIdToKeySessionPromise[keyId];\n        if (!mediaKeySessionContext) {\n            const keySystem = keySystemFormatToKeySystemDomain(decryptdata.keyFormat);\n            const keySystemsToAttempt = keySystem ? [\n                keySystem\n            ] : getKeySystemsForConfig(this.config);\n            return this.attemptKeySystemAccess(keySystemsToAttempt);\n        }\n        return mediaKeySessionContext;\n    }\n    getKeySystemSelectionPromise(keySystemsToAttempt) {\n        if (!keySystemsToAttempt.length) {\n            keySystemsToAttempt = getKeySystemsForConfig(this.config);\n        }\n        if (keySystemsToAttempt.length === 0) {\n            throw new EMEKeyError({\n                type: ErrorTypes.KEY_SYSTEM_ERROR,\n                details: ErrorDetails.KEY_SYSTEM_NO_CONFIGURED_LICENSE,\n                fatal: true\n            }, `Missing key-system license configuration options ${JSON.stringify({\n                drmSystems: this.config.drmSystems\n            })}`);\n        }\n        return this.attemptKeySystemAccess(keySystemsToAttempt);\n    }\n    _onMediaEncrypted(event) {\n        const { initDataType, initData } = event;\n        this.debug(`\"${event.type}\" event: init data type: \"${initDataType}\"`);\n        // Ignore event when initData is null\n        if (initData === null) {\n            return;\n        }\n        let keyId;\n        let keySystemDomain;\n        if (initDataType === \"sinf\" && this.config.drmSystems[KeySystems.FAIRPLAY]) {\n            // Match sinf keyId to playlist skd://keyId=\n            const json = bin2str(new Uint8Array(initData));\n            try {\n                const sinf = base64Decode(JSON.parse(json).sinf);\n                const tenc = parseSinf(new Uint8Array(sinf));\n                if (!tenc) {\n                    return;\n                }\n                keyId = tenc.subarray(8, 24);\n                keySystemDomain = KeySystems.FAIRPLAY;\n            } catch (error) {\n                this.warn('Failed to parse sinf \"encrypted\" event message initData');\n                return;\n            }\n        } else {\n            // Support clear-lead key-session creation (otherwise depend on playlist keys)\n            const psshInfo = parsePssh(initData);\n            if (psshInfo === null) {\n                return;\n            }\n            if (psshInfo.version === 0 && psshInfo.systemId === KeySystemIds.WIDEVINE && psshInfo.data) {\n                keyId = psshInfo.data.subarray(8, 24);\n            }\n            keySystemDomain = keySystemIdToKeySystemDomain(psshInfo.systemId);\n        }\n        if (!keySystemDomain || !keyId) {\n            return;\n        }\n        const keyIdHex = Hex.hexDump(keyId);\n        const { keyIdToKeySessionPromise, mediaKeySessions } = this;\n        let keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex];\n        for(let i = 0; i < mediaKeySessions.length; i++){\n            // Match playlist key\n            const keyContext = mediaKeySessions[i];\n            const decryptdata = keyContext.decryptdata;\n            if (decryptdata.pssh || !decryptdata.keyId) {\n                continue;\n            }\n            const oldKeyIdHex = Hex.hexDump(decryptdata.keyId);\n            if (keyIdHex === oldKeyIdHex || decryptdata.uri.replace(/-/g, \"\").indexOf(keyIdHex) !== -1) {\n                keySessionContextPromise = keyIdToKeySessionPromise[oldKeyIdHex];\n                delete keyIdToKeySessionPromise[oldKeyIdHex];\n                decryptdata.pssh = new Uint8Array(initData);\n                decryptdata.keyId = keyId;\n                keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex] = keySessionContextPromise.then(()=>{\n                    return this.generateRequestWithPreferredKeySession(keyContext, initDataType, initData, \"encrypted-event-key-match\");\n                });\n                break;\n            }\n        }\n        if (!keySessionContextPromise) {\n            // Clear-lead key (not encountered in playlist)\n            keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex] = this.getKeySystemSelectionPromise([\n                keySystemDomain\n            ]).then(({ keySystem, mediaKeys })=>{\n                var _keySystemToKeySystem;\n                this.throwIfDestroyed();\n                const decryptdata = new LevelKey(\"ISO-23001-7\", keyIdHex, (_keySystemToKeySystem = keySystemDomainToKeySystemFormat(keySystem)) != null ? _keySystemToKeySystem : \"\");\n                decryptdata.pssh = new Uint8Array(initData);\n                decryptdata.keyId = keyId;\n                return this.attemptSetMediaKeys(keySystem, mediaKeys).then(()=>{\n                    this.throwIfDestroyed();\n                    const keySessionContext = this.createMediaKeySessionContext({\n                        decryptdata,\n                        keySystem,\n                        mediaKeys\n                    });\n                    return this.generateRequestWithPreferredKeySession(keySessionContext, initDataType, initData, \"encrypted-event-no-match\");\n                });\n            });\n        }\n        keySessionContextPromise.catch((error)=>this.handleError(error));\n    }\n    _onWaitingForKey(event) {\n        this.log(`\"${event.type}\" event`);\n    }\n    attemptSetMediaKeys(keySystem, mediaKeys) {\n        const queue = this.setMediaKeysQueue.slice();\n        this.log(`Setting media-keys for \"${keySystem}\"`);\n        // Only one setMediaKeys() can run at one time, and multiple setMediaKeys() operations\n        // can be queued for execution for multiple key sessions.\n        const setMediaKeysPromise = Promise.all(queue).then(()=>{\n            if (!this.media) {\n                throw new Error(\"Attempted to set mediaKeys without media element attached\");\n            }\n            return this.media.setMediaKeys(mediaKeys);\n        });\n        this.setMediaKeysQueue.push(setMediaKeysPromise);\n        return setMediaKeysPromise.then(()=>{\n            this.log(`Media-keys set for \"${keySystem}\"`);\n            queue.push(setMediaKeysPromise);\n            this.setMediaKeysQueue = this.setMediaKeysQueue.filter((p)=>queue.indexOf(p) === -1);\n        });\n    }\n    generateRequestWithPreferredKeySession(context, initDataType, initData, reason) {\n        var _this$config$drmSyste, _this$config$drmSyste2;\n        const generateRequestFilter = (_this$config$drmSyste = this.config.drmSystems) == null ? void 0 : (_this$config$drmSyste2 = _this$config$drmSyste[context.keySystem]) == null ? void 0 : _this$config$drmSyste2.generateRequest;\n        if (generateRequestFilter) {\n            try {\n                const mappedInitData = generateRequestFilter.call(this.hls, initDataType, initData, context);\n                if (!mappedInitData) {\n                    throw new Error(\"Invalid response from configured generateRequest filter\");\n                }\n                initDataType = mappedInitData.initDataType;\n                initData = context.decryptdata.pssh = mappedInitData.initData ? new Uint8Array(mappedInitData.initData) : null;\n            } catch (error) {\n                var _this$hls;\n                this.warn(error.message);\n                if ((_this$hls = this.hls) != null && _this$hls.config.debug) {\n                    throw error;\n                }\n            }\n        }\n        if (initData === null) {\n            this.log(`Skipping key-session request for \"${reason}\" (no initData)`);\n            return Promise.resolve(context);\n        }\n        const keyId = this.getKeyIdString(context.decryptdata);\n        this.log(`Generating key-session request for \"${reason}\": ${keyId} (init data type: ${initDataType} length: ${initData ? initData.byteLength : null})`);\n        const licenseStatus = new EventEmitter();\n        const onmessage = context._onmessage = (event)=>{\n            const keySession = context.mediaKeysSession;\n            if (!keySession) {\n                licenseStatus.emit(\"error\", new Error(\"invalid state\"));\n                return;\n            }\n            const { messageType, message } = event;\n            this.log(`\"${messageType}\" message event for session \"${keySession.sessionId}\" message size: ${message.byteLength}`);\n            if (messageType === \"license-request\" || messageType === \"license-renewal\") {\n                this.renewLicense(context, message).catch((error)=>{\n                    this.handleError(error);\n                    licenseStatus.emit(\"error\", error);\n                });\n            } else if (messageType === \"license-release\") {\n                if (context.keySystem === KeySystems.FAIRPLAY) {\n                    this.updateKeySession(context, strToUtf8array(\"acknowledged\"));\n                    this.removeSession(context);\n                }\n            } else {\n                this.warn(`unhandled media key message type \"${messageType}\"`);\n            }\n        };\n        const onkeystatuseschange = context._onkeystatuseschange = (event)=>{\n            const keySession = context.mediaKeysSession;\n            if (!keySession) {\n                licenseStatus.emit(\"error\", new Error(\"invalid state\"));\n                return;\n            }\n            this.onKeyStatusChange(context);\n            const keyStatus = context.keyStatus;\n            licenseStatus.emit(\"keyStatus\", keyStatus);\n            if (keyStatus === \"expired\") {\n                this.warn(`${context.keySystem} expired for key ${keyId}`);\n                this.renewKeySession(context);\n            }\n        };\n        context.mediaKeysSession.addEventListener(\"message\", onmessage);\n        context.mediaKeysSession.addEventListener(\"keystatuseschange\", onkeystatuseschange);\n        const keyUsablePromise = new Promise((resolve, reject)=>{\n            licenseStatus.on(\"error\", reject);\n            licenseStatus.on(\"keyStatus\", (keyStatus)=>{\n                if (keyStatus.startsWith(\"usable\")) {\n                    resolve();\n                } else if (keyStatus === \"output-restricted\") {\n                    reject(new EMEKeyError({\n                        type: ErrorTypes.KEY_SYSTEM_ERROR,\n                        details: ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED,\n                        fatal: false\n                    }, \"HDCP level output restricted\"));\n                } else if (keyStatus === \"internal-error\") {\n                    reject(new EMEKeyError({\n                        type: ErrorTypes.KEY_SYSTEM_ERROR,\n                        details: ErrorDetails.KEY_SYSTEM_STATUS_INTERNAL_ERROR,\n                        fatal: true\n                    }, `key status changed to \"${keyStatus}\"`));\n                } else if (keyStatus === \"expired\") {\n                    reject(new Error(\"key expired while generating request\"));\n                } else {\n                    this.warn(`unhandled key status change \"${keyStatus}\"`);\n                }\n            });\n        });\n        return context.mediaKeysSession.generateRequest(initDataType, initData).then(()=>{\n            var _context$mediaKeysSes;\n            this.log(`Request generated for key-session \"${(_context$mediaKeysSes = context.mediaKeysSession) == null ? void 0 : _context$mediaKeysSes.sessionId}\" keyId: ${keyId}`);\n        }).catch((error)=>{\n            throw new EMEKeyError({\n                type: ErrorTypes.KEY_SYSTEM_ERROR,\n                details: ErrorDetails.KEY_SYSTEM_NO_SESSION,\n                error,\n                fatal: false\n            }, `Error generating key-session request: ${error}`);\n        }).then(()=>keyUsablePromise).catch((error)=>{\n            licenseStatus.removeAllListeners();\n            this.removeSession(context);\n            throw error;\n        }).then(()=>{\n            licenseStatus.removeAllListeners();\n            return context;\n        });\n    }\n    onKeyStatusChange(mediaKeySessionContext) {\n        mediaKeySessionContext.mediaKeysSession.keyStatuses.forEach((status1, keyId)=>{\n            this.log(`key status change \"${status1}\" for keyStatuses keyId: ${Hex.hexDump(\"buffer\" in keyId ? new Uint8Array(keyId.buffer, keyId.byteOffset, keyId.byteLength) : new Uint8Array(keyId))} session keyId: ${Hex.hexDump(new Uint8Array(mediaKeySessionContext.decryptdata.keyId || []))} uri: ${mediaKeySessionContext.decryptdata.uri}`);\n            mediaKeySessionContext.keyStatus = status1;\n        });\n    }\n    fetchServerCertificate(keySystem) {\n        const config = this.config;\n        const Loader = config.loader;\n        const certLoader = new Loader(config);\n        const url = this.getServerCertificateUrl(keySystem);\n        if (!url) {\n            return Promise.resolve();\n        }\n        this.log(`Fetching server certificate for \"${keySystem}\"`);\n        return new Promise((resolve, reject)=>{\n            const loaderContext = {\n                responseType: \"arraybuffer\",\n                url\n            };\n            const loadPolicy = config.certLoadPolicy.default;\n            const loaderConfig = {\n                loadPolicy,\n                timeout: loadPolicy.maxLoadTimeMs,\n                maxRetry: 0,\n                retryDelay: 0,\n                maxRetryDelay: 0\n            };\n            const loaderCallbacks = {\n                onSuccess: (response, stats, context, networkDetails)=>{\n                    resolve(response.data);\n                },\n                onError: (response, contex, networkDetails, stats)=>{\n                    reject(new EMEKeyError({\n                        type: ErrorTypes.KEY_SYSTEM_ERROR,\n                        details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,\n                        fatal: true,\n                        networkDetails,\n                        response: _objectSpread2({\n                            url: loaderContext.url,\n                            data: undefined\n                        }, response)\n                    }, `\"${keySystem}\" certificate request failed (${url}). Status: ${response.code} (${response.text})`));\n                },\n                onTimeout: (stats, context, networkDetails)=>{\n                    reject(new EMEKeyError({\n                        type: ErrorTypes.KEY_SYSTEM_ERROR,\n                        details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,\n                        fatal: true,\n                        networkDetails,\n                        response: {\n                            url: loaderContext.url,\n                            data: undefined\n                        }\n                    }, `\"${keySystem}\" certificate request timed out (${url})`));\n                },\n                onAbort: (stats, context, networkDetails)=>{\n                    reject(new Error(\"aborted\"));\n                }\n            };\n            certLoader.load(loaderContext, loaderConfig, loaderCallbacks);\n        });\n    }\n    setMediaKeysServerCertificate(mediaKeys, keySystem, cert) {\n        return new Promise((resolve, reject)=>{\n            mediaKeys.setServerCertificate(cert).then((success)=>{\n                this.log(`setServerCertificate ${success ? \"success\" : \"not supported by CDM\"} (${cert == null ? void 0 : cert.byteLength}) on \"${keySystem}\"`);\n                resolve(mediaKeys);\n            }).catch((error)=>{\n                reject(new EMEKeyError({\n                    type: ErrorTypes.KEY_SYSTEM_ERROR,\n                    details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED,\n                    error,\n                    fatal: true\n                }, error.message));\n            });\n        });\n    }\n    renewLicense(context, keyMessage) {\n        return this.requestLicense(context, new Uint8Array(keyMessage)).then((data)=>{\n            return this.updateKeySession(context, new Uint8Array(data)).catch((error)=>{\n                throw new EMEKeyError({\n                    type: ErrorTypes.KEY_SYSTEM_ERROR,\n                    details: ErrorDetails.KEY_SYSTEM_SESSION_UPDATE_FAILED,\n                    error,\n                    fatal: true\n                }, error.message);\n            });\n        });\n    }\n    unpackPlayReadyKeyMessage(xhr, licenseChallenge) {\n        // On Edge, the raw license message is UTF-16-encoded XML.  We need\n        // to unpack the Challenge element (base64-encoded string containing the\n        // actual license request) and any HttpHeader elements (sent as request\n        // headers).\n        // For PlayReady CDMs, we need to dig the Challenge out of the XML.\n        const xmlString = String.fromCharCode.apply(null, new Uint16Array(licenseChallenge.buffer));\n        if (!xmlString.includes(\"PlayReadyKeyMessage\")) {\n            // This does not appear to be a wrapped message as on Edge.  Some\n            // clients do not need this unwrapping, so we will assume this is one of\n            // them.  Note that \"xml\" at this point probably looks like random\n            // garbage, since we interpreted UTF-8 as UTF-16.\n            xhr.setRequestHeader(\"Content-Type\", \"text/xml; charset=utf-8\");\n            return licenseChallenge;\n        }\n        const keyMessageXml = new DOMParser().parseFromString(xmlString, \"application/xml\");\n        // Set request headers.\n        const headers = keyMessageXml.querySelectorAll(\"HttpHeader\");\n        if (headers.length > 0) {\n            let header;\n            for(let i = 0, len = headers.length; i < len; i++){\n                var _header$querySelector, _header$querySelector2;\n                header = headers[i];\n                const name = (_header$querySelector = header.querySelector(\"name\")) == null ? void 0 : _header$querySelector.textContent;\n                const value = (_header$querySelector2 = header.querySelector(\"value\")) == null ? void 0 : _header$querySelector2.textContent;\n                if (name && value) {\n                    xhr.setRequestHeader(name, value);\n                }\n            }\n        }\n        const challengeElement = keyMessageXml.querySelector(\"Challenge\");\n        const challengeText = challengeElement == null ? void 0 : challengeElement.textContent;\n        if (!challengeText) {\n            throw new Error(`Cannot find <Challenge> in key message`);\n        }\n        return strToUtf8array(atob(challengeText));\n    }\n    setupLicenseXHR(xhr, url, keysListItem, licenseChallenge) {\n        const licenseXhrSetup = this.config.licenseXhrSetup;\n        if (!licenseXhrSetup) {\n            xhr.open(\"POST\", url, true);\n            return Promise.resolve({\n                xhr,\n                licenseChallenge\n            });\n        }\n        return Promise.resolve().then(()=>{\n            if (!keysListItem.decryptdata) {\n                throw new Error(\"Key removed\");\n            }\n            return licenseXhrSetup.call(this.hls, xhr, url, keysListItem, licenseChallenge);\n        }).catch((error)=>{\n            if (!keysListItem.decryptdata) {\n                // Key session removed. Cancel license request.\n                throw error;\n            }\n            // let's try to open before running setup\n            xhr.open(\"POST\", url, true);\n            return licenseXhrSetup.call(this.hls, xhr, url, keysListItem, licenseChallenge);\n        }).then((licenseXhrSetupResult)=>{\n            // if licenseXhrSetup did not yet call open, let's do it now\n            if (!xhr.readyState) {\n                xhr.open(\"POST\", url, true);\n            }\n            const finalLicenseChallenge = licenseXhrSetupResult ? licenseXhrSetupResult : licenseChallenge;\n            return {\n                xhr,\n                licenseChallenge: finalLicenseChallenge\n            };\n        });\n    }\n    requestLicense(keySessionContext, licenseChallenge) {\n        const keyLoadPolicy = this.config.keyLoadPolicy.default;\n        return new Promise((resolve, reject)=>{\n            const url = this.getLicenseServerUrl(keySessionContext.keySystem);\n            this.log(`Sending license request to URL: ${url}`);\n            const xhr = new XMLHttpRequest();\n            xhr.responseType = \"arraybuffer\";\n            xhr.onreadystatechange = ()=>{\n                if (!this.hls || !keySessionContext.mediaKeysSession) {\n                    return reject(new Error(\"invalid state\"));\n                }\n                if (xhr.readyState === 4) {\n                    if (xhr.status === 200) {\n                        this._requestLicenseFailureCount = 0;\n                        let data = xhr.response;\n                        this.log(`License received ${data instanceof ArrayBuffer ? data.byteLength : data}`);\n                        const licenseResponseCallback = this.config.licenseResponseCallback;\n                        if (licenseResponseCallback) {\n                            try {\n                                data = licenseResponseCallback.call(this.hls, xhr, url, keySessionContext);\n                            } catch (error) {\n                                this.error(error);\n                            }\n                        }\n                        resolve(data);\n                    } else {\n                        const retryConfig = keyLoadPolicy.errorRetry;\n                        const maxNumRetry = retryConfig ? retryConfig.maxNumRetry : 0;\n                        this._requestLicenseFailureCount++;\n                        if (this._requestLicenseFailureCount > maxNumRetry || xhr.status >= 400 && xhr.status < 500) {\n                            reject(new EMEKeyError({\n                                type: ErrorTypes.KEY_SYSTEM_ERROR,\n                                details: ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,\n                                fatal: true,\n                                networkDetails: xhr,\n                                response: {\n                                    url,\n                                    data: undefined,\n                                    code: xhr.status,\n                                    text: xhr.statusText\n                                }\n                            }, `License Request XHR failed (${url}). Status: ${xhr.status} (${xhr.statusText})`));\n                        } else {\n                            const attemptsLeft = maxNumRetry - this._requestLicenseFailureCount + 1;\n                            this.warn(`Retrying license request, ${attemptsLeft} attempts left`);\n                            this.requestLicense(keySessionContext, licenseChallenge).then(resolve, reject);\n                        }\n                    }\n                }\n            };\n            if (keySessionContext.licenseXhr && keySessionContext.licenseXhr.readyState !== XMLHttpRequest.DONE) {\n                keySessionContext.licenseXhr.abort();\n            }\n            keySessionContext.licenseXhr = xhr;\n            this.setupLicenseXHR(xhr, url, keySessionContext, licenseChallenge).then(({ xhr, licenseChallenge })=>{\n                if (keySessionContext.keySystem == KeySystems.PLAYREADY) {\n                    licenseChallenge = this.unpackPlayReadyKeyMessage(xhr, licenseChallenge);\n                }\n                xhr.send(licenseChallenge);\n            });\n        });\n    }\n    onMediaAttached(event, data) {\n        if (!this.config.emeEnabled) {\n            return;\n        }\n        const media = data.media;\n        // keep reference of media\n        this.media = media;\n        media.addEventListener(\"encrypted\", this.onMediaEncrypted);\n        media.addEventListener(\"waitingforkey\", this.onWaitingForKey);\n    }\n    onMediaDetached() {\n        const media = this.media;\n        const mediaKeysList = this.mediaKeySessions;\n        if (media) {\n            media.removeEventListener(\"encrypted\", this.onMediaEncrypted);\n            media.removeEventListener(\"waitingforkey\", this.onWaitingForKey);\n            this.media = null;\n        }\n        this._requestLicenseFailureCount = 0;\n        this.setMediaKeysQueue = [];\n        this.mediaKeySessions = [];\n        this.keyIdToKeySessionPromise = {};\n        LevelKey.clearKeyUriToKeyIdMap();\n        // Close all sessions and remove media keys from the video element.\n        const keySessionCount = mediaKeysList.length;\n        EMEController.CDMCleanupPromise = Promise.all(mediaKeysList.map((mediaKeySessionContext)=>this.removeSession(mediaKeySessionContext)).concat(media == null ? void 0 : media.setMediaKeys(null).catch((error)=>{\n            this.log(`Could not clear media keys: ${error}`);\n        }))).then(()=>{\n            if (keySessionCount) {\n                this.log(\"finished closing key sessions and clearing media keys\");\n                mediaKeysList.length = 0;\n            }\n        }).catch((error)=>{\n            this.log(`Could not close sessions and clear media keys: ${error}`);\n        });\n    }\n    onManifestLoading() {\n        this.keyFormatPromise = null;\n    }\n    onManifestLoaded(event, { sessionKeys }) {\n        if (!sessionKeys || !this.config.emeEnabled) {\n            return;\n        }\n        if (!this.keyFormatPromise) {\n            const keyFormats = sessionKeys.reduce((formats, sessionKey)=>{\n                if (formats.indexOf(sessionKey.keyFormat) === -1) {\n                    formats.push(sessionKey.keyFormat);\n                }\n                return formats;\n            }, []);\n            this.log(`Selecting key-system from session-keys ${keyFormats.join(\", \")}`);\n            this.keyFormatPromise = this.getKeyFormatPromise(keyFormats);\n        }\n    }\n    removeSession(mediaKeySessionContext) {\n        const { mediaKeysSession, licenseXhr } = mediaKeySessionContext;\n        if (mediaKeysSession) {\n            this.log(`Remove licenses and keys and close session ${mediaKeysSession.sessionId}`);\n            if (mediaKeySessionContext._onmessage) {\n                mediaKeysSession.removeEventListener(\"message\", mediaKeySessionContext._onmessage);\n                mediaKeySessionContext._onmessage = undefined;\n            }\n            if (mediaKeySessionContext._onkeystatuseschange) {\n                mediaKeysSession.removeEventListener(\"keystatuseschange\", mediaKeySessionContext._onkeystatuseschange);\n                mediaKeySessionContext._onkeystatuseschange = undefined;\n            }\n            if (licenseXhr && licenseXhr.readyState !== XMLHttpRequest.DONE) {\n                licenseXhr.abort();\n            }\n            mediaKeySessionContext.mediaKeysSession = mediaKeySessionContext.decryptdata = mediaKeySessionContext.licenseXhr = undefined;\n            const index = this.mediaKeySessions.indexOf(mediaKeySessionContext);\n            if (index > -1) {\n                this.mediaKeySessions.splice(index, 1);\n            }\n            return mediaKeysSession.remove().catch((error)=>{\n                this.log(`Could not remove session: ${error}`);\n            }).then(()=>{\n                return mediaKeysSession.close();\n            }).catch((error)=>{\n                this.log(`Could not close session: ${error}`);\n            });\n        }\n    }\n}\nEMEController.CDMCleanupPromise = void 0;\nclass EMEKeyError extends Error {\n    constructor(data, message){\n        super(message);\n        this.data = void 0;\n        data.error || (data.error = new Error(message));\n        this.data = data;\n        data.err = data.error;\n    }\n}\n/**\n * Common Media Object Type\n *\n * @group CMCD\n * @group CMSD\n *\n * @beta\n */ var CmObjectType;\n(function(CmObjectType) {\n    /**\n   * text file, such as a manifest or playlist\n   */ CmObjectType[\"MANIFEST\"] = \"m\";\n    /**\n   * audio only\n   */ CmObjectType[\"AUDIO\"] = \"a\";\n    /**\n   * video only\n   */ CmObjectType[\"VIDEO\"] = \"v\";\n    /**\n   * muxed audio and video\n   */ CmObjectType[\"MUXED\"] = \"av\";\n    /**\n   * init segment\n   */ CmObjectType[\"INIT\"] = \"i\";\n    /**\n   * caption or subtitle\n   */ CmObjectType[\"CAPTION\"] = \"c\";\n    /**\n   * ISOBMFF timed text track\n   */ CmObjectType[\"TIMED_TEXT\"] = \"tt\";\n    /**\n   * cryptographic key, license or certificate.\n   */ CmObjectType[\"KEY\"] = \"k\";\n    /**\n   * other\n   */ CmObjectType[\"OTHER\"] = \"o\";\n})(CmObjectType || (CmObjectType = {}));\n/**\n * Common Media Streaming Format\n *\n * @group CMCD\n * @group CMSD\n *\n * @beta\n */ var CmStreamingFormat;\n(function(CmStreamingFormat) {\n    /**\n   * MPEG DASH\n   */ CmStreamingFormat[\"DASH\"] = \"d\";\n    /**\n   * HTTP Live Streaming (HLS)\n   */ CmStreamingFormat[\"HLS\"] = \"h\";\n    /**\n   * Smooth Streaming\n   */ CmStreamingFormat[\"SMOOTH\"] = \"s\";\n    /**\n   * Other\n   */ CmStreamingFormat[\"OTHER\"] = \"o\";\n})(CmStreamingFormat || (CmStreamingFormat = {}));\n/**\n * CMCD header fields.\n *\n * @group CMCD\n *\n * @beta\n */ var CmcdHeaderField;\n(function(CmcdHeaderField) {\n    /**\n   * keys whose values vary with the object being requested.\n   */ CmcdHeaderField[\"OBJECT\"] = \"CMCD-Object\";\n    /**\n   * keys whose values vary with each request.\n   */ CmcdHeaderField[\"REQUEST\"] = \"CMCD-Request\";\n    /**\n   * keys whose values are expected to be invariant over the life of the session.\n   */ CmcdHeaderField[\"SESSION\"] = \"CMCD-Session\";\n    /**\n   * keys whose values do not vary with every request or object.\n   */ CmcdHeaderField[\"STATUS\"] = \"CMCD-Status\";\n})(CmcdHeaderField || (CmcdHeaderField = {}));\n/**\n * The map of CMCD header fields to official CMCD keys.\n *\n * @internal\n *\n * @group CMCD\n */ const CmcdHeaderMap = {\n    [CmcdHeaderField.OBJECT]: [\n        \"br\",\n        \"d\",\n        \"ot\",\n        \"tb\"\n    ],\n    [CmcdHeaderField.REQUEST]: [\n        \"bl\",\n        \"dl\",\n        \"mtp\",\n        \"nor\",\n        \"nrr\",\n        \"su\"\n    ],\n    [CmcdHeaderField.SESSION]: [\n        \"cid\",\n        \"pr\",\n        \"sf\",\n        \"sid\",\n        \"st\",\n        \"v\"\n    ],\n    [CmcdHeaderField.STATUS]: [\n        \"bs\",\n        \"rtp\"\n    ]\n};\n/**\n * Structured Field Item\n *\n * @group Structured Field\n *\n * @beta\n */ class SfItem {\n    constructor(value, params){\n        this.value = void 0;\n        this.params = void 0;\n        if (Array.isArray(value)) {\n            value = value.map((v)=>v instanceof SfItem ? v : new SfItem(v));\n        }\n        this.value = value;\n        this.params = params;\n    }\n}\n/**\n * A class to represent structured field tokens when `Symbol` is not available.\n *\n * @group Structured Field\n *\n * @beta\n */ class SfToken {\n    constructor(description){\n        this.description = void 0;\n        this.description = description;\n    }\n}\nconst DICT = \"Dict\";\nfunction format(value) {\n    if (Array.isArray(value)) {\n        return JSON.stringify(value);\n    }\n    if (value instanceof Map) {\n        return \"Map{}\";\n    }\n    if (value instanceof Set) {\n        return \"Set{}\";\n    }\n    if (typeof value === \"object\") {\n        return JSON.stringify(value);\n    }\n    return String(value);\n}\nfunction throwError(action, src, type, cause) {\n    return new Error(`failed to ${action} \"${format(src)}\" as ${type}`, {\n        cause\n    });\n}\nconst BARE_ITEM = \"Bare Item\";\nconst BOOLEAN = \"Boolean\";\nconst BYTES = \"Byte Sequence\";\nconst DECIMAL = \"Decimal\";\nconst INTEGER = \"Integer\";\nfunction isInvalidInt(value) {\n    return value < -999999999999999 || 999999999999999 < value;\n}\nconst STRING_REGEX = /[\\x00-\\x1f\\x7f]+/; // eslint-disable-line no-control-regex\nconst TOKEN = \"Token\";\nconst KEY = \"Key\";\nfunction serializeError(src, type, cause) {\n    return throwError(\"serialize\", src, type, cause);\n}\n// 4.1.9.  Serializing a Boolean\n//\n// Given a Boolean as input_boolean, return an ASCII string suitable for\n// use in a HTTP field value.\n//\n// 1.  If input_boolean is not a boolean, fail serialization.\n//\n// 2.  Let output be an empty string.\n//\n// 3.  Append \"?\" to output.\n//\n// 4.  If input_boolean is true, append \"1\" to output.\n//\n// 5.  If input_boolean is false, append \"0\" to output.\n//\n// 6.  Return output.\nfunction serializeBoolean(value) {\n    if (typeof value !== \"boolean\") {\n        throw serializeError(value, BOOLEAN);\n    }\n    return value ? \"?1\" : \"?0\";\n}\n/**\n * Encodes binary data to base64\n *\n * @param binary - The binary data to encode\n * @returns The base64 encoded string\n *\n * @group Utils\n *\n * @beta\n */ function base64encode(binary) {\n    return btoa(String.fromCharCode(...binary));\n}\n// 4.1.8.  Serializing a Byte Sequence\n//\n// Given a Byte Sequence as input_bytes, return an ASCII string suitable\n// for use in a HTTP field value.\n//\n// 1.  If input_bytes is not a sequence of bytes, fail serialization.\n//\n// 2.  Let output be an empty string.\n//\n// 3.  Append \":\" to output.\n//\n// 4.  Append the result of base64-encoding input_bytes as per\n//     [RFC4648], Section 4, taking account of the requirements below.\n//\n// 5.  Append \":\" to output.\n//\n// 6.  Return output.\n//\n// The encoded data is required to be padded with \"=\", as per [RFC4648],\n// Section 3.2.\n//\n// Likewise, encoded data SHOULD have pad bits set to zero, as per\n// [RFC4648], Section 3.5, unless it is not possible to do so due to\n// implementation constraints.\nfunction serializeByteSequence(value) {\n    if (ArrayBuffer.isView(value) === false) {\n        throw serializeError(value, BYTES);\n    }\n    return `:${base64encode(value)}:`;\n}\n// 4.1.4.  Serializing an Integer\n//\n// Given an Integer as input_integer, return an ASCII string suitable\n// for use in a HTTP field value.\n//\n// 1.  If input_integer is not an integer in the range of\n//     -999,999,999,999,999 to 999,999,999,999,999 inclusive, fail\n//     serialization.\n//\n// 2.  Let output be an empty string.\n//\n// 3.  If input_integer is less than (but not equal to) 0, append \"-\" to\n//     output.\n//\n// 4.  Append input_integer's numeric value represented in base 10 using\n//     only decimal digits to output.\n//\n// 5.  Return output.\nfunction serializeInteger(value) {\n    if (isInvalidInt(value)) {\n        throw serializeError(value, INTEGER);\n    }\n    return value.toString();\n}\n// 4.1.10.  Serializing a Date\n//\n// Given a Date as input_integer, return an ASCII string suitable for\n// use in an HTTP field value.\n// 1.  Let output be \"@\".\n// 2.  Append to output the result of running Serializing an Integer\n//     with input_date (Section 4.1.4).\n// 3.  Return output.\nfunction serializeDate(value) {\n    return `@${serializeInteger(value.getTime() / 1000)}`;\n}\n/**\n * This implements the rounding procedure described in step 2 of the \"Serializing a Decimal\" specification.\n * This rounding style is known as \"even rounding\", \"banker's rounding\", or \"commercial rounding\".\n *\n * @param value - The value to round\n * @param precision - The number of decimal places to round to\n * @returns The rounded value\n *\n * @group Utils\n *\n * @beta\n */ function roundToEven(value, precision) {\n    if (value < 0) {\n        return -roundToEven(-value, precision);\n    }\n    const decimalShift = Math.pow(10, precision);\n    const isEquidistant = Math.abs(value * decimalShift % 1 - 0.5) < Number.EPSILON;\n    if (isEquidistant) {\n        // If the tail of the decimal place is 'equidistant' we round to the nearest even value\n        const flooredValue = Math.floor(value * decimalShift);\n        return (flooredValue % 2 === 0 ? flooredValue : flooredValue + 1) / decimalShift;\n    } else {\n        // Otherwise, proceed as normal\n        return Math.round(value * decimalShift) / decimalShift;\n    }\n}\n// 4.1.5.  Serializing a Decimal\n//\n// Given a decimal number as input_decimal, return an ASCII string\n// suitable for use in a HTTP field value.\n//\n// 1.   If input_decimal is not a decimal number, fail serialization.\n//\n// 2.   If input_decimal has more than three significant digits to the\n//      right of the decimal point, round it to three decimal places,\n//      rounding the final digit to the nearest value, or to the even\n//      value if it is equidistant.\n//\n// 3.   If input_decimal has more than 12 significant digits to the left\n//      of the decimal point after rounding, fail serialization.\n//\n// 4.   Let output be an empty string.\n//\n// 5.   If input_decimal is less than (but not equal to) 0, append \"-\"\n//      to output.\n//\n// 6.   Append input_decimal's integer component represented in base 10\n//      (using only decimal digits) to output; if it is zero, append\n//      \"0\".\n//\n// 7.   Append \".\" to output.\n//\n// 8.   If input_decimal's fractional component is zero, append \"0\" to\n//      output.\n//\n// 9.   Otherwise, append the significant digits of input_decimal's\n//      fractional component represented in base 10 (using only decimal\n//      digits) to output.\n//\n// 10.  Return output.\nfunction serializeDecimal(value) {\n    const roundedValue = roundToEven(value, 3); // round to 3 decimal places\n    if (Math.floor(Math.abs(roundedValue)).toString().length > 12) {\n        throw serializeError(value, DECIMAL);\n    }\n    const stringValue = roundedValue.toString();\n    return stringValue.includes(\".\") ? stringValue : `${stringValue}.0`;\n}\nconst STRING = \"String\";\n// 4.1.6.  Serializing a String\n//\n// Given a String as input_string, return an ASCII string suitable for\n// use in a HTTP field value.\n//\n// 1.  Convert input_string into a sequence of ASCII characters; if\n//     conversion fails, fail serialization.\n//\n// 2.  If input_string contains characters in the range %x00-1f or %x7f\n//     (i.e., not in VCHAR or SP), fail serialization.\n//\n// 3.  Let output be the string DQUOTE.\n//\n// 4.  For each character char in input_string:\n//\n//     1.  If char is \"\\\" or DQUOTE:\n//\n//         1.  Append \"\\\" to output.\n//\n//     2.  Append char to output.\n//\n// 5.  Append DQUOTE to output.\n//\n// 6.  Return output.\nfunction serializeString(value) {\n    if (STRING_REGEX.test(value)) {\n        throw serializeError(value, STRING);\n    }\n    return `\"${value.replace(/\\\\/g, `\\\\\\\\`).replace(/\"/g, `\\\\\"`)}\"`;\n}\nfunction symbolToStr(symbol) {\n    return symbol.description || symbol.toString().slice(7, -1);\n}\nfunction serializeToken(token) {\n    const value = symbolToStr(token);\n    if (/^([a-zA-Z*])([!#$%&'*+\\-.^_`|~\\w:/]*)$/.test(value) === false) {\n        throw serializeError(value, TOKEN);\n    }\n    return value;\n}\n// 4.1.3.1.  Serializing a Bare Item\n//\n// Given an Item as input_item, return an ASCII string suitable for use\n// in a HTTP field value.\n//\n// 1.  If input_item is an Integer, return the result of running\n//     Serializing an Integer (Section 4.1.4) with input_item.\n//\n// 2.  If input_item is a Decimal, return the result of running\n//     Serializing a Decimal (Section 4.1.5) with input_item.\n//\n// 3.  If input_item is a String, return the result of running\n//     Serializing a String (Section 4.1.6) with input_item.\n//\n// 4.  If input_item is a Token, return the result of running\n//     Serializing a Token (Section 4.1.7) with input_item.\n//\n// 5.  If input_item is a Boolean, return the result of running\n//     Serializing a Boolean (Section 4.1.9) with input_item.\n//\n// 6.  If input_item is a Byte Sequence, return the result of running\n//     Serializing a Byte Sequence (Section 4.1.8) with input_item.\n//\n// 7.  If input_item is a Date, return the result of running Serializing\n//     a Date (Section 4.1.10) with input_item.\n//\n// 8.  Otherwise, fail serialization.\nfunction serializeBareItem(value) {\n    switch(typeof value){\n        case \"number\":\n            if (!isFiniteNumber(value)) {\n                throw serializeError(value, BARE_ITEM);\n            }\n            if (Number.isInteger(value)) {\n                return serializeInteger(value);\n            }\n            return serializeDecimal(value);\n        case \"string\":\n            return serializeString(value);\n        case \"symbol\":\n            return serializeToken(value);\n        case \"boolean\":\n            return serializeBoolean(value);\n        case \"object\":\n            if (value instanceof Date) {\n                return serializeDate(value);\n            }\n            if (value instanceof Uint8Array) {\n                return serializeByteSequence(value);\n            }\n            if (value instanceof SfToken) {\n                return serializeToken(value);\n            }\n        default:\n            // fail\n            throw serializeError(value, BARE_ITEM);\n    }\n}\n// 4.1.1.3.  Serializing a Key\n//\n// Given a key as input_key, return an ASCII string suitable for use in\n// a HTTP field value.\n//\n// 1.  Convert input_key into a sequence of ASCII characters; if\n//     conversion fails, fail serialization.\n//\n// 2.  If input_key contains characters not in lcalpha, DIGIT, \"_\", \"-\",\n//     \".\", or \"*\" fail serialization.\n//\n// 3.  If the first character of input_key is not lcalpha or \"*\", fail\n//     serialization.\n//\n// 4.  Let output be an empty string.\n//\n// 5.  Append input_key to output.\n//\n// 6.  Return output.\nfunction serializeKey(value) {\n    if (/^[a-z*][a-z0-9\\-_.*]*$/.test(value) === false) {\n        throw serializeError(value, KEY);\n    }\n    return value;\n}\n// 4.1.1.2.  Serializing Parameters\n//\n// Given an ordered Dictionary as input_parameters (each member having a\n// param_name and a param_value), return an ASCII string suitable for\n// use in a HTTP field value.\n//\n// 1.  Let output be an empty string.\n//\n// 2.  For each param_name with a value of param_value in\n//     input_parameters:\n//\n//     1.  Append \";\" to output.\n//\n//     2.  Append the result of running Serializing a Key\n//         (Section 4.1.1.3) with param_name to output.\n//\n//     3.  If param_value is not Boolean true:\n//\n//         1.  Append \"=\" to output.\n//\n//         2.  Append the result of running Serializing a bare Item\n//             (Section 4.1.3.1) with param_value to output.\n//\n// 3.  Return output.\nfunction serializeParams(params) {\n    if (params == null) {\n        return \"\";\n    }\n    return Object.entries(params).map(([key, value])=>{\n        if (value === true) {\n            return `;${serializeKey(key)}`; // omit true\n        }\n        return `;${serializeKey(key)}=${serializeBareItem(value)}`;\n    }).join(\"\");\n}\n// 4.1.3.  Serializing an Item\n//\n// Given an Item as bare_item and Parameters as item_parameters, return\n// an ASCII string suitable for use in a HTTP field value.\n//\n// 1.  Let output be an empty string.\n//\n// 2.  Append the result of running Serializing a Bare Item\n//     Section 4.1.3.1 with bare_item to output.\n//\n// 3.  Append the result of running Serializing Parameters\n//     Section 4.1.1.2 with item_parameters to output.\n//\n// 4.  Return output.\nfunction serializeItem(value) {\n    if (value instanceof SfItem) {\n        return `${serializeBareItem(value.value)}${serializeParams(value.params)}`;\n    } else {\n        return serializeBareItem(value);\n    }\n}\n// 4.1.1.1.  Serializing an Inner List\n//\n// Given an array of (member_value, parameters) tuples as inner_list,\n// and parameters as list_parameters, return an ASCII string suitable\n// for use in a HTTP field value.\n//\n// 1.  Let output be the string \"(\".\n//\n// 2.  For each (member_value, parameters) of inner_list:\n//\n//     1.  Append the result of running Serializing an Item\n//         (Section 4.1.3) with (member_value, parameters) to output.\n//\n//     2.  If more values remain in inner_list, append a single SP to\n//         output.\n//\n// 3.  Append \")\" to output.\n//\n// 4.  Append the result of running Serializing Parameters\n//     (Section 4.1.1.2) with list_parameters to output.\n//\n// 5.  Return output.\nfunction serializeInnerList(value) {\n    return `(${value.value.map(serializeItem).join(\" \")})${serializeParams(value.params)}`;\n}\n// 4.1.2.  Serializing a Dictionary\n//\n// Given an ordered Dictionary as input_dictionary (each member having a\n// member_name and a tuple value of (member_value, parameters)), return\n// an ASCII string suitable for use in a HTTP field value.\n//\n// 1.  Let output be an empty string.\n//\n// 2.  For each member_name with a value of (member_value, parameters)\n//     in input_dictionary:\n//\n//     1.  Append the result of running Serializing a Key\n//         (Section 4.1.1.3) with member's member_name to output.\n//\n//     2.  If member_value is Boolean true:\n//\n//         1.  Append the result of running Serializing Parameters\n//             (Section 4.1.1.2) with parameters to output.\n//\n//     3.  Otherwise:\n//\n//         1.  Append \"=\" to output.\n//\n//         2.  If member_value is an array, append the result of running\n//             Serializing an Inner List (Section 4.1.1.1) with\n//             (member_value, parameters) to output.\n//\n//         3.  Otherwise, append the result of running Serializing an\n//             Item (Section 4.1.3) with (member_value, parameters) to\n//             output.\n//\n//     4.  If more members remain in input_dictionary:\n//\n//         1.  Append \",\" to output.\n//\n//         2.  Append a single SP to output.\n//\n// 3.  Return output.\nfunction serializeDict(dict, options = {\n    whitespace: true\n}) {\n    if (typeof dict !== \"object\") {\n        throw serializeError(dict, DICT);\n    }\n    const entries = dict instanceof Map ? dict.entries() : Object.entries(dict);\n    const optionalWhiteSpace = options != null && options.whitespace ? \" \" : \"\";\n    return Array.from(entries).map(([key, item])=>{\n        if (item instanceof SfItem === false) {\n            item = new SfItem(item);\n        }\n        let output = serializeKey(key);\n        if (item.value === true) {\n            output += serializeParams(item.params);\n        } else {\n            output += \"=\";\n            if (Array.isArray(item.value)) {\n                output += serializeInnerList(item);\n            } else {\n                output += serializeItem(item);\n            }\n        }\n        return output;\n    }).join(`,${optionalWhiteSpace}`);\n}\n/**\n * Encode an object into a structured field dictionary\n *\n * @param input - The structured field dictionary to encode\n * @returns The structured field string\n *\n * @group Structured Field\n *\n * @beta\n */ function encodeSfDict(value, options) {\n    return serializeDict(value, options);\n}\n/**\n * Checks if the given key is a token field.\n *\n * @param key - The key to check.\n *\n * @returns `true` if the key is a token field.\n *\n * @internal\n *\n * @group CMCD\n */ const isTokenField = (key)=>key === \"ot\" || key === \"sf\" || key === \"st\";\nconst isValid = (value)=>{\n    if (typeof value === \"number\") {\n        return isFiniteNumber(value);\n    }\n    return value != null && value !== \"\" && value !== false;\n};\n/**\n * Constructs a relative path from a URL.\n *\n * @param url - The destination URL\n * @param base - The base URL\n * @returns The relative path\n *\n * @group Utils\n *\n * @beta\n */ function urlToRelativePath(url, base) {\n    const to = new URL(url);\n    const from = new URL(base);\n    if (to.origin !== from.origin) {\n        return url;\n    }\n    const toPath = to.pathname.split(\"/\").slice(1);\n    const fromPath = from.pathname.split(\"/\").slice(1, -1);\n    // remove common parents\n    while(toPath[0] === fromPath[0]){\n        toPath.shift();\n        fromPath.shift();\n    }\n    // add back paths\n    while(fromPath.length){\n        fromPath.shift();\n        toPath.unshift(\"..\");\n    }\n    return toPath.join(\"/\");\n}\n/**\n * Generate a random v4 UUID\n *\n * @returns A random v4 UUID\n *\n * @group Utils\n *\n * @beta\n */ function uuid() {\n    try {\n        return crypto.randomUUID();\n    } catch (error) {\n        try {\n            const url = URL.createObjectURL(new Blob());\n            const uuid = url.toString();\n            URL.revokeObjectURL(url);\n            return uuid.slice(uuid.lastIndexOf(\"/\") + 1);\n        } catch (error) {\n            let dt = new Date().getTime();\n            const uuid = \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c)=>{\n                const r = (dt + Math.random() * 16) % 16 | 0;\n                dt = Math.floor(dt / 16);\n                return (c == \"x\" ? r : r & 0x3 | 0x8).toString(16);\n            });\n            return uuid;\n        }\n    }\n}\nconst toRounded = (value)=>Math.round(value);\nconst toUrlSafe = (value, options)=>{\n    if (options != null && options.baseUrl) {\n        value = urlToRelativePath(value, options.baseUrl);\n    }\n    return encodeURIComponent(value);\n};\nconst toHundred = (value)=>toRounded(value / 100) * 100;\n/**\n * The default formatters for CMCD values.\n *\n * @group CMCD\n *\n * @beta\n */ const CmcdFormatters = {\n    /**\n   * Bitrate (kbps) rounded integer\n   */ br: toRounded,\n    /**\n   * Duration (milliseconds) rounded integer\n   */ d: toRounded,\n    /**\n   * Buffer Length (milliseconds) rounded nearest 100ms\n   */ bl: toHundred,\n    /**\n   * Deadline (milliseconds) rounded nearest 100ms\n   */ dl: toHundred,\n    /**\n   * Measured Throughput (kbps) rounded nearest 100kbps\n   */ mtp: toHundred,\n    /**\n   * Next Object Request URL encoded\n   */ nor: toUrlSafe,\n    /**\n   * Requested maximum throughput (kbps) rounded nearest 100kbps\n   */ rtp: toHundred,\n    /**\n   * Top Bitrate (kbps) rounded integer\n   */ tb: toRounded\n};\n/**\n * Internal CMCD processing function.\n *\n * @param obj - The CMCD object to process.\n * @param map - The mapping function to use.\n * @param options - Options for encoding.\n *\n * @internal\n *\n * @group CMCD\n */ function processCmcd(obj, options) {\n    const results = {};\n    if (obj == null || typeof obj !== \"object\") {\n        return results;\n    }\n    const keys = Object.keys(obj).sort();\n    const formatters = _extends({}, CmcdFormatters, options == null ? void 0 : options.formatters);\n    const filter = options == null ? void 0 : options.filter;\n    keys.forEach((key)=>{\n        if (filter != null && filter(key)) {\n            return;\n        }\n        let value = obj[key];\n        const formatter = formatters[key];\n        if (formatter) {\n            value = formatter(value, options);\n        }\n        // Version should only be reported if not equal to 1.\n        if (key === \"v\" && value === 1) {\n            return;\n        }\n        // Playback rate should only be sent if not equal to 1.\n        if (key == \"pr\" && value === 1) {\n            return;\n        }\n        // ignore invalid values\n        if (!isValid(value)) {\n            return;\n        }\n        if (isTokenField(key) && typeof value === \"string\") {\n            value = new SfToken(value);\n        }\n        results[key] = value;\n    });\n    return results;\n}\n/**\n * Encode a CMCD object to a string.\n *\n * @param cmcd - The CMCD object to encode.\n * @param options - Options for encoding.\n *\n * @returns The encoded CMCD string.\n *\n * @group CMCD\n *\n * @beta\n */ function encodeCmcd(cmcd, options = {}) {\n    if (!cmcd) {\n        return \"\";\n    }\n    return encodeSfDict(processCmcd(cmcd, options), _extends({\n        whitespace: false\n    }, options));\n}\n/**\n * Convert a CMCD data object to request headers\n *\n * @param cmcd - The CMCD data object to convert.\n * @param options - Options for encoding the CMCD object.\n *\n * @returns The CMCD header shards.\n *\n * @group CMCD\n *\n * @beta\n */ function toCmcdHeaders(cmcd, options = {}) {\n    if (!cmcd) {\n        return {};\n    }\n    const entries = Object.entries(cmcd);\n    const headerMap = Object.entries(CmcdHeaderMap).concat(Object.entries((options == null ? void 0 : options.customHeaderMap) || {}));\n    const shards = entries.reduce((acc, entry)=>{\n        var _headerMap$find, _acc$field;\n        const [key, value] = entry;\n        const field = ((_headerMap$find = headerMap.find((entry)=>entry[1].includes(key))) == null ? void 0 : _headerMap$find[0]) || CmcdHeaderField.REQUEST;\n        (_acc$field = acc[field]) != null ? _acc$field : acc[field] = {};\n        acc[field][key] = value;\n        return acc;\n    }, {});\n    return Object.entries(shards).reduce((acc, [field, value])=>{\n        acc[field] = encodeCmcd(value, options);\n        return acc;\n    }, {});\n}\n/**\n * Append CMCD query args to a header object.\n *\n * @param headers - The headers to append to.\n * @param cmcd - The CMCD object to append.\n * @param customHeaderMap - A map of custom CMCD keys to header fields.\n *\n * @returns The headers with the CMCD header shards appended.\n *\n * @group CMCD\n *\n * @beta\n */ function appendCmcdHeaders(headers, cmcd, options) {\n    return _extends(headers, toCmcdHeaders(cmcd, options));\n}\n/**\n * CMCD parameter name.\n *\n * @group CMCD\n *\n * @beta\n */ const CMCD_PARAM = \"CMCD\";\n/**\n * Convert a CMCD data object to a query arg.\n *\n * @param cmcd - The CMCD object to convert.\n * @param options - Options for encoding the CMCD object.\n *\n * @returns The CMCD query arg.\n *\n * @group CMCD\n *\n * @beta\n */ function toCmcdQuery(cmcd, options = {}) {\n    if (!cmcd) {\n        return \"\";\n    }\n    const params = encodeCmcd(cmcd, options);\n    return `${CMCD_PARAM}=${encodeURIComponent(params)}`;\n}\nconst REGEX = /CMCD=[^&#]+/;\n/**\n * Append CMCD query args to a URL.\n *\n * @param url - The URL to append to.\n * @param cmcd - The CMCD object to append.\n * @param options - Options for encoding the CMCD object.\n *\n * @returns The URL with the CMCD query args appended.\n *\n * @group CMCD\n *\n * @beta\n */ function appendCmcdQuery(url, cmcd, options) {\n    // TODO: Replace with URLSearchParams once we drop Safari < 10.1 & Chrome < 49 support.\n    // https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams\n    const query = toCmcdQuery(cmcd, options);\n    if (!query) {\n        return url;\n    }\n    if (REGEX.test(url)) {\n        return url.replace(REGEX, query);\n    }\n    const separator = url.includes(\"?\") ? \"&\" : \"?\";\n    return `${url}${separator}${query}`;\n}\n/**\n * Controller to deal with Common Media Client Data (CMCD)\n * @see https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf\n */ class CMCDController {\n    // eslint-disable-line no-restricted-globals\n    constructor(hls){\n        this.hls = void 0;\n        this.config = void 0;\n        this.media = void 0;\n        this.sid = void 0;\n        this.cid = void 0;\n        this.useHeaders = false;\n        this.includeKeys = void 0;\n        this.initialized = false;\n        this.starved = false;\n        this.buffering = true;\n        this.audioBuffer = void 0;\n        // eslint-disable-line no-restricted-globals\n        this.videoBuffer = void 0;\n        this.onWaiting = ()=>{\n            if (this.initialized) {\n                this.starved = true;\n            }\n            this.buffering = true;\n        };\n        this.onPlaying = ()=>{\n            if (!this.initialized) {\n                this.initialized = true;\n            }\n            this.buffering = false;\n        };\n        /**\n     * Apply CMCD data to a manifest request.\n     */ this.applyPlaylistData = (context)=>{\n            try {\n                this.apply(context, {\n                    ot: CmObjectType.MANIFEST,\n                    su: !this.initialized\n                });\n            } catch (error) {\n                logger.warn(\"Could not generate manifest CMCD data.\", error);\n            }\n        };\n        /**\n     * Apply CMCD data to a segment request\n     */ this.applyFragmentData = (context)=>{\n            try {\n                const fragment = context.frag;\n                const level = this.hls.levels[fragment.level];\n                const ot = this.getObjectType(fragment);\n                const data = {\n                    d: fragment.duration * 1000,\n                    ot\n                };\n                if (ot === CmObjectType.VIDEO || ot === CmObjectType.AUDIO || ot == CmObjectType.MUXED) {\n                    data.br = level.bitrate / 1000;\n                    data.tb = this.getTopBandwidth(ot) / 1000;\n                    data.bl = this.getBufferLength(ot);\n                }\n                this.apply(context, data);\n            } catch (error) {\n                logger.warn(\"Could not generate segment CMCD data.\", error);\n            }\n        };\n        this.hls = hls;\n        const config = this.config = hls.config;\n        const { cmcd } = config;\n        if (cmcd != null) {\n            config.pLoader = this.createPlaylistLoader();\n            config.fLoader = this.createFragmentLoader();\n            this.sid = cmcd.sessionId || uuid();\n            this.cid = cmcd.contentId;\n            this.useHeaders = cmcd.useHeaders === true;\n            this.includeKeys = cmcd.includeKeys;\n            this.registerListeners();\n        }\n    }\n    registerListeners() {\n        const hls = this.hls;\n        hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        hls.on(Events.MEDIA_DETACHED, this.onMediaDetached, this);\n        hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);\n    }\n    unregisterListeners() {\n        const hls = this.hls;\n        hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        hls.off(Events.MEDIA_DETACHED, this.onMediaDetached, this);\n        hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);\n    }\n    destroy() {\n        this.unregisterListeners();\n        this.onMediaDetached();\n        // @ts-ignore\n        this.hls = this.config = this.audioBuffer = this.videoBuffer = null;\n        // @ts-ignore\n        this.onWaiting = this.onPlaying = null;\n    }\n    onMediaAttached(event, data) {\n        this.media = data.media;\n        this.media.addEventListener(\"waiting\", this.onWaiting);\n        this.media.addEventListener(\"playing\", this.onPlaying);\n    }\n    onMediaDetached() {\n        if (!this.media) {\n            return;\n        }\n        this.media.removeEventListener(\"waiting\", this.onWaiting);\n        this.media.removeEventListener(\"playing\", this.onPlaying);\n        // @ts-ignore\n        this.media = null;\n    }\n    onBufferCreated(event, data) {\n        var _data$tracks$audio, _data$tracks$video;\n        this.audioBuffer = (_data$tracks$audio = data.tracks.audio) == null ? void 0 : _data$tracks$audio.buffer;\n        this.videoBuffer = (_data$tracks$video = data.tracks.video) == null ? void 0 : _data$tracks$video.buffer;\n    }\n    /**\n   * Create baseline CMCD data\n   */ createData() {\n        var _this$media;\n        return {\n            v: 1,\n            sf: CmStreamingFormat.HLS,\n            sid: this.sid,\n            cid: this.cid,\n            pr: (_this$media = this.media) == null ? void 0 : _this$media.playbackRate,\n            mtp: this.hls.bandwidthEstimate / 1000\n        };\n    }\n    /**\n   * Apply CMCD data to a request.\n   */ apply(context, data = {}) {\n        // apply baseline data\n        _extends(data, this.createData());\n        const isVideo = data.ot === CmObjectType.INIT || data.ot === CmObjectType.VIDEO || data.ot === CmObjectType.MUXED;\n        if (this.starved && isVideo) {\n            data.bs = true;\n            data.su = true;\n            this.starved = false;\n        }\n        if (data.su == null) {\n            data.su = this.buffering;\n        }\n        // TODO: Implement rtp, nrr, nor, dl\n        const { includeKeys } = this;\n        if (includeKeys) {\n            data = Object.keys(data).reduce((acc, key)=>{\n                includeKeys.includes(key) && (acc[key] = data[key]);\n                return acc;\n            }, {});\n        }\n        if (this.useHeaders) {\n            if (!context.headers) {\n                context.headers = {};\n            }\n            appendCmcdHeaders(context.headers, data);\n        } else {\n            context.url = appendCmcdQuery(context.url, data);\n        }\n    }\n    /**\n   * The CMCD object type.\n   */ getObjectType(fragment) {\n        const { type } = fragment;\n        if (type === \"subtitle\") {\n            return CmObjectType.TIMED_TEXT;\n        }\n        if (fragment.sn === \"initSegment\") {\n            return CmObjectType.INIT;\n        }\n        if (type === \"audio\") {\n            return CmObjectType.AUDIO;\n        }\n        if (type === \"main\") {\n            if (!this.hls.audioTracks.length) {\n                return CmObjectType.MUXED;\n            }\n            return CmObjectType.VIDEO;\n        }\n        return undefined;\n    }\n    /**\n   * Get the highest bitrate.\n   */ getTopBandwidth(type) {\n        let bitrate = 0;\n        let levels;\n        const hls = this.hls;\n        if (type === CmObjectType.AUDIO) {\n            levels = hls.audioTracks;\n        } else {\n            const max = hls.maxAutoLevel;\n            const len = max > -1 ? max + 1 : hls.levels.length;\n            levels = hls.levels.slice(0, len);\n        }\n        for (const level of levels){\n            if (level.bitrate > bitrate) {\n                bitrate = level.bitrate;\n            }\n        }\n        return bitrate > 0 ? bitrate : NaN;\n    }\n    /**\n   * Get the buffer length for a media type in milliseconds\n   */ getBufferLength(type) {\n        const media = this.hls.media;\n        const buffer = type === CmObjectType.AUDIO ? this.audioBuffer : this.videoBuffer;\n        if (!buffer || !media) {\n            return NaN;\n        }\n        const info = BufferHelper.bufferInfo(buffer, media.currentTime, this.config.maxBufferHole);\n        return info.len * 1000;\n    }\n    /**\n   * Create a playlist loader\n   */ createPlaylistLoader() {\n        const { pLoader } = this.config;\n        const apply = this.applyPlaylistData;\n        const Ctor = pLoader || this.config.loader;\n        return class CmcdPlaylistLoader {\n            constructor(config){\n                this.loader = void 0;\n                this.loader = new Ctor(config);\n            }\n            get stats() {\n                return this.loader.stats;\n            }\n            get context() {\n                return this.loader.context;\n            }\n            destroy() {\n                this.loader.destroy();\n            }\n            abort() {\n                this.loader.abort();\n            }\n            load(context, config, callbacks) {\n                apply(context);\n                this.loader.load(context, config, callbacks);\n            }\n        };\n    }\n    /**\n   * Create a playlist loader\n   */ createFragmentLoader() {\n        const { fLoader } = this.config;\n        const apply = this.applyFragmentData;\n        const Ctor = fLoader || this.config.loader;\n        return class CmcdFragmentLoader {\n            constructor(config){\n                this.loader = void 0;\n                this.loader = new Ctor(config);\n            }\n            get stats() {\n                return this.loader.stats;\n            }\n            get context() {\n                return this.loader.context;\n            }\n            destroy() {\n                this.loader.destroy();\n            }\n            abort() {\n                this.loader.abort();\n            }\n            load(context, config, callbacks) {\n                apply(context);\n                this.loader.load(context, config, callbacks);\n            }\n        };\n    }\n}\nconst PATHWAY_PENALTY_DURATION_MS = 300000;\nclass ContentSteeringController {\n    constructor(hls){\n        this.hls = void 0;\n        this.log = void 0;\n        this.loader = null;\n        this.uri = null;\n        this.pathwayId = \".\";\n        this.pathwayPriority = null;\n        this.timeToLoad = 300;\n        this.reloadTimer = -1;\n        this.updated = 0;\n        this.started = false;\n        this.enabled = true;\n        this.levels = null;\n        this.audioTracks = null;\n        this.subtitleTracks = null;\n        this.penalizedPathways = {};\n        this.hls = hls;\n        this.log = logger.log.bind(logger, `[content-steering]:`);\n        this.registerListeners();\n    }\n    registerListeners() {\n        const hls = this.hls;\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n        hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n        hls.on(Events.ERROR, this.onError, this);\n    }\n    unregisterListeners() {\n        const hls = this.hls;\n        if (!hls) {\n            return;\n        }\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n        hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n        hls.off(Events.ERROR, this.onError, this);\n    }\n    startLoad() {\n        this.started = true;\n        this.clearTimeout();\n        if (this.enabled && this.uri) {\n            if (this.updated) {\n                const ttl = this.timeToLoad * 1000 - (performance.now() - this.updated);\n                if (ttl > 0) {\n                    this.scheduleRefresh(this.uri, ttl);\n                    return;\n                }\n            }\n            this.loadSteeringManifest(this.uri);\n        }\n    }\n    stopLoad() {\n        this.started = false;\n        if (this.loader) {\n            this.loader.destroy();\n            this.loader = null;\n        }\n        this.clearTimeout();\n    }\n    clearTimeout() {\n        if (this.reloadTimer !== -1) {\n            self.clearTimeout(this.reloadTimer);\n            this.reloadTimer = -1;\n        }\n    }\n    destroy() {\n        this.unregisterListeners();\n        this.stopLoad();\n        // @ts-ignore\n        this.hls = null;\n        this.levels = this.audioTracks = this.subtitleTracks = null;\n    }\n    removeLevel(levelToRemove) {\n        const levels = this.levels;\n        if (levels) {\n            this.levels = levels.filter((level)=>level !== levelToRemove);\n        }\n    }\n    onManifestLoading() {\n        this.stopLoad();\n        this.enabled = true;\n        this.timeToLoad = 300;\n        this.updated = 0;\n        this.uri = null;\n        this.pathwayId = \".\";\n        this.levels = this.audioTracks = this.subtitleTracks = null;\n    }\n    onManifestLoaded(event, data) {\n        const { contentSteering } = data;\n        if (contentSteering === null) {\n            return;\n        }\n        this.pathwayId = contentSteering.pathwayId;\n        this.uri = contentSteering.uri;\n        if (this.started) {\n            this.startLoad();\n        }\n    }\n    onManifestParsed(event, data) {\n        this.audioTracks = data.audioTracks;\n        this.subtitleTracks = data.subtitleTracks;\n    }\n    onError(event, data) {\n        const { errorAction } = data;\n        if ((errorAction == null ? void 0 : errorAction.action) === NetworkErrorAction.SendAlternateToPenaltyBox && errorAction.flags === ErrorActionFlags.MoveAllAlternatesMatchingHost) {\n            const levels = this.levels;\n            let pathwayPriority = this.pathwayPriority;\n            let errorPathway = this.pathwayId;\n            if (data.context) {\n                const { groupId, pathwayId, type } = data.context;\n                if (groupId && levels) {\n                    errorPathway = this.getPathwayForGroupId(groupId, type, errorPathway);\n                } else if (pathwayId) {\n                    errorPathway = pathwayId;\n                }\n            }\n            if (!(errorPathway in this.penalizedPathways)) {\n                this.penalizedPathways[errorPathway] = performance.now();\n            }\n            if (!pathwayPriority && levels) {\n                // If PATHWAY-PRIORITY was not provided, list pathways for error handling\n                pathwayPriority = levels.reduce((pathways, level)=>{\n                    if (pathways.indexOf(level.pathwayId) === -1) {\n                        pathways.push(level.pathwayId);\n                    }\n                    return pathways;\n                }, []);\n            }\n            if (pathwayPriority && pathwayPriority.length > 1) {\n                this.updatePathwayPriority(pathwayPriority);\n                errorAction.resolved = this.pathwayId !== errorPathway;\n            }\n            if (!errorAction.resolved) {\n                logger.warn(`Could not resolve ${data.details} (\"${data.error.message}\") with content-steering for Pathway: ${errorPathway} levels: ${levels ? levels.length : levels} priorities: ${JSON.stringify(pathwayPriority)} penalized: ${JSON.stringify(this.penalizedPathways)}`);\n            }\n        }\n    }\n    filterParsedLevels(levels) {\n        // Filter levels to only include those that are in the initial pathway\n        this.levels = levels;\n        let pathwayLevels = this.getLevelsForPathway(this.pathwayId);\n        if (pathwayLevels.length === 0) {\n            const pathwayId = levels[0].pathwayId;\n            this.log(`No levels found in Pathway ${this.pathwayId}. Setting initial Pathway to \"${pathwayId}\"`);\n            pathwayLevels = this.getLevelsForPathway(pathwayId);\n            this.pathwayId = pathwayId;\n        }\n        if (pathwayLevels.length !== levels.length) {\n            this.log(`Found ${pathwayLevels.length}/${levels.length} levels in Pathway \"${this.pathwayId}\"`);\n            return pathwayLevels;\n        }\n        return levels;\n    }\n    getLevelsForPathway(pathwayId) {\n        if (this.levels === null) {\n            return [];\n        }\n        return this.levels.filter((level)=>pathwayId === level.pathwayId);\n    }\n    updatePathwayPriority(pathwayPriority) {\n        this.pathwayPriority = pathwayPriority;\n        let levels;\n        // Evaluate if we should remove the pathway from the penalized list\n        const penalizedPathways = this.penalizedPathways;\n        const now = performance.now();\n        Object.keys(penalizedPathways).forEach((pathwayId)=>{\n            if (now - penalizedPathways[pathwayId] > PATHWAY_PENALTY_DURATION_MS) {\n                delete penalizedPathways[pathwayId];\n            }\n        });\n        for(let i = 0; i < pathwayPriority.length; i++){\n            const pathwayId = pathwayPriority[i];\n            if (pathwayId in penalizedPathways) {\n                continue;\n            }\n            if (pathwayId === this.pathwayId) {\n                return;\n            }\n            const selectedIndex = this.hls.nextLoadLevel;\n            const selectedLevel = this.hls.levels[selectedIndex];\n            levels = this.getLevelsForPathway(pathwayId);\n            if (levels.length > 0) {\n                this.log(`Setting Pathway to \"${pathwayId}\"`);\n                this.pathwayId = pathwayId;\n                reassignFragmentLevelIndexes(levels);\n                this.hls.trigger(Events.LEVELS_UPDATED, {\n                    levels\n                });\n                // Set LevelController's level to trigger LEVEL_SWITCHING which loads playlist if needed\n                const levelAfterChange = this.hls.levels[selectedIndex];\n                if (selectedLevel && levelAfterChange && this.levels) {\n                    if (levelAfterChange.attrs[\"STABLE-VARIANT-ID\"] !== selectedLevel.attrs[\"STABLE-VARIANT-ID\"] && levelAfterChange.bitrate !== selectedLevel.bitrate) {\n                        this.log(`Unstable Pathways change from bitrate ${selectedLevel.bitrate} to ${levelAfterChange.bitrate}`);\n                    }\n                    this.hls.nextLoadLevel = selectedIndex;\n                }\n                break;\n            }\n        }\n    }\n    getPathwayForGroupId(groupId, type, defaultPathway) {\n        const levels = this.getLevelsForPathway(defaultPathway).concat(this.levels || []);\n        for(let i = 0; i < levels.length; i++){\n            if (type === PlaylistContextType.AUDIO_TRACK && levels[i].hasAudioGroup(groupId) || type === PlaylistContextType.SUBTITLE_TRACK && levels[i].hasSubtitleGroup(groupId)) {\n                return levels[i].pathwayId;\n            }\n        }\n        return defaultPathway;\n    }\n    clonePathways(pathwayClones) {\n        const levels = this.levels;\n        if (!levels) {\n            return;\n        }\n        const audioGroupCloneMap = {};\n        const subtitleGroupCloneMap = {};\n        pathwayClones.forEach((pathwayClone)=>{\n            const { ID: cloneId, \"BASE-ID\": baseId, \"URI-REPLACEMENT\": uriReplacement } = pathwayClone;\n            if (levels.some((level)=>level.pathwayId === cloneId)) {\n                return;\n            }\n            const clonedVariants = this.getLevelsForPathway(baseId).map((baseLevel)=>{\n                const attributes = new AttrList(baseLevel.attrs);\n                attributes[\"PATHWAY-ID\"] = cloneId;\n                const clonedAudioGroupId = attributes.AUDIO && `${attributes.AUDIO}_clone_${cloneId}`;\n                const clonedSubtitleGroupId = attributes.SUBTITLES && `${attributes.SUBTITLES}_clone_${cloneId}`;\n                if (clonedAudioGroupId) {\n                    audioGroupCloneMap[attributes.AUDIO] = clonedAudioGroupId;\n                    attributes.AUDIO = clonedAudioGroupId;\n                }\n                if (clonedSubtitleGroupId) {\n                    subtitleGroupCloneMap[attributes.SUBTITLES] = clonedSubtitleGroupId;\n                    attributes.SUBTITLES = clonedSubtitleGroupId;\n                }\n                const url = performUriReplacement(baseLevel.uri, attributes[\"STABLE-VARIANT-ID\"], \"PER-VARIANT-URIS\", uriReplacement);\n                const clonedLevel = new Level({\n                    attrs: attributes,\n                    audioCodec: baseLevel.audioCodec,\n                    bitrate: baseLevel.bitrate,\n                    height: baseLevel.height,\n                    name: baseLevel.name,\n                    url,\n                    videoCodec: baseLevel.videoCodec,\n                    width: baseLevel.width\n                });\n                if (baseLevel.audioGroups) {\n                    for(let i = 1; i < baseLevel.audioGroups.length; i++){\n                        clonedLevel.addGroupId(\"audio\", `${baseLevel.audioGroups[i]}_clone_${cloneId}`);\n                    }\n                }\n                if (baseLevel.subtitleGroups) {\n                    for(let i = 1; i < baseLevel.subtitleGroups.length; i++){\n                        clonedLevel.addGroupId(\"text\", `${baseLevel.subtitleGroups[i]}_clone_${cloneId}`);\n                    }\n                }\n                return clonedLevel;\n            });\n            levels.push(...clonedVariants);\n            cloneRenditionGroups(this.audioTracks, audioGroupCloneMap, uriReplacement, cloneId);\n            cloneRenditionGroups(this.subtitleTracks, subtitleGroupCloneMap, uriReplacement, cloneId);\n        });\n    }\n    loadSteeringManifest(uri) {\n        const config = this.hls.config;\n        const Loader = config.loader;\n        if (this.loader) {\n            this.loader.destroy();\n        }\n        this.loader = new Loader(config);\n        let url;\n        try {\n            url = new self.URL(uri);\n        } catch (error) {\n            this.enabled = false;\n            this.log(`Failed to parse Steering Manifest URI: ${uri}`);\n            return;\n        }\n        if (url.protocol !== \"data:\") {\n            const throughput = (this.hls.bandwidthEstimate || config.abrEwmaDefaultEstimate) | 0;\n            url.searchParams.set(\"_HLS_pathway\", this.pathwayId);\n            url.searchParams.set(\"_HLS_throughput\", \"\" + throughput);\n        }\n        const context = {\n            responseType: \"json\",\n            url: url.href\n        };\n        const loadPolicy = config.steeringManifestLoadPolicy.default;\n        const legacyRetryCompatibility = loadPolicy.errorRetry || loadPolicy.timeoutRetry || {};\n        const loaderConfig = {\n            loadPolicy,\n            timeout: loadPolicy.maxLoadTimeMs,\n            maxRetry: legacyRetryCompatibility.maxNumRetry || 0,\n            retryDelay: legacyRetryCompatibility.retryDelayMs || 0,\n            maxRetryDelay: legacyRetryCompatibility.maxRetryDelayMs || 0\n        };\n        const callbacks = {\n            onSuccess: (response, stats, context, networkDetails)=>{\n                this.log(`Loaded steering manifest: \"${url}\"`);\n                const steeringData = response.data;\n                if (steeringData.VERSION !== 1) {\n                    this.log(`Steering VERSION ${steeringData.VERSION} not supported!`);\n                    return;\n                }\n                this.updated = performance.now();\n                this.timeToLoad = steeringData.TTL;\n                const { \"RELOAD-URI\": reloadUri, \"PATHWAY-CLONES\": pathwayClones, \"PATHWAY-PRIORITY\": pathwayPriority } = steeringData;\n                if (reloadUri) {\n                    try {\n                        this.uri = new self.URL(reloadUri, url).href;\n                    } catch (error) {\n                        this.enabled = false;\n                        this.log(`Failed to parse Steering Manifest RELOAD-URI: ${reloadUri}`);\n                        return;\n                    }\n                }\n                this.scheduleRefresh(this.uri || context.url);\n                if (pathwayClones) {\n                    this.clonePathways(pathwayClones);\n                }\n                const loadedSteeringData = {\n                    steeringManifest: steeringData,\n                    url: url.toString()\n                };\n                this.hls.trigger(Events.STEERING_MANIFEST_LOADED, loadedSteeringData);\n                if (pathwayPriority) {\n                    this.updatePathwayPriority(pathwayPriority);\n                }\n            },\n            onError: (error, context, networkDetails, stats)=>{\n                this.log(`Error loading steering manifest: ${error.code} ${error.text} (${context.url})`);\n                this.stopLoad();\n                if (error.code === 410) {\n                    this.enabled = false;\n                    this.log(`Steering manifest ${context.url} no longer available`);\n                    return;\n                }\n                let ttl = this.timeToLoad * 1000;\n                if (error.code === 429) {\n                    const loader = this.loader;\n                    if (typeof (loader == null ? void 0 : loader.getResponseHeader) === \"function\") {\n                        const retryAfter = loader.getResponseHeader(\"Retry-After\");\n                        if (retryAfter) {\n                            ttl = parseFloat(retryAfter) * 1000;\n                        }\n                    }\n                    this.log(`Steering manifest ${context.url} rate limited`);\n                    return;\n                }\n                this.scheduleRefresh(this.uri || context.url, ttl);\n            },\n            onTimeout: (stats, context, networkDetails)=>{\n                this.log(`Timeout loading steering manifest (${context.url})`);\n                this.scheduleRefresh(this.uri || context.url);\n            }\n        };\n        this.log(`Requesting steering manifest: ${url}`);\n        this.loader.load(context, loaderConfig, callbacks);\n    }\n    scheduleRefresh(uri, ttlMs = this.timeToLoad * 1000) {\n        this.clearTimeout();\n        this.reloadTimer = self.setTimeout(()=>{\n            var _this$hls;\n            const media = (_this$hls = this.hls) == null ? void 0 : _this$hls.media;\n            if (media && !media.ended) {\n                this.loadSteeringManifest(uri);\n                return;\n            }\n            this.scheduleRefresh(uri, this.timeToLoad * 1000);\n        }, ttlMs);\n    }\n}\nfunction cloneRenditionGroups(tracks, groupCloneMap, uriReplacement, cloneId) {\n    if (!tracks) {\n        return;\n    }\n    Object.keys(groupCloneMap).forEach((audioGroupId)=>{\n        const clonedTracks = tracks.filter((track)=>track.groupId === audioGroupId).map((track)=>{\n            const clonedTrack = _extends({}, track);\n            clonedTrack.details = undefined;\n            clonedTrack.attrs = new AttrList(clonedTrack.attrs);\n            clonedTrack.url = clonedTrack.attrs.URI = performUriReplacement(track.url, track.attrs[\"STABLE-RENDITION-ID\"], \"PER-RENDITION-URIS\", uriReplacement);\n            clonedTrack.groupId = clonedTrack.attrs[\"GROUP-ID\"] = groupCloneMap[audioGroupId];\n            clonedTrack.attrs[\"PATHWAY-ID\"] = cloneId;\n            return clonedTrack;\n        });\n        tracks.push(...clonedTracks);\n    });\n}\nfunction performUriReplacement(uri, stableId, perOptionKey, uriReplacement) {\n    const { HOST: host, PARAMS: params, [perOptionKey]: perOptionUris } = uriReplacement;\n    let perVariantUri;\n    if (stableId) {\n        perVariantUri = perOptionUris == null ? void 0 : perOptionUris[stableId];\n        if (perVariantUri) {\n            uri = perVariantUri;\n        }\n    }\n    const url = new self.URL(uri);\n    if (host && !perVariantUri) {\n        url.host = host;\n    }\n    if (params) {\n        Object.keys(params).sort().forEach((key)=>{\n            if (key) {\n                url.searchParams.set(key, params[key]);\n            }\n        });\n    }\n    return url.href;\n}\nconst AGE_HEADER_LINE_REGEX = /^age:\\s*[\\d.]+\\s*$/im;\nclass XhrLoader {\n    constructor(config){\n        this.xhrSetup = void 0;\n        this.requestTimeout = void 0;\n        this.retryTimeout = void 0;\n        this.retryDelay = void 0;\n        this.config = null;\n        this.callbacks = null;\n        this.context = null;\n        this.loader = null;\n        this.stats = void 0;\n        this.xhrSetup = config ? config.xhrSetup || null : null;\n        this.stats = new LoadStats();\n        this.retryDelay = 0;\n    }\n    destroy() {\n        this.callbacks = null;\n        this.abortInternal();\n        this.loader = null;\n        this.config = null;\n        this.context = null;\n        this.xhrSetup = null;\n        // @ts-ignore\n        this.stats = null;\n    }\n    abortInternal() {\n        const loader = this.loader;\n        self.clearTimeout(this.requestTimeout);\n        self.clearTimeout(this.retryTimeout);\n        if (loader) {\n            loader.onreadystatechange = null;\n            loader.onprogress = null;\n            if (loader.readyState !== 4) {\n                this.stats.aborted = true;\n                loader.abort();\n            }\n        }\n    }\n    abort() {\n        var _this$callbacks;\n        this.abortInternal();\n        if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {\n            this.callbacks.onAbort(this.stats, this.context, this.loader);\n        }\n    }\n    load(context, config, callbacks) {\n        if (this.stats.loading.start) {\n            throw new Error(\"Loader can only be used once.\");\n        }\n        this.stats.loading.start = self.performance.now();\n        this.context = context;\n        this.config = config;\n        this.callbacks = callbacks;\n        this.loadInternal();\n    }\n    loadInternal() {\n        const { config, context } = this;\n        if (!config || !context) {\n            return;\n        }\n        const xhr = this.loader = new self.XMLHttpRequest();\n        const stats = this.stats;\n        stats.loading.first = 0;\n        stats.loaded = 0;\n        stats.aborted = false;\n        const xhrSetup = this.xhrSetup;\n        if (xhrSetup) {\n            Promise.resolve().then(()=>{\n                if (this.stats.aborted) return;\n                return xhrSetup(xhr, context.url);\n            }).catch((error)=>{\n                xhr.open(\"GET\", context.url, true);\n                return xhrSetup(xhr, context.url);\n            }).then(()=>{\n                if (this.stats.aborted) return;\n                this.openAndSendXhr(xhr, context, config);\n            }).catch((error)=>{\n                // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS\n                this.callbacks.onError({\n                    code: xhr.status,\n                    text: error.message\n                }, context, xhr, stats);\n                return;\n            });\n        } else {\n            this.openAndSendXhr(xhr, context, config);\n        }\n    }\n    openAndSendXhr(xhr, context, config) {\n        if (!xhr.readyState) {\n            xhr.open(\"GET\", context.url, true);\n        }\n        const headers = context.headers;\n        const { maxTimeToFirstByteMs, maxLoadTimeMs } = config.loadPolicy;\n        if (headers) {\n            for(const header in headers){\n                xhr.setRequestHeader(header, headers[header]);\n            }\n        }\n        if (context.rangeEnd) {\n            xhr.setRequestHeader(\"Range\", \"bytes=\" + context.rangeStart + \"-\" + (context.rangeEnd - 1));\n        }\n        xhr.onreadystatechange = this.readystatechange.bind(this);\n        xhr.onprogress = this.loadprogress.bind(this);\n        xhr.responseType = context.responseType;\n        // setup timeout before we perform request\n        self.clearTimeout(this.requestTimeout);\n        config.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;\n        this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.timeout);\n        xhr.send();\n    }\n    readystatechange() {\n        const { context, loader: xhr, stats } = this;\n        if (!context || !xhr) {\n            return;\n        }\n        const readyState = xhr.readyState;\n        const config = this.config;\n        // don't proceed if xhr has been aborted\n        if (stats.aborted) {\n            return;\n        }\n        // >= HEADERS_RECEIVED\n        if (readyState >= 2) {\n            if (stats.loading.first === 0) {\n                stats.loading.first = Math.max(self.performance.now(), stats.loading.start);\n                // readyState >= 2 AND readyState !==4 (readyState = HEADERS_RECEIVED || LOADING) rearm timeout as xhr not finished yet\n                if (config.timeout !== config.loadPolicy.maxLoadTimeMs) {\n                    self.clearTimeout(this.requestTimeout);\n                    config.timeout = config.loadPolicy.maxLoadTimeMs;\n                    this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.loadPolicy.maxLoadTimeMs - (stats.loading.first - stats.loading.start));\n                }\n            }\n            if (readyState === 4) {\n                self.clearTimeout(this.requestTimeout);\n                xhr.onreadystatechange = null;\n                xhr.onprogress = null;\n                const status1 = xhr.status;\n                // http status between 200 to 299 are all successful\n                const useResponse = xhr.responseType !== \"text\";\n                if (status1 >= 200 && status1 < 300 && (useResponse && xhr.response || xhr.responseText !== null)) {\n                    stats.loading.end = Math.max(self.performance.now(), stats.loading.first);\n                    const data = useResponse ? xhr.response : xhr.responseText;\n                    const len = xhr.responseType === \"arraybuffer\" ? data.byteLength : data.length;\n                    stats.loaded = stats.total = len;\n                    stats.bwEstimate = stats.total * 8000 / (stats.loading.end - stats.loading.first);\n                    if (!this.callbacks) {\n                        return;\n                    }\n                    const onProgress = this.callbacks.onProgress;\n                    if (onProgress) {\n                        onProgress(stats, context, data, xhr);\n                    }\n                    if (!this.callbacks) {\n                        return;\n                    }\n                    const response = {\n                        url: xhr.responseURL,\n                        data: data,\n                        code: status1\n                    };\n                    this.callbacks.onSuccess(response, stats, context, xhr);\n                } else {\n                    const retryConfig = config.loadPolicy.errorRetry;\n                    const retryCount = stats.retry;\n                    // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error\n                    const response = {\n                        url: context.url,\n                        data: undefined,\n                        code: status1\n                    };\n                    if (shouldRetry(retryConfig, retryCount, false, response)) {\n                        this.retry(retryConfig);\n                    } else {\n                        logger.error(`${status1} while loading ${context.url}`);\n                        this.callbacks.onError({\n                            code: status1,\n                            text: xhr.statusText\n                        }, context, xhr, stats);\n                    }\n                }\n            }\n        }\n    }\n    loadtimeout() {\n        var _this$config;\n        const retryConfig = (_this$config = this.config) == null ? void 0 : _this$config.loadPolicy.timeoutRetry;\n        const retryCount = this.stats.retry;\n        if (shouldRetry(retryConfig, retryCount, true)) {\n            this.retry(retryConfig);\n        } else {\n            var _this$context;\n            logger.warn(`timeout while loading ${(_this$context = this.context) == null ? void 0 : _this$context.url}`);\n            const callbacks = this.callbacks;\n            if (callbacks) {\n                this.abortInternal();\n                callbacks.onTimeout(this.stats, this.context, this.loader);\n            }\n        }\n    }\n    retry(retryConfig) {\n        const { context, stats } = this;\n        this.retryDelay = getRetryDelay(retryConfig, stats.retry);\n        stats.retry++;\n        logger.warn(`${status ? \"HTTP Status \" + status : \"Timeout\"} while loading ${context == null ? void 0 : context.url}, retrying ${stats.retry}/${retryConfig.maxNumRetry} in ${this.retryDelay}ms`);\n        // abort and reset internal state\n        this.abortInternal();\n        this.loader = null;\n        // schedule retry\n        self.clearTimeout(this.retryTimeout);\n        this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay);\n    }\n    loadprogress(event) {\n        const stats = this.stats;\n        stats.loaded = event.loaded;\n        if (event.lengthComputable) {\n            stats.total = event.total;\n        }\n    }\n    getCacheAge() {\n        let result = null;\n        if (this.loader && AGE_HEADER_LINE_REGEX.test(this.loader.getAllResponseHeaders())) {\n            const ageHeader = this.loader.getResponseHeader(\"age\");\n            result = ageHeader ? parseFloat(ageHeader) : null;\n        }\n        return result;\n    }\n    getResponseHeader(name) {\n        if (this.loader && new RegExp(`^${name}:\\\\s*[\\\\d.]+\\\\s*$`, \"im\").test(this.loader.getAllResponseHeaders())) {\n            return this.loader.getResponseHeader(name);\n        }\n        return null;\n    }\n}\nfunction fetchSupported() {\n    if (// @ts-ignore\n    self.fetch && self.AbortController && self.ReadableStream && self.Request) {\n        try {\n            new self.ReadableStream({}); // eslint-disable-line no-new\n            return true;\n        } catch (e) {\n        /* noop */ }\n    }\n    return false;\n}\nconst BYTERANGE = /(\\d+)-(\\d+)\\/(\\d+)/;\nclass FetchLoader {\n    constructor(config /* HlsConfig */ ){\n        this.fetchSetup = void 0;\n        this.requestTimeout = void 0;\n        this.request = null;\n        this.response = null;\n        this.controller = void 0;\n        this.context = null;\n        this.config = null;\n        this.callbacks = null;\n        this.stats = void 0;\n        this.loader = null;\n        this.fetchSetup = config.fetchSetup || getRequest;\n        this.controller = new self.AbortController();\n        this.stats = new LoadStats();\n    }\n    destroy() {\n        this.loader = this.callbacks = this.context = this.config = this.request = null;\n        this.abortInternal();\n        this.response = null;\n        // @ts-ignore\n        this.fetchSetup = this.controller = this.stats = null;\n    }\n    abortInternal() {\n        if (this.controller && !this.stats.loading.end) {\n            this.stats.aborted = true;\n            this.controller.abort();\n        }\n    }\n    abort() {\n        var _this$callbacks;\n        this.abortInternal();\n        if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {\n            this.callbacks.onAbort(this.stats, this.context, this.response);\n        }\n    }\n    load(context, config, callbacks) {\n        const stats = this.stats;\n        if (stats.loading.start) {\n            throw new Error(\"Loader can only be used once.\");\n        }\n        stats.loading.start = self.performance.now();\n        const initParams = getRequestParameters(context, this.controller.signal);\n        const onProgress = callbacks.onProgress;\n        const isArrayBuffer = context.responseType === \"arraybuffer\";\n        const LENGTH = isArrayBuffer ? \"byteLength\" : \"length\";\n        const { maxTimeToFirstByteMs, maxLoadTimeMs } = config.loadPolicy;\n        this.context = context;\n        this.config = config;\n        this.callbacks = callbacks;\n        this.request = this.fetchSetup(context, initParams);\n        self.clearTimeout(this.requestTimeout);\n        config.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;\n        this.requestTimeout = self.setTimeout(()=>{\n            this.abortInternal();\n            callbacks.onTimeout(stats, context, this.response);\n        }, config.timeout);\n        self.fetch(this.request).then((response)=>{\n            this.response = this.loader = response;\n            const first = Math.max(self.performance.now(), stats.loading.start);\n            self.clearTimeout(this.requestTimeout);\n            config.timeout = maxLoadTimeMs;\n            this.requestTimeout = self.setTimeout(()=>{\n                this.abortInternal();\n                callbacks.onTimeout(stats, context, this.response);\n            }, maxLoadTimeMs - (first - stats.loading.start));\n            if (!response.ok) {\n                const { status: status1, statusText } = response;\n                throw new FetchError(statusText || \"fetch, bad network response\", status1, response);\n            }\n            stats.loading.first = first;\n            stats.total = getContentLength(response.headers) || stats.total;\n            if (onProgress && isFiniteNumber(config.highWaterMark)) {\n                return this.loadProgressively(response, stats, context, config.highWaterMark, onProgress);\n            }\n            if (isArrayBuffer) {\n                return response.arrayBuffer();\n            }\n            if (context.responseType === \"json\") {\n                return response.json();\n            }\n            return response.text();\n        }).then((responseData)=>{\n            const response = this.response;\n            if (!response) {\n                throw new Error(\"loader destroyed\");\n            }\n            self.clearTimeout(this.requestTimeout);\n            stats.loading.end = Math.max(self.performance.now(), stats.loading.first);\n            const total = responseData[LENGTH];\n            if (total) {\n                stats.loaded = stats.total = total;\n            }\n            const loaderResponse = {\n                url: response.url,\n                data: responseData,\n                code: response.status\n            };\n            if (onProgress && !isFiniteNumber(config.highWaterMark)) {\n                onProgress(stats, context, responseData, response);\n            }\n            callbacks.onSuccess(loaderResponse, stats, context, response);\n        }).catch((error)=>{\n            self.clearTimeout(this.requestTimeout);\n            if (stats.aborted) {\n                return;\n            }\n            // CORS errors result in an undefined code. Set it to 0 here to align with XHR's behavior\n            // when destroying, 'error' itself can be undefined\n            const code = !error ? 0 : error.code || 0;\n            const text = !error ? null : error.message;\n            callbacks.onError({\n                code,\n                text\n            }, context, error ? error.details : null, stats);\n        });\n    }\n    getCacheAge() {\n        let result = null;\n        if (this.response) {\n            const ageHeader = this.response.headers.get(\"age\");\n            result = ageHeader ? parseFloat(ageHeader) : null;\n        }\n        return result;\n    }\n    getResponseHeader(name) {\n        return this.response ? this.response.headers.get(name) : null;\n    }\n    loadProgressively(response, stats, context, highWaterMark = 0, onProgress) {\n        const chunkCache = new ChunkCache();\n        const reader = response.body.getReader();\n        const pump = ()=>{\n            return reader.read().then((data)=>{\n                if (data.done) {\n                    if (chunkCache.dataLength) {\n                        onProgress(stats, context, chunkCache.flush(), response);\n                    }\n                    return Promise.resolve(new ArrayBuffer(0));\n                }\n                const chunk = data.value;\n                const len = chunk.length;\n                stats.loaded += len;\n                if (len < highWaterMark || chunkCache.dataLength) {\n                    // The current chunk is too small to to be emitted or the cache already has data\n                    // Push it to the cache\n                    chunkCache.push(chunk);\n                    if (chunkCache.dataLength >= highWaterMark) {\n                        // flush in order to join the typed arrays\n                        onProgress(stats, context, chunkCache.flush(), response);\n                    }\n                } else {\n                    // If there's nothing cached already, and the chache is large enough\n                    // just emit the progress event\n                    onProgress(stats, context, chunk, response);\n                }\n                return pump();\n            }).catch(()=>{\n                /* aborted */ return Promise.reject();\n            });\n        };\n        return pump();\n    }\n}\nfunction getRequestParameters(context, signal) {\n    const initParams = {\n        method: \"GET\",\n        mode: \"cors\",\n        credentials: \"same-origin\",\n        signal,\n        headers: new self.Headers(_extends({}, context.headers))\n    };\n    if (context.rangeEnd) {\n        initParams.headers.set(\"Range\", \"bytes=\" + context.rangeStart + \"-\" + String(context.rangeEnd - 1));\n    }\n    return initParams;\n}\nfunction getByteRangeLength(byteRangeHeader) {\n    const result = BYTERANGE.exec(byteRangeHeader);\n    if (result) {\n        return parseInt(result[2]) - parseInt(result[1]) + 1;\n    }\n}\nfunction getContentLength(headers) {\n    const contentRange = headers.get(\"Content-Range\");\n    if (contentRange) {\n        const byteRangeLength = getByteRangeLength(contentRange);\n        if (isFiniteNumber(byteRangeLength)) {\n            return byteRangeLength;\n        }\n    }\n    const contentLength = headers.get(\"Content-Length\");\n    if (contentLength) {\n        return parseInt(contentLength);\n    }\n}\nfunction getRequest(context, initParams) {\n    return new self.Request(context.url, initParams);\n}\nclass FetchError extends Error {\n    constructor(message, code, details){\n        super(message);\n        this.code = void 0;\n        this.details = void 0;\n        this.code = code;\n        this.details = details;\n    }\n}\nconst WHITESPACE_CHAR = /\\s/;\nconst Cues = {\n    newCue (track, startTime, endTime, captionScreen) {\n        const result = [];\n        let row;\n        // the type data states this is VTTCue, but it can potentially be a TextTrackCue on old browsers\n        let cue;\n        let indenting;\n        let indent;\n        let text;\n        const Cue = self.VTTCue || self.TextTrackCue;\n        for(let r = 0; r < captionScreen.rows.length; r++){\n            row = captionScreen.rows[r];\n            indenting = true;\n            indent = 0;\n            text = \"\";\n            if (!row.isEmpty()) {\n                var _track$cues;\n                for(let c = 0; c < row.chars.length; c++){\n                    if (WHITESPACE_CHAR.test(row.chars[c].uchar) && indenting) {\n                        indent++;\n                    } else {\n                        text += row.chars[c].uchar;\n                        indenting = false;\n                    }\n                }\n                // To be used for cleaning-up orphaned roll-up captions\n                row.cueStartTime = startTime;\n                // Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE\n                if (startTime === endTime) {\n                    endTime += 0.0001;\n                }\n                if (indent >= 16) {\n                    indent--;\n                } else {\n                    indent++;\n                }\n                const cueText = fixLineBreaks(text.trim());\n                const id = generateCueId(startTime, endTime, cueText);\n                // If this cue already exists in the track do not push it\n                if (!(track != null && (_track$cues = track.cues) != null && _track$cues.getCueById(id))) {\n                    cue = new Cue(startTime, endTime, cueText);\n                    cue.id = id;\n                    cue.line = r + 1;\n                    cue.align = \"left\";\n                    // Clamp the position between 10 and 80 percent (CEA-608 PAC indent code)\n                    // https://dvcs.w3.org/hg/text-tracks/raw-file/default/608toVTT/608toVTT.html#positioning-in-cea-608\n                    // Firefox throws an exception and captions break with out of bounds 0-100 values\n                    cue.position = 10 + Math.min(80, Math.floor(indent * 8 / 32) * 10);\n                    result.push(cue);\n                }\n            }\n        }\n        if (track && result.length) {\n            // Sort bottom cues in reverse order so that they render in line order when overlapping in Chrome\n            result.sort((cueA, cueB)=>{\n                if (cueA.line === \"auto\" || cueB.line === \"auto\") {\n                    return 0;\n                }\n                if (cueA.line > 8 && cueB.line > 8) {\n                    return cueB.line - cueA.line;\n                }\n                return cueA.line - cueB.line;\n            });\n            result.forEach((cue)=>addCueToTrack(track, cue));\n        }\n        return result;\n    }\n};\n/**\n * @deprecated use fragLoadPolicy.default\n */ /**\n * @deprecated use manifestLoadPolicy.default and playlistLoadPolicy.default\n */ const defaultLoadPolicy = {\n    maxTimeToFirstByteMs: 8000,\n    maxLoadTimeMs: 20000,\n    timeoutRetry: null,\n    errorRetry: null\n};\n/**\n * @ignore\n * If possible, keep hlsDefaultConfig shallow\n * It is cloned whenever a new Hls instance is created, by keeping the config\n * shallow the properties are cloned, and we don't end up manipulating the default\n */ const hlsDefaultConfig = _objectSpread2(_objectSpread2({\n    autoStartLoad: true,\n    // used by stream-controller\n    startPosition: -1,\n    // used by stream-controller\n    defaultAudioCodec: undefined,\n    // used by stream-controller\n    debug: false,\n    // used by logger\n    capLevelOnFPSDrop: false,\n    // used by fps-controller\n    capLevelToPlayerSize: false,\n    // used by cap-level-controller\n    ignoreDevicePixelRatio: false,\n    // used by cap-level-controller\n    preferManagedMediaSource: true,\n    initialLiveManifestSize: 1,\n    // used by stream-controller\n    maxBufferLength: 30,\n    // used by stream-controller\n    backBufferLength: Infinity,\n    // used by buffer-controller\n    frontBufferFlushThreshold: Infinity,\n    maxBufferSize: 60 * 1000 * 1000,\n    // used by stream-controller\n    maxBufferHole: 0.1,\n    // used by stream-controller\n    highBufferWatchdogPeriod: 2,\n    // used by stream-controller\n    nudgeOffset: 0.1,\n    // used by stream-controller\n    nudgeMaxRetry: 3,\n    // used by stream-controller\n    maxFragLookUpTolerance: 0.25,\n    // used by stream-controller\n    liveSyncDurationCount: 3,\n    // used by latency-controller\n    liveMaxLatencyDurationCount: Infinity,\n    // used by latency-controller\n    liveSyncDuration: undefined,\n    // used by latency-controller\n    liveMaxLatencyDuration: undefined,\n    // used by latency-controller\n    maxLiveSyncPlaybackRate: 1,\n    // used by latency-controller\n    liveDurationInfinity: false,\n    // used by buffer-controller\n    /**\n   * @deprecated use backBufferLength\n   */ liveBackBufferLength: null,\n    // used by buffer-controller\n    maxMaxBufferLength: 600,\n    // used by stream-controller\n    enableWorker: true,\n    // used by transmuxer\n    workerPath: null,\n    // used by transmuxer\n    enableSoftwareAES: true,\n    // used by decrypter\n    startLevel: undefined,\n    // used by level-controller\n    startFragPrefetch: false,\n    // used by stream-controller\n    fpsDroppedMonitoringPeriod: 5000,\n    // used by fps-controller\n    fpsDroppedMonitoringThreshold: 0.2,\n    // used by fps-controller\n    appendErrorMaxRetry: 3,\n    // used by buffer-controller\n    loader: XhrLoader,\n    // loader: FetchLoader,\n    fLoader: undefined,\n    // used by fragment-loader\n    pLoader: undefined,\n    // used by playlist-loader\n    xhrSetup: undefined,\n    // used by xhr-loader\n    licenseXhrSetup: undefined,\n    // used by eme-controller\n    licenseResponseCallback: undefined,\n    // used by eme-controller\n    abrController: AbrController,\n    bufferController: BufferController,\n    capLevelController: CapLevelController,\n    errorController: ErrorController,\n    fpsController: FPSController,\n    stretchShortVideoTrack: false,\n    // used by mp4-remuxer\n    maxAudioFramesDrift: 1,\n    // used by mp4-remuxer\n    forceKeyFrameOnDiscontinuity: true,\n    // used by ts-demuxer\n    abrEwmaFastLive: 3,\n    // used by abr-controller\n    abrEwmaSlowLive: 9,\n    // used by abr-controller\n    abrEwmaFastVoD: 3,\n    // used by abr-controller\n    abrEwmaSlowVoD: 9,\n    // used by abr-controller\n    abrEwmaDefaultEstimate: 5e5,\n    // 500 kbps  // used by abr-controller\n    abrEwmaDefaultEstimateMax: 5e6,\n    // 5 mbps\n    abrBandWidthFactor: 0.95,\n    // used by abr-controller\n    abrBandWidthUpFactor: 0.7,\n    // used by abr-controller\n    abrMaxWithRealBitrate: false,\n    // used by abr-controller\n    maxStarvationDelay: 4,\n    // used by abr-controller\n    maxLoadingDelay: 4,\n    // used by abr-controller\n    minAutoBitrate: 0,\n    // used by hls\n    emeEnabled: false,\n    // used by eme-controller\n    widevineLicenseUrl: undefined,\n    // used by eme-controller\n    drmSystems: {},\n    // used by eme-controller\n    drmSystemOptions: {},\n    // used by eme-controller\n    requestMediaKeySystemAccessFunc: requestMediaKeySystemAccess,\n    // used by eme-controller\n    testBandwidth: true,\n    progressive: false,\n    lowLatencyMode: true,\n    cmcd: undefined,\n    enableDateRangeMetadataCues: true,\n    enableEmsgMetadataCues: true,\n    enableID3MetadataCues: true,\n    useMediaCapabilities: true,\n    certLoadPolicy: {\n        default: defaultLoadPolicy\n    },\n    keyLoadPolicy: {\n        default: {\n            maxTimeToFirstByteMs: 8000,\n            maxLoadTimeMs: 20000,\n            timeoutRetry: {\n                maxNumRetry: 1,\n                retryDelayMs: 1000,\n                maxRetryDelayMs: 20000,\n                backoff: \"linear\"\n            },\n            errorRetry: {\n                maxNumRetry: 8,\n                retryDelayMs: 1000,\n                maxRetryDelayMs: 20000,\n                backoff: \"linear\"\n            }\n        }\n    },\n    manifestLoadPolicy: {\n        default: {\n            maxTimeToFirstByteMs: Infinity,\n            maxLoadTimeMs: 20000,\n            timeoutRetry: {\n                maxNumRetry: 2,\n                retryDelayMs: 0,\n                maxRetryDelayMs: 0\n            },\n            errorRetry: {\n                maxNumRetry: 1,\n                retryDelayMs: 1000,\n                maxRetryDelayMs: 8000\n            }\n        }\n    },\n    playlistLoadPolicy: {\n        default: {\n            maxTimeToFirstByteMs: 10000,\n            maxLoadTimeMs: 20000,\n            timeoutRetry: {\n                maxNumRetry: 2,\n                retryDelayMs: 0,\n                maxRetryDelayMs: 0\n            },\n            errorRetry: {\n                maxNumRetry: 2,\n                retryDelayMs: 1000,\n                maxRetryDelayMs: 8000\n            }\n        }\n    },\n    fragLoadPolicy: {\n        default: {\n            maxTimeToFirstByteMs: 10000,\n            maxLoadTimeMs: 120000,\n            timeoutRetry: {\n                maxNumRetry: 4,\n                retryDelayMs: 0,\n                maxRetryDelayMs: 0\n            },\n            errorRetry: {\n                maxNumRetry: 6,\n                retryDelayMs: 1000,\n                maxRetryDelayMs: 8000\n            }\n        }\n    },\n    steeringManifestLoadPolicy: {\n        default: {\n            maxTimeToFirstByteMs: 10000,\n            maxLoadTimeMs: 20000,\n            timeoutRetry: {\n                maxNumRetry: 2,\n                retryDelayMs: 0,\n                maxRetryDelayMs: 0\n            },\n            errorRetry: {\n                maxNumRetry: 1,\n                retryDelayMs: 1000,\n                maxRetryDelayMs: 8000\n            }\n        }\n    },\n    // These default settings are deprecated in favor of the above policies\n    // and are maintained for backwards compatibility\n    manifestLoadingTimeOut: 10000,\n    manifestLoadingMaxRetry: 1,\n    manifestLoadingRetryDelay: 1000,\n    manifestLoadingMaxRetryTimeout: 64000,\n    levelLoadingTimeOut: 10000,\n    levelLoadingMaxRetry: 4,\n    levelLoadingRetryDelay: 1000,\n    levelLoadingMaxRetryTimeout: 64000,\n    fragLoadingTimeOut: 20000,\n    fragLoadingMaxRetry: 6,\n    fragLoadingRetryDelay: 1000,\n    fragLoadingMaxRetryTimeout: 64000\n}, timelineConfig()), {}, {\n    subtitleStreamController: SubtitleStreamController,\n    subtitleTrackController: SubtitleTrackController,\n    timelineController: TimelineController,\n    audioStreamController: AudioStreamController,\n    audioTrackController: AudioTrackController,\n    emeController: EMEController,\n    cmcdController: CMCDController,\n    contentSteeringController: ContentSteeringController\n});\nfunction timelineConfig() {\n    return {\n        cueHandler: Cues,\n        // used by timeline-controller\n        enableWebVTT: true,\n        // used by timeline-controller\n        enableIMSC1: true,\n        // used by timeline-controller\n        enableCEA708Captions: true,\n        // used by timeline-controller\n        captionsTextTrack1Label: \"English\",\n        // used by timeline-controller\n        captionsTextTrack1LanguageCode: \"en\",\n        // used by timeline-controller\n        captionsTextTrack2Label: \"Spanish\",\n        // used by timeline-controller\n        captionsTextTrack2LanguageCode: \"es\",\n        // used by timeline-controller\n        captionsTextTrack3Label: \"Unknown CC\",\n        // used by timeline-controller\n        captionsTextTrack3LanguageCode: \"\",\n        // used by timeline-controller\n        captionsTextTrack4Label: \"Unknown CC\",\n        // used by timeline-controller\n        captionsTextTrack4LanguageCode: \"\",\n        // used by timeline-controller\n        renderTextTracksNatively: true\n    };\n}\n/**\n * @ignore\n */ function mergeConfig(defaultConfig, userConfig) {\n    if ((userConfig.liveSyncDurationCount || userConfig.liveMaxLatencyDurationCount) && (userConfig.liveSyncDuration || userConfig.liveMaxLatencyDuration)) {\n        throw new Error(\"Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration\");\n    }\n    if (userConfig.liveMaxLatencyDurationCount !== undefined && (userConfig.liveSyncDurationCount === undefined || userConfig.liveMaxLatencyDurationCount <= userConfig.liveSyncDurationCount)) {\n        throw new Error('Illegal hls.js config: \"liveMaxLatencyDurationCount\" must be greater than \"liveSyncDurationCount\"');\n    }\n    if (userConfig.liveMaxLatencyDuration !== undefined && (userConfig.liveSyncDuration === undefined || userConfig.liveMaxLatencyDuration <= userConfig.liveSyncDuration)) {\n        throw new Error('Illegal hls.js config: \"liveMaxLatencyDuration\" must be greater than \"liveSyncDuration\"');\n    }\n    const defaultsCopy = deepCpy(defaultConfig);\n    // Backwards compatibility with deprecated config values\n    const deprecatedSettingTypes = [\n        \"manifest\",\n        \"level\",\n        \"frag\"\n    ];\n    const deprecatedSettings = [\n        \"TimeOut\",\n        \"MaxRetry\",\n        \"RetryDelay\",\n        \"MaxRetryTimeout\"\n    ];\n    deprecatedSettingTypes.forEach((type)=>{\n        const policyName = `${type === \"level\" ? \"playlist\" : type}LoadPolicy`;\n        const policyNotSet = userConfig[policyName] === undefined;\n        const report = [];\n        deprecatedSettings.forEach((setting)=>{\n            const deprecatedSetting = `${type}Loading${setting}`;\n            const value = userConfig[deprecatedSetting];\n            if (value !== undefined && policyNotSet) {\n                report.push(deprecatedSetting);\n                const settings = defaultsCopy[policyName].default;\n                userConfig[policyName] = {\n                    default: settings\n                };\n                switch(setting){\n                    case \"TimeOut\":\n                        settings.maxLoadTimeMs = value;\n                        settings.maxTimeToFirstByteMs = value;\n                        break;\n                    case \"MaxRetry\":\n                        settings.errorRetry.maxNumRetry = value;\n                        settings.timeoutRetry.maxNumRetry = value;\n                        break;\n                    case \"RetryDelay\":\n                        settings.errorRetry.retryDelayMs = value;\n                        settings.timeoutRetry.retryDelayMs = value;\n                        break;\n                    case \"MaxRetryTimeout\":\n                        settings.errorRetry.maxRetryDelayMs = value;\n                        settings.timeoutRetry.maxRetryDelayMs = value;\n                        break;\n                }\n            }\n        });\n        if (report.length) {\n            logger.warn(`hls.js config: \"${report.join('\", \"')}\" setting(s) are deprecated, use \"${policyName}\": ${JSON.stringify(userConfig[policyName])}`);\n        }\n    });\n    return _objectSpread2(_objectSpread2({}, defaultsCopy), userConfig);\n}\nfunction deepCpy(obj) {\n    if (obj && typeof obj === \"object\") {\n        if (Array.isArray(obj)) {\n            return obj.map(deepCpy);\n        }\n        return Object.keys(obj).reduce((result, key)=>{\n            result[key] = deepCpy(obj[key]);\n            return result;\n        }, {});\n    }\n    return obj;\n}\n/**\n * @ignore\n */ function enableStreamingMode(config) {\n    const currentLoader = config.loader;\n    if (currentLoader !== FetchLoader && currentLoader !== XhrLoader) {\n        // If a developer has configured their own loader, respect that choice\n        logger.log(\"[config]: Custom loader detected, cannot enable progressive streaming\");\n        config.progressive = false;\n    } else {\n        const canStreamProgressively = fetchSupported();\n        if (canStreamProgressively) {\n            config.loader = FetchLoader;\n            config.progressive = true;\n            config.enableSoftwareAES = true;\n            logger.log(\"[config]: Progressive streaming enabled, using FetchLoader\");\n        }\n    }\n}\nlet chromeOrFirefox;\nclass LevelController extends BasePlaylistController {\n    constructor(hls, contentSteeringController){\n        super(hls, \"[level-controller]\");\n        this._levels = [];\n        this._firstLevel = -1;\n        this._maxAutoLevel = -1;\n        this._startLevel = void 0;\n        this.currentLevel = null;\n        this.currentLevelIndex = -1;\n        this.manualLevelIndex = -1;\n        this.steering = void 0;\n        this.onParsedComplete = void 0;\n        this.steering = contentSteeringController;\n        this._registerListeners();\n    }\n    _registerListeners() {\n        const { hls } = this;\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n        hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n        hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n        hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n        hls.on(Events.ERROR, this.onError, this);\n    }\n    _unregisterListeners() {\n        const { hls } = this;\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n        hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n        hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n        hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n        hls.off(Events.ERROR, this.onError, this);\n    }\n    destroy() {\n        this._unregisterListeners();\n        this.steering = null;\n        this.resetLevels();\n        super.destroy();\n    }\n    stopLoad() {\n        const levels = this._levels;\n        // clean up live level details to force reload them, and reset load errors\n        levels.forEach((level)=>{\n            level.loadError = 0;\n            level.fragmentError = 0;\n        });\n        super.stopLoad();\n    }\n    resetLevels() {\n        this._startLevel = undefined;\n        this.manualLevelIndex = -1;\n        this.currentLevelIndex = -1;\n        this.currentLevel = null;\n        this._levels = [];\n        this._maxAutoLevel = -1;\n    }\n    onManifestLoading(event, data) {\n        this.resetLevels();\n    }\n    onManifestLoaded(event, data) {\n        const preferManagedMediaSource = this.hls.config.preferManagedMediaSource;\n        const levels = [];\n        const redundantSet = {};\n        const generatePathwaySet = {};\n        let resolutionFound = false;\n        let videoCodecFound = false;\n        let audioCodecFound = false;\n        data.levels.forEach((levelParsed)=>{\n            var _audioCodec, _videoCodec;\n            const attributes = levelParsed.attrs;\n            // erase audio codec info if browser does not support mp4a.40.34.\n            // demuxer will autodetect codec and fallback to mpeg/audio\n            let { audioCodec, videoCodec } = levelParsed;\n            if (((_audioCodec = audioCodec) == null ? void 0 : _audioCodec.indexOf(\"mp4a.40.34\")) !== -1) {\n                chromeOrFirefox || (chromeOrFirefox = /chrome|firefox/i.test(navigator.userAgent));\n                if (chromeOrFirefox) {\n                    levelParsed.audioCodec = audioCodec = undefined;\n                }\n            }\n            if (audioCodec) {\n                levelParsed.audioCodec = audioCodec = getCodecCompatibleName(audioCodec, preferManagedMediaSource);\n            }\n            if (((_videoCodec = videoCodec) == null ? void 0 : _videoCodec.indexOf(\"avc1\")) === 0) {\n                videoCodec = levelParsed.videoCodec = convertAVC1ToAVCOTI(videoCodec);\n            }\n            // only keep levels with supported audio/video codecs\n            const { width, height, unknownCodecs } = levelParsed;\n            resolutionFound || (resolutionFound = !!(width && height));\n            videoCodecFound || (videoCodecFound = !!videoCodec);\n            audioCodecFound || (audioCodecFound = !!audioCodec);\n            if (unknownCodecs != null && unknownCodecs.length || audioCodec && !areCodecsMediaSourceSupported(audioCodec, \"audio\", preferManagedMediaSource) || videoCodec && !areCodecsMediaSourceSupported(videoCodec, \"video\", preferManagedMediaSource)) {\n                return;\n            }\n            const { CODECS, \"FRAME-RATE\": FRAMERATE, \"HDCP-LEVEL\": HDCP, \"PATHWAY-ID\": PATHWAY, RESOLUTION, \"VIDEO-RANGE\": VIDEO_RANGE } = attributes;\n            const contentSteeringPrefix = `${PATHWAY || \".\"}-`;\n            const levelKey = `${contentSteeringPrefix}${levelParsed.bitrate}-${RESOLUTION}-${FRAMERATE}-${CODECS}-${VIDEO_RANGE}-${HDCP}`;\n            if (!redundantSet[levelKey]) {\n                const level = new Level(levelParsed);\n                redundantSet[levelKey] = level;\n                generatePathwaySet[levelKey] = 1;\n                levels.push(level);\n            } else if (redundantSet[levelKey].uri !== levelParsed.url && !levelParsed.attrs[\"PATHWAY-ID\"]) {\n                // Assign Pathway IDs to Redundant Streams (default Pathways is \".\". Redundant Streams \"..\", \"...\", and so on.)\n                // Content Steering controller to handles Pathway fallback on error\n                const pathwayCount = generatePathwaySet[levelKey] += 1;\n                levelParsed.attrs[\"PATHWAY-ID\"] = new Array(pathwayCount + 1).join(\".\");\n                const level = new Level(levelParsed);\n                redundantSet[levelKey] = level;\n                levels.push(level);\n            } else {\n                redundantSet[levelKey].addGroupId(\"audio\", attributes.AUDIO);\n                redundantSet[levelKey].addGroupId(\"text\", attributes.SUBTITLES);\n            }\n        });\n        this.filterAndSortMediaOptions(levels, data, resolutionFound, videoCodecFound, audioCodecFound);\n    }\n    filterAndSortMediaOptions(filteredLevels, data, resolutionFound, videoCodecFound, audioCodecFound) {\n        let audioTracks = [];\n        let subtitleTracks = [];\n        let levels = filteredLevels;\n        // remove audio-only and invalid video-range levels if we also have levels with video codecs or RESOLUTION signalled\n        if ((resolutionFound || videoCodecFound) && audioCodecFound) {\n            levels = levels.filter(({ videoCodec, videoRange, width, height })=>(!!videoCodec || !!(width && height)) && isVideoRange(videoRange));\n        }\n        if (levels.length === 0) {\n            // Dispatch error after MANIFEST_LOADED is done propagating\n            Promise.resolve().then(()=>{\n                if (this.hls) {\n                    if (data.levels.length) {\n                        this.warn(`One or more CODECS in variant not supported: ${JSON.stringify(data.levels[0].attrs)}`);\n                    }\n                    const error = new Error(\"no level with compatible codecs found in manifest\");\n                    this.hls.trigger(Events.ERROR, {\n                        type: ErrorTypes.MEDIA_ERROR,\n                        details: ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR,\n                        fatal: true,\n                        url: data.url,\n                        error,\n                        reason: error.message\n                    });\n                }\n            });\n            return;\n        }\n        if (data.audioTracks) {\n            const { preferManagedMediaSource } = this.hls.config;\n            audioTracks = data.audioTracks.filter((track)=>!track.audioCodec || areCodecsMediaSourceSupported(track.audioCodec, \"audio\", preferManagedMediaSource));\n            // Assign ids after filtering as array indices by group-id\n            assignTrackIdsByGroup(audioTracks);\n        }\n        if (data.subtitles) {\n            subtitleTracks = data.subtitles;\n            assignTrackIdsByGroup(subtitleTracks);\n        }\n        // start bitrate is the first bitrate of the manifest\n        const unsortedLevels = levels.slice(0);\n        // sort levels from lowest to highest\n        levels.sort((a, b)=>{\n            if (a.attrs[\"HDCP-LEVEL\"] !== b.attrs[\"HDCP-LEVEL\"]) {\n                return (a.attrs[\"HDCP-LEVEL\"] || \"\") > (b.attrs[\"HDCP-LEVEL\"] || \"\") ? 1 : -1;\n            }\n            // sort on height before bitrate for cap-level-controller\n            if (resolutionFound && a.height !== b.height) {\n                return a.height - b.height;\n            }\n            if (a.frameRate !== b.frameRate) {\n                return a.frameRate - b.frameRate;\n            }\n            if (a.videoRange !== b.videoRange) {\n                return VideoRangeValues.indexOf(a.videoRange) - VideoRangeValues.indexOf(b.videoRange);\n            }\n            if (a.videoCodec !== b.videoCodec) {\n                const valueA = videoCodecPreferenceValue(a.videoCodec);\n                const valueB = videoCodecPreferenceValue(b.videoCodec);\n                if (valueA !== valueB) {\n                    return valueB - valueA;\n                }\n            }\n            if (a.uri === b.uri && a.codecSet !== b.codecSet) {\n                const valueA = codecsSetSelectionPreferenceValue(a.codecSet);\n                const valueB = codecsSetSelectionPreferenceValue(b.codecSet);\n                if (valueA !== valueB) {\n                    return valueB - valueA;\n                }\n            }\n            if (a.averageBitrate !== b.averageBitrate) {\n                return a.averageBitrate - b.averageBitrate;\n            }\n            return 0;\n        });\n        let firstLevelInPlaylist = unsortedLevels[0];\n        if (this.steering) {\n            levels = this.steering.filterParsedLevels(levels);\n            if (levels.length !== unsortedLevels.length) {\n                for(let i = 0; i < unsortedLevels.length; i++){\n                    if (unsortedLevels[i].pathwayId === levels[0].pathwayId) {\n                        firstLevelInPlaylist = unsortedLevels[i];\n                        break;\n                    }\n                }\n            }\n        }\n        this._levels = levels;\n        // find index of first level in sorted levels\n        for(let i = 0; i < levels.length; i++){\n            if (levels[i] === firstLevelInPlaylist) {\n                var _this$hls$userConfig;\n                this._firstLevel = i;\n                const firstLevelBitrate = firstLevelInPlaylist.bitrate;\n                const bandwidthEstimate = this.hls.bandwidthEstimate;\n                this.log(`manifest loaded, ${levels.length} level(s) found, first bitrate: ${firstLevelBitrate}`);\n                // Update default bwe to first variant bitrate as long it has not been configured or set\n                if (((_this$hls$userConfig = this.hls.userConfig) == null ? void 0 : _this$hls$userConfig.abrEwmaDefaultEstimate) === undefined) {\n                    const startingBwEstimate = Math.min(firstLevelBitrate, this.hls.config.abrEwmaDefaultEstimateMax);\n                    if (startingBwEstimate > bandwidthEstimate && bandwidthEstimate === hlsDefaultConfig.abrEwmaDefaultEstimate) {\n                        this.hls.bandwidthEstimate = startingBwEstimate;\n                    }\n                }\n                break;\n            }\n        }\n        // Audio is only alternate if manifest include a URI along with the audio group tag,\n        // and this is not an audio-only stream where levels contain audio-only\n        const audioOnly = audioCodecFound && !videoCodecFound;\n        const edata = {\n            levels,\n            audioTracks,\n            subtitleTracks,\n            sessionData: data.sessionData,\n            sessionKeys: data.sessionKeys,\n            firstLevel: this._firstLevel,\n            stats: data.stats,\n            audio: audioCodecFound,\n            video: videoCodecFound,\n            altAudio: !audioOnly && audioTracks.some((t)=>!!t.url)\n        };\n        this.hls.trigger(Events.MANIFEST_PARSED, edata);\n        // Initiate loading after all controllers have received MANIFEST_PARSED\n        if (this.hls.config.autoStartLoad || this.hls.forceStartLoad) {\n            this.hls.startLoad(this.hls.config.startPosition);\n        }\n    }\n    get levels() {\n        if (this._levels.length === 0) {\n            return null;\n        }\n        return this._levels;\n    }\n    get level() {\n        return this.currentLevelIndex;\n    }\n    set level(newLevel) {\n        const levels = this._levels;\n        if (levels.length === 0) {\n            return;\n        }\n        // check if level idx is valid\n        if (newLevel < 0 || newLevel >= levels.length) {\n            // invalid level id given, trigger error\n            const error = new Error(\"invalid level idx\");\n            const fatal = newLevel < 0;\n            this.hls.trigger(Events.ERROR, {\n                type: ErrorTypes.OTHER_ERROR,\n                details: ErrorDetails.LEVEL_SWITCH_ERROR,\n                level: newLevel,\n                fatal,\n                error,\n                reason: error.message\n            });\n            if (fatal) {\n                return;\n            }\n            newLevel = Math.min(newLevel, levels.length - 1);\n        }\n        const lastLevelIndex = this.currentLevelIndex;\n        const lastLevel = this.currentLevel;\n        const lastPathwayId = lastLevel ? lastLevel.attrs[\"PATHWAY-ID\"] : undefined;\n        const level = levels[newLevel];\n        const pathwayId = level.attrs[\"PATHWAY-ID\"];\n        this.currentLevelIndex = newLevel;\n        this.currentLevel = level;\n        if (lastLevelIndex === newLevel && level.details && lastLevel && lastPathwayId === pathwayId) {\n            return;\n        }\n        this.log(`Switching to level ${newLevel} (${level.height ? level.height + \"p \" : \"\"}${level.videoRange ? level.videoRange + \" \" : \"\"}${level.codecSet ? level.codecSet + \" \" : \"\"}@${level.bitrate})${pathwayId ? \" with Pathway \" + pathwayId : \"\"} from level ${lastLevelIndex}${lastPathwayId ? \" with Pathway \" + lastPathwayId : \"\"}`);\n        const levelSwitchingData = {\n            level: newLevel,\n            attrs: level.attrs,\n            details: level.details,\n            bitrate: level.bitrate,\n            averageBitrate: level.averageBitrate,\n            maxBitrate: level.maxBitrate,\n            realBitrate: level.realBitrate,\n            width: level.width,\n            height: level.height,\n            codecSet: level.codecSet,\n            audioCodec: level.audioCodec,\n            videoCodec: level.videoCodec,\n            audioGroups: level.audioGroups,\n            subtitleGroups: level.subtitleGroups,\n            loaded: level.loaded,\n            loadError: level.loadError,\n            fragmentError: level.fragmentError,\n            name: level.name,\n            id: level.id,\n            uri: level.uri,\n            url: level.url,\n            urlId: 0,\n            audioGroupIds: level.audioGroupIds,\n            textGroupIds: level.textGroupIds\n        };\n        this.hls.trigger(Events.LEVEL_SWITCHING, levelSwitchingData);\n        // check if we need to load playlist for this level\n        const levelDetails = level.details;\n        if (!levelDetails || levelDetails.live) {\n            // level not retrieved yet, or live playlist we need to (re)load it\n            const hlsUrlParameters = this.switchParams(level.uri, lastLevel == null ? void 0 : lastLevel.details);\n            this.loadPlaylist(hlsUrlParameters);\n        }\n    }\n    get manualLevel() {\n        return this.manualLevelIndex;\n    }\n    set manualLevel(newLevel) {\n        this.manualLevelIndex = newLevel;\n        if (this._startLevel === undefined) {\n            this._startLevel = newLevel;\n        }\n        if (newLevel !== -1) {\n            this.level = newLevel;\n        }\n    }\n    get firstLevel() {\n        return this._firstLevel;\n    }\n    set firstLevel(newLevel) {\n        this._firstLevel = newLevel;\n    }\n    get startLevel() {\n        // Setting hls.startLevel (this._startLevel) overrides config.startLevel\n        if (this._startLevel === undefined) {\n            const configStartLevel = this.hls.config.startLevel;\n            if (configStartLevel !== undefined) {\n                return configStartLevel;\n            }\n            return this.hls.firstAutoLevel;\n        }\n        return this._startLevel;\n    }\n    set startLevel(newLevel) {\n        this._startLevel = newLevel;\n    }\n    onError(event, data) {\n        if (data.fatal || !data.context) {\n            return;\n        }\n        if (data.context.type === PlaylistContextType.LEVEL && data.context.level === this.level) {\n            this.checkRetry(data);\n        }\n    }\n    // reset errors on the successful load of a fragment\n    onFragBuffered(event, { frag }) {\n        if (frag !== undefined && frag.type === PlaylistLevelType.MAIN) {\n            const el = frag.elementaryStreams;\n            if (!Object.keys(el).some((type)=>!!el[type])) {\n                return;\n            }\n            const level = this._levels[frag.level];\n            if (level != null && level.loadError) {\n                this.log(`Resetting level error count of ${level.loadError} on frag buffered`);\n                level.loadError = 0;\n            }\n        }\n    }\n    onLevelLoaded(event, data) {\n        var _data$deliveryDirecti2;\n        const { level, details } = data;\n        const curLevel = this._levels[level];\n        if (!curLevel) {\n            var _data$deliveryDirecti;\n            this.warn(`Invalid level index ${level}`);\n            if ((_data$deliveryDirecti = data.deliveryDirectives) != null && _data$deliveryDirecti.skip) {\n                details.deltaUpdateFailed = true;\n            }\n            return;\n        }\n        // only process level loaded events matching with expected level\n        if (level === this.currentLevelIndex) {\n            // reset level load error counter on successful level loaded only if there is no issues with fragments\n            if (curLevel.fragmentError === 0) {\n                curLevel.loadError = 0;\n            }\n            this.playlistLoaded(level, data, curLevel.details);\n        } else if ((_data$deliveryDirecti2 = data.deliveryDirectives) != null && _data$deliveryDirecti2.skip) {\n            // received a delta playlist update that cannot be merged\n            details.deltaUpdateFailed = true;\n        }\n    }\n    loadPlaylist(hlsUrlParameters) {\n        super.loadPlaylist();\n        const currentLevelIndex = this.currentLevelIndex;\n        const currentLevel = this.currentLevel;\n        if (currentLevel && this.shouldLoadPlaylist(currentLevel)) {\n            let url = currentLevel.uri;\n            if (hlsUrlParameters) {\n                try {\n                    url = hlsUrlParameters.addDirectives(url);\n                } catch (error) {\n                    this.warn(`Could not construct new URL with HLS Delivery Directives: ${error}`);\n                }\n            }\n            const pathwayId = currentLevel.attrs[\"PATHWAY-ID\"];\n            this.log(`Loading level index ${currentLevelIndex}${(hlsUrlParameters == null ? void 0 : hlsUrlParameters.msn) !== undefined ? \" at sn \" + hlsUrlParameters.msn + \" part \" + hlsUrlParameters.part : \"\"} with${pathwayId ? \" Pathway \" + pathwayId : \"\"} ${url}`);\n            // console.log('Current audio track group ID:', this.hls.audioTracks[this.hls.audioTrack].groupId);\n            // console.log('New video quality level audio group id:', levelObject.attrs.AUDIO, level);\n            this.clearTimer();\n            this.hls.trigger(Events.LEVEL_LOADING, {\n                url,\n                level: currentLevelIndex,\n                pathwayId: currentLevel.attrs[\"PATHWAY-ID\"],\n                id: 0,\n                // Deprecated Level urlId\n                deliveryDirectives: hlsUrlParameters || null\n            });\n        }\n    }\n    get nextLoadLevel() {\n        if (this.manualLevelIndex !== -1) {\n            return this.manualLevelIndex;\n        } else {\n            return this.hls.nextAutoLevel;\n        }\n    }\n    set nextLoadLevel(nextLevel) {\n        this.level = nextLevel;\n        if (this.manualLevelIndex === -1) {\n            this.hls.nextAutoLevel = nextLevel;\n        }\n    }\n    removeLevel(levelIndex) {\n        var _this$currentLevel;\n        const levels = this._levels.filter((level, index)=>{\n            if (index !== levelIndex) {\n                return true;\n            }\n            if (this.steering) {\n                this.steering.removeLevel(level);\n            }\n            if (level === this.currentLevel) {\n                this.currentLevel = null;\n                this.currentLevelIndex = -1;\n                if (level.details) {\n                    level.details.fragments.forEach((f)=>f.level = -1);\n                }\n            }\n            return false;\n        });\n        reassignFragmentLevelIndexes(levels);\n        this._levels = levels;\n        if (this.currentLevelIndex > -1 && (_this$currentLevel = this.currentLevel) != null && _this$currentLevel.details) {\n            this.currentLevelIndex = this.currentLevel.details.fragments[0].level;\n        }\n        this.hls.trigger(Events.LEVELS_UPDATED, {\n            levels\n        });\n    }\n    onLevelsUpdated(event, { levels }) {\n        this._levels = levels;\n    }\n    checkMaxAutoUpdated() {\n        const { autoLevelCapping, maxAutoLevel, maxHdcpLevel } = this.hls;\n        if (this._maxAutoLevel !== maxAutoLevel) {\n            this._maxAutoLevel = maxAutoLevel;\n            this.hls.trigger(Events.MAX_AUTO_LEVEL_UPDATED, {\n                autoLevelCapping,\n                levels: this.levels,\n                maxAutoLevel,\n                minAutoLevel: this.hls.minAutoLevel,\n                maxHdcpLevel\n            });\n        }\n    }\n}\nfunction assignTrackIdsByGroup(tracks) {\n    const groups = {};\n    tracks.forEach((track)=>{\n        const groupId = track.groupId || \"\";\n        track.id = groups[groupId] = groups[groupId] || 0;\n        groups[groupId]++;\n    });\n}\nclass KeyLoader {\n    constructor(config){\n        this.config = void 0;\n        this.keyUriToKeyInfo = {};\n        this.emeController = null;\n        this.config = config;\n    }\n    abort(type) {\n        for(const uri in this.keyUriToKeyInfo){\n            const loader = this.keyUriToKeyInfo[uri].loader;\n            if (loader) {\n                var _loader$context;\n                if (type && type !== ((_loader$context = loader.context) == null ? void 0 : _loader$context.frag.type)) {\n                    return;\n                }\n                loader.abort();\n            }\n        }\n    }\n    detach() {\n        for(const uri in this.keyUriToKeyInfo){\n            const keyInfo = this.keyUriToKeyInfo[uri];\n            // Remove cached EME keys on detach\n            if (keyInfo.mediaKeySessionContext || keyInfo.decryptdata.isCommonEncryption) {\n                delete this.keyUriToKeyInfo[uri];\n            }\n        }\n    }\n    destroy() {\n        this.detach();\n        for(const uri in this.keyUriToKeyInfo){\n            const loader = this.keyUriToKeyInfo[uri].loader;\n            if (loader) {\n                loader.destroy();\n            }\n        }\n        this.keyUriToKeyInfo = {};\n    }\n    createKeyLoadError(frag, details = ErrorDetails.KEY_LOAD_ERROR, error, networkDetails, response) {\n        return new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details,\n            fatal: false,\n            frag,\n            response,\n            error,\n            networkDetails\n        });\n    }\n    loadClear(loadingFrag, encryptedFragments) {\n        if (this.emeController && this.config.emeEnabled) {\n            // access key-system with nearest key on start (loaidng frag is unencrypted)\n            const { sn, cc } = loadingFrag;\n            for(let i = 0; i < encryptedFragments.length; i++){\n                const frag = encryptedFragments[i];\n                if (cc <= frag.cc && (sn === \"initSegment\" || frag.sn === \"initSegment\" || sn < frag.sn)) {\n                    this.emeController.selectKeySystemFormat(frag).then((keySystemFormat)=>{\n                        frag.setKeyFormat(keySystemFormat);\n                    });\n                    break;\n                }\n            }\n        }\n    }\n    load(frag) {\n        if (!frag.decryptdata && frag.encrypted && this.emeController) {\n            // Multiple keys, but none selected, resolve in eme-controller\n            return this.emeController.selectKeySystemFormat(frag).then((keySystemFormat)=>{\n                return this.loadInternal(frag, keySystemFormat);\n            });\n        }\n        return this.loadInternal(frag);\n    }\n    loadInternal(frag, keySystemFormat) {\n        var _keyInfo, _keyInfo2;\n        if (keySystemFormat) {\n            frag.setKeyFormat(keySystemFormat);\n        }\n        const decryptdata = frag.decryptdata;\n        if (!decryptdata) {\n            const error = new Error(keySystemFormat ? `Expected frag.decryptdata to be defined after setting format ${keySystemFormat}` : \"Missing decryption data on fragment in onKeyLoading\");\n            return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, error));\n        }\n        const uri = decryptdata.uri;\n        if (!uri) {\n            return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(`Invalid key URI: \"${uri}\"`)));\n        }\n        let keyInfo = this.keyUriToKeyInfo[uri];\n        if ((_keyInfo = keyInfo) != null && _keyInfo.decryptdata.key) {\n            decryptdata.key = keyInfo.decryptdata.key;\n            return Promise.resolve({\n                frag,\n                keyInfo\n            });\n        }\n        // Return key load promise as long as it does not have a mediakey session with an unusable key status\n        if ((_keyInfo2 = keyInfo) != null && _keyInfo2.keyLoadPromise) {\n            var _keyInfo$mediaKeySess;\n            switch((_keyInfo$mediaKeySess = keyInfo.mediaKeySessionContext) == null ? void 0 : _keyInfo$mediaKeySess.keyStatus){\n                case undefined:\n                case \"status-pending\":\n                case \"usable\":\n                case \"usable-in-future\":\n                    return keyInfo.keyLoadPromise.then((keyLoadedData)=>{\n                        // Return the correct fragment with updated decryptdata key and loaded keyInfo\n                        decryptdata.key = keyLoadedData.keyInfo.decryptdata.key;\n                        return {\n                            frag,\n                            keyInfo\n                        };\n                    });\n            }\n        // If we have a key session and status and it is not pending or usable, continue\n        // This will go back to the eme-controller for expired keys to get a new keyLoadPromise\n        }\n        // Load the key or return the loading promise\n        keyInfo = this.keyUriToKeyInfo[uri] = {\n            decryptdata,\n            keyLoadPromise: null,\n            loader: null,\n            mediaKeySessionContext: null\n        };\n        switch(decryptdata.method){\n            case \"ISO-23001-7\":\n            case \"SAMPLE-AES\":\n            case \"SAMPLE-AES-CENC\":\n            case \"SAMPLE-AES-CTR\":\n                if (decryptdata.keyFormat === \"identity\") {\n                    // loadKeyHTTP handles http(s) and data URLs\n                    return this.loadKeyHTTP(keyInfo, frag);\n                }\n                return this.loadKeyEME(keyInfo, frag);\n            case \"AES-128\":\n                return this.loadKeyHTTP(keyInfo, frag);\n            default:\n                return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(`Key supplied with unsupported METHOD: \"${decryptdata.method}\"`)));\n        }\n    }\n    loadKeyEME(keyInfo, frag) {\n        const keyLoadedData = {\n            frag,\n            keyInfo\n        };\n        if (this.emeController && this.config.emeEnabled) {\n            const keySessionContextPromise = this.emeController.loadKey(keyLoadedData);\n            if (keySessionContextPromise) {\n                return (keyInfo.keyLoadPromise = keySessionContextPromise.then((keySessionContext)=>{\n                    keyInfo.mediaKeySessionContext = keySessionContext;\n                    return keyLoadedData;\n                })).catch((error)=>{\n                    // Remove promise for license renewal or retry\n                    keyInfo.keyLoadPromise = null;\n                    throw error;\n                });\n            }\n        }\n        return Promise.resolve(keyLoadedData);\n    }\n    loadKeyHTTP(keyInfo, frag) {\n        const config = this.config;\n        const Loader = config.loader;\n        const keyLoader = new Loader(config);\n        frag.keyLoader = keyInfo.loader = keyLoader;\n        return keyInfo.keyLoadPromise = new Promise((resolve, reject)=>{\n            const loaderContext = {\n                keyInfo,\n                frag,\n                responseType: \"arraybuffer\",\n                url: keyInfo.decryptdata.uri\n            };\n            // maxRetry is 0 so that instead of retrying the same key on the same variant multiple times,\n            // key-loader will trigger an error and rely on stream-controller to handle retry logic.\n            // this will also align retry logic with fragment-loader\n            const loadPolicy = config.keyLoadPolicy.default;\n            const loaderConfig = {\n                loadPolicy,\n                timeout: loadPolicy.maxLoadTimeMs,\n                maxRetry: 0,\n                retryDelay: 0,\n                maxRetryDelay: 0\n            };\n            const loaderCallbacks = {\n                onSuccess: (response, stats, context, networkDetails)=>{\n                    const { frag, keyInfo, url: uri } = context;\n                    if (!frag.decryptdata || keyInfo !== this.keyUriToKeyInfo[uri]) {\n                        return reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(\"after key load, decryptdata unset or changed\"), networkDetails));\n                    }\n                    keyInfo.decryptdata.key = frag.decryptdata.key = new Uint8Array(response.data);\n                    // detach fragment key loader on load success\n                    frag.keyLoader = null;\n                    keyInfo.loader = null;\n                    resolve({\n                        frag,\n                        keyInfo\n                    });\n                },\n                onError: (response, context, networkDetails, stats)=>{\n                    this.resetLoader(context);\n                    reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(`HTTP Error ${response.code} loading key ${response.text}`), networkDetails, _objectSpread2({\n                        url: loaderContext.url,\n                        data: undefined\n                    }, response)));\n                },\n                onTimeout: (stats, context, networkDetails)=>{\n                    this.resetLoader(context);\n                    reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_TIMEOUT, new Error(\"key loading timed out\"), networkDetails));\n                },\n                onAbort: (stats, context, networkDetails)=>{\n                    this.resetLoader(context);\n                    reject(this.createKeyLoadError(frag, ErrorDetails.INTERNAL_ABORTED, new Error(\"key loading aborted\"), networkDetails));\n                }\n            };\n            keyLoader.load(loaderContext, loaderConfig, loaderCallbacks);\n        });\n    }\n    resetLoader(context) {\n        const { frag, keyInfo, url: uri } = context;\n        const loader = keyInfo.loader;\n        if (frag.keyLoader === loader) {\n            frag.keyLoader = null;\n            keyInfo.loader = null;\n        }\n        delete this.keyUriToKeyInfo[uri];\n        if (loader) {\n            loader.destroy();\n        }\n    }\n}\nfunction getSourceBuffer() {\n    return self.SourceBuffer || self.WebKitSourceBuffer;\n}\nfunction isMSESupported() {\n    const mediaSource = getMediaSource();\n    if (!mediaSource) {\n        return false;\n    }\n    // if SourceBuffer is exposed ensure its API is valid\n    // Older browsers do not expose SourceBuffer globally so checking SourceBuffer.prototype is impossible\n    const sourceBuffer = getSourceBuffer();\n    return !sourceBuffer || sourceBuffer.prototype && typeof sourceBuffer.prototype.appendBuffer === \"function\" && typeof sourceBuffer.prototype.remove === \"function\";\n}\nfunction isSupported() {\n    if (!isMSESupported()) {\n        return false;\n    }\n    const mediaSource = getMediaSource();\n    return typeof (mediaSource == null ? void 0 : mediaSource.isTypeSupported) === \"function\" && ([\n        \"avc1.42E01E,mp4a.40.2\",\n        \"av01.0.01M.08\",\n        \"vp09.00.50.08\"\n    ].some((codecsForVideoContainer)=>mediaSource.isTypeSupported(mimeTypeForCodec(codecsForVideoContainer, \"video\"))) || [\n        \"mp4a.40.2\",\n        \"fLaC\"\n    ].some((codecForAudioContainer)=>mediaSource.isTypeSupported(mimeTypeForCodec(codecForAudioContainer, \"audio\"))));\n}\nfunction changeTypeSupported() {\n    var _sourceBuffer$prototy;\n    const sourceBuffer = getSourceBuffer();\n    return typeof (sourceBuffer == null ? void 0 : (_sourceBuffer$prototy = sourceBuffer.prototype) == null ? void 0 : _sourceBuffer$prototy.changeType) === \"function\";\n}\nconst STALL_MINIMUM_DURATION_MS = 250;\nconst MAX_START_GAP_JUMP = 2.0;\nconst SKIP_BUFFER_HOLE_STEP_SECONDS = 0.1;\nconst SKIP_BUFFER_RANGE_START = 0.05;\nclass GapController {\n    constructor(config, media, fragmentTracker, hls){\n        this.config = void 0;\n        this.media = null;\n        this.fragmentTracker = void 0;\n        this.hls = void 0;\n        this.nudgeRetry = 0;\n        this.stallReported = false;\n        this.stalled = null;\n        this.moved = false;\n        this.seeking = false;\n        this.config = config;\n        this.media = media;\n        this.fragmentTracker = fragmentTracker;\n        this.hls = hls;\n    }\n    destroy() {\n        this.media = null;\n        // @ts-ignore\n        this.hls = this.fragmentTracker = null;\n    }\n    /**\n   * Checks if the playhead is stuck within a gap, and if so, attempts to free it.\n   * A gap is an unbuffered range between two buffered ranges (or the start and the first buffered range).\n   *\n   * @param lastCurrentTime - Previously read playhead position\n   */ poll(lastCurrentTime, activeFrag) {\n        const { config, media, stalled } = this;\n        if (media === null) {\n            return;\n        }\n        const { currentTime, seeking } = media;\n        const seeked = this.seeking && !seeking;\n        const beginSeek = !this.seeking && seeking;\n        this.seeking = seeking;\n        // The playhead is moving, no-op\n        if (currentTime !== lastCurrentTime) {\n            this.moved = true;\n            if (!seeking) {\n                this.nudgeRetry = 0;\n            }\n            if (stalled !== null) {\n                // The playhead is now moving, but was previously stalled\n                if (this.stallReported) {\n                    const _stalledDuration = self.performance.now() - stalled;\n                    logger.warn(`playback not stuck anymore @${currentTime}, after ${Math.round(_stalledDuration)}ms`);\n                    this.stallReported = false;\n                }\n                this.stalled = null;\n            }\n            return;\n        }\n        // Clear stalled state when beginning or finishing seeking so that we don't report stalls coming out of a seek\n        if (beginSeek || seeked) {\n            this.stalled = null;\n            return;\n        }\n        // The playhead should not be moving\n        if (media.paused && !seeking || media.ended || media.playbackRate === 0 || !BufferHelper.getBuffered(media).length) {\n            this.nudgeRetry = 0;\n            return;\n        }\n        const bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);\n        const nextStart = bufferInfo.nextStart || 0;\n        if (seeking) {\n            // Waiting for seeking in a buffered range to complete\n            const hasEnoughBuffer = bufferInfo.len > MAX_START_GAP_JUMP;\n            // Next buffered range is too far ahead to jump to while still seeking\n            const noBufferGap = !nextStart || activeFrag && activeFrag.start <= currentTime || nextStart - currentTime > MAX_START_GAP_JUMP && !this.fragmentTracker.getPartialFragment(currentTime);\n            if (hasEnoughBuffer || noBufferGap) {\n                return;\n            }\n            // Reset moved state when seeking to a point in or before a gap\n            this.moved = false;\n        }\n        // Skip start gaps if we haven't played, but the last poll detected the start of a stall\n        // The addition poll gives the browser a chance to jump the gap for us\n        if (!this.moved && this.stalled !== null) {\n            var _level$details;\n            // There is no playable buffer (seeked, waiting for buffer)\n            const isBuffered = bufferInfo.len > 0;\n            if (!isBuffered && !nextStart) {\n                return;\n            }\n            // Jump start gaps within jump threshold\n            const startJump = Math.max(nextStart, bufferInfo.start || 0) - currentTime;\n            // When joining a live stream with audio tracks, account for live playlist window sliding by allowing\n            // a larger jump over start gaps caused by the audio-stream-controller buffering a start fragment\n            // that begins over 1 target duration after the video start position.\n            const level = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null;\n            const isLive = level == null ? void 0 : (_level$details = level.details) == null ? void 0 : _level$details.live;\n            const maxStartGapJump = isLive ? level.details.targetduration * 2 : MAX_START_GAP_JUMP;\n            const partialOrGap = this.fragmentTracker.getPartialFragment(currentTime);\n            if (startJump > 0 && (startJump <= maxStartGapJump || partialOrGap)) {\n                if (!media.paused) {\n                    this._trySkipBufferHole(partialOrGap);\n                }\n                return;\n            }\n        }\n        // Start tracking stall time\n        const tnow = self.performance.now();\n        if (stalled === null) {\n            this.stalled = tnow;\n            return;\n        }\n        const stalledDuration = tnow - stalled;\n        if (!seeking && stalledDuration >= STALL_MINIMUM_DURATION_MS) {\n            // Report stalling after trying to fix\n            this._reportStall(bufferInfo);\n            if (!this.media) {\n                return;\n            }\n        }\n        const bufferedWithHoles = BufferHelper.bufferInfo(media, currentTime, config.maxBufferHole);\n        this._tryFixBufferStall(bufferedWithHoles, stalledDuration);\n    }\n    /**\n   * Detects and attempts to fix known buffer stalling issues.\n   * @param bufferInfo - The properties of the current buffer.\n   * @param stalledDurationMs - The amount of time Hls.js has been stalling for.\n   * @private\n   */ _tryFixBufferStall(bufferInfo, stalledDurationMs) {\n        const { config, fragmentTracker, media } = this;\n        if (media === null) {\n            return;\n        }\n        const currentTime = media.currentTime;\n        const partial = fragmentTracker.getPartialFragment(currentTime);\n        if (partial) {\n            // Try to skip over the buffer hole caused by a partial fragment\n            // This method isn't limited by the size of the gap between buffered ranges\n            const targetTime = this._trySkipBufferHole(partial);\n            // we return here in this case, meaning\n            // the branch below only executes when we haven't seeked to a new position\n            if (targetTime || !this.media) {\n                return;\n            }\n        }\n        // if we haven't had to skip over a buffer hole of a partial fragment\n        // we may just have to \"nudge\" the playlist as the browser decoding/rendering engine\n        // needs to cross some sort of threshold covering all source-buffers content\n        // to start playing properly.\n        if ((bufferInfo.len > config.maxBufferHole || bufferInfo.nextStart && bufferInfo.nextStart - currentTime < config.maxBufferHole) && stalledDurationMs > config.highBufferWatchdogPeriod * 1000) {\n            logger.warn(\"Trying to nudge playhead over buffer-hole\");\n            // Try to nudge currentTime over a buffer hole if we've been stalling for the configured amount of seconds\n            // We only try to jump the hole if it's under the configured size\n            // Reset stalled so to rearm watchdog timer\n            this.stalled = null;\n            this._tryNudgeBuffer();\n        }\n    }\n    /**\n   * Triggers a BUFFER_STALLED_ERROR event, but only once per stall period.\n   * @param bufferLen - The playhead distance from the end of the current buffer segment.\n   * @private\n   */ _reportStall(bufferInfo) {\n        const { hls, media, stallReported } = this;\n        if (!stallReported && media) {\n            // Report stalled error once\n            this.stallReported = true;\n            const error = new Error(`Playback stalling at @${media.currentTime} due to low buffer (${JSON.stringify(bufferInfo)})`);\n            logger.warn(error.message);\n            hls.trigger(Events.ERROR, {\n                type: ErrorTypes.MEDIA_ERROR,\n                details: ErrorDetails.BUFFER_STALLED_ERROR,\n                fatal: false,\n                error,\n                buffer: bufferInfo.len\n            });\n        }\n    }\n    /**\n   * Attempts to fix buffer stalls by jumping over known gaps caused by partial fragments\n   * @param partial - The partial fragment found at the current time (where playback is stalling).\n   * @private\n   */ _trySkipBufferHole(partial) {\n        const { config, hls, media } = this;\n        if (media === null) {\n            return 0;\n        }\n        // Check if currentTime is between unbuffered regions of partial fragments\n        const currentTime = media.currentTime;\n        const bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);\n        const startTime = currentTime < bufferInfo.start ? bufferInfo.start : bufferInfo.nextStart;\n        if (startTime) {\n            const bufferStarved = bufferInfo.len <= config.maxBufferHole;\n            const waiting = bufferInfo.len > 0 && bufferInfo.len < 1 && media.readyState < 3;\n            const gapLength = startTime - currentTime;\n            if (gapLength > 0 && (bufferStarved || waiting)) {\n                // Only allow large gaps to be skipped if it is a start gap, or all fragments in skip range are partial\n                if (gapLength > config.maxBufferHole) {\n                    const { fragmentTracker } = this;\n                    let startGap = false;\n                    if (currentTime === 0) {\n                        const startFrag = fragmentTracker.getAppendedFrag(0, PlaylistLevelType.MAIN);\n                        if (startFrag && startTime < startFrag.end) {\n                            startGap = true;\n                        }\n                    }\n                    if (!startGap) {\n                        const startProvisioned = partial || fragmentTracker.getAppendedFrag(currentTime, PlaylistLevelType.MAIN);\n                        if (startProvisioned) {\n                            let moreToLoad = false;\n                            let pos = startProvisioned.end;\n                            while(pos < startTime){\n                                const provisioned = fragmentTracker.getPartialFragment(pos);\n                                if (provisioned) {\n                                    pos += provisioned.duration;\n                                } else {\n                                    moreToLoad = true;\n                                    break;\n                                }\n                            }\n                            if (moreToLoad) {\n                                return 0;\n                            }\n                        }\n                    }\n                }\n                const targetTime = Math.max(startTime + SKIP_BUFFER_RANGE_START, currentTime + SKIP_BUFFER_HOLE_STEP_SECONDS);\n                logger.warn(`skipping hole, adjusting currentTime from ${currentTime} to ${targetTime}`);\n                this.moved = true;\n                this.stalled = null;\n                media.currentTime = targetTime;\n                if (partial && !partial.gap) {\n                    const error = new Error(`fragment loaded with buffer holes, seeking from ${currentTime} to ${targetTime}`);\n                    hls.trigger(Events.ERROR, {\n                        type: ErrorTypes.MEDIA_ERROR,\n                        details: ErrorDetails.BUFFER_SEEK_OVER_HOLE,\n                        fatal: false,\n                        error,\n                        reason: error.message,\n                        frag: partial\n                    });\n                }\n                return targetTime;\n            }\n        }\n        return 0;\n    }\n    /**\n   * Attempts to fix buffer stalls by advancing the mediaElement's current time by a small amount.\n   * @private\n   */ _tryNudgeBuffer() {\n        const { config, hls, media, nudgeRetry } = this;\n        if (media === null) {\n            return;\n        }\n        const currentTime = media.currentTime;\n        this.nudgeRetry++;\n        if (nudgeRetry < config.nudgeMaxRetry) {\n            const targetTime = currentTime + (nudgeRetry + 1) * config.nudgeOffset;\n            // playback stalled in buffered area ... let's nudge currentTime to try to overcome this\n            const error = new Error(`Nudging 'currentTime' from ${currentTime} to ${targetTime}`);\n            logger.warn(error.message);\n            media.currentTime = targetTime;\n            hls.trigger(Events.ERROR, {\n                type: ErrorTypes.MEDIA_ERROR,\n                details: ErrorDetails.BUFFER_NUDGE_ON_STALL,\n                error,\n                fatal: false\n            });\n        } else {\n            const error = new Error(`Playhead still not moving while enough data buffered @${currentTime} after ${config.nudgeMaxRetry} nudges`);\n            logger.error(error.message);\n            hls.trigger(Events.ERROR, {\n                type: ErrorTypes.MEDIA_ERROR,\n                details: ErrorDetails.BUFFER_STALLED_ERROR,\n                error,\n                fatal: true\n            });\n        }\n    }\n}\nconst TICK_INTERVAL = 100; // how often to tick in ms\nclass StreamController extends BaseStreamController {\n    constructor(hls, fragmentTracker, keyLoader){\n        super(hls, fragmentTracker, keyLoader, \"[stream-controller]\", PlaylistLevelType.MAIN);\n        this.audioCodecSwap = false;\n        this.gapController = null;\n        this.level = -1;\n        this._forceStartLoad = false;\n        this.altAudio = false;\n        this.audioOnly = false;\n        this.fragPlaying = null;\n        this.onvplaying = null;\n        this.onvseeked = null;\n        this.fragLastKbps = 0;\n        this.couldBacktrack = false;\n        this.backtrackFragment = null;\n        this.audioCodecSwitch = false;\n        this.videoBuffer = null;\n        this._registerListeners();\n    }\n    _registerListeners() {\n        const { hls } = this;\n        hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n        hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n        hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n        hls.on(Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);\n        hls.on(Events.ERROR, this.onError, this);\n        hls.on(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n        hls.on(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n        hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);\n        hls.on(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n        hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n        hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    }\n    _unregisterListeners() {\n        const { hls } = this;\n        hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n        hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n        hls.off(Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);\n        hls.off(Events.ERROR, this.onError, this);\n        hls.off(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n        hls.off(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n        hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);\n        hls.off(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n        hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n        hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    }\n    onHandlerDestroying() {\n        this._unregisterListeners();\n        super.onHandlerDestroying();\n    }\n    startLoad(startPosition) {\n        if (this.levels) {\n            const { lastCurrentTime, hls } = this;\n            this.stopLoad();\n            this.setInterval(TICK_INTERVAL);\n            this.level = -1;\n            if (!this.startFragRequested) {\n                // determine load level\n                let startLevel = hls.startLevel;\n                if (startLevel === -1) {\n                    if (hls.config.testBandwidth && this.levels.length > 1) {\n                        // -1 : guess start Level by doing a bitrate test by loading first fragment of lowest quality level\n                        startLevel = 0;\n                        this.bitrateTest = true;\n                    } else {\n                        startLevel = hls.firstAutoLevel;\n                    }\n                }\n                // set new level to playlist loader : this will trigger start level load\n                // hls.nextLoadLevel remains until it is set to a new value or until a new frag is successfully loaded\n                hls.nextLoadLevel = startLevel;\n                this.level = hls.loadLevel;\n                this.loadedmetadata = false;\n            }\n            // if startPosition undefined but lastCurrentTime set, set startPosition to last currentTime\n            if (lastCurrentTime > 0 && startPosition === -1) {\n                this.log(`Override startPosition with lastCurrentTime @${lastCurrentTime.toFixed(3)}`);\n                startPosition = lastCurrentTime;\n            }\n            this.state = State.IDLE;\n            this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;\n            this.tick();\n        } else {\n            this._forceStartLoad = true;\n            this.state = State.STOPPED;\n        }\n    }\n    stopLoad() {\n        this._forceStartLoad = false;\n        super.stopLoad();\n    }\n    doTick() {\n        switch(this.state){\n            case State.WAITING_LEVEL:\n                {\n                    const { levels, level } = this;\n                    const currentLevel = levels == null ? void 0 : levels[level];\n                    const details = currentLevel == null ? void 0 : currentLevel.details;\n                    if (details && (!details.live || this.levelLastLoaded === currentLevel)) {\n                        if (this.waitForCdnTuneIn(details)) {\n                            break;\n                        }\n                        this.state = State.IDLE;\n                        break;\n                    } else if (this.hls.nextLoadLevel !== this.level) {\n                        this.state = State.IDLE;\n                        break;\n                    }\n                    break;\n                }\n            case State.FRAG_LOADING_WAITING_RETRY:\n                {\n                    var _this$media;\n                    const now = self.performance.now();\n                    const retryDate = this.retryDate;\n                    // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading\n                    if (!retryDate || now >= retryDate || (_this$media = this.media) != null && _this$media.seeking) {\n                        const { levels, level } = this;\n                        const currentLevel = levels == null ? void 0 : levels[level];\n                        this.resetStartWhenNotLoaded(currentLevel || null);\n                        this.state = State.IDLE;\n                    }\n                }\n                break;\n        }\n        if (this.state === State.IDLE) {\n            this.doTickIdle();\n        }\n        this.onTickEnd();\n    }\n    onTickEnd() {\n        super.onTickEnd();\n        this.checkBuffer();\n        this.checkFragmentChanged();\n    }\n    doTickIdle() {\n        const { hls, levelLastLoaded, levels, media } = this;\n        // if start level not parsed yet OR\n        // if video not attached AND start fragment already requested OR start frag prefetch not enabled\n        // exit loop, as we either need more info (level not parsed) or we need media to be attached to load new fragment\n        if (levelLastLoaded === null || !media && (this.startFragRequested || !hls.config.startFragPrefetch)) {\n            return;\n        }\n        // If the \"main\" level is audio-only but we are loading an alternate track in the same group, do not load anything\n        if (this.altAudio && this.audioOnly) {\n            return;\n        }\n        const level = hls.nextLoadLevel;\n        if (!(levels != null && levels[level])) {\n            return;\n        }\n        const levelInfo = levels[level];\n        // if buffer length is less than maxBufLen try to load a new fragment\n        const bufferInfo = this.getMainFwdBufferInfo();\n        if (bufferInfo === null) {\n            return;\n        }\n        const lastDetails = this.getLevelDetails();\n        if (lastDetails && this._streamEnded(bufferInfo, lastDetails)) {\n            const data = {};\n            if (this.altAudio) {\n                data.type = \"video\";\n            }\n            this.hls.trigger(Events.BUFFER_EOS, data);\n            this.state = State.ENDED;\n            return;\n        }\n        // set next load level : this will trigger a playlist load if needed\n        if (hls.loadLevel !== level && hls.manualLevel === -1) {\n            this.log(`Adapting to level ${level} from level ${this.level}`);\n        }\n        this.level = hls.nextLoadLevel = level;\n        const levelDetails = levelInfo.details;\n        // if level info not retrieved yet, switch state and wait for level retrieval\n        // if live playlist, ensure that new playlist has been refreshed to avoid loading/try to load\n        // a useless and outdated fragment (that might even introduce load error if it is already out of the live playlist)\n        if (!levelDetails || this.state === State.WAITING_LEVEL || levelDetails.live && this.levelLastLoaded !== levelInfo) {\n            this.level = level;\n            this.state = State.WAITING_LEVEL;\n            return;\n        }\n        const bufferLen = bufferInfo.len;\n        // compute max Buffer Length that we could get from this load level, based on level bitrate. don't buffer more than 60 MB and more than 30s\n        const maxBufLen = this.getMaxBufferLength(levelInfo.maxBitrate);\n        // Stay idle if we are still with buffer margins\n        if (bufferLen >= maxBufLen) {\n            return;\n        }\n        if (this.backtrackFragment && this.backtrackFragment.start > bufferInfo.end) {\n            this.backtrackFragment = null;\n        }\n        const targetBufferTime = this.backtrackFragment ? this.backtrackFragment.start : bufferInfo.end;\n        let frag = this.getNextFragment(targetBufferTime, levelDetails);\n        // Avoid backtracking by loading an earlier segment in streams with segments that do not start with a key frame (flagged by `couldBacktrack`)\n        if (this.couldBacktrack && !this.fragPrevious && frag && frag.sn !== \"initSegment\" && this.fragmentTracker.getState(frag) !== FragmentState.OK) {\n            var _this$backtrackFragme;\n            const backtrackSn = ((_this$backtrackFragme = this.backtrackFragment) != null ? _this$backtrackFragme : frag).sn;\n            const fragIdx = backtrackSn - levelDetails.startSN;\n            const backtrackFrag = levelDetails.fragments[fragIdx - 1];\n            if (backtrackFrag && frag.cc === backtrackFrag.cc) {\n                frag = backtrackFrag;\n                this.fragmentTracker.removeFragment(backtrackFrag);\n            }\n        } else if (this.backtrackFragment && bufferInfo.len) {\n            this.backtrackFragment = null;\n        }\n        // Avoid loop loading by using nextLoadPosition set for backtracking and skipping consecutive GAP tags\n        if (frag && this.isLoopLoading(frag, targetBufferTime)) {\n            const gapStart = frag.gap;\n            if (!gapStart) {\n                // Cleanup the fragment tracker before trying to find the next unbuffered fragment\n                const type = this.audioOnly && !this.altAudio ? ElementaryStreamTypes.AUDIO : ElementaryStreamTypes.VIDEO;\n                const mediaBuffer = (type === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;\n                if (mediaBuffer) {\n                    this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.MAIN);\n                }\n            }\n            frag = this.getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, PlaylistLevelType.MAIN, maxBufLen);\n        }\n        if (!frag) {\n            return;\n        }\n        if (frag.initSegment && !frag.initSegment.data && !this.bitrateTest) {\n            frag = frag.initSegment;\n        }\n        this.loadFragment(frag, levelInfo, targetBufferTime);\n    }\n    loadFragment(frag, level, targetBufferTime) {\n        // Check if fragment is not loaded\n        const fragState = this.fragmentTracker.getState(frag);\n        this.fragCurrent = frag;\n        if (fragState === FragmentState.NOT_LOADED || fragState === FragmentState.PARTIAL) {\n            if (frag.sn === \"initSegment\") {\n                this._loadInitSegment(frag, level);\n            } else if (this.bitrateTest) {\n                this.log(`Fragment ${frag.sn} of level ${frag.level} is being downloaded to test bitrate and will not be buffered`);\n                this._loadBitrateTestFrag(frag, level);\n            } else {\n                this.startFragRequested = true;\n                super.loadFragment(frag, level, targetBufferTime);\n            }\n        } else {\n            this.clearTrackerIfNeeded(frag);\n        }\n    }\n    getBufferedFrag(position) {\n        return this.fragmentTracker.getBufferedFrag(position, PlaylistLevelType.MAIN);\n    }\n    followingBufferedFrag(frag) {\n        if (frag) {\n            // try to get range of next fragment (500ms after this range)\n            return this.getBufferedFrag(frag.end + 0.5);\n        }\n        return null;\n    }\n    /*\n    on immediate level switch :\n     - pause playback if playing\n     - cancel any pending load request\n     - and trigger a buffer flush\n  */ immediateLevelSwitch() {\n        this.abortCurrentFrag();\n        this.flushMainBuffer(0, Number.POSITIVE_INFINITY);\n    }\n    /**\n   * try to switch ASAP without breaking video playback:\n   * in order to ensure smooth but quick level switching,\n   * we need to find the next flushable buffer range\n   * we should take into account new segment fetch time\n   */ nextLevelSwitch() {\n        const { levels, media } = this;\n        // ensure that media is defined and that metadata are available (to retrieve currentTime)\n        if (media != null && media.readyState) {\n            let fetchdelay;\n            const fragPlayingCurrent = this.getAppendedFrag(media.currentTime);\n            if (fragPlayingCurrent && fragPlayingCurrent.start > 1) {\n                // flush buffer preceding current fragment (flush until current fragment start offset)\n                // minus 1s to avoid video freezing, that could happen if we flush keyframe of current video ...\n                this.flushMainBuffer(0, fragPlayingCurrent.start - 1);\n            }\n            const levelDetails = this.getLevelDetails();\n            if (levelDetails != null && levelDetails.live) {\n                const bufferInfo = this.getMainFwdBufferInfo();\n                // Do not flush in live stream with low buffer\n                if (!bufferInfo || bufferInfo.len < levelDetails.targetduration * 2) {\n                    return;\n                }\n            }\n            if (!media.paused && levels) {\n                // add a safety delay of 1s\n                const nextLevelId = this.hls.nextLoadLevel;\n                const nextLevel = levels[nextLevelId];\n                const fragLastKbps = this.fragLastKbps;\n                if (fragLastKbps && this.fragCurrent) {\n                    fetchdelay = this.fragCurrent.duration * nextLevel.maxBitrate / (1000 * fragLastKbps) + 1;\n                } else {\n                    fetchdelay = 0;\n                }\n            } else {\n                fetchdelay = 0;\n            }\n            // this.log('fetchdelay:'+fetchdelay);\n            // find buffer range that will be reached once new fragment will be fetched\n            const bufferedFrag = this.getBufferedFrag(media.currentTime + fetchdelay);\n            if (bufferedFrag) {\n                // we can flush buffer range following this one without stalling playback\n                const nextBufferedFrag = this.followingBufferedFrag(bufferedFrag);\n                if (nextBufferedFrag) {\n                    // if we are here, we can also cancel any loading/demuxing in progress, as they are useless\n                    this.abortCurrentFrag();\n                    // start flush position is in next buffered frag. Leave some padding for non-independent segments and smoother playback.\n                    const maxStart = nextBufferedFrag.maxStartPTS ? nextBufferedFrag.maxStartPTS : nextBufferedFrag.start;\n                    const fragDuration = nextBufferedFrag.duration;\n                    const startPts = Math.max(bufferedFrag.end, maxStart + Math.min(Math.max(fragDuration - this.config.maxFragLookUpTolerance, fragDuration * (this.couldBacktrack ? 0.5 : 0.125)), fragDuration * (this.couldBacktrack ? 0.75 : 0.25)));\n                    this.flushMainBuffer(startPts, Number.POSITIVE_INFINITY);\n                }\n            }\n        }\n    }\n    abortCurrentFrag() {\n        const fragCurrent = this.fragCurrent;\n        this.fragCurrent = null;\n        this.backtrackFragment = null;\n        if (fragCurrent) {\n            fragCurrent.abortRequests();\n            this.fragmentTracker.removeFragment(fragCurrent);\n        }\n        switch(this.state){\n            case State.KEY_LOADING:\n            case State.FRAG_LOADING:\n            case State.FRAG_LOADING_WAITING_RETRY:\n            case State.PARSING:\n            case State.PARSED:\n                this.state = State.IDLE;\n                break;\n        }\n        this.nextLoadPosition = this.getLoadPosition();\n    }\n    flushMainBuffer(startOffset, endOffset) {\n        super.flushMainBuffer(startOffset, endOffset, this.altAudio ? \"video\" : null);\n    }\n    onMediaAttached(event, data) {\n        super.onMediaAttached(event, data);\n        const media = data.media;\n        this.onvplaying = this.onMediaPlaying.bind(this);\n        this.onvseeked = this.onMediaSeeked.bind(this);\n        media.addEventListener(\"playing\", this.onvplaying);\n        media.addEventListener(\"seeked\", this.onvseeked);\n        this.gapController = new GapController(this.config, media, this.fragmentTracker, this.hls);\n    }\n    onMediaDetaching() {\n        const { media } = this;\n        if (media && this.onvplaying && this.onvseeked) {\n            media.removeEventListener(\"playing\", this.onvplaying);\n            media.removeEventListener(\"seeked\", this.onvseeked);\n            this.onvplaying = this.onvseeked = null;\n            this.videoBuffer = null;\n        }\n        this.fragPlaying = null;\n        if (this.gapController) {\n            this.gapController.destroy();\n            this.gapController = null;\n        }\n        super.onMediaDetaching();\n    }\n    onMediaPlaying() {\n        // tick to speed up FRAG_CHANGED triggering\n        this.tick();\n    }\n    onMediaSeeked() {\n        const media = this.media;\n        const currentTime = media ? media.currentTime : null;\n        if (isFiniteNumber(currentTime)) {\n            this.log(`Media seeked to ${currentTime.toFixed(3)}`);\n        }\n        // If seeked was issued before buffer was appended do not tick immediately\n        const bufferInfo = this.getMainFwdBufferInfo();\n        if (bufferInfo === null || bufferInfo.len === 0) {\n            this.warn(`Main forward buffer length on \"seeked\" event ${bufferInfo ? bufferInfo.len : \"empty\"})`);\n            return;\n        }\n        // tick to speed up FRAG_CHANGED triggering\n        this.tick();\n    }\n    onManifestLoading() {\n        // reset buffer on manifest loading\n        this.log(\"Trigger BUFFER_RESET\");\n        this.hls.trigger(Events.BUFFER_RESET, undefined);\n        this.fragmentTracker.removeAllFragments();\n        this.couldBacktrack = false;\n        this.startPosition = this.lastCurrentTime = this.fragLastKbps = 0;\n        this.levels = this.fragPlaying = this.backtrackFragment = this.levelLastLoaded = null;\n        this.altAudio = this.audioOnly = this.startFragRequested = false;\n    }\n    onManifestParsed(event, data) {\n        // detect if we have different kind of audio codecs used amongst playlists\n        let aac = false;\n        let heaac = false;\n        data.levels.forEach((level)=>{\n            const codec = level.audioCodec;\n            if (codec) {\n                aac = aac || codec.indexOf(\"mp4a.40.2\") !== -1;\n                heaac = heaac || codec.indexOf(\"mp4a.40.5\") !== -1;\n            }\n        });\n        this.audioCodecSwitch = aac && heaac && !changeTypeSupported();\n        if (this.audioCodecSwitch) {\n            this.log(\"Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC\");\n        }\n        this.levels = data.levels;\n        this.startFragRequested = false;\n    }\n    onLevelLoading(event, data) {\n        const { levels } = this;\n        if (!levels || this.state !== State.IDLE) {\n            return;\n        }\n        const level = levels[data.level];\n        if (!level.details || level.details.live && this.levelLastLoaded !== level || this.waitForCdnTuneIn(level.details)) {\n            this.state = State.WAITING_LEVEL;\n        }\n    }\n    onLevelLoaded(event, data) {\n        var _curLevel$details;\n        const { levels } = this;\n        const newLevelId = data.level;\n        const newDetails = data.details;\n        const duration = newDetails.totalduration;\n        if (!levels) {\n            this.warn(`Levels were reset while loading level ${newLevelId}`);\n            return;\n        }\n        this.log(`Level ${newLevelId} loaded [${newDetails.startSN},${newDetails.endSN}]${newDetails.lastPartSn ? `[part-${newDetails.lastPartSn}-${newDetails.lastPartIndex}]` : \"\"}, cc [${newDetails.startCC}, ${newDetails.endCC}] duration:${duration}`);\n        const curLevel = levels[newLevelId];\n        const fragCurrent = this.fragCurrent;\n        if (fragCurrent && (this.state === State.FRAG_LOADING || this.state === State.FRAG_LOADING_WAITING_RETRY)) {\n            if (fragCurrent.level !== data.level && fragCurrent.loader) {\n                this.abortCurrentFrag();\n            }\n        }\n        let sliding = 0;\n        if (newDetails.live || (_curLevel$details = curLevel.details) != null && _curLevel$details.live) {\n            var _this$levelLastLoaded;\n            this.checkLiveUpdate(newDetails);\n            if (newDetails.deltaUpdateFailed) {\n                return;\n            }\n            sliding = this.alignPlaylists(newDetails, curLevel.details, (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details);\n        }\n        // override level info\n        curLevel.details = newDetails;\n        this.levelLastLoaded = curLevel;\n        this.hls.trigger(Events.LEVEL_UPDATED, {\n            details: newDetails,\n            level: newLevelId\n        });\n        // only switch back to IDLE state if we were waiting for level to start downloading a new fragment\n        if (this.state === State.WAITING_LEVEL) {\n            if (this.waitForCdnTuneIn(newDetails)) {\n                // Wait for Low-Latency CDN Tune-in\n                return;\n            }\n            this.state = State.IDLE;\n        }\n        if (!this.startFragRequested) {\n            this.setStartPosition(newDetails, sliding);\n        } else if (newDetails.live) {\n            this.synchronizeToLiveEdge(newDetails);\n        }\n        // trigger handler right now\n        this.tick();\n    }\n    _handleFragmentLoadProgress(data) {\n        var _frag$initSegment;\n        const { frag, part, payload } = data;\n        const { levels } = this;\n        if (!levels) {\n            this.warn(`Levels were reset while fragment load was in progress. Fragment ${frag.sn} of level ${frag.level} will not be buffered`);\n            return;\n        }\n        const currentLevel = levels[frag.level];\n        const details = currentLevel.details;\n        if (!details) {\n            this.warn(`Dropping fragment ${frag.sn} of level ${frag.level} after level details were reset`);\n            this.fragmentTracker.removeFragment(frag);\n            return;\n        }\n        const videoCodec = currentLevel.videoCodec;\n        // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)\n        const accurateTimeOffset = details.PTSKnown || !details.live;\n        const initSegmentData = (_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.data;\n        const audioCodec = this._getAudioCodec(currentLevel);\n        // transmux the MPEG-TS data to ISO-BMFF segments\n        // this.log(`Transmuxing ${frag.sn} of [${details.startSN} ,${details.endSN}],level ${frag.level}, cc ${frag.cc}`);\n        const transmuxer = this.transmuxer = this.transmuxer || new TransmuxerInterface(this.hls, PlaylistLevelType.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));\n        const partIndex = part ? part.index : -1;\n        const partial = partIndex !== -1;\n        const chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);\n        const initPTS = this.initPTS[frag.cc];\n        transmuxer.push(payload, initSegmentData, audioCodec, videoCodec, frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);\n    }\n    onAudioTrackSwitching(event, data) {\n        // if any URL found on new audio track, it is an alternate audio track\n        const fromAltAudio = this.altAudio;\n        const altAudio = !!data.url;\n        // if we switch on main audio, ensure that main fragment scheduling is synced with media.buffered\n        // don't do anything if we switch to alt audio: audio stream controller is handling it.\n        // we will just have to change buffer scheduling on audioTrackSwitched\n        if (!altAudio) {\n            if (this.mediaBuffer !== this.media) {\n                this.log(\"Switching on main audio, use media.buffered to schedule main fragment loading\");\n                this.mediaBuffer = this.media;\n                const fragCurrent = this.fragCurrent;\n                // we need to refill audio buffer from main: cancel any frag loading to speed up audio switch\n                if (fragCurrent) {\n                    this.log(\"Switching to main audio track, cancel main fragment load\");\n                    fragCurrent.abortRequests();\n                    this.fragmentTracker.removeFragment(fragCurrent);\n                }\n                // destroy transmuxer to force init segment generation (following audio switch)\n                this.resetTransmuxer();\n                // switch to IDLE state to load new fragment\n                this.resetLoadingState();\n            } else if (this.audioOnly) {\n                // Reset audio transmuxer so when switching back to main audio we're not still appending where we left off\n                this.resetTransmuxer();\n            }\n            const hls = this.hls;\n            // If switching from alt to main audio, flush all audio and trigger track switched\n            if (fromAltAudio) {\n                hls.trigger(Events.BUFFER_FLUSHING, {\n                    startOffset: 0,\n                    endOffset: Number.POSITIVE_INFINITY,\n                    type: null\n                });\n                this.fragmentTracker.removeAllFragments();\n            }\n            hls.trigger(Events.AUDIO_TRACK_SWITCHED, data);\n        }\n    }\n    onAudioTrackSwitched(event, data) {\n        const trackId = data.id;\n        const altAudio = !!this.hls.audioTracks[trackId].url;\n        if (altAudio) {\n            const videoBuffer = this.videoBuffer;\n            // if we switched on alternate audio, ensure that main fragment scheduling is synced with video sourcebuffer buffered\n            if (videoBuffer && this.mediaBuffer !== videoBuffer) {\n                this.log(\"Switching on alternate audio, use video.buffered to schedule main fragment loading\");\n                this.mediaBuffer = videoBuffer;\n            }\n        }\n        this.altAudio = altAudio;\n        this.tick();\n    }\n    onBufferCreated(event, data) {\n        const tracks = data.tracks;\n        let mediaTrack;\n        let name;\n        let alternate = false;\n        for(const type in tracks){\n            const track = tracks[type];\n            if (track.id === \"main\") {\n                name = type;\n                mediaTrack = track;\n                // keep video source buffer reference\n                if (type === \"video\") {\n                    const videoTrack = tracks[type];\n                    if (videoTrack) {\n                        this.videoBuffer = videoTrack.buffer;\n                    }\n                }\n            } else {\n                alternate = true;\n            }\n        }\n        if (alternate && mediaTrack) {\n            this.log(`Alternate track found, use ${name}.buffered to schedule main fragment loading`);\n            this.mediaBuffer = mediaTrack.buffer;\n        } else {\n            this.mediaBuffer = this.media;\n        }\n    }\n    onFragBuffered(event, data) {\n        const { frag, part } = data;\n        if (frag && frag.type !== PlaylistLevelType.MAIN) {\n            return;\n        }\n        if (this.fragContextChanged(frag)) {\n            // If a level switch was requested while a fragment was buffering, it will emit the FRAG_BUFFERED event upon completion\n            // Avoid setting state back to IDLE, since that will interfere with a level switch\n            this.warn(`Fragment ${frag.sn}${part ? \" p: \" + part.index : \"\"} of level ${frag.level} finished buffering, but was aborted. state: ${this.state}`);\n            if (this.state === State.PARSED) {\n                this.state = State.IDLE;\n            }\n            return;\n        }\n        const stats = part ? part.stats : frag.stats;\n        this.fragLastKbps = Math.round(8 * stats.total / (stats.buffering.end - stats.loading.first));\n        if (frag.sn !== \"initSegment\") {\n            this.fragPrevious = frag;\n        }\n        this.fragBufferedComplete(frag, part);\n    }\n    onError(event, data) {\n        var _data$context;\n        if (data.fatal) {\n            this.state = State.ERROR;\n            return;\n        }\n        switch(data.details){\n            case ErrorDetails.FRAG_GAP:\n            case ErrorDetails.FRAG_PARSING_ERROR:\n            case ErrorDetails.FRAG_DECRYPT_ERROR:\n            case ErrorDetails.FRAG_LOAD_ERROR:\n            case ErrorDetails.FRAG_LOAD_TIMEOUT:\n            case ErrorDetails.KEY_LOAD_ERROR:\n            case ErrorDetails.KEY_LOAD_TIMEOUT:\n                this.onFragmentOrKeyLoadError(PlaylistLevelType.MAIN, data);\n                break;\n            case ErrorDetails.LEVEL_LOAD_ERROR:\n            case ErrorDetails.LEVEL_LOAD_TIMEOUT:\n            case ErrorDetails.LEVEL_PARSING_ERROR:\n                // in case of non fatal error while loading level, if level controller is not retrying to load level, switch back to IDLE\n                if (!data.levelRetry && this.state === State.WAITING_LEVEL && ((_data$context = data.context) == null ? void 0 : _data$context.type) === PlaylistContextType.LEVEL) {\n                    this.state = State.IDLE;\n                }\n                break;\n            case ErrorDetails.BUFFER_APPEND_ERROR:\n            case ErrorDetails.BUFFER_FULL_ERROR:\n                if (!data.parent || data.parent !== \"main\") {\n                    return;\n                }\n                if (data.details === ErrorDetails.BUFFER_APPEND_ERROR) {\n                    this.resetLoadingState();\n                    return;\n                }\n                if (this.reduceLengthAndFlushBuffer(data)) {\n                    this.flushMainBuffer(0, Number.POSITIVE_INFINITY);\n                }\n                break;\n            case ErrorDetails.INTERNAL_EXCEPTION:\n                this.recoverWorkerError(data);\n                break;\n        }\n    }\n    // Checks the health of the buffer and attempts to resolve playback stalls.\n    checkBuffer() {\n        const { media, gapController } = this;\n        if (!media || !gapController || !media.readyState) {\n            // Exit early if we don't have media or if the media hasn't buffered anything yet (readyState 0)\n            return;\n        }\n        if (this.loadedmetadata || !BufferHelper.getBuffered(media).length) {\n            // Resolve gaps using the main buffer, whose ranges are the intersections of the A/V sourcebuffers\n            const activeFrag = this.state !== State.IDLE ? this.fragCurrent : null;\n            gapController.poll(this.lastCurrentTime, activeFrag);\n        }\n        this.lastCurrentTime = media.currentTime;\n    }\n    onFragLoadEmergencyAborted() {\n        this.state = State.IDLE;\n        // if loadedmetadata is not set, it means that we are emergency switch down on first frag\n        // in that case, reset startFragRequested flag\n        if (!this.loadedmetadata) {\n            this.startFragRequested = false;\n            this.nextLoadPosition = this.startPosition;\n        }\n        this.tickImmediate();\n    }\n    onBufferFlushed(event, { type }) {\n        if (type !== ElementaryStreamTypes.AUDIO || this.audioOnly && !this.altAudio) {\n            const mediaBuffer = (type === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;\n            this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.MAIN);\n            this.tick();\n        }\n    }\n    onLevelsUpdated(event, data) {\n        if (this.level > -1 && this.fragCurrent) {\n            this.level = this.fragCurrent.level;\n        }\n        this.levels = data.levels;\n    }\n    swapAudioCodec() {\n        this.audioCodecSwap = !this.audioCodecSwap;\n    }\n    /**\n   * Seeks to the set startPosition if not equal to the mediaElement's current time.\n   */ seekToStartPos() {\n        const { media } = this;\n        if (!media) {\n            return;\n        }\n        const currentTime = media.currentTime;\n        let startPosition = this.startPosition;\n        // only adjust currentTime if different from startPosition or if startPosition not buffered\n        // at that stage, there should be only one buffered range, as we reach that code after first fragment has been buffered\n        if (startPosition >= 0 && currentTime < startPosition) {\n            if (media.seeking) {\n                this.log(`could not seek to ${startPosition}, already seeking at ${currentTime}`);\n                return;\n            }\n            const buffered = BufferHelper.getBuffered(media);\n            const bufferStart = buffered.length ? buffered.start(0) : 0;\n            const delta = bufferStart - startPosition;\n            if (delta > 0 && (delta < this.config.maxBufferHole || delta < this.config.maxFragLookUpTolerance)) {\n                this.log(`adjusting start position by ${delta} to match buffer start`);\n                startPosition += delta;\n                this.startPosition = startPosition;\n            }\n            this.log(`seek to target start position ${startPosition} from current time ${currentTime}`);\n            media.currentTime = startPosition;\n        }\n    }\n    _getAudioCodec(currentLevel) {\n        let audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;\n        if (this.audioCodecSwap && audioCodec) {\n            this.log(\"Swapping audio codec\");\n            if (audioCodec.indexOf(\"mp4a.40.5\") !== -1) {\n                audioCodec = \"mp4a.40.2\";\n            } else {\n                audioCodec = \"mp4a.40.5\";\n            }\n        }\n        return audioCodec;\n    }\n    _loadBitrateTestFrag(frag, level) {\n        frag.bitrateTest = true;\n        this._doFragLoad(frag, level).then((data)=>{\n            const { hls } = this;\n            if (!data || this.fragContextChanged(frag)) {\n                return;\n            }\n            level.fragmentError = 0;\n            this.state = State.IDLE;\n            this.startFragRequested = false;\n            this.bitrateTest = false;\n            const stats = frag.stats;\n            // Bitrate tests fragments are neither parsed nor buffered\n            stats.parsing.start = stats.parsing.end = stats.buffering.start = stats.buffering.end = self.performance.now();\n            hls.trigger(Events.FRAG_LOADED, data);\n            frag.bitrateTest = false;\n        });\n    }\n    _handleTransmuxComplete(transmuxResult) {\n        var _id3$samples;\n        const id = \"main\";\n        const { hls } = this;\n        const { remuxResult, chunkMeta } = transmuxResult;\n        const context = this.getCurrentContext(chunkMeta);\n        if (!context) {\n            this.resetWhenMissingContext(chunkMeta);\n            return;\n        }\n        const { frag, part, level } = context;\n        const { video, text, id3, initSegment } = remuxResult;\n        const { details } = level;\n        // The audio-stream-controller handles audio buffering if Hls.js is playing an alternate audio track\n        const audio = this.altAudio ? undefined : remuxResult.audio;\n        // Check if the current fragment has been aborted. We check this by first seeing if we're still playing the current level.\n        // If we are, subsequently check if the currently loading fragment (fragCurrent) has changed.\n        if (this.fragContextChanged(frag)) {\n            this.fragmentTracker.removeFragment(frag);\n            return;\n        }\n        this.state = State.PARSING;\n        if (initSegment) {\n            if (initSegment != null && initSegment.tracks) {\n                const mapFragment = frag.initSegment || frag;\n                this._bufferInitSegment(level, initSegment.tracks, mapFragment, chunkMeta);\n                hls.trigger(Events.FRAG_PARSING_INIT_SEGMENT, {\n                    frag: mapFragment,\n                    id,\n                    tracks: initSegment.tracks\n                });\n            }\n            // This would be nice if Number.isFinite acted as a typeguard, but it doesn't. See: https://github.com/Microsoft/TypeScript/issues/10038\n            const initPTS = initSegment.initPTS;\n            const timescale = initSegment.timescale;\n            if (isFiniteNumber(initPTS)) {\n                this.initPTS[frag.cc] = {\n                    baseTime: initPTS,\n                    timescale\n                };\n                hls.trigger(Events.INIT_PTS_FOUND, {\n                    frag,\n                    id,\n                    initPTS,\n                    timescale\n                });\n            }\n        }\n        // Avoid buffering if backtracking this fragment\n        if (video && details && frag.sn !== \"initSegment\") {\n            const prevFrag = details.fragments[frag.sn - 1 - details.startSN];\n            const isFirstFragment = frag.sn === details.startSN;\n            const isFirstInDiscontinuity = !prevFrag || frag.cc > prevFrag.cc;\n            if (remuxResult.independent !== false) {\n                const { startPTS, endPTS, startDTS, endDTS } = video;\n                if (part) {\n                    part.elementaryStreams[video.type] = {\n                        startPTS,\n                        endPTS,\n                        startDTS,\n                        endDTS\n                    };\n                } else {\n                    if (video.firstKeyFrame && video.independent && chunkMeta.id === 1 && !isFirstInDiscontinuity) {\n                        this.couldBacktrack = true;\n                    }\n                    if (video.dropped && video.independent) {\n                        // Backtrack if dropped frames create a gap after currentTime\n                        const bufferInfo = this.getMainFwdBufferInfo();\n                        const targetBufferTime = (bufferInfo ? bufferInfo.end : this.getLoadPosition()) + this.config.maxBufferHole;\n                        const startTime = video.firstKeyFramePTS ? video.firstKeyFramePTS : startPTS;\n                        if (!isFirstFragment && targetBufferTime < startTime - this.config.maxBufferHole && !isFirstInDiscontinuity) {\n                            this.backtrack(frag);\n                            return;\n                        } else if (isFirstInDiscontinuity) {\n                            // Mark segment with a gap to avoid loop loading\n                            frag.gap = true;\n                        }\n                        // Set video stream start to fragment start so that truncated samples do not distort the timeline, and mark it partial\n                        frag.setElementaryStreamInfo(video.type, frag.start, endPTS, frag.start, endDTS, true);\n                    } else if (isFirstFragment && startPTS > MAX_START_GAP_JUMP) {\n                        // Mark segment with a gap to skip large start gap\n                        frag.gap = true;\n                    }\n                }\n                frag.setElementaryStreamInfo(video.type, startPTS, endPTS, startDTS, endDTS);\n                if (this.backtrackFragment) {\n                    this.backtrackFragment = frag;\n                }\n                this.bufferFragmentData(video, frag, part, chunkMeta, isFirstFragment || isFirstInDiscontinuity);\n            } else if (isFirstFragment || isFirstInDiscontinuity) {\n                // Mark segment with a gap to avoid loop loading\n                frag.gap = true;\n            } else {\n                this.backtrack(frag);\n                return;\n            }\n        }\n        if (audio) {\n            const { startPTS, endPTS, startDTS, endDTS } = audio;\n            if (part) {\n                part.elementaryStreams[ElementaryStreamTypes.AUDIO] = {\n                    startPTS,\n                    endPTS,\n                    startDTS,\n                    endDTS\n                };\n            }\n            frag.setElementaryStreamInfo(ElementaryStreamTypes.AUDIO, startPTS, endPTS, startDTS, endDTS);\n            this.bufferFragmentData(audio, frag, part, chunkMeta);\n        }\n        if (details && id3 != null && (_id3$samples = id3.samples) != null && _id3$samples.length) {\n            const emittedID3 = {\n                id,\n                frag,\n                details,\n                samples: id3.samples\n            };\n            hls.trigger(Events.FRAG_PARSING_METADATA, emittedID3);\n        }\n        if (details && text) {\n            const emittedText = {\n                id,\n                frag,\n                details,\n                samples: text.samples\n            };\n            hls.trigger(Events.FRAG_PARSING_USERDATA, emittedText);\n        }\n    }\n    _bufferInitSegment(currentLevel, tracks, frag, chunkMeta) {\n        if (this.state !== State.PARSING) {\n            return;\n        }\n        this.audioOnly = !!tracks.audio && !tracks.video;\n        // if audio track is expected to come from audio stream controller, discard any coming from main\n        if (this.altAudio && !this.audioOnly) {\n            delete tracks.audio;\n        }\n        // include levelCodec in audio and video tracks\n        const { audio, video, audiovideo } = tracks;\n        if (audio) {\n            let audioCodec = currentLevel.audioCodec;\n            const ua = navigator.userAgent.toLowerCase();\n            if (this.audioCodecSwitch) {\n                if (audioCodec) {\n                    if (audioCodec.indexOf(\"mp4a.40.5\") !== -1) {\n                        audioCodec = \"mp4a.40.2\";\n                    } else {\n                        audioCodec = \"mp4a.40.5\";\n                    }\n                }\n                // In the case that AAC and HE-AAC audio codecs are signalled in manifest,\n                // force HE-AAC, as it seems that most browsers prefers it.\n                // don't force HE-AAC if mono stream, or in Firefox\n                if (audio.metadata.channelCount !== 1 && ua.indexOf(\"firefox\") === -1) {\n                    audioCodec = \"mp4a.40.5\";\n                }\n            }\n            // HE-AAC is broken on Android, always signal audio codec as AAC even if variant manifest states otherwise\n            if (audioCodec && audioCodec.indexOf(\"mp4a.40.5\") !== -1 && ua.indexOf(\"android\") !== -1 && audio.container !== \"audio/mpeg\") {\n                // Exclude mpeg audio\n                audioCodec = \"mp4a.40.2\";\n                this.log(`Android: force audio codec to ${audioCodec}`);\n            }\n            if (currentLevel.audioCodec && currentLevel.audioCodec !== audioCodec) {\n                this.log(`Swapping manifest audio codec \"${currentLevel.audioCodec}\" for \"${audioCodec}\"`);\n            }\n            audio.levelCodec = audioCodec;\n            audio.id = \"main\";\n            this.log(`Init audio buffer, container:${audio.container}, codecs[selected/level/parsed]=[${audioCodec || \"\"}/${currentLevel.audioCodec || \"\"}/${audio.codec}]`);\n        }\n        if (video) {\n            video.levelCodec = currentLevel.videoCodec;\n            video.id = \"main\";\n            this.log(`Init video buffer, container:${video.container}, codecs[level/parsed]=[${currentLevel.videoCodec || \"\"}/${video.codec}]`);\n        }\n        if (audiovideo) {\n            this.log(`Init audiovideo buffer, container:${audiovideo.container}, codecs[level/parsed]=[${currentLevel.codecs}/${audiovideo.codec}]`);\n        }\n        this.hls.trigger(Events.BUFFER_CODECS, tracks);\n        // loop through tracks that are going to be provided to bufferController\n        Object.keys(tracks).forEach((trackName)=>{\n            const track = tracks[trackName];\n            const initSegment = track.initSegment;\n            if (initSegment != null && initSegment.byteLength) {\n                this.hls.trigger(Events.BUFFER_APPENDING, {\n                    type: trackName,\n                    data: initSegment,\n                    frag,\n                    part: null,\n                    chunkMeta,\n                    parent: frag.type\n                });\n            }\n        });\n        // trigger handler right now\n        this.tickImmediate();\n    }\n    getMainFwdBufferInfo() {\n        return this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, PlaylistLevelType.MAIN);\n    }\n    backtrack(frag) {\n        this.couldBacktrack = true;\n        // Causes findFragments to backtrack through fragments to find the keyframe\n        this.backtrackFragment = frag;\n        this.resetTransmuxer();\n        this.flushBufferGap(frag);\n        this.fragmentTracker.removeFragment(frag);\n        this.fragPrevious = null;\n        this.nextLoadPosition = frag.start;\n        this.state = State.IDLE;\n    }\n    checkFragmentChanged() {\n        const video = this.media;\n        let fragPlayingCurrent = null;\n        if (video && video.readyState > 1 && video.seeking === false) {\n            const currentTime = video.currentTime;\n            /* if video element is in seeked state, currentTime can only increase.\n        (assuming that playback rate is positive ...)\n        As sometimes currentTime jumps back to zero after a\n        media decode error, check this, to avoid seeking back to\n        wrong position after a media decode error\n      */ if (BufferHelper.isBuffered(video, currentTime)) {\n                fragPlayingCurrent = this.getAppendedFrag(currentTime);\n            } else if (BufferHelper.isBuffered(video, currentTime + 0.1)) {\n                /* ensure that FRAG_CHANGED event is triggered at startup,\n          when first video frame is displayed and playback is paused.\n          add a tolerance of 100ms, in case current position is not buffered,\n          check if current pos+100ms is buffered and use that buffer range\n          for FRAG_CHANGED event reporting */ fragPlayingCurrent = this.getAppendedFrag(currentTime + 0.1);\n            }\n            if (fragPlayingCurrent) {\n                this.backtrackFragment = null;\n                const fragPlaying = this.fragPlaying;\n                const fragCurrentLevel = fragPlayingCurrent.level;\n                if (!fragPlaying || fragPlayingCurrent.sn !== fragPlaying.sn || fragPlaying.level !== fragCurrentLevel) {\n                    this.fragPlaying = fragPlayingCurrent;\n                    this.hls.trigger(Events.FRAG_CHANGED, {\n                        frag: fragPlayingCurrent\n                    });\n                    if (!fragPlaying || fragPlaying.level !== fragCurrentLevel) {\n                        this.hls.trigger(Events.LEVEL_SWITCHED, {\n                            level: fragCurrentLevel\n                        });\n                    }\n                }\n            }\n        }\n    }\n    get nextLevel() {\n        const frag = this.nextBufferedFrag;\n        if (frag) {\n            return frag.level;\n        }\n        return -1;\n    }\n    get currentFrag() {\n        const media = this.media;\n        if (media) {\n            return this.fragPlaying || this.getAppendedFrag(media.currentTime);\n        }\n        return null;\n    }\n    get currentProgramDateTime() {\n        const media = this.media;\n        if (media) {\n            const currentTime = media.currentTime;\n            const frag = this.currentFrag;\n            if (frag && isFiniteNumber(currentTime) && isFiniteNumber(frag.programDateTime)) {\n                const epocMs = frag.programDateTime + (currentTime - frag.start) * 1000;\n                return new Date(epocMs);\n            }\n        }\n        return null;\n    }\n    get currentLevel() {\n        const frag = this.currentFrag;\n        if (frag) {\n            return frag.level;\n        }\n        return -1;\n    }\n    get nextBufferedFrag() {\n        const frag = this.currentFrag;\n        if (frag) {\n            return this.followingBufferedFrag(frag);\n        }\n        return null;\n    }\n    get forceStartLoad() {\n        return this._forceStartLoad;\n    }\n}\n/**\n * The `Hls` class is the core of the HLS.js library used to instantiate player instances.\n * @public\n */ class Hls {\n    /**\n   * Get the video-dev/hls.js package version.\n   */ static get version() {\n        return \"1.5.6\";\n    }\n    /**\n   * Check if the required MediaSource Extensions are available.\n   */ static isMSESupported() {\n        return isMSESupported();\n    }\n    /**\n   * Check if MediaSource Extensions are available and isTypeSupported checks pass for any baseline codecs.\n   */ static isSupported() {\n        return isSupported();\n    }\n    /**\n   * Get the MediaSource global used for MSE playback (ManagedMediaSource, MediaSource, or WebKitMediaSource).\n   */ static getMediaSource() {\n        return getMediaSource();\n    }\n    static get Events() {\n        return Events;\n    }\n    static get ErrorTypes() {\n        return ErrorTypes;\n    }\n    static get ErrorDetails() {\n        return ErrorDetails;\n    }\n    /**\n   * Get the default configuration applied to new instances.\n   */ static get DefaultConfig() {\n        if (!Hls.defaultConfig) {\n            return hlsDefaultConfig;\n        }\n        return Hls.defaultConfig;\n    }\n    /**\n   * Replace the default configuration applied to new instances.\n   */ static set DefaultConfig(defaultConfig) {\n        Hls.defaultConfig = defaultConfig;\n    }\n    /**\n   * Creates an instance of an HLS client that can attach to exactly one `HTMLMediaElement`.\n   * @param userConfig - Configuration options applied over `Hls.DefaultConfig`\n   */ constructor(userConfig = {}){\n        /**\n     * The runtime configuration used by the player. At instantiation this is combination of `hls.userConfig` merged over `Hls.DefaultConfig`.\n     */ this.config = void 0;\n        /**\n     * The configuration object provided on player instantiation.\n     */ this.userConfig = void 0;\n        this.coreComponents = void 0;\n        this.networkControllers = void 0;\n        this.started = false;\n        this._emitter = new EventEmitter();\n        this._autoLevelCapping = -1;\n        this._maxHdcpLevel = null;\n        this.abrController = void 0;\n        this.bufferController = void 0;\n        this.capLevelController = void 0;\n        this.latencyController = void 0;\n        this.levelController = void 0;\n        this.streamController = void 0;\n        this.audioTrackController = void 0;\n        this.subtitleTrackController = void 0;\n        this.emeController = void 0;\n        this.cmcdController = void 0;\n        this._media = null;\n        this.url = null;\n        this.triggeringException = void 0;\n        enableLogs(userConfig.debug || false, \"Hls instance\");\n        const config = this.config = mergeConfig(Hls.DefaultConfig, userConfig);\n        this.userConfig = userConfig;\n        if (config.progressive) {\n            enableStreamingMode(config);\n        }\n        // core controllers and network loaders\n        const { abrController: ConfigAbrController, bufferController: ConfigBufferController, capLevelController: ConfigCapLevelController, errorController: ConfigErrorController, fpsController: ConfigFpsController } = config;\n        const errorController = new ConfigErrorController(this);\n        const abrController = this.abrController = new ConfigAbrController(this);\n        const bufferController = this.bufferController = new ConfigBufferController(this);\n        const capLevelController = this.capLevelController = new ConfigCapLevelController(this);\n        const fpsController = new ConfigFpsController(this);\n        const playListLoader = new PlaylistLoader(this);\n        const id3TrackController = new ID3TrackController(this);\n        const ConfigContentSteeringController = config.contentSteeringController;\n        // ConentSteeringController is defined before LevelController to receive Multivariant Playlist events first\n        const contentSteering = ConfigContentSteeringController ? new ConfigContentSteeringController(this) : null;\n        const levelController = this.levelController = new LevelController(this, contentSteering);\n        // FragmentTracker must be defined before StreamController because the order of event handling is important\n        const fragmentTracker = new FragmentTracker(this);\n        const keyLoader = new KeyLoader(this.config);\n        const streamController = this.streamController = new StreamController(this, fragmentTracker, keyLoader);\n        // Cap level controller uses streamController to flush the buffer\n        capLevelController.setStreamController(streamController);\n        // fpsController uses streamController to switch when frames are being dropped\n        fpsController.setStreamController(streamController);\n        const networkControllers = [\n            playListLoader,\n            levelController,\n            streamController\n        ];\n        if (contentSteering) {\n            networkControllers.splice(1, 0, contentSteering);\n        }\n        this.networkControllers = networkControllers;\n        const coreComponents = [\n            abrController,\n            bufferController,\n            capLevelController,\n            fpsController,\n            id3TrackController,\n            fragmentTracker\n        ];\n        this.audioTrackController = this.createController(config.audioTrackController, networkControllers);\n        const AudioStreamControllerClass = config.audioStreamController;\n        if (AudioStreamControllerClass) {\n            networkControllers.push(new AudioStreamControllerClass(this, fragmentTracker, keyLoader));\n        }\n        // subtitleTrackController must be defined before subtitleStreamController because the order of event handling is important\n        this.subtitleTrackController = this.createController(config.subtitleTrackController, networkControllers);\n        const SubtitleStreamControllerClass = config.subtitleStreamController;\n        if (SubtitleStreamControllerClass) {\n            networkControllers.push(new SubtitleStreamControllerClass(this, fragmentTracker, keyLoader));\n        }\n        this.createController(config.timelineController, coreComponents);\n        keyLoader.emeController = this.emeController = this.createController(config.emeController, coreComponents);\n        this.cmcdController = this.createController(config.cmcdController, coreComponents);\n        this.latencyController = this.createController(LatencyController, coreComponents);\n        this.coreComponents = coreComponents;\n        // Error controller handles errors before and after all other controllers\n        // This listener will be invoked after all other controllers error listeners\n        networkControllers.push(errorController);\n        const onErrorOut = errorController.onErrorOut;\n        if (typeof onErrorOut === \"function\") {\n            this.on(Events.ERROR, onErrorOut, errorController);\n        }\n    }\n    createController(ControllerClass, components) {\n        if (ControllerClass) {\n            const controllerInstance = new ControllerClass(this);\n            if (components) {\n                components.push(controllerInstance);\n            }\n            return controllerInstance;\n        }\n        return null;\n    }\n    // Delegate the EventEmitter through the public API of Hls.js\n    on(event, listener, context = this) {\n        this._emitter.on(event, listener, context);\n    }\n    once(event, listener, context = this) {\n        this._emitter.once(event, listener, context);\n    }\n    removeAllListeners(event) {\n        this._emitter.removeAllListeners(event);\n    }\n    off(event, listener, context = this, once) {\n        this._emitter.off(event, listener, context, once);\n    }\n    listeners(event) {\n        return this._emitter.listeners(event);\n    }\n    emit(event, name, eventObject) {\n        return this._emitter.emit(event, name, eventObject);\n    }\n    trigger(event, eventObject) {\n        if (this.config.debug) {\n            return this.emit(event, event, eventObject);\n        } else {\n            try {\n                return this.emit(event, event, eventObject);\n            } catch (error) {\n                logger.error(\"An internal error happened while handling event \" + event + '. Error message: \"' + error.message + '\". Here is a stacktrace:', error);\n                // Prevent recursion in error event handlers that throw #5497\n                if (!this.triggeringException) {\n                    this.triggeringException = true;\n                    const fatal = event === Events.ERROR;\n                    this.trigger(Events.ERROR, {\n                        type: ErrorTypes.OTHER_ERROR,\n                        details: ErrorDetails.INTERNAL_EXCEPTION,\n                        fatal,\n                        event,\n                        error\n                    });\n                    this.triggeringException = false;\n                }\n            }\n        }\n        return false;\n    }\n    listenerCount(event) {\n        return this._emitter.listenerCount(event);\n    }\n    /**\n   * Dispose of the instance\n   */ destroy() {\n        logger.log(\"destroy\");\n        this.trigger(Events.DESTROYING, undefined);\n        this.detachMedia();\n        this.removeAllListeners();\n        this._autoLevelCapping = -1;\n        this.url = null;\n        this.networkControllers.forEach((component)=>component.destroy());\n        this.networkControllers.length = 0;\n        this.coreComponents.forEach((component)=>component.destroy());\n        this.coreComponents.length = 0;\n        // Remove any references that could be held in config options or callbacks\n        const config = this.config;\n        config.xhrSetup = config.fetchSetup = undefined;\n        // @ts-ignore\n        this.userConfig = null;\n    }\n    /**\n   * Attaches Hls.js to a media element\n   */ attachMedia(media) {\n        logger.log(\"attachMedia\");\n        this._media = media;\n        this.trigger(Events.MEDIA_ATTACHING, {\n            media: media\n        });\n    }\n    /**\n   * Detach Hls.js from the media\n   */ detachMedia() {\n        logger.log(\"detachMedia\");\n        this.trigger(Events.MEDIA_DETACHING, undefined);\n        this._media = null;\n    }\n    /**\n   * Set the source URL. Can be relative or absolute.\n   */ loadSource(url) {\n        this.stopLoad();\n        const media = this.media;\n        const loadedSource = this.url;\n        const loadingSource = this.url = urlToolkitExports.buildAbsoluteURL(self.location.href, url, {\n            alwaysNormalize: true\n        });\n        this._autoLevelCapping = -1;\n        this._maxHdcpLevel = null;\n        logger.log(`loadSource:${loadingSource}`);\n        if (media && loadedSource && (loadedSource !== loadingSource || this.bufferController.hasSourceTypes())) {\n            this.detachMedia();\n            this.attachMedia(media);\n        }\n        // when attaching to a source URL, trigger a playlist load\n        this.trigger(Events.MANIFEST_LOADING, {\n            url: url\n        });\n    }\n    /**\n   * Start loading data from the stream source.\n   * Depending on default config, client starts loading automatically when a source is set.\n   *\n   * @param startPosition - Set the start position to stream from.\n   * Defaults to -1 (None: starts from earliest point)\n   */ startLoad(startPosition = -1) {\n        logger.log(`startLoad(${startPosition})`);\n        this.started = true;\n        this.networkControllers.forEach((controller)=>{\n            controller.startLoad(startPosition);\n        });\n    }\n    /**\n   * Stop loading of any stream data.\n   */ stopLoad() {\n        logger.log(\"stopLoad\");\n        this.started = false;\n        this.networkControllers.forEach((controller)=>{\n            controller.stopLoad();\n        });\n    }\n    /**\n   * Resumes stream controller segment loading if previously started.\n   */ resumeBuffering() {\n        if (this.started) {\n            this.networkControllers.forEach((controller)=>{\n                if (\"fragmentLoader\" in controller) {\n                    controller.startLoad(-1);\n                }\n            });\n        }\n    }\n    /**\n   * Stops stream controller segment loading without changing 'started' state like stopLoad().\n   * This allows for media buffering to be paused without interupting playlist loading.\n   */ pauseBuffering() {\n        this.networkControllers.forEach((controller)=>{\n            if (\"fragmentLoader\" in controller) {\n                controller.stopLoad();\n            }\n        });\n    }\n    /**\n   * Swap through possible audio codecs in the stream (for example to switch from stereo to 5.1)\n   */ swapAudioCodec() {\n        logger.log(\"swapAudioCodec\");\n        this.streamController.swapAudioCodec();\n    }\n    /**\n   * When the media-element fails, this allows to detach and then re-attach it\n   * as one call (convenience method).\n   *\n   * Automatic recovery of media-errors by this process is configurable.\n   */ recoverMediaError() {\n        logger.log(\"recoverMediaError\");\n        const media = this._media;\n        this.detachMedia();\n        if (media) {\n            this.attachMedia(media);\n        }\n    }\n    removeLevel(levelIndex) {\n        this.levelController.removeLevel(levelIndex);\n    }\n    /**\n   * @returns an array of levels (variants) sorted by HDCP-LEVEL, RESOLUTION (height), FRAME-RATE, CODECS, VIDEO-RANGE, and BANDWIDTH\n   */ get levels() {\n        const levels = this.levelController.levels;\n        return levels ? levels : [];\n    }\n    /**\n   * Index of quality level (variant) currently played\n   */ get currentLevel() {\n        return this.streamController.currentLevel;\n    }\n    /**\n   * Set quality level index immediately. This will flush the current buffer to replace the quality asap. That means playback will interrupt at least shortly to re-buffer and re-sync eventually. Set to -1 for automatic level selection.\n   */ set currentLevel(newLevel) {\n        logger.log(`set currentLevel:${newLevel}`);\n        this.levelController.manualLevel = newLevel;\n        this.streamController.immediateLevelSwitch();\n    }\n    /**\n   * Index of next quality level loaded as scheduled by stream controller.\n   */ get nextLevel() {\n        return this.streamController.nextLevel;\n    }\n    /**\n   * Set quality level index for next loaded data.\n   * This will switch the video quality asap, without interrupting playback.\n   * May abort current loading of data, and flush parts of buffer (outside currently played fragment region).\n   * @param newLevel - Pass -1 for automatic level selection\n   */ set nextLevel(newLevel) {\n        logger.log(`set nextLevel:${newLevel}`);\n        this.levelController.manualLevel = newLevel;\n        this.streamController.nextLevelSwitch();\n    }\n    /**\n   * Return the quality level of the currently or last (of none is loaded currently) segment\n   */ get loadLevel() {\n        return this.levelController.level;\n    }\n    /**\n   * Set quality level index for next loaded data in a conservative way.\n   * This will switch the quality without flushing, but interrupt current loading.\n   * Thus the moment when the quality switch will appear in effect will only be after the already existing buffer.\n   * @param newLevel - Pass -1 for automatic level selection\n   */ set loadLevel(newLevel) {\n        logger.log(`set loadLevel:${newLevel}`);\n        this.levelController.manualLevel = newLevel;\n    }\n    /**\n   * get next quality level loaded\n   */ get nextLoadLevel() {\n        return this.levelController.nextLoadLevel;\n    }\n    /**\n   * Set quality level of next loaded segment in a fully \"non-destructive\" way.\n   * Same as `loadLevel` but will wait for next switch (until current loading is done).\n   */ set nextLoadLevel(level) {\n        this.levelController.nextLoadLevel = level;\n    }\n    /**\n   * Return \"first level\": like a default level, if not set,\n   * falls back to index of first level referenced in manifest\n   */ get firstLevel() {\n        return Math.max(this.levelController.firstLevel, this.minAutoLevel);\n    }\n    /**\n   * Sets \"first-level\", see getter.\n   */ set firstLevel(newLevel) {\n        logger.log(`set firstLevel:${newLevel}`);\n        this.levelController.firstLevel = newLevel;\n    }\n    /**\n   * Return the desired start level for the first fragment that will be loaded.\n   * The default value of -1 indicates automatic start level selection.\n   * Setting hls.nextAutoLevel without setting a startLevel will result in\n   * the nextAutoLevel value being used for one fragment load.\n   */ get startLevel() {\n        const startLevel = this.levelController.startLevel;\n        if (startLevel === -1 && this.abrController.forcedAutoLevel > -1) {\n            return this.abrController.forcedAutoLevel;\n        }\n        return startLevel;\n    }\n    /**\n   * set  start level (level of first fragment that will be played back)\n   * if not overrided by user, first level appearing in manifest will be used as start level\n   * if -1 : automatic start level selection, playback will start from level matching download bandwidth\n   * (determined from download of first segment)\n   */ set startLevel(newLevel) {\n        logger.log(`set startLevel:${newLevel}`);\n        // if not in automatic start level detection, ensure startLevel is greater than minAutoLevel\n        if (newLevel !== -1) {\n            newLevel = Math.max(newLevel, this.minAutoLevel);\n        }\n        this.levelController.startLevel = newLevel;\n    }\n    /**\n   * Whether level capping is enabled.\n   * Default value is set via `config.capLevelToPlayerSize`.\n   */ get capLevelToPlayerSize() {\n        return this.config.capLevelToPlayerSize;\n    }\n    /**\n   * Enables or disables level capping. If disabled after previously enabled, `nextLevelSwitch` will be immediately called.\n   */ set capLevelToPlayerSize(shouldStartCapping) {\n        const newCapLevelToPlayerSize = !!shouldStartCapping;\n        if (newCapLevelToPlayerSize !== this.config.capLevelToPlayerSize) {\n            if (newCapLevelToPlayerSize) {\n                this.capLevelController.startCapping(); // If capping occurs, nextLevelSwitch will happen based on size.\n            } else {\n                this.capLevelController.stopCapping();\n                this.autoLevelCapping = -1;\n                this.streamController.nextLevelSwitch(); // Now we're uncapped, get the next level asap.\n            }\n            this.config.capLevelToPlayerSize = newCapLevelToPlayerSize;\n        }\n    }\n    /**\n   * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)\n   */ get autoLevelCapping() {\n        return this._autoLevelCapping;\n    }\n    /**\n   * Returns the current bandwidth estimate in bits per second, when available. Otherwise, `NaN` is returned.\n   */ get bandwidthEstimate() {\n        const { bwEstimator } = this.abrController;\n        if (!bwEstimator) {\n            return NaN;\n        }\n        return bwEstimator.getEstimate();\n    }\n    set bandwidthEstimate(abrEwmaDefaultEstimate) {\n        this.abrController.resetEstimator(abrEwmaDefaultEstimate);\n    }\n    /**\n   * get time to first byte estimate\n   * @type {number}\n   */ get ttfbEstimate() {\n        const { bwEstimator } = this.abrController;\n        if (!bwEstimator) {\n            return NaN;\n        }\n        return bwEstimator.getEstimateTTFB();\n    }\n    /**\n   * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)\n   */ set autoLevelCapping(newLevel) {\n        if (this._autoLevelCapping !== newLevel) {\n            logger.log(`set autoLevelCapping:${newLevel}`);\n            this._autoLevelCapping = newLevel;\n            this.levelController.checkMaxAutoUpdated();\n        }\n    }\n    get maxHdcpLevel() {\n        return this._maxHdcpLevel;\n    }\n    set maxHdcpLevel(value) {\n        if (isHdcpLevel(value) && this._maxHdcpLevel !== value) {\n            this._maxHdcpLevel = value;\n            this.levelController.checkMaxAutoUpdated();\n        }\n    }\n    /**\n   * True when automatic level selection enabled\n   */ get autoLevelEnabled() {\n        return this.levelController.manualLevel === -1;\n    }\n    /**\n   * Level set manually (if any)\n   */ get manualLevel() {\n        return this.levelController.manualLevel;\n    }\n    /**\n   * min level selectable in auto mode according to config.minAutoBitrate\n   */ get minAutoLevel() {\n        const { levels, config: { minAutoBitrate } } = this;\n        if (!levels) return 0;\n        const len = levels.length;\n        for(let i = 0; i < len; i++){\n            if (levels[i].maxBitrate >= minAutoBitrate) {\n                return i;\n            }\n        }\n        return 0;\n    }\n    /**\n   * max level selectable in auto mode according to autoLevelCapping\n   */ get maxAutoLevel() {\n        const { levels, autoLevelCapping, maxHdcpLevel } = this;\n        let maxAutoLevel;\n        if (autoLevelCapping === -1 && levels != null && levels.length) {\n            maxAutoLevel = levels.length - 1;\n        } else {\n            maxAutoLevel = autoLevelCapping;\n        }\n        if (maxHdcpLevel) {\n            for(let i = maxAutoLevel; i--;){\n                const hdcpLevel = levels[i].attrs[\"HDCP-LEVEL\"];\n                if (hdcpLevel && hdcpLevel <= maxHdcpLevel) {\n                    return i;\n                }\n            }\n        }\n        return maxAutoLevel;\n    }\n    get firstAutoLevel() {\n        return this.abrController.firstAutoLevel;\n    }\n    /**\n   * next automatically selected quality level\n   */ get nextAutoLevel() {\n        return this.abrController.nextAutoLevel;\n    }\n    /**\n   * this setter is used to force next auto level.\n   * this is useful to force a switch down in auto mode:\n   * in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)\n   * forced value is valid for one fragment. upon successful frag loading at forced level,\n   * this value will be resetted to -1 by ABR controller.\n   */ set nextAutoLevel(nextLevel) {\n        this.abrController.nextAutoLevel = nextLevel;\n    }\n    /**\n   * get the datetime value relative to media.currentTime for the active level Program Date Time if present\n   */ get playingDate() {\n        return this.streamController.currentProgramDateTime;\n    }\n    get mainForwardBufferInfo() {\n        return this.streamController.getMainFwdBufferInfo();\n    }\n    /**\n   * Find and select the best matching audio track, making a level switch when a Group change is necessary.\n   * Updates `hls.config.audioPreference`. Returns the selected track, or null when no matching track is found.\n   */ setAudioOption(audioOption) {\n        var _this$audioTrackContr;\n        return (_this$audioTrackContr = this.audioTrackController) == null ? void 0 : _this$audioTrackContr.setAudioOption(audioOption);\n    }\n    /**\n   * Find and select the best matching subtitle track, making a level switch when a Group change is necessary.\n   * Updates `hls.config.subtitlePreference`. Returns the selected track, or null when no matching track is found.\n   */ setSubtitleOption(subtitleOption) {\n        var _this$subtitleTrackCo;\n        (_this$subtitleTrackCo = this.subtitleTrackController) == null ? void 0 : _this$subtitleTrackCo.setSubtitleOption(subtitleOption);\n        return null;\n    }\n    /**\n   * Get the complete list of audio tracks across all media groups\n   */ get allAudioTracks() {\n        const audioTrackController = this.audioTrackController;\n        return audioTrackController ? audioTrackController.allAudioTracks : [];\n    }\n    /**\n   * Get the list of selectable audio tracks\n   */ get audioTracks() {\n        const audioTrackController = this.audioTrackController;\n        return audioTrackController ? audioTrackController.audioTracks : [];\n    }\n    /**\n   * index of the selected audio track (index in audio track lists)\n   */ get audioTrack() {\n        const audioTrackController = this.audioTrackController;\n        return audioTrackController ? audioTrackController.audioTrack : -1;\n    }\n    /**\n   * selects an audio track, based on its index in audio track lists\n   */ set audioTrack(audioTrackId) {\n        const audioTrackController = this.audioTrackController;\n        if (audioTrackController) {\n            audioTrackController.audioTrack = audioTrackId;\n        }\n    }\n    /**\n   * get the complete list of subtitle tracks across all media groups\n   */ get allSubtitleTracks() {\n        const subtitleTrackController = this.subtitleTrackController;\n        return subtitleTrackController ? subtitleTrackController.allSubtitleTracks : [];\n    }\n    /**\n   * get alternate subtitle tracks list from playlist\n   */ get subtitleTracks() {\n        const subtitleTrackController = this.subtitleTrackController;\n        return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];\n    }\n    /**\n   * index of the selected subtitle track (index in subtitle track lists)\n   */ get subtitleTrack() {\n        const subtitleTrackController = this.subtitleTrackController;\n        return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;\n    }\n    get media() {\n        return this._media;\n    }\n    /**\n   * select an subtitle track, based on its index in subtitle track lists\n   */ set subtitleTrack(subtitleTrackId) {\n        const subtitleTrackController = this.subtitleTrackController;\n        if (subtitleTrackController) {\n            subtitleTrackController.subtitleTrack = subtitleTrackId;\n        }\n    }\n    /**\n   * Whether subtitle display is enabled or not\n   */ get subtitleDisplay() {\n        const subtitleTrackController = this.subtitleTrackController;\n        return subtitleTrackController ? subtitleTrackController.subtitleDisplay : false;\n    }\n    /**\n   * Enable/disable subtitle display rendering\n   */ set subtitleDisplay(value) {\n        const subtitleTrackController = this.subtitleTrackController;\n        if (subtitleTrackController) {\n            subtitleTrackController.subtitleDisplay = value;\n        }\n    }\n    /**\n   * get mode for Low-Latency HLS loading\n   */ get lowLatencyMode() {\n        return this.config.lowLatencyMode;\n    }\n    /**\n   * Enable/disable Low-Latency HLS part playlist and segment loading, and start live streams at playlist PART-HOLD-BACK rather than HOLD-BACK.\n   */ set lowLatencyMode(mode) {\n        this.config.lowLatencyMode = mode;\n    }\n    /**\n   * Position (in seconds) of live sync point (ie edge of live position minus safety delay defined by ```hls.config.liveSyncDuration```)\n   * @returns null prior to loading live Playlist\n   */ get liveSyncPosition() {\n        return this.latencyController.liveSyncPosition;\n    }\n    /**\n   * Estimated position (in seconds) of live edge (ie edge of live playlist plus time sync playlist advanced)\n   * @returns 0 before first playlist is loaded\n   */ get latency() {\n        return this.latencyController.latency;\n    }\n    /**\n   * maximum distance from the edge before the player seeks forward to ```hls.liveSyncPosition```\n   * configured using ```liveMaxLatencyDurationCount``` (multiple of target duration) or ```liveMaxLatencyDuration```\n   * @returns 0 before first playlist is loaded\n   */ get maxLatency() {\n        return this.latencyController.maxLatency;\n    }\n    /**\n   * target distance from the edge as calculated by the latency controller\n   */ get targetLatency() {\n        return this.latencyController.targetLatency;\n    }\n    /**\n   * the rate at which the edge of the current live playlist is advancing or 1 if there is none\n   */ get drift() {\n        return this.latencyController.drift;\n    }\n    /**\n   * set to true when startLoad is called before MANIFEST_PARSED event\n   */ get forceStartLoad() {\n        return this.streamController.forceStartLoad;\n    }\n}\nHls.defaultConfig = void 0;\n //# sourceMappingURL=hls.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGxzLmpzL2Rpc3QvaGxzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLFNBQVNBLHdCQUF5QkMsQ0FBQztJQUNsQyxPQUFPQSxLQUFLQSxFQUFFQyxVQUFVLElBQUlDLE9BQU9DLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNMLEdBQUcsYUFBYUEsQ0FBQyxDQUFDLFVBQVUsR0FBR0E7QUFDakc7QUFFQSxJQUFJTSxhQUFhO0lBQUNDLFNBQVMsQ0FBQztBQUFDO0FBRTVCLFVBQVVDLE1BQU0sRUFBRUQsT0FBTztJQUN6QiwwQ0FBMEM7SUFFekMsVUFBVUUsSUFBSTtRQUNiLElBQUlDLFlBQ0Y7UUFDRixJQUFJQyxzQkFBc0I7UUFDMUIsSUFBSUMsa0JBQWtCO1FBQ3RCLElBQUlDLHNCQUFzQjtRQUUxQixJQUFJQyxhQUFhO1lBQ2YsMkdBQTJHO1lBQzNHLE1BQU07WUFDTiw4REFBOEQ7WUFDOUQseURBQXlEO1lBQ3pELHdEQUF3RDtZQUN4RCxvREFBb0Q7WUFDcERDLGtCQUFrQixTQUFVQyxPQUFPLEVBQUVDLFdBQVcsRUFBRUMsSUFBSTtnQkFDcERBLE9BQU9BLFFBQVEsQ0FBQztnQkFDaEIsc0NBQXNDO2dCQUN0Q0YsVUFBVUEsUUFBUUcsSUFBSTtnQkFDdEJGLGNBQWNBLFlBQVlFLElBQUk7Z0JBQzlCLElBQUksQ0FBQ0YsYUFBYTtvQkFDaEIsNkRBQTZEO29CQUM3RCx1REFBdUQ7b0JBQ3ZELG1CQUFtQjtvQkFDbkIsSUFBSSxDQUFDQyxLQUFLRSxlQUFlLEVBQUU7d0JBQ3pCLE9BQU9KO29CQUNUO29CQUNBLElBQUlLLHdCQUF3QlAsV0FBV1EsUUFBUSxDQUFDTjtvQkFDaEQsSUFBSSxDQUFDSyx1QkFBdUI7d0JBQzFCLE1BQU0sSUFBSUUsTUFBTTtvQkFDbEI7b0JBQ0FGLHNCQUFzQkcsSUFBSSxHQUFHVixXQUFXVyxhQUFhLENBQ25E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LENBQUNBLHVCQUF1QjtRQUM1RCxJQUFJQSx5QkFBeUI7WUFDM0JBLHdCQUF3QjlnQyxlQUFlLEdBQUd6c0Y7UUFDNUM7SUFDRjtJQUVBOztHQUVDLEdBQ0QsSUFBSTZqQyxpQkFBaUI7UUFDbkIsT0FBTyxJQUFJLENBQUNoeUIsTUFBTSxDQUFDZ3lCLGNBQWM7SUFDbkM7SUFFQTs7R0FFQyxHQUNELElBQUlBLGVBQWUzRixJQUFJLEVBQUU7UUFDdkIsSUFBSSxDQUFDcnNCLE1BQU0sQ0FBQ2d5QixjQUFjLEdBQUczRjtJQUMvQjtJQUVBOzs7R0FHQyxHQUNELElBQUkrRixtQkFBbUI7UUFDckIsT0FBTyxJQUFJLENBQUMrMEYsaUJBQWlCLENBQUMvMEYsZ0JBQWdCO0lBQ2hEO0lBRUE7OztHQUdDLEdBQ0QsSUFBSVgsVUFBVTtRQUNaLE9BQU8sSUFBSSxDQUFDMDFGLGlCQUFpQixDQUFDMTFGLE9BQU87SUFDdkM7SUFFQTs7OztHQUlDLEdBQ0QsSUFBSUMsYUFBYTtRQUNmLE9BQU8sSUFBSSxDQUFDeTFGLGlCQUFpQixDQUFDejFGLFVBQVU7SUFDMUM7SUFFQTs7R0FFQyxHQUNELElBQUlHLGdCQUFnQjtRQUNsQixPQUFPLElBQUksQ0FBQ3MxRixpQkFBaUIsQ0FBQ3QxRixhQUFhO0lBQzdDO0lBRUE7O0dBRUMsR0FDRCxJQUFJcjFCLFFBQVE7UUFDVixPQUFPLElBQUksQ0FBQzJxSCxpQkFBaUIsQ0FBQzNxSCxLQUFLO0lBQ3JDO0lBRUE7O0dBRUMsR0FDRCxJQUFJNGlILGlCQUFpQjtRQUNuQixPQUFPLElBQUksQ0FBQ3poQixnQkFBZ0IsQ0FBQ3loQixjQUFjO0lBQzdDO0FBQ0Y7QUFDQXdILElBQUkzSyxhQUFhLEdBQUcsS0FBSztBQUVtbkIsQ0FDNW9CLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL3N0cmVhbWluZy8uL25vZGVfbW9kdWxlcy9obHMuanMvZGlzdC9obHMubWpzPzQ3MWYiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMgKHgpIHtcblx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcbn1cblxudmFyIHVybFRvb2xraXQgPSB7ZXhwb3J0czoge319O1xuXG4oZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHQvLyBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzE4MDhcblxuXHQoZnVuY3Rpb24gKHJvb3QpIHtcblx0ICB2YXIgVVJMX1JFR0VYID1cblx0ICAgIC9eKD89KCg/OlthLXpBLVowLTkrXFwtLl0rOik/KSlcXDEoPz0oKD86XFwvXFwvW15cXC8/I10qKT8pKVxcMig/PSgoPzooPzpbXj8jXFwvXSpcXC8pKlteOz8jXFwvXSopPykpXFwzKCg/OjtbXj8jXSopPykoXFw/W14jXSopPygjW15dKik/JC87XG5cdCAgdmFyIEZJUlNUX1NFR01FTlRfUkVHRVggPSAvXig/PShbXlxcLz8jXSopKVxcMShbXl0qKSQvO1xuXHQgIHZhciBTTEFTSF9ET1RfUkVHRVggPSAvKD86XFwvfF4pXFwuKD89XFwvKS9nO1xuXHQgIHZhciBTTEFTSF9ET1RfRE9UX1JFR0VYID0gLyg/OlxcL3xeKVxcLlxcLlxcLyg/IVxcLlxcLlxcLylbXlxcL10qKD89XFwvKS9nO1xuXG5cdCAgdmFyIFVSTFRvb2xraXQgPSB7XG5cdCAgICAvLyBJZiBvcHRzLmFsd2F5c05vcm1hbGl6ZSBpcyB0cnVlIHRoZW4gdGhlIHBhdGggd2lsbCBhbHdheXMgYmUgbm9ybWFsaXplZCBldmVuIHdoZW4gaXQgc3RhcnRzIHdpdGggLyBvciAvL1xuXHQgICAgLy8gRS5nXG5cdCAgICAvLyBXaXRoIG9wdHMuYWx3YXlzTm9ybWFsaXplID0gZmFsc2UgKGRlZmF1bHQsIHNwZWMgY29tcGxpYW50KVxuXHQgICAgLy8gaHR0cDovL2EuY29tL2IvY2QgKyAvZS9mLy4uL2cgPT4gaHR0cDovL2EuY29tL2UvZi8uLi9nXG5cdCAgICAvLyBXaXRoIG9wdHMuYWx3YXlzTm9ybWFsaXplID0gdHJ1ZSAobm90IHNwZWMgY29tcGxpYW50KVxuXHQgICAgLy8gaHR0cDovL2EuY29tL2IvY2QgKyAvZS9mLy4uL2cgPT4gaHR0cDovL2EuY29tL2UvZ1xuXHQgICAgYnVpbGRBYnNvbHV0ZVVSTDogZnVuY3Rpb24gKGJhc2VVUkwsIHJlbGF0aXZlVVJMLCBvcHRzKSB7XG5cdCAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXHQgICAgICAvLyByZW1vdmUgYW55IHJlbWFpbmluZyBzcGFjZSBhbmQgQ1JMRlxuXHQgICAgICBiYXNlVVJMID0gYmFzZVVSTC50cmltKCk7XG5cdCAgICAgIHJlbGF0aXZlVVJMID0gcmVsYXRpdmVVUkwudHJpbSgpO1xuXHQgICAgICBpZiAoIXJlbGF0aXZlVVJMKSB7XG5cdCAgICAgICAgLy8gMmEpIElmIHRoZSBlbWJlZGRlZCBVUkwgaXMgZW50aXJlbHkgZW1wdHksIGl0IGluaGVyaXRzIHRoZVxuXHQgICAgICAgIC8vIGVudGlyZSBiYXNlIFVSTCAoaS5lLiwgaXMgc2V0IGVxdWFsIHRvIHRoZSBiYXNlIFVSTClcblx0ICAgICAgICAvLyBhbmQgd2UgYXJlIGRvbmUuXG5cdCAgICAgICAgaWYgKCFvcHRzLmFsd2F5c05vcm1hbGl6ZSkge1xuXHQgICAgICAgICAgcmV0dXJuIGJhc2VVUkw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBiYXNlUGFydHNGb3JOb3JtYWxpc2UgPSBVUkxUb29sa2l0LnBhcnNlVVJMKGJhc2VVUkwpO1xuXHQgICAgICAgIGlmICghYmFzZVBhcnRzRm9yTm9ybWFsaXNlKSB7XG5cdCAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIHRyeWluZyB0byBwYXJzZSBiYXNlIFVSTC4nKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgYmFzZVBhcnRzRm9yTm9ybWFsaXNlLnBhdGggPSBVUkxUb29sa2l0Lm5vcm1hbGl6ZVBhdGgoXG5cdCAgICAgICAgICBiYXNlUGFydHNGb3JOb3JtYWxpc2UucGF0aFxuXHQgICAgICAgICk7XG5cdCAgICAgICAgcmV0dXJuIFVSTFRvb2xraXQuYnVpbGRVUkxGcm9tUGFydHMoYmFzZVBhcnRzRm9yTm9ybWFsaXNlKTtcblx0ICAgICAgfVxuXHQgICAgICB2YXIgcmVsYXRpdmVQYXJ0cyA9IFVSTFRvb2xraXQucGFyc2VVUkwocmVsYXRpdmVVUkwpO1xuXHQgICAgICBpZiAoIXJlbGF0aXZlUGFydHMpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIHRyeWluZyB0byBwYXJzZSByZWxhdGl2ZSBVUkwuJyk7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHJlbGF0aXZlUGFydHMuc2NoZW1lKSB7XG5cdCAgICAgICAgLy8gMmIpIElmIHRoZSBlbWJlZGRlZCBVUkwgc3RhcnRzIHdpdGggYSBzY2hlbWUgbmFtZSwgaXQgaXNcblx0ICAgICAgICAvLyBpbnRlcnByZXRlZCBhcyBhbiBhYnNvbHV0ZSBVUkwgYW5kIHdlIGFyZSBkb25lLlxuXHQgICAgICAgIGlmICghb3B0cy5hbHdheXNOb3JtYWxpemUpIHtcblx0ICAgICAgICAgIHJldHVybiByZWxhdGl2ZVVSTDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmVsYXRpdmVQYXJ0cy5wYXRoID0gVVJMVG9vbGtpdC5ub3JtYWxpemVQYXRoKHJlbGF0aXZlUGFydHMucGF0aCk7XG5cdCAgICAgICAgcmV0dXJuIFVSTFRvb2xraXQuYnVpbGRVUkxGcm9tUGFydHMocmVsYXRpdmVQYXJ0cyk7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIGJhc2VQYXJ0cyA9IFVSTFRvb2xraXQucGFyc2VVUkwoYmFzZVVSTCk7XG5cdCAgICAgIGlmICghYmFzZVBhcnRzKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciB0cnlpbmcgdG8gcGFyc2UgYmFzZSBVUkwuJyk7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKCFiYXNlUGFydHMubmV0TG9jICYmIGJhc2VQYXJ0cy5wYXRoICYmIGJhc2VQYXJ0cy5wYXRoWzBdICE9PSAnLycpIHtcblx0ICAgICAgICAvLyBJZiBuZXRMb2MgbWlzc2luZyBhbmQgcGF0aCBkb2Vzbid0IHN0YXJ0IHdpdGggJy8nLCBhc3N1bWUgZXZlcnRoaW5nIGJlZm9yZSB0aGUgZmlyc3QgJy8nIGlzIHRoZSBuZXRMb2Ncblx0ICAgICAgICAvLyBUaGlzIGNhdXNlcyAnZXhhbXBsZS5jb20vYScgdG8gYmUgaGFuZGxlZCBhcyAnLy9leGFtcGxlLmNvbS9hJyBpbnN0ZWFkIG9mICcvZXhhbXBsZS5jb20vYSdcblx0ICAgICAgICB2YXIgcGF0aFBhcnRzID0gRklSU1RfU0VHTUVOVF9SRUdFWC5leGVjKGJhc2VQYXJ0cy5wYXRoKTtcblx0ICAgICAgICBiYXNlUGFydHMubmV0TG9jID0gcGF0aFBhcnRzWzFdO1xuXHQgICAgICAgIGJhc2VQYXJ0cy5wYXRoID0gcGF0aFBhcnRzWzJdO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChiYXNlUGFydHMubmV0TG9jICYmICFiYXNlUGFydHMucGF0aCkge1xuXHQgICAgICAgIGJhc2VQYXJ0cy5wYXRoID0gJy8nO1xuXHQgICAgICB9XG5cdCAgICAgIHZhciBidWlsdFBhcnRzID0ge1xuXHQgICAgICAgIC8vIDJjKSBPdGhlcndpc2UsIHRoZSBlbWJlZGRlZCBVUkwgaW5oZXJpdHMgdGhlIHNjaGVtZSBvZlxuXHQgICAgICAgIC8vIHRoZSBiYXNlIFVSTC5cblx0ICAgICAgICBzY2hlbWU6IGJhc2VQYXJ0cy5zY2hlbWUsXG5cdCAgICAgICAgbmV0TG9jOiByZWxhdGl2ZVBhcnRzLm5ldExvYyxcblx0ICAgICAgICBwYXRoOiBudWxsLFxuXHQgICAgICAgIHBhcmFtczogcmVsYXRpdmVQYXJ0cy5wYXJhbXMsXG5cdCAgICAgICAgcXVlcnk6IHJlbGF0aXZlUGFydHMucXVlcnksXG5cdCAgICAgICAgZnJhZ21lbnQ6IHJlbGF0aXZlUGFydHMuZnJhZ21lbnQsXG5cdCAgICAgIH07XG5cdCAgICAgIGlmICghcmVsYXRpdmVQYXJ0cy5uZXRMb2MpIHtcblx0ICAgICAgICAvLyAzKSBJZiB0aGUgZW1iZWRkZWQgVVJMJ3MgPG5ldF9sb2M+IGlzIG5vbi1lbXB0eSwgd2Ugc2tpcCB0b1xuXHQgICAgICAgIC8vIFN0ZXAgNy4gIE90aGVyd2lzZSwgdGhlIGVtYmVkZGVkIFVSTCBpbmhlcml0cyB0aGUgPG5ldF9sb2M+XG5cdCAgICAgICAgLy8gKGlmIGFueSkgb2YgdGhlIGJhc2UgVVJMLlxuXHQgICAgICAgIGJ1aWx0UGFydHMubmV0TG9jID0gYmFzZVBhcnRzLm5ldExvYztcblx0ICAgICAgICAvLyA0KSBJZiB0aGUgZW1iZWRkZWQgVVJMIHBhdGggaXMgcHJlY2VkZWQgYnkgYSBzbGFzaCBcIi9cIiwgdGhlXG5cdCAgICAgICAgLy8gcGF0aCBpcyBub3QgcmVsYXRpdmUgYW5kIHdlIHNraXAgdG8gU3RlcCA3LlxuXHQgICAgICAgIGlmIChyZWxhdGl2ZVBhcnRzLnBhdGhbMF0gIT09ICcvJykge1xuXHQgICAgICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzLnBhdGgpIHtcblx0ICAgICAgICAgICAgLy8gNSkgSWYgdGhlIGVtYmVkZGVkIFVSTCBwYXRoIGlzIGVtcHR5IChhbmQgbm90IHByZWNlZGVkIGJ5IGFcblx0ICAgICAgICAgICAgLy8gc2xhc2gpLCB0aGVuIHRoZSBlbWJlZGRlZCBVUkwgaW5oZXJpdHMgdGhlIGJhc2UgVVJMIHBhdGhcblx0ICAgICAgICAgICAgYnVpbHRQYXJ0cy5wYXRoID0gYmFzZVBhcnRzLnBhdGg7XG5cdCAgICAgICAgICAgIC8vIDVhKSBpZiB0aGUgZW1iZWRkZWQgVVJMJ3MgPHBhcmFtcz4gaXMgbm9uLWVtcHR5LCB3ZSBza2lwIHRvXG5cdCAgICAgICAgICAgIC8vIHN0ZXAgNzsgb3RoZXJ3aXNlLCBpdCBpbmhlcml0cyB0aGUgPHBhcmFtcz4gb2YgdGhlIGJhc2Vcblx0ICAgICAgICAgICAgLy8gVVJMIChpZiBhbnkpIGFuZFxuXHQgICAgICAgICAgICBpZiAoIXJlbGF0aXZlUGFydHMucGFyYW1zKSB7XG5cdCAgICAgICAgICAgICAgYnVpbHRQYXJ0cy5wYXJhbXMgPSBiYXNlUGFydHMucGFyYW1zO1xuXHQgICAgICAgICAgICAgIC8vIDViKSBpZiB0aGUgZW1iZWRkZWQgVVJMJ3MgPHF1ZXJ5PiBpcyBub24tZW1wdHksIHdlIHNraXAgdG9cblx0ICAgICAgICAgICAgICAvLyBzdGVwIDc7IG90aGVyd2lzZSwgaXQgaW5oZXJpdHMgdGhlIDxxdWVyeT4gb2YgdGhlIGJhc2Vcblx0ICAgICAgICAgICAgICAvLyBVUkwgKGlmIGFueSkgYW5kIHdlIHNraXAgdG8gc3RlcCA3LlxuXHQgICAgICAgICAgICAgIGlmICghcmVsYXRpdmVQYXJ0cy5xdWVyeSkge1xuXHQgICAgICAgICAgICAgICAgYnVpbHRQYXJ0cy5xdWVyeSA9IGJhc2VQYXJ0cy5xdWVyeTtcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIC8vIDYpIFRoZSBsYXN0IHNlZ21lbnQgb2YgdGhlIGJhc2UgVVJMJ3MgcGF0aCAoYW55dGhpbmdcblx0ICAgICAgICAgICAgLy8gZm9sbG93aW5nIHRoZSByaWdodG1vc3Qgc2xhc2ggXCIvXCIsIG9yIHRoZSBlbnRpcmUgcGF0aCBpZiBub1xuXHQgICAgICAgICAgICAvLyBzbGFzaCBpcyBwcmVzZW50KSBpcyByZW1vdmVkIGFuZCB0aGUgZW1iZWRkZWQgVVJMJ3MgcGF0aCBpc1xuXHQgICAgICAgICAgICAvLyBhcHBlbmRlZCBpbiBpdHMgcGxhY2UuXG5cdCAgICAgICAgICAgIHZhciBiYXNlVVJMUGF0aCA9IGJhc2VQYXJ0cy5wYXRoO1xuXHQgICAgICAgICAgICB2YXIgbmV3UGF0aCA9XG5cdCAgICAgICAgICAgICAgYmFzZVVSTFBhdGguc3Vic3RyaW5nKDAsIGJhc2VVUkxQYXRoLmxhc3RJbmRleE9mKCcvJykgKyAxKSArXG5cdCAgICAgICAgICAgICAgcmVsYXRpdmVQYXJ0cy5wYXRoO1xuXHQgICAgICAgICAgICBidWlsdFBhcnRzLnBhdGggPSBVUkxUb29sa2l0Lm5vcm1hbGl6ZVBhdGgobmV3UGF0aCk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIGlmIChidWlsdFBhcnRzLnBhdGggPT09IG51bGwpIHtcblx0ICAgICAgICBidWlsdFBhcnRzLnBhdGggPSBvcHRzLmFsd2F5c05vcm1hbGl6ZVxuXHQgICAgICAgICAgPyBVUkxUb29sa2l0Lm5vcm1hbGl6ZVBhdGgocmVsYXRpdmVQYXJ0cy5wYXRoKVxuXHQgICAgICAgICAgOiByZWxhdGl2ZVBhcnRzLnBhdGg7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIFVSTFRvb2xraXQuYnVpbGRVUkxGcm9tUGFydHMoYnVpbHRQYXJ0cyk7XG5cdCAgICB9LFxuXHQgICAgcGFyc2VVUkw6IGZ1bmN0aW9uICh1cmwpIHtcblx0ICAgICAgdmFyIHBhcnRzID0gVVJMX1JFR0VYLmV4ZWModXJsKTtcblx0ICAgICAgaWYgKCFwYXJ0cykge1xuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiB7XG5cdCAgICAgICAgc2NoZW1lOiBwYXJ0c1sxXSB8fCAnJyxcblx0ICAgICAgICBuZXRMb2M6IHBhcnRzWzJdIHx8ICcnLFxuXHQgICAgICAgIHBhdGg6IHBhcnRzWzNdIHx8ICcnLFxuXHQgICAgICAgIHBhcmFtczogcGFydHNbNF0gfHwgJycsXG5cdCAgICAgICAgcXVlcnk6IHBhcnRzWzVdIHx8ICcnLFxuXHQgICAgICAgIGZyYWdtZW50OiBwYXJ0c1s2XSB8fCAnJyxcblx0ICAgICAgfTtcblx0ICAgIH0sXG5cdCAgICBub3JtYWxpemVQYXRoOiBmdW5jdGlvbiAocGF0aCkge1xuXHQgICAgICAvLyBUaGUgZm9sbG93aW5nIG9wZXJhdGlvbnMgYXJlXG5cdCAgICAgIC8vIHRoZW4gYXBwbGllZCwgaW4gb3JkZXIsIHRvIHRoZSBuZXcgcGF0aDpcblx0ICAgICAgLy8gNmEpIEFsbCBvY2N1cnJlbmNlcyBvZiBcIi4vXCIsIHdoZXJlIFwiLlwiIGlzIGEgY29tcGxldGUgcGF0aFxuXHQgICAgICAvLyBzZWdtZW50LCBhcmUgcmVtb3ZlZC5cblx0ICAgICAgLy8gNmIpIElmIHRoZSBwYXRoIGVuZHMgd2l0aCBcIi5cIiBhcyBhIGNvbXBsZXRlIHBhdGggc2VnbWVudCxcblx0ICAgICAgLy8gdGhhdCBcIi5cIiBpcyByZW1vdmVkLlxuXHQgICAgICBwYXRoID0gcGF0aC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpLnJlcGxhY2UoU0xBU0hfRE9UX1JFR0VYLCAnJyk7XG5cdCAgICAgIC8vIDZjKSBBbGwgb2NjdXJyZW5jZXMgb2YgXCI8c2VnbWVudD4vLi4vXCIsIHdoZXJlIDxzZWdtZW50PiBpcyBhXG5cdCAgICAgIC8vIGNvbXBsZXRlIHBhdGggc2VnbWVudCBub3QgZXF1YWwgdG8gXCIuLlwiLCBhcmUgcmVtb3ZlZC5cblx0ICAgICAgLy8gUmVtb3ZhbCBvZiB0aGVzZSBwYXRoIHNlZ21lbnRzIGlzIHBlcmZvcm1lZCBpdGVyYXRpdmVseSxcblx0ICAgICAgLy8gcmVtb3ZpbmcgdGhlIGxlZnRtb3N0IG1hdGNoaW5nIHBhdHRlcm4gb24gZWFjaCBpdGVyYXRpb24sXG5cdCAgICAgIC8vIHVudGlsIG5vIG1hdGNoaW5nIHBhdHRlcm4gcmVtYWlucy5cblx0ICAgICAgLy8gNmQpIElmIHRoZSBwYXRoIGVuZHMgd2l0aCBcIjxzZWdtZW50Pi8uLlwiLCB3aGVyZSA8c2VnbWVudD4gaXMgYVxuXHQgICAgICAvLyBjb21wbGV0ZSBwYXRoIHNlZ21lbnQgbm90IGVxdWFsIHRvIFwiLi5cIiwgdGhhdFxuXHQgICAgICAvLyBcIjxzZWdtZW50Pi8uLlwiIGlzIHJlbW92ZWQuXG5cdCAgICAgIHdoaWxlIChcblx0ICAgICAgICBwYXRoLmxlbmd0aCAhPT0gKHBhdGggPSBwYXRoLnJlcGxhY2UoU0xBU0hfRE9UX0RPVF9SRUdFWCwgJycpKS5sZW5ndGhcblx0ICAgICAgKSB7fVxuXHQgICAgICByZXR1cm4gcGF0aC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpO1xuXHQgICAgfSxcblx0ICAgIGJ1aWxkVVJMRnJvbVBhcnRzOiBmdW5jdGlvbiAocGFydHMpIHtcblx0ICAgICAgcmV0dXJuIChcblx0ICAgICAgICBwYXJ0cy5zY2hlbWUgK1xuXHQgICAgICAgIHBhcnRzLm5ldExvYyArXG5cdCAgICAgICAgcGFydHMucGF0aCArXG5cdCAgICAgICAgcGFydHMucGFyYW1zICtcblx0ICAgICAgICBwYXJ0cy5xdWVyeSArXG5cdCAgICAgICAgcGFydHMuZnJhZ21lbnRcblx0ICAgICAgKTtcblx0ICAgIH0sXG5cdCAgfTtcblxuXHQgIG1vZHVsZS5leHBvcnRzID0gVVJMVG9vbGtpdDtcblx0fSkoKTsgXG59ICh1cmxUb29sa2l0KSk7XG5cbnZhciB1cmxUb29sa2l0RXhwb3J0cyA9IHVybFRvb2xraXQuZXhwb3J0cztcblxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7XG4gIHZhciB0ID0gT2JqZWN0LmtleXMoZSk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuICAgIHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTtcbiAgICB9KSksIHQucHVzaC5hcHBseSh0LCBvKTtcbiAgfVxuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKGUpIHtcbiAgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHtcbiAgICB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307XG4gICAgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTtcbiAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7XG4gIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiB0IHx8ICF0KSByZXR1cm4gdDtcbiAgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgaSkgcmV0dXJuIGk7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7XG59XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7XG4gIHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gXCJzeW1ib2xcIiA9PSB0eXBlb2YgaSA/IGkgOiBTdHJpbmcoaSk7XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS9tZG4tamF2YXNjcmlwdF9idWlsdGluc19udW1iZXJfaXNmaW5pdGVcbmNvbnN0IGlzRmluaXRlTnVtYmVyID0gTnVtYmVyLmlzRmluaXRlIHx8IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWx1ZSk7XG59O1xuXG4vLyBodHRwczovL2Nhbml1c2UuY29tL21kbi1qYXZhc2NyaXB0X2J1aWx0aW5zX251bWJlcl9pc3NhZmVpbnRlZ2VyXG5jb25zdCBpc1NhZmVJbnRlZ2VyID0gTnVtYmVyLmlzU2FmZUludGVnZXIgfHwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIE1hdGguYWJzKHZhbHVlKSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufTtcbmNvbnN0IE1BWF9TQUZFX0lOVEVHRVIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCA5MDA3MTk5MjU0NzQwOTkxO1xuXG5sZXQgRXZlbnRzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChFdmVudHMpIHtcbiAgRXZlbnRzW1wiTUVESUFfQVRUQUNISU5HXCJdID0gXCJobHNNZWRpYUF0dGFjaGluZ1wiO1xuICBFdmVudHNbXCJNRURJQV9BVFRBQ0hFRFwiXSA9IFwiaGxzTWVkaWFBdHRhY2hlZFwiO1xuICBFdmVudHNbXCJNRURJQV9ERVRBQ0hJTkdcIl0gPSBcImhsc01lZGlhRGV0YWNoaW5nXCI7XG4gIEV2ZW50c1tcIk1FRElBX0RFVEFDSEVEXCJdID0gXCJobHNNZWRpYURldGFjaGVkXCI7XG4gIEV2ZW50c1tcIkJVRkZFUl9SRVNFVFwiXSA9IFwiaGxzQnVmZmVyUmVzZXRcIjtcbiAgRXZlbnRzW1wiQlVGRkVSX0NPREVDU1wiXSA9IFwiaGxzQnVmZmVyQ29kZWNzXCI7XG4gIEV2ZW50c1tcIkJVRkZFUl9DUkVBVEVEXCJdID0gXCJobHNCdWZmZXJDcmVhdGVkXCI7XG4gIEV2ZW50c1tcIkJVRkZFUl9BUFBFTkRJTkdcIl0gPSBcImhsc0J1ZmZlckFwcGVuZGluZ1wiO1xuICBFdmVudHNbXCJCVUZGRVJfQVBQRU5ERURcIl0gPSBcImhsc0J1ZmZlckFwcGVuZGVkXCI7XG4gIEV2ZW50c1tcIkJVRkZFUl9FT1NcIl0gPSBcImhsc0J1ZmZlckVvc1wiO1xuICBFdmVudHNbXCJCVUZGRVJfRkxVU0hJTkdcIl0gPSBcImhsc0J1ZmZlckZsdXNoaW5nXCI7XG4gIEV2ZW50c1tcIkJVRkZFUl9GTFVTSEVEXCJdID0gXCJobHNCdWZmZXJGbHVzaGVkXCI7XG4gIEV2ZW50c1tcIk1BTklGRVNUX0xPQURJTkdcIl0gPSBcImhsc01hbmlmZXN0TG9hZGluZ1wiO1xuICBFdmVudHNbXCJNQU5JRkVTVF9MT0FERURcIl0gPSBcImhsc01hbmlmZXN0TG9hZGVkXCI7XG4gIEV2ZW50c1tcIk1BTklGRVNUX1BBUlNFRFwiXSA9IFwiaGxzTWFuaWZlc3RQYXJzZWRcIjtcbiAgRXZlbnRzW1wiTEVWRUxfU1dJVENISU5HXCJdID0gXCJobHNMZXZlbFN3aXRjaGluZ1wiO1xuICBFdmVudHNbXCJMRVZFTF9TV0lUQ0hFRFwiXSA9IFwiaGxzTGV2ZWxTd2l0Y2hlZFwiO1xuICBFdmVudHNbXCJMRVZFTF9MT0FESU5HXCJdID0gXCJobHNMZXZlbExvYWRpbmdcIjtcbiAgRXZlbnRzW1wiTEVWRUxfTE9BREVEXCJdID0gXCJobHNMZXZlbExvYWRlZFwiO1xuICBFdmVudHNbXCJMRVZFTF9VUERBVEVEXCJdID0gXCJobHNMZXZlbFVwZGF0ZWRcIjtcbiAgRXZlbnRzW1wiTEVWRUxfUFRTX1VQREFURURcIl0gPSBcImhsc0xldmVsUHRzVXBkYXRlZFwiO1xuICBFdmVudHNbXCJMRVZFTFNfVVBEQVRFRFwiXSA9IFwiaGxzTGV2ZWxzVXBkYXRlZFwiO1xuICBFdmVudHNbXCJBVURJT19UUkFDS1NfVVBEQVRFRFwiXSA9IFwiaGxzQXVkaW9UcmFja3NVcGRhdGVkXCI7XG4gIEV2ZW50c1tcIkFVRElPX1RSQUNLX1NXSVRDSElOR1wiXSA9IFwiaGxzQXVkaW9UcmFja1N3aXRjaGluZ1wiO1xuICBFdmVudHNbXCJBVURJT19UUkFDS19TV0lUQ0hFRFwiXSA9IFwiaGxzQXVkaW9UcmFja1N3aXRjaGVkXCI7XG4gIEV2ZW50c1tcIkFVRElPX1RSQUNLX0xPQURJTkdcIl0gPSBcImhsc0F1ZGlvVHJhY2tMb2FkaW5nXCI7XG4gIEV2ZW50c1tcIkFVRElPX1RSQUNLX0xPQURFRFwiXSA9IFwiaGxzQXVkaW9UcmFja0xvYWRlZFwiO1xuICBFdmVudHNbXCJTVUJUSVRMRV9UUkFDS1NfVVBEQVRFRFwiXSA9IFwiaGxzU3VidGl0bGVUcmFja3NVcGRhdGVkXCI7XG4gIEV2ZW50c1tcIlNVQlRJVExFX1RSQUNLU19DTEVBUkVEXCJdID0gXCJobHNTdWJ0aXRsZVRyYWNrc0NsZWFyZWRcIjtcbiAgRXZlbnRzW1wiU1VCVElUTEVfVFJBQ0tfU1dJVENIXCJdID0gXCJobHNTdWJ0aXRsZVRyYWNrU3dpdGNoXCI7XG4gIEV2ZW50c1tcIlNVQlRJVExFX1RSQUNLX0xPQURJTkdcIl0gPSBcImhsc1N1YnRpdGxlVHJhY2tMb2FkaW5nXCI7XG4gIEV2ZW50c1tcIlNVQlRJVExFX1RSQUNLX0xPQURFRFwiXSA9IFwiaGxzU3VidGl0bGVUcmFja0xvYWRlZFwiO1xuICBFdmVudHNbXCJTVUJUSVRMRV9GUkFHX1BST0NFU1NFRFwiXSA9IFwiaGxzU3VidGl0bGVGcmFnUHJvY2Vzc2VkXCI7XG4gIEV2ZW50c1tcIkNVRVNfUEFSU0VEXCJdID0gXCJobHNDdWVzUGFyc2VkXCI7XG4gIEV2ZW50c1tcIk5PTl9OQVRJVkVfVEVYVF9UUkFDS1NfRk9VTkRcIl0gPSBcImhsc05vbk5hdGl2ZVRleHRUcmFja3NGb3VuZFwiO1xuICBFdmVudHNbXCJJTklUX1BUU19GT1VORFwiXSA9IFwiaGxzSW5pdFB0c0ZvdW5kXCI7XG4gIEV2ZW50c1tcIkZSQUdfTE9BRElOR1wiXSA9IFwiaGxzRnJhZ0xvYWRpbmdcIjtcbiAgRXZlbnRzW1wiRlJBR19MT0FEX0VNRVJHRU5DWV9BQk9SVEVEXCJdID0gXCJobHNGcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWRcIjtcbiAgRXZlbnRzW1wiRlJBR19MT0FERURcIl0gPSBcImhsc0ZyYWdMb2FkZWRcIjtcbiAgRXZlbnRzW1wiRlJBR19ERUNSWVBURURcIl0gPSBcImhsc0ZyYWdEZWNyeXB0ZWRcIjtcbiAgRXZlbnRzW1wiRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVFwiXSA9IFwiaGxzRnJhZ1BhcnNpbmdJbml0U2VnbWVudFwiO1xuICBFdmVudHNbXCJGUkFHX1BBUlNJTkdfVVNFUkRBVEFcIl0gPSBcImhsc0ZyYWdQYXJzaW5nVXNlcmRhdGFcIjtcbiAgRXZlbnRzW1wiRlJBR19QQVJTSU5HX01FVEFEQVRBXCJdID0gXCJobHNGcmFnUGFyc2luZ01ldGFkYXRhXCI7XG4gIEV2ZW50c1tcIkZSQUdfUEFSU0VEXCJdID0gXCJobHNGcmFnUGFyc2VkXCI7XG4gIEV2ZW50c1tcIkZSQUdfQlVGRkVSRURcIl0gPSBcImhsc0ZyYWdCdWZmZXJlZFwiO1xuICBFdmVudHNbXCJGUkFHX0NIQU5HRURcIl0gPSBcImhsc0ZyYWdDaGFuZ2VkXCI7XG4gIEV2ZW50c1tcIkZQU19EUk9QXCJdID0gXCJobHNGcHNEcm9wXCI7XG4gIEV2ZW50c1tcIkZQU19EUk9QX0xFVkVMX0NBUFBJTkdcIl0gPSBcImhsc0Zwc0Ryb3BMZXZlbENhcHBpbmdcIjtcbiAgRXZlbnRzW1wiTUFYX0FVVE9fTEVWRUxfVVBEQVRFRFwiXSA9IFwiaGxzTWF4QXV0b0xldmVsVXBkYXRlZFwiO1xuICBFdmVudHNbXCJFUlJPUlwiXSA9IFwiaGxzRXJyb3JcIjtcbiAgRXZlbnRzW1wiREVTVFJPWUlOR1wiXSA9IFwiaGxzRGVzdHJveWluZ1wiO1xuICBFdmVudHNbXCJLRVlfTE9BRElOR1wiXSA9IFwiaGxzS2V5TG9hZGluZ1wiO1xuICBFdmVudHNbXCJLRVlfTE9BREVEXCJdID0gXCJobHNLZXlMb2FkZWRcIjtcbiAgRXZlbnRzW1wiTElWRV9CQUNLX0JVRkZFUl9SRUFDSEVEXCJdID0gXCJobHNMaXZlQmFja0J1ZmZlclJlYWNoZWRcIjtcbiAgRXZlbnRzW1wiQkFDS19CVUZGRVJfUkVBQ0hFRFwiXSA9IFwiaGxzQmFja0J1ZmZlclJlYWNoZWRcIjtcbiAgRXZlbnRzW1wiU1RFRVJJTkdfTUFOSUZFU1RfTE9BREVEXCJdID0gXCJobHNTdGVlcmluZ01hbmlmZXN0TG9hZGVkXCI7XG4gIHJldHVybiBFdmVudHM7XG59KHt9KTtcblxuLyoqXG4gKiBEZWZpbmVzIGVhY2ggRXZlbnQgdHlwZSBhbmQgcGF5bG9hZCBieSBFdmVudCBuYW1lLiBVc2VkIGluIHtAbGluayBobHMuanMjSGxzRXZlbnRFbWl0dGVyfSB0byBzdHJvbmdseSB0eXBlIHRoZSBldmVudCBsaXN0ZW5lciBBUEkuXG4gKi9cblxubGV0IEVycm9yVHlwZXMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKEVycm9yVHlwZXMpIHtcbiAgRXJyb3JUeXBlc1tcIk5FVFdPUktfRVJST1JcIl0gPSBcIm5ldHdvcmtFcnJvclwiO1xuICBFcnJvclR5cGVzW1wiTUVESUFfRVJST1JcIl0gPSBcIm1lZGlhRXJyb3JcIjtcbiAgRXJyb3JUeXBlc1tcIktFWV9TWVNURU1fRVJST1JcIl0gPSBcImtleVN5c3RlbUVycm9yXCI7XG4gIEVycm9yVHlwZXNbXCJNVVhfRVJST1JcIl0gPSBcIm11eEVycm9yXCI7XG4gIEVycm9yVHlwZXNbXCJPVEhFUl9FUlJPUlwiXSA9IFwib3RoZXJFcnJvclwiO1xuICByZXR1cm4gRXJyb3JUeXBlcztcbn0oe30pO1xubGV0IEVycm9yRGV0YWlscyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoRXJyb3JEZXRhaWxzKSB7XG4gIEVycm9yRGV0YWlsc1tcIktFWV9TWVNURU1fTk9fS0VZU1wiXSA9IFwia2V5U3lzdGVtTm9LZXlzXCI7XG4gIEVycm9yRGV0YWlsc1tcIktFWV9TWVNURU1fTk9fQUNDRVNTXCJdID0gXCJrZXlTeXN0ZW1Ob0FjY2Vzc1wiO1xuICBFcnJvckRldGFpbHNbXCJLRVlfU1lTVEVNX05PX1NFU1NJT05cIl0gPSBcImtleVN5c3RlbU5vU2Vzc2lvblwiO1xuICBFcnJvckRldGFpbHNbXCJLRVlfU1lTVEVNX05PX0NPTkZJR1VSRURfTElDRU5TRVwiXSA9IFwia2V5U3lzdGVtTm9Db25maWd1cmVkTGljZW5zZVwiO1xuICBFcnJvckRldGFpbHNbXCJLRVlfU1lTVEVNX0xJQ0VOU0VfUkVRVUVTVF9GQUlMRURcIl0gPSBcImtleVN5c3RlbUxpY2Vuc2VSZXF1ZXN0RmFpbGVkXCI7XG4gIEVycm9yRGV0YWlsc1tcIktFWV9TWVNURU1fU0VSVkVSX0NFUlRJRklDQVRFX1JFUVVFU1RfRkFJTEVEXCJdID0gXCJrZXlTeXN0ZW1TZXJ2ZXJDZXJ0aWZpY2F0ZVJlcXVlc3RGYWlsZWRcIjtcbiAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9TRVJWRVJfQ0VSVElGSUNBVEVfVVBEQVRFX0ZBSUxFRFwiXSA9IFwia2V5U3lzdGVtU2VydmVyQ2VydGlmaWNhdGVVcGRhdGVGYWlsZWRcIjtcbiAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9TRVNTSU9OX1VQREFURV9GQUlMRURcIl0gPSBcImtleVN5c3RlbVNlc3Npb25VcGRhdGVGYWlsZWRcIjtcbiAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9TVEFUVVNfT1VUUFVUX1JFU1RSSUNURURcIl0gPSBcImtleVN5c3RlbVN0YXR1c091dHB1dFJlc3RyaWN0ZWRcIjtcbiAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9TVEFUVVNfSU5URVJOQUxfRVJST1JcIl0gPSBcImtleVN5c3RlbVN0YXR1c0ludGVybmFsRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiTUFOSUZFU1RfTE9BRF9FUlJPUlwiXSA9IFwibWFuaWZlc3RMb2FkRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiTUFOSUZFU1RfTE9BRF9USU1FT1VUXCJdID0gXCJtYW5pZmVzdExvYWRUaW1lT3V0XCI7XG4gIEVycm9yRGV0YWlsc1tcIk1BTklGRVNUX1BBUlNJTkdfRVJST1JcIl0gPSBcIm1hbmlmZXN0UGFyc2luZ0Vycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIk1BTklGRVNUX0lOQ09NUEFUSUJMRV9DT0RFQ1NfRVJST1JcIl0gPSBcIm1hbmlmZXN0SW5jb21wYXRpYmxlQ29kZWNzRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiTEVWRUxfRU1QVFlfRVJST1JcIl0gPSBcImxldmVsRW1wdHlFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJMRVZFTF9MT0FEX0VSUk9SXCJdID0gXCJsZXZlbExvYWRFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJMRVZFTF9MT0FEX1RJTUVPVVRcIl0gPSBcImxldmVsTG9hZFRpbWVPdXRcIjtcbiAgRXJyb3JEZXRhaWxzW1wiTEVWRUxfUEFSU0lOR19FUlJPUlwiXSA9IFwibGV2ZWxQYXJzaW5nRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiTEVWRUxfU1dJVENIX0VSUk9SXCJdID0gXCJsZXZlbFN3aXRjaEVycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIkFVRElPX1RSQUNLX0xPQURfRVJST1JcIl0gPSBcImF1ZGlvVHJhY2tMb2FkRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUXCJdID0gXCJhdWRpb1RyYWNrTG9hZFRpbWVPdXRcIjtcbiAgRXJyb3JEZXRhaWxzW1wiU1VCVElUTEVfTE9BRF9FUlJPUlwiXSA9IFwic3VidGl0bGVUcmFja0xvYWRFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJTVUJUSVRMRV9UUkFDS19MT0FEX1RJTUVPVVRcIl0gPSBcInN1YnRpdGxlVHJhY2tMb2FkVGltZU91dFwiO1xuICBFcnJvckRldGFpbHNbXCJGUkFHX0xPQURfRVJST1JcIl0gPSBcImZyYWdMb2FkRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiRlJBR19MT0FEX1RJTUVPVVRcIl0gPSBcImZyYWdMb2FkVGltZU91dFwiO1xuICBFcnJvckRldGFpbHNbXCJGUkFHX0RFQ1JZUFRfRVJST1JcIl0gPSBcImZyYWdEZWNyeXB0RXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiRlJBR19QQVJTSU5HX0VSUk9SXCJdID0gXCJmcmFnUGFyc2luZ0Vycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIkZSQUdfR0FQXCJdID0gXCJmcmFnR2FwXCI7XG4gIEVycm9yRGV0YWlsc1tcIlJFTVVYX0FMTE9DX0VSUk9SXCJdID0gXCJyZW11eEFsbG9jRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiS0VZX0xPQURfRVJST1JcIl0gPSBcImtleUxvYWRFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJLRVlfTE9BRF9USU1FT1VUXCJdID0gXCJrZXlMb2FkVGltZU91dFwiO1xuICBFcnJvckRldGFpbHNbXCJCVUZGRVJfQUREX0NPREVDX0VSUk9SXCJdID0gXCJidWZmZXJBZGRDb2RlY0Vycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIkJVRkZFUl9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SXCJdID0gXCJidWZmZXJJbmNvbXBhdGlibGVDb2RlY3NFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJCVUZGRVJfQVBQRU5EX0VSUk9SXCJdID0gXCJidWZmZXJBcHBlbmRFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJCVUZGRVJfQVBQRU5ESU5HX0VSUk9SXCJdID0gXCJidWZmZXJBcHBlbmRpbmdFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJCVUZGRVJfU1RBTExFRF9FUlJPUlwiXSA9IFwiYnVmZmVyU3RhbGxlZEVycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIkJVRkZFUl9GVUxMX0VSUk9SXCJdID0gXCJidWZmZXJGdWxsRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiQlVGRkVSX1NFRUtfT1ZFUl9IT0xFXCJdID0gXCJidWZmZXJTZWVrT3ZlckhvbGVcIjtcbiAgRXJyb3JEZXRhaWxzW1wiQlVGRkVSX05VREdFX09OX1NUQUxMXCJdID0gXCJidWZmZXJOdWRnZU9uU3RhbGxcIjtcbiAgRXJyb3JEZXRhaWxzW1wiSU5URVJOQUxfRVhDRVBUSU9OXCJdID0gXCJpbnRlcm5hbEV4Y2VwdGlvblwiO1xuICBFcnJvckRldGFpbHNbXCJJTlRFUk5BTF9BQk9SVEVEXCJdID0gXCJhYm9ydGVkXCI7XG4gIEVycm9yRGV0YWlsc1tcIlVOS05PV05cIl0gPSBcInVua25vd25cIjtcbiAgcmV0dXJuIEVycm9yRGV0YWlscztcbn0oe30pO1xuXG5jb25zdCBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuY29uc3QgZmFrZUxvZ2dlciA9IHtcbiAgdHJhY2U6IG5vb3AsXG4gIGRlYnVnOiBub29wLFxuICBsb2c6IG5vb3AsXG4gIHdhcm46IG5vb3AsXG4gIGluZm86IG5vb3AsXG4gIGVycm9yOiBub29wXG59O1xubGV0IGV4cG9ydGVkTG9nZ2VyID0gZmFrZUxvZ2dlcjtcblxuLy8gbGV0IGxhc3RDYWxsVGltZTtcbi8vIGZ1bmN0aW9uIGZvcm1hdE1zZ1dpdGhUaW1lSW5mbyh0eXBlLCBtc2cpIHtcbi8vICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbi8vICAgY29uc3QgZGlmZiA9IGxhc3RDYWxsVGltZSA/ICcrJyArIChub3cgLSBsYXN0Q2FsbFRpbWUpIDogJzAnO1xuLy8gICBsYXN0Q2FsbFRpbWUgPSBub3c7XG4vLyAgIG1zZyA9IChuZXcgRGF0ZShub3cpKS50b0lTT1N0cmluZygpICsgJyB8IFsnICsgIHR5cGUgKyAnXSA+ICcgKyBtc2cgKyAnICggJyArIGRpZmYgKyAnIG1zICknO1xuLy8gICByZXR1cm4gbXNnO1xuLy8gfVxuXG5mdW5jdGlvbiBjb25zb2xlUHJpbnRGbih0eXBlKSB7XG4gIGNvbnN0IGZ1bmMgPSBzZWxmLmNvbnNvbGVbdHlwZV07XG4gIGlmIChmdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmMuYmluZChzZWxmLmNvbnNvbGUsIGBbJHt0eXBlfV0gPmApO1xuICB9XG4gIHJldHVybiBub29wO1xufVxuZnVuY3Rpb24gZXhwb3J0TG9nZ2VyRnVuY3Rpb25zKGRlYnVnQ29uZmlnLCAuLi5mdW5jdGlvbnMpIHtcbiAgZnVuY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBleHBvcnRlZExvZ2dlclt0eXBlXSA9IGRlYnVnQ29uZmlnW3R5cGVdID8gZGVidWdDb25maWdbdHlwZV0uYmluZChkZWJ1Z0NvbmZpZykgOiBjb25zb2xlUHJpbnRGbih0eXBlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBlbmFibGVMb2dzKGRlYnVnQ29uZmlnLCBpZCkge1xuICAvLyBjaGVjayB0aGF0IGNvbnNvbGUgaXMgYXZhaWxhYmxlXG4gIGlmICh0eXBlb2YgY29uc29sZSA9PT0gJ29iamVjdCcgJiYgZGVidWdDb25maWcgPT09IHRydWUgfHwgdHlwZW9mIGRlYnVnQ29uZmlnID09PSAnb2JqZWN0Jykge1xuICAgIGV4cG9ydExvZ2dlckZ1bmN0aW9ucyhkZWJ1Z0NvbmZpZyxcbiAgICAvLyBSZW1vdmUgb3V0IGZyb20gbGlzdCBoZXJlIHRvIGhhcmQtZGlzYWJsZSBhIGxvZy1sZXZlbFxuICAgIC8vICd0cmFjZScsXG4gICAgJ2RlYnVnJywgJ2xvZycsICdpbmZvJywgJ3dhcm4nLCAnZXJyb3InKTtcbiAgICAvLyBTb21lIGJyb3dzZXJzIGRvbid0IGFsbG93IHRvIHVzZSBiaW5kIG9uIGNvbnNvbGUgb2JqZWN0IGFueXdheVxuICAgIC8vIGZhbGxiYWNrIHRvIGRlZmF1bHQgaWYgbmVlZGVkXG4gICAgdHJ5IHtcbiAgICAgIGV4cG9ydGVkTG9nZ2VyLmxvZyhgRGVidWcgbG9ncyBlbmFibGVkIGZvciBcIiR7aWR9XCIgaW4gaGxzLmpzIHZlcnNpb24gJHtcIjEuNS42XCJ9YCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXhwb3J0ZWRMb2dnZXIgPSBmYWtlTG9nZ2VyO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBleHBvcnRlZExvZ2dlciA9IGZha2VMb2dnZXI7XG4gIH1cbn1cbmNvbnN0IGxvZ2dlciA9IGV4cG9ydGVkTG9nZ2VyO1xuXG5jb25zdCBERUNJTUFMX1JFU09MVVRJT05fUkVHRVggPSAvXihcXGQrKXgoXFxkKykkLztcbmNvbnN0IEFUVFJfTElTVF9SRUdFWCA9IC8oLis/KT0oXCIuKj9cInwuKj8pKD86LHwkKS9nO1xuXG4vLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2thbm9uZ2lsL25vZGUtbTN1OHBhcnNlL2Jsb2IvbWFzdGVyL2F0dHJsaXN0LmpzXG5jbGFzcyBBdHRyTGlzdCB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzKSB7XG4gICAgaWYgKHR5cGVvZiBhdHRycyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGF0dHJzID0gQXR0ckxpc3QucGFyc2VBdHRyTGlzdChhdHRycyk7XG4gICAgfVxuICAgIF9leHRlbmRzKHRoaXMsIGF0dHJzKTtcbiAgfVxuICBnZXQgY2xpZW50QXR0cnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMpLmZpbHRlcihhdHRyID0+IGF0dHIuc3Vic3RyaW5nKDAsIDIpID09PSAnWC0nKTtcbiAgfVxuICBkZWNpbWFsSW50ZWdlcihhdHRyTmFtZSkge1xuICAgIGNvbnN0IGludFZhbHVlID0gcGFyc2VJbnQodGhpc1thdHRyTmFtZV0sIDEwKTtcbiAgICBpZiAoaW50VmFsdWUgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cbiAgICByZXR1cm4gaW50VmFsdWU7XG4gIH1cbiAgaGV4YWRlY2ltYWxJbnRlZ2VyKGF0dHJOYW1lKSB7XG4gICAgaWYgKHRoaXNbYXR0ck5hbWVdKSB7XG4gICAgICBsZXQgc3RyaW5nVmFsdWUgPSAodGhpc1thdHRyTmFtZV0gfHwgJzB4Jykuc2xpY2UoMik7XG4gICAgICBzdHJpbmdWYWx1ZSA9IChzdHJpbmdWYWx1ZS5sZW5ndGggJiAxID8gJzAnIDogJycpICsgc3RyaW5nVmFsdWU7XG4gICAgICBjb25zdCB2YWx1ZSA9IG5ldyBVaW50OEFycmF5KHN0cmluZ1ZhbHVlLmxlbmd0aCAvIDIpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmdWYWx1ZS5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgdmFsdWVbaV0gPSBwYXJzZUludChzdHJpbmdWYWx1ZS5zbGljZShpICogMiwgaSAqIDIgKyAyKSwgMTYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgaGV4YWRlY2ltYWxJbnRlZ2VyQXNOdW1iZXIoYXR0ck5hbWUpIHtcbiAgICBjb25zdCBpbnRWYWx1ZSA9IHBhcnNlSW50KHRoaXNbYXR0ck5hbWVdLCAxNik7XG4gICAgaWYgKGludFZhbHVlID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgcmV0dXJuIGludFZhbHVlO1xuICB9XG4gIGRlY2ltYWxGbG9hdGluZ1BvaW50KGF0dHJOYW1lKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodGhpc1thdHRyTmFtZV0pO1xuICB9XG4gIG9wdGlvbmFsRmxvYXQoYXR0ck5hbWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpc1thdHRyTmFtZV07XG4gICAgcmV0dXJuIHZhbHVlID8gcGFyc2VGbG9hdCh2YWx1ZSkgOiBkZWZhdWx0VmFsdWU7XG4gIH1cbiAgZW51bWVyYXRlZFN0cmluZyhhdHRyTmFtZSkge1xuICAgIHJldHVybiB0aGlzW2F0dHJOYW1lXTtcbiAgfVxuICBib29sKGF0dHJOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXNbYXR0ck5hbWVdID09PSAnWUVTJztcbiAgfVxuICBkZWNpbWFsUmVzb2x1dGlvbihhdHRyTmFtZSkge1xuICAgIGNvbnN0IHJlcyA9IERFQ0lNQUxfUkVTT0xVVElPTl9SRUdFWC5leGVjKHRoaXNbYXR0ck5hbWVdKTtcbiAgICBpZiAocmVzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHBhcnNlSW50KHJlc1sxXSwgMTApLFxuICAgICAgaGVpZ2h0OiBwYXJzZUludChyZXNbMl0sIDEwKVxuICAgIH07XG4gIH1cbiAgc3RhdGljIHBhcnNlQXR0ckxpc3QoaW5wdXQpIHtcbiAgICBsZXQgbWF0Y2g7XG4gICAgY29uc3QgYXR0cnMgPSB7fTtcbiAgICBjb25zdCBxdW90ZSA9ICdcIic7XG4gICAgQVRUUl9MSVNUX1JFR0VYLmxhc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKChtYXRjaCA9IEFUVFJfTElTVF9SRUdFWC5leGVjKGlucHV0KSkgIT09IG51bGwpIHtcbiAgICAgIGxldCB2YWx1ZSA9IG1hdGNoWzJdO1xuICAgICAgaWYgKHZhbHVlLmluZGV4T2YocXVvdGUpID09PSAwICYmIHZhbHVlLmxhc3RJbmRleE9mKHF1b3RlKSA9PT0gdmFsdWUubGVuZ3RoIC0gMSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEsIC0xKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5hbWUgPSBtYXRjaFsxXS50cmltKCk7XG4gICAgICBhdHRyc1tuYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gYXR0cnM7XG4gIH1cbn1cblxuLy8gQXZvaWQgZXhwb3J0aW5nIGNvbnN0IGVudW0gc28gdGhhdCB0aGVzZSB2YWx1ZXMgY2FuIGJlIGlubGluZWRcblxuZnVuY3Rpb24gaXNEYXRlUmFuZ2VDdWVBdHRyaWJ1dGUoYXR0ck5hbWUpIHtcbiAgcmV0dXJuIGF0dHJOYW1lICE9PSBcIklEXCIgJiYgYXR0ck5hbWUgIT09IFwiQ0xBU1NcIiAmJiBhdHRyTmFtZSAhPT0gXCJTVEFSVC1EQVRFXCIgJiYgYXR0ck5hbWUgIT09IFwiRFVSQVRJT05cIiAmJiBhdHRyTmFtZSAhPT0gXCJFTkQtREFURVwiICYmIGF0dHJOYW1lICE9PSBcIkVORC1PTi1ORVhUXCI7XG59XG5mdW5jdGlvbiBpc1NDVEUzNUF0dHJpYnV0ZShhdHRyTmFtZSkge1xuICByZXR1cm4gYXR0ck5hbWUgPT09IFwiU0NURTM1LU9VVFwiIHx8IGF0dHJOYW1lID09PSBcIlNDVEUzNS1JTlwiO1xufVxuY2xhc3MgRGF0ZVJhbmdlIHtcbiAgY29uc3RydWN0b3IoZGF0ZVJhbmdlQXR0ciwgZGF0ZVJhbmdlV2l0aFNhbWVJZCkge1xuICAgIHRoaXMuYXR0ciA9IHZvaWQgMDtcbiAgICB0aGlzLl9zdGFydERhdGUgPSB2b2lkIDA7XG4gICAgdGhpcy5fZW5kRGF0ZSA9IHZvaWQgMDtcbiAgICB0aGlzLl9iYWRWYWx1ZUZvclNhbWVJZCA9IHZvaWQgMDtcbiAgICBpZiAoZGF0ZVJhbmdlV2l0aFNhbWVJZCkge1xuICAgICAgY29uc3QgcHJldmlvdXNBdHRyID0gZGF0ZVJhbmdlV2l0aFNhbWVJZC5hdHRyO1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJldmlvdXNBdHRyKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGF0ZVJhbmdlQXR0ciwga2V5KSAmJiBkYXRlUmFuZ2VBdHRyW2tleV0gIT09IHByZXZpb3VzQXR0cltrZXldKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYERBVEVSQU5HRSB0YWcgYXR0cmlidXRlOiBcIiR7a2V5fVwiIGRvZXMgbm90IG1hdGNoIGZvciB0YWdzIHdpdGggSUQ6IFwiJHtkYXRlUmFuZ2VBdHRyLklEfVwiYCk7XG4gICAgICAgICAgdGhpcy5fYmFkVmFsdWVGb3JTYW1lSWQgPSBrZXk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIE1lcmdlIERhdGVSYW5nZSB0YWdzIHdpdGggdGhlIHNhbWUgSURcbiAgICAgIGRhdGVSYW5nZUF0dHIgPSBfZXh0ZW5kcyhuZXcgQXR0ckxpc3Qoe30pLCBwcmV2aW91c0F0dHIsIGRhdGVSYW5nZUF0dHIpO1xuICAgIH1cbiAgICB0aGlzLmF0dHIgPSBkYXRlUmFuZ2VBdHRyO1xuICAgIHRoaXMuX3N0YXJ0RGF0ZSA9IG5ldyBEYXRlKGRhdGVSYW5nZUF0dHJbXCJTVEFSVC1EQVRFXCJdKTtcbiAgICBpZiAoXCJFTkQtREFURVwiIGluIHRoaXMuYXR0cikge1xuICAgICAgY29uc3QgZW5kRGF0ZSA9IG5ldyBEYXRlKHRoaXMuYXR0cltcIkVORC1EQVRFXCJdKTtcbiAgICAgIGlmIChpc0Zpbml0ZU51bWJlcihlbmREYXRlLmdldFRpbWUoKSkpIHtcbiAgICAgICAgdGhpcy5fZW5kRGF0ZSA9IGVuZERhdGU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyLklEO1xuICB9XG4gIGdldCBjbGFzcygpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyLkNMQVNTO1xuICB9XG4gIGdldCBzdGFydERhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0RGF0ZTtcbiAgfVxuICBnZXQgZW5kRGF0ZSgpIHtcbiAgICBpZiAodGhpcy5fZW5kRGF0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VuZERhdGU7XG4gICAgfVxuICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5kdXJhdGlvbjtcbiAgICBpZiAoZHVyYXRpb24gIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLl9zdGFydERhdGUuZ2V0VGltZSgpICsgZHVyYXRpb24gKiAxMDAwKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2V0IGR1cmF0aW9uKCkge1xuICAgIGlmIChcIkRVUkFUSU9OXCIgaW4gdGhpcy5hdHRyKSB7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IHRoaXMuYXR0ci5kZWNpbWFsRmxvYXRpbmdQb2ludChcIkRVUkFUSU9OXCIpO1xuICAgICAgaWYgKGlzRmluaXRlTnVtYmVyKGR1cmF0aW9uKSkge1xuICAgICAgICByZXR1cm4gZHVyYXRpb247XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9lbmREYXRlKSB7XG4gICAgICByZXR1cm4gKHRoaXMuX2VuZERhdGUuZ2V0VGltZSgpIC0gdGhpcy5fc3RhcnREYXRlLmdldFRpbWUoKSkgLyAxMDAwO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnZXQgcGxhbm5lZER1cmF0aW9uKCkge1xuICAgIGlmIChcIlBMQU5ORUQtRFVSQVRJT05cIiBpbiB0aGlzLmF0dHIpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHIuZGVjaW1hbEZsb2F0aW5nUG9pbnQoXCJQTEFOTkVELURVUkFUSU9OXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnZXQgZW5kT25OZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmF0dHIuYm9vbChcIkVORC1PTi1ORVhUXCIpO1xuICB9XG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiAhIXRoaXMuaWQgJiYgIXRoaXMuX2JhZFZhbHVlRm9yU2FtZUlkICYmIGlzRmluaXRlTnVtYmVyKHRoaXMuc3RhcnREYXRlLmdldFRpbWUoKSkgJiYgKHRoaXMuZHVyYXRpb24gPT09IG51bGwgfHwgdGhpcy5kdXJhdGlvbiA+PSAwKSAmJiAoIXRoaXMuZW5kT25OZXh0IHx8ICEhdGhpcy5jbGFzcyk7XG4gIH1cbn1cblxuY2xhc3MgTG9hZFN0YXRzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5hYm9ydGVkID0gZmFsc2U7XG4gICAgdGhpcy5sb2FkZWQgPSAwO1xuICAgIHRoaXMucmV0cnkgPSAwO1xuICAgIHRoaXMudG90YWwgPSAwO1xuICAgIHRoaXMuY2h1bmtDb3VudCA9IDA7XG4gICAgdGhpcy5id0VzdGltYXRlID0gMDtcbiAgICB0aGlzLmxvYWRpbmcgPSB7XG4gICAgICBzdGFydDogMCxcbiAgICAgIGZpcnN0OiAwLFxuICAgICAgZW5kOiAwXG4gICAgfTtcbiAgICB0aGlzLnBhcnNpbmcgPSB7XG4gICAgICBzdGFydDogMCxcbiAgICAgIGVuZDogMFxuICAgIH07XG4gICAgdGhpcy5idWZmZXJpbmcgPSB7XG4gICAgICBzdGFydDogMCxcbiAgICAgIGZpcnN0OiAwLFxuICAgICAgZW5kOiAwXG4gICAgfTtcbiAgfVxufVxuXG52YXIgRWxlbWVudGFyeVN0cmVhbVR5cGVzID0ge1xuICBBVURJTzogXCJhdWRpb1wiLFxuICBWSURFTzogXCJ2aWRlb1wiLFxuICBBVURJT1ZJREVPOiBcImF1ZGlvdmlkZW9cIlxufTtcbmNsYXNzIEJhc2VTZWdtZW50IHtcbiAgY29uc3RydWN0b3IoYmFzZXVybCkge1xuICAgIHRoaXMuX2J5dGVSYW5nZSA9IG51bGw7XG4gICAgdGhpcy5fdXJsID0gbnVsbDtcbiAgICAvLyBiYXNldXJsIGlzIHRoZSBVUkwgdG8gdGhlIHBsYXlsaXN0XG4gICAgdGhpcy5iYXNldXJsID0gdm9pZCAwO1xuICAgIC8vIHJlbHVybCBpcyB0aGUgcG9ydGlvbiBvZiB0aGUgVVJMIHRoYXQgY29tZXMgZnJvbSBpbnNpZGUgdGhlIHBsYXlsaXN0LlxuICAgIHRoaXMucmVsdXJsID0gdm9pZCAwO1xuICAgIC8vIEhvbGRzIHRoZSB0eXBlcyBvZiBkYXRhIHRoaXMgZnJhZ21lbnQgc3VwcG9ydHNcbiAgICB0aGlzLmVsZW1lbnRhcnlTdHJlYW1zID0ge1xuICAgICAgW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJT106IG51bGwsXG4gICAgICBbRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPXTogbnVsbCxcbiAgICAgIFtFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU9WSURFT106IG51bGxcbiAgICB9O1xuICAgIHRoaXMuYmFzZXVybCA9IGJhc2V1cmw7XG4gIH1cblxuICAvLyBzZXRCeXRlUmFuZ2UgY29udmVydHMgYSBFWFQtWC1CWVRFUkFOR0UgYXR0cmlidXRlIGludG8gYSB0d28gZWxlbWVudCBhcnJheVxuICBzZXRCeXRlUmFuZ2UodmFsdWUsIHByZXZpb3VzKSB7XG4gICAgY29uc3QgcGFyYW1zID0gdmFsdWUuc3BsaXQoJ0AnLCAyKTtcbiAgICBsZXQgc3RhcnQ7XG4gICAgaWYgKHBhcmFtcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHN0YXJ0ID0gKHByZXZpb3VzID09IG51bGwgPyB2b2lkIDAgOiBwcmV2aW91cy5ieXRlUmFuZ2VFbmRPZmZzZXQpIHx8IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0ID0gcGFyc2VJbnQocGFyYW1zWzFdKTtcbiAgICB9XG4gICAgdGhpcy5fYnl0ZVJhbmdlID0gW3N0YXJ0LCBwYXJzZUludChwYXJhbXNbMF0pICsgc3RhcnRdO1xuICB9XG4gIGdldCBieXRlUmFuZ2UoKSB7XG4gICAgaWYgKCF0aGlzLl9ieXRlUmFuZ2UpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2J5dGVSYW5nZTtcbiAgfVxuICBnZXQgYnl0ZVJhbmdlU3RhcnRPZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnl0ZVJhbmdlWzBdO1xuICB9XG4gIGdldCBieXRlUmFuZ2VFbmRPZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnl0ZVJhbmdlWzFdO1xuICB9XG4gIGdldCB1cmwoKSB7XG4gICAgaWYgKCF0aGlzLl91cmwgJiYgdGhpcy5iYXNldXJsICYmIHRoaXMucmVsdXJsKSB7XG4gICAgICB0aGlzLl91cmwgPSB1cmxUb29sa2l0RXhwb3J0cy5idWlsZEFic29sdXRlVVJMKHRoaXMuYmFzZXVybCwgdGhpcy5yZWx1cmwsIHtcbiAgICAgICAgYWx3YXlzTm9ybWFsaXplOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3VybCB8fCAnJztcbiAgfVxuICBzZXQgdXJsKHZhbHVlKSB7XG4gICAgdGhpcy5fdXJsID0gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBPYmplY3QgcmVwcmVzZW50aW5nIHBhcnNlZCBkYXRhIGZyb20gYW4gSExTIFNlZ21lbnQuIEZvdW5kIGluIHtAbGluayBobHMuanMjTGV2ZWxEZXRhaWxzLmZyYWdtZW50c30uXG4gKi9cbmNsYXNzIEZyYWdtZW50IGV4dGVuZHMgQmFzZVNlZ21lbnQge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBiYXNldXJsKSB7XG4gICAgc3VwZXIoYmFzZXVybCk7XG4gICAgdGhpcy5fZGVjcnlwdGRhdGEgPSBudWxsO1xuICAgIHRoaXMucmF3UHJvZ3JhbURhdGVUaW1lID0gbnVsbDtcbiAgICB0aGlzLnByb2dyYW1EYXRlVGltZSA9IG51bGw7XG4gICAgdGhpcy50YWdMaXN0ID0gW107XG4gICAgLy8gRVhUSU5GIGhhcyB0byBiZSBwcmVzZW50IGZvciBhIG0zdTggdG8gYmUgY29uc2lkZXJlZCB2YWxpZFxuICAgIHRoaXMuZHVyYXRpb24gPSAwO1xuICAgIC8vIHNuIG5vdGF0ZXMgdGhlIHNlcXVlbmNlIG51bWJlciBmb3IgYSBzZWdtZW50LCBhbmQgaWYgc2V0IHRvIGEgc3RyaW5nIGNhbiBiZSAnaW5pdFNlZ21lbnQnXG4gICAgdGhpcy5zbiA9IDA7XG4gICAgLy8gbGV2ZWxrZXlzIGFyZSB0aGUgRVhULVgtS0VZIHRhZ3MgdGhhdCBhcHBseSB0byB0aGlzIHNlZ21lbnQgZm9yIGRlY3J5cHRpb25cbiAgICAvLyBjb3JlIGRpZmZlcmVuY2UgZnJvbSB0aGUgcHJpdmF0ZSBmaWVsZCBfZGVjcnlwdGRhdGEgaXMgdGhlIGxhY2sgb2YgdGhlIGluaXRpYWxpemVkIElWXG4gICAgLy8gX2RlY3J5cHRkYXRhIHdpbGwgc2V0IHRoZSBJViBmb3IgdGhpcyBzZWdtZW50IGJhc2VkIG9uIHRoZSBzZWdtZW50IG51bWJlciBpbiB0aGUgZnJhZ21lbnRcbiAgICB0aGlzLmxldmVsa2V5cyA9IHZvaWQgMDtcbiAgICAvLyBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGZyYWdtZW50IHR5cGVcbiAgICB0aGlzLnR5cGUgPSB2b2lkIDA7XG4gICAgLy8gQSByZWZlcmVuY2UgdG8gdGhlIGxvYWRlci4gU2V0IHdoaWxlIHRoZSBmcmFnbWVudCBpcyBsb2FkaW5nLCBhbmQgcmVtb3ZlZCBhZnRlcndhcmRzLiBVc2VkIHRvIGFib3J0IGZyYWdtZW50IGxvYWRpbmdcbiAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgLy8gQSByZWZlcmVuY2UgdG8gdGhlIGtleSBsb2FkZXIuIFNldCB3aGlsZSB0aGUga2V5IGlzIGxvYWRpbmcsIGFuZCByZW1vdmVkIGFmdGVyd2FyZHMuIFVzZWQgdG8gYWJvcnQga2V5IGxvYWRpbmdcbiAgICB0aGlzLmtleUxvYWRlciA9IG51bGw7XG4gICAgLy8gVGhlIGxldmVsL3RyYWNrIGluZGV4IHRvIHdoaWNoIHRoZSBmcmFnbWVudCBiZWxvbmdzXG4gICAgdGhpcy5sZXZlbCA9IC0xO1xuICAgIC8vIFRoZSBjb250aW51aXR5IGNvdW50ZXIgb2YgdGhlIGZyYWdtZW50XG4gICAgdGhpcy5jYyA9IDA7XG4gICAgLy8gVGhlIHN0YXJ0aW5nIFByZXNlbnRhdGlvbiBUaW1lIFN0YW1wIChQVFMpIG9mIHRoZSBmcmFnbWVudC4gU2V0IGFmdGVyIHRyYW5zbXV4IGNvbXBsZXRlLlxuICAgIHRoaXMuc3RhcnRQVFMgPSB2b2lkIDA7XG4gICAgLy8gVGhlIGVuZGluZyBQcmVzZW50YXRpb24gVGltZSBTdGFtcCAoUFRTKSBvZiB0aGUgZnJhZ21lbnQuIFNldCBhZnRlciB0cmFuc211eCBjb21wbGV0ZS5cbiAgICB0aGlzLmVuZFBUUyA9IHZvaWQgMDtcbiAgICAvLyBUaGUgc3RhcnRpbmcgRGVjb2RlIFRpbWUgU3RhbXAgKERUUykgb2YgdGhlIGZyYWdtZW50LiBTZXQgYWZ0ZXIgdHJhbnNtdXggY29tcGxldGUuXG4gICAgdGhpcy5zdGFydERUUyA9IHZvaWQgMDtcbiAgICAvLyBUaGUgZW5kaW5nIERlY29kZSBUaW1lIFN0YW1wIChEVFMpIG9mIHRoZSBmcmFnbWVudC4gU2V0IGFmdGVyIHRyYW5zbXV4IGNvbXBsZXRlLlxuICAgIHRoaXMuZW5kRFRTID0gdm9pZCAwO1xuICAgIC8vIFRoZSBzdGFydCB0aW1lIG9mIHRoZSBmcmFnbWVudCwgYXMgbGlzdGVkIGluIHRoZSBtYW5pZmVzdC4gVXBkYXRlZCBhZnRlciB0cmFuc211eCBjb21wbGV0ZS5cbiAgICB0aGlzLnN0YXJ0ID0gMDtcbiAgICAvLyBTZXQgYnkgYHVwZGF0ZUZyYWdQVFNEVFNgIGluIGxldmVsLWhlbHBlclxuICAgIHRoaXMuZGVsdGFQVFMgPSB2b2lkIDA7XG4gICAgLy8gVGhlIG1heGltdW0gc3RhcnRpbmcgUHJlc2VudGF0aW9uIFRpbWUgU3RhbXAgKGF1ZGlvL3ZpZGVvIFBUUykgb2YgdGhlIGZyYWdtZW50LiBTZXQgYWZ0ZXIgdHJhbnNtdXggY29tcGxldGUuXG4gICAgdGhpcy5tYXhTdGFydFBUUyA9IHZvaWQgMDtcbiAgICAvLyBUaGUgbWluaW11bSBlbmRpbmcgUHJlc2VudGF0aW9uIFRpbWUgU3RhbXAgKGF1ZGlvL3ZpZGVvIFBUUykgb2YgdGhlIGZyYWdtZW50LiBTZXQgYWZ0ZXIgdHJhbnNtdXggY29tcGxldGUuXG4gICAgdGhpcy5taW5FbmRQVFMgPSB2b2lkIDA7XG4gICAgLy8gTG9hZC9wYXJzZSB0aW1pbmcgaW5mb3JtYXRpb25cbiAgICB0aGlzLnN0YXRzID0gbmV3IExvYWRTdGF0cygpO1xuICAgIC8vIEluaXQgU2VnbWVudCBieXRlcyAodW5zZXQgZm9yIG1lZGlhIHNlZ21lbnRzKVxuICAgIHRoaXMuZGF0YSA9IHZvaWQgMDtcbiAgICAvLyBBIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBzZWdtZW50IHdhcyBkb3dubG9hZGVkIGluIG9yZGVyIHRvIHRlc3QgYml0cmF0ZSwgYW5kIHdhcyBub3QgYnVmZmVyZWRcbiAgICB0aGlzLmJpdHJhdGVUZXN0ID0gZmFsc2U7XG4gICAgLy8gI0VYVElORiAgc2VnbWVudCB0aXRsZVxuICAgIHRoaXMudGl0bGUgPSBudWxsO1xuICAgIC8vIFRoZSBNZWRpYSBJbml0aWFsaXphdGlvbiBTZWN0aW9uIGZvciB0aGlzIHNlZ21lbnRcbiAgICB0aGlzLmluaXRTZWdtZW50ID0gbnVsbDtcbiAgICAvLyBGcmFnbWVudCBpcyB0aGUgbGFzdCBmcmFnbWVudCBpbiB0aGUgbWVkaWEgcGxheWxpc3RcbiAgICB0aGlzLmVuZExpc3QgPSB2b2lkIDA7XG4gICAgLy8gRnJhZ21lbnQgaXMgbWFya2VkIGJ5IGFuIEVYVC1YLUdBUCB0YWcgaW5kaWNhdGluZyB0aGF0IGl0IGRvZXMgbm90IGNvbnRhaW4gbWVkaWEgZGF0YSBhbmQgc2hvdWxkIG5vdCBiZSBsb2FkZWRcbiAgICB0aGlzLmdhcCA9IHZvaWQgMDtcbiAgICAvLyBEZXByZWNhdGVkXG4gICAgdGhpcy51cmxJZCA9IDA7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgfVxuICBnZXQgZGVjcnlwdGRhdGEoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWxrZXlzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFsZXZlbGtleXMgJiYgIXRoaXMuX2RlY3J5cHRkYXRhKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9kZWNyeXB0ZGF0YSAmJiB0aGlzLmxldmVsa2V5cyAmJiAhdGhpcy5sZXZlbGtleXMuTk9ORSkge1xuICAgICAgY29uc3Qga2V5ID0gdGhpcy5sZXZlbGtleXMuaWRlbnRpdHk7XG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHRoaXMuX2RlY3J5cHRkYXRhID0ga2V5LmdldERlY3J5cHREYXRhKHRoaXMuc24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qga2V5Rm9ybWF0cyA9IE9iamVjdC5rZXlzKHRoaXMubGV2ZWxrZXlzKTtcbiAgICAgICAgaWYgKGtleUZvcm1hdHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2RlY3J5cHRkYXRhID0gdGhpcy5sZXZlbGtleXNba2V5Rm9ybWF0c1swXV0uZ2V0RGVjcnlwdERhdGEodGhpcy5zbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2RlY3J5cHRkYXRhO1xuICB9XG4gIGdldCBlbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhcnQgKyB0aGlzLmR1cmF0aW9uO1xuICB9XG4gIGdldCBlbmRQcm9ncmFtRGF0ZVRpbWUoKSB7XG4gICAgaWYgKHRoaXMucHJvZ3JhbURhdGVUaW1lID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFpc0Zpbml0ZU51bWJlcih0aGlzLnByb2dyYW1EYXRlVGltZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBkdXJhdGlvbiA9ICFpc0Zpbml0ZU51bWJlcih0aGlzLmR1cmF0aW9uKSA/IDAgOiB0aGlzLmR1cmF0aW9uO1xuICAgIHJldHVybiB0aGlzLnByb2dyYW1EYXRlVGltZSArIGR1cmF0aW9uICogMTAwMDtcbiAgfVxuICBnZXQgZW5jcnlwdGVkKCkge1xuICAgIHZhciBfdGhpcyRfZGVjcnlwdGRhdGE7XG4gICAgLy8gQXQgdGhlIG0zdTgtcGFyc2VyIGxldmVsIHdlIG5lZWQgdG8gYWRkIHN1cHBvcnQgZm9yIG1hbmlmZXN0IHNpZ25hbGxlZCBrZXlmb3JtYXRzXG4gICAgLy8gd2hlbiB3ZSB3YW50IHRoZSBmcmFnbWVudCB0byBzdGFydCByZXBvcnRpbmcgdGhhdCBpdCBpcyBlbmNyeXB0ZWQuXG4gICAgLy8gQ3VycmVudGx5LCBrZXlGb3JtYXQgd2lsbCBvbmx5IGJlIHNldCBmb3IgaWRlbnRpdHkga2V5c1xuICAgIGlmICgoX3RoaXMkX2RlY3J5cHRkYXRhID0gdGhpcy5fZGVjcnlwdGRhdGEpICE9IG51bGwgJiYgX3RoaXMkX2RlY3J5cHRkYXRhLmVuY3J5cHRlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxldmVsa2V5cykge1xuICAgICAgY29uc3Qga2V5Rm9ybWF0cyA9IE9iamVjdC5rZXlzKHRoaXMubGV2ZWxrZXlzKTtcbiAgICAgIGNvbnN0IGxlbiA9IGtleUZvcm1hdHMubGVuZ3RoO1xuICAgICAgaWYgKGxlbiA+IDEgfHwgbGVuID09PSAxICYmIHRoaXMubGV2ZWxrZXlzW2tleUZvcm1hdHNbMF1dLmVuY3J5cHRlZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHNldEtleUZvcm1hdChrZXlGb3JtYXQpIHtcbiAgICBpZiAodGhpcy5sZXZlbGtleXMpIHtcbiAgICAgIGNvbnN0IGtleSA9IHRoaXMubGV2ZWxrZXlzW2tleUZvcm1hdF07XG4gICAgICBpZiAoa2V5ICYmICF0aGlzLl9kZWNyeXB0ZGF0YSkge1xuICAgICAgICB0aGlzLl9kZWNyeXB0ZGF0YSA9IGtleS5nZXREZWNyeXB0RGF0YSh0aGlzLnNuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYWJvcnRSZXF1ZXN0cygpIHtcbiAgICB2YXIgX3RoaXMkbG9hZGVyLCBfdGhpcyRrZXlMb2FkZXI7XG4gICAgKF90aGlzJGxvYWRlciA9IHRoaXMubG9hZGVyKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbG9hZGVyLmFib3J0KCk7XG4gICAgKF90aGlzJGtleUxvYWRlciA9IHRoaXMua2V5TG9hZGVyKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMka2V5TG9hZGVyLmFib3J0KCk7XG4gIH1cbiAgc2V0RWxlbWVudGFyeVN0cmVhbUluZm8odHlwZSwgc3RhcnRQVFMsIGVuZFBUUywgc3RhcnREVFMsIGVuZERUUywgcGFydGlhbCA9IGZhbHNlKSB7XG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudGFyeVN0cmVhbXNcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBpbmZvID0gZWxlbWVudGFyeVN0cmVhbXNbdHlwZV07XG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICBlbGVtZW50YXJ5U3RyZWFtc1t0eXBlXSA9IHtcbiAgICAgICAgc3RhcnRQVFMsXG4gICAgICAgIGVuZFBUUyxcbiAgICAgICAgc3RhcnREVFMsXG4gICAgICAgIGVuZERUUyxcbiAgICAgICAgcGFydGlhbFxuICAgICAgfTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW5mby5zdGFydFBUUyA9IE1hdGgubWluKGluZm8uc3RhcnRQVFMsIHN0YXJ0UFRTKTtcbiAgICBpbmZvLmVuZFBUUyA9IE1hdGgubWF4KGluZm8uZW5kUFRTLCBlbmRQVFMpO1xuICAgIGluZm8uc3RhcnREVFMgPSBNYXRoLm1pbihpbmZvLnN0YXJ0RFRTLCBzdGFydERUUyk7XG4gICAgaW5mby5lbmREVFMgPSBNYXRoLm1heChpbmZvLmVuZERUUywgZW5kRFRTKTtcbiAgfVxuICBjbGVhckVsZW1lbnRhcnlTdHJlYW1JbmZvKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW1lbnRhcnlTdHJlYW1zXG4gICAgfSA9IHRoaXM7XG4gICAgZWxlbWVudGFyeVN0cmVhbXNbRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPXSA9IG51bGw7XG4gICAgZWxlbWVudGFyeVN0cmVhbXNbRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPXSA9IG51bGw7XG4gICAgZWxlbWVudGFyeVN0cmVhbXNbRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPVklERU9dID0gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIE9iamVjdCByZXByZXNlbnRpbmcgcGFyc2VkIGRhdGEgZnJvbSBhbiBITFMgUGFydGlhbCBTZWdtZW50LiBGb3VuZCBpbiB7QGxpbmsgaGxzLmpzI0xldmVsRGV0YWlscy5wYXJ0TGlzdH0uXG4gKi9cbmNsYXNzIFBhcnQgZXh0ZW5kcyBCYXNlU2VnbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcnRBdHRycywgZnJhZywgYmFzZXVybCwgaW5kZXgsIHByZXZpb3VzKSB7XG4gICAgc3VwZXIoYmFzZXVybCk7XG4gICAgdGhpcy5mcmFnT2Zmc2V0ID0gMDtcbiAgICB0aGlzLmR1cmF0aW9uID0gMDtcbiAgICB0aGlzLmdhcCA9IGZhbHNlO1xuICAgIHRoaXMuaW5kZXBlbmRlbnQgPSBmYWxzZTtcbiAgICB0aGlzLnJlbHVybCA9IHZvaWQgMDtcbiAgICB0aGlzLmZyYWdtZW50ID0gdm9pZCAwO1xuICAgIHRoaXMuaW5kZXggPSB2b2lkIDA7XG4gICAgdGhpcy5zdGF0cyA9IG5ldyBMb2FkU3RhdHMoKTtcbiAgICB0aGlzLmR1cmF0aW9uID0gcGFydEF0dHJzLmRlY2ltYWxGbG9hdGluZ1BvaW50KCdEVVJBVElPTicpO1xuICAgIHRoaXMuZ2FwID0gcGFydEF0dHJzLmJvb2woJ0dBUCcpO1xuICAgIHRoaXMuaW5kZXBlbmRlbnQgPSBwYXJ0QXR0cnMuYm9vbCgnSU5ERVBFTkRFTlQnKTtcbiAgICB0aGlzLnJlbHVybCA9IHBhcnRBdHRycy5lbnVtZXJhdGVkU3RyaW5nKCdVUkknKTtcbiAgICB0aGlzLmZyYWdtZW50ID0gZnJhZztcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgY29uc3QgYnl0ZVJhbmdlID0gcGFydEF0dHJzLmVudW1lcmF0ZWRTdHJpbmcoJ0JZVEVSQU5HRScpO1xuICAgIGlmIChieXRlUmFuZ2UpIHtcbiAgICAgIHRoaXMuc2V0Qnl0ZVJhbmdlKGJ5dGVSYW5nZSwgcHJldmlvdXMpO1xuICAgIH1cbiAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgIHRoaXMuZnJhZ09mZnNldCA9IHByZXZpb3VzLmZyYWdPZmZzZXQgKyBwcmV2aW91cy5kdXJhdGlvbjtcbiAgICB9XG4gIH1cbiAgZ2V0IHN0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLmZyYWdtZW50LnN0YXJ0ICsgdGhpcy5mcmFnT2Zmc2V0O1xuICB9XG4gIGdldCBlbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhcnQgKyB0aGlzLmR1cmF0aW9uO1xuICB9XG4gIGdldCBsb2FkZWQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudGFyeVN0cmVhbXNcbiAgICB9ID0gdGhpcztcbiAgICByZXR1cm4gISEoZWxlbWVudGFyeVN0cmVhbXMuYXVkaW8gfHwgZWxlbWVudGFyeVN0cmVhbXMudmlkZW8gfHwgZWxlbWVudGFyeVN0cmVhbXMuYXVkaW92aWRlbyk7XG4gIH1cbn1cblxuY29uc3QgREVGQVVMVF9UQVJHRVRfRFVSQVRJT04gPSAxMDtcblxuLyoqXG4gKiBPYmplY3QgcmVwcmVzZW50aW5nIHBhcnNlZCBkYXRhIGZyb20gYW4gSExTIE1lZGlhIFBsYXlsaXN0LiBGb3VuZCBpbiB7QGxpbmsgaGxzLmpzI0xldmVsLmRldGFpbHN9LlxuICovXG5jbGFzcyBMZXZlbERldGFpbHMge1xuICBjb25zdHJ1Y3RvcihiYXNlVXJsKSB7XG4gICAgdGhpcy5QVFNLbm93biA9IGZhbHNlO1xuICAgIHRoaXMuYWxpZ25lZFNsaWRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbiA9IHZvaWQgMDtcbiAgICB0aGlzLmVuZENDID0gMDtcbiAgICB0aGlzLmVuZFNOID0gMDtcbiAgICB0aGlzLmZyYWdtZW50cyA9IHZvaWQgMDtcbiAgICB0aGlzLmZyYWdtZW50SGludCA9IHZvaWQgMDtcbiAgICB0aGlzLnBhcnRMaXN0ID0gbnVsbDtcbiAgICB0aGlzLmRhdGVSYW5nZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5saXZlID0gdHJ1ZTtcbiAgICB0aGlzLmFnZUhlYWRlciA9IDA7XG4gICAgdGhpcy5hZHZhbmNlZERhdGVUaW1lID0gdm9pZCAwO1xuICAgIHRoaXMudXBkYXRlZCA9IHRydWU7XG4gICAgdGhpcy5hZHZhbmNlZCA9IHRydWU7XG4gICAgdGhpcy5hdmFpbGFiaWxpdHlEZWxheSA9IHZvaWQgMDtcbiAgICAvLyBNYW5pZmVzdCByZWxvYWQgc3luY2hyb25pemF0aW9uXG4gICAgdGhpcy5taXNzZXMgPSAwO1xuICAgIHRoaXMuc3RhcnRDQyA9IDA7XG4gICAgdGhpcy5zdGFydFNOID0gMDtcbiAgICB0aGlzLnN0YXJ0VGltZU9mZnNldCA9IG51bGw7XG4gICAgdGhpcy50YXJnZXRkdXJhdGlvbiA9IDA7XG4gICAgdGhpcy50b3RhbGR1cmF0aW9uID0gMDtcbiAgICB0aGlzLnR5cGUgPSBudWxsO1xuICAgIHRoaXMudXJsID0gdm9pZCAwO1xuICAgIHRoaXMubTN1OCA9ICcnO1xuICAgIHRoaXMudmVyc2lvbiA9IG51bGw7XG4gICAgdGhpcy5jYW5CbG9ja1JlbG9hZCA9IGZhbHNlO1xuICAgIHRoaXMuY2FuU2tpcFVudGlsID0gMDtcbiAgICB0aGlzLmNhblNraXBEYXRlUmFuZ2VzID0gZmFsc2U7XG4gICAgdGhpcy5za2lwcGVkU2VnbWVudHMgPSAwO1xuICAgIHRoaXMucmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcyA9IHZvaWQgMDtcbiAgICB0aGlzLnBhcnRIb2xkQmFjayA9IDA7XG4gICAgdGhpcy5ob2xkQmFjayA9IDA7XG4gICAgdGhpcy5wYXJ0VGFyZ2V0ID0gMDtcbiAgICB0aGlzLnByZWxvYWRIaW50ID0gdm9pZCAwO1xuICAgIHRoaXMucmVuZGl0aW9uUmVwb3J0cyA9IHZvaWQgMDtcbiAgICB0aGlzLnR1bmVJbkdvYWwgPSAwO1xuICAgIHRoaXMuZGVsdGFVcGRhdGVGYWlsZWQgPSB2b2lkIDA7XG4gICAgdGhpcy5kcmlmdFN0YXJ0VGltZSA9IDA7XG4gICAgdGhpcy5kcmlmdEVuZFRpbWUgPSAwO1xuICAgIHRoaXMuZHJpZnRTdGFydCA9IDA7XG4gICAgdGhpcy5kcmlmdEVuZCA9IDA7XG4gICAgdGhpcy5lbmNyeXB0ZWRGcmFnbWVudHMgPSB2b2lkIDA7XG4gICAgdGhpcy5wbGF5bGlzdFBhcnNpbmdFcnJvciA9IG51bGw7XG4gICAgdGhpcy52YXJpYWJsZUxpc3QgPSBudWxsO1xuICAgIHRoaXMuaGFzVmFyaWFibGVSZWZzID0gZmFsc2U7XG4gICAgdGhpcy5mcmFnbWVudHMgPSBbXTtcbiAgICB0aGlzLmVuY3J5cHRlZEZyYWdtZW50cyA9IFtdO1xuICAgIHRoaXMuZGF0ZVJhbmdlcyA9IHt9O1xuICAgIHRoaXMudXJsID0gYmFzZVVybDtcbiAgfVxuICByZWxvYWRlZChwcmV2aW91cykge1xuICAgIGlmICghcHJldmlvdXMpIHtcbiAgICAgIHRoaXMuYWR2YW5jZWQgPSB0cnVlO1xuICAgICAgdGhpcy51cGRhdGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGFydFNuRGlmZiA9IHRoaXMubGFzdFBhcnRTbiAtIHByZXZpb3VzLmxhc3RQYXJ0U247XG4gICAgY29uc3QgcGFydEluZGV4RGlmZiA9IHRoaXMubGFzdFBhcnRJbmRleCAtIHByZXZpb3VzLmxhc3RQYXJ0SW5kZXg7XG4gICAgdGhpcy51cGRhdGVkID0gdGhpcy5lbmRTTiAhPT0gcHJldmlvdXMuZW5kU04gfHwgISFwYXJ0SW5kZXhEaWZmIHx8ICEhcGFydFNuRGlmZiB8fCAhdGhpcy5saXZlO1xuICAgIHRoaXMuYWR2YW5jZWQgPSB0aGlzLmVuZFNOID4gcHJldmlvdXMuZW5kU04gfHwgcGFydFNuRGlmZiA+IDAgfHwgcGFydFNuRGlmZiA9PT0gMCAmJiBwYXJ0SW5kZXhEaWZmID4gMDtcbiAgICBpZiAodGhpcy51cGRhdGVkIHx8IHRoaXMuYWR2YW5jZWQpIHtcbiAgICAgIHRoaXMubWlzc2VzID0gTWF0aC5mbG9vcihwcmV2aW91cy5taXNzZXMgKiAwLjYpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1pc3NlcyA9IHByZXZpb3VzLm1pc3NlcyArIDE7XG4gICAgfVxuICAgIHRoaXMuYXZhaWxhYmlsaXR5RGVsYXkgPSBwcmV2aW91cy5hdmFpbGFiaWxpdHlEZWxheTtcbiAgfVxuICBnZXQgaGFzUHJvZ3JhbURhdGVUaW1lKCkge1xuICAgIGlmICh0aGlzLmZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBpc0Zpbml0ZU51bWJlcih0aGlzLmZyYWdtZW50c1t0aGlzLmZyYWdtZW50cy5sZW5ndGggLSAxXS5wcm9ncmFtRGF0ZVRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZ2V0IGxldmVsVGFyZ2V0RHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYXZlcmFnZXRhcmdldGR1cmF0aW9uIHx8IHRoaXMudGFyZ2V0ZHVyYXRpb24gfHwgREVGQVVMVF9UQVJHRVRfRFVSQVRJT047XG4gIH1cbiAgZ2V0IGRyaWZ0KCkge1xuICAgIGNvbnN0IHJ1blRpbWUgPSB0aGlzLmRyaWZ0RW5kVGltZSAtIHRoaXMuZHJpZnRTdGFydFRpbWU7XG4gICAgaWYgKHJ1blRpbWUgPiAwKSB7XG4gICAgICBjb25zdCBydW5EdXJhdGlvbiA9IHRoaXMuZHJpZnRFbmQgLSB0aGlzLmRyaWZ0U3RhcnQ7XG4gICAgICByZXR1cm4gcnVuRHVyYXRpb24gKiAxMDAwIC8gcnVuVGltZTtcbiAgICB9XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgZ2V0IGVkZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFydEVuZCB8fCB0aGlzLmZyYWdtZW50RW5kO1xuICB9XG4gIGdldCBwYXJ0RW5kKCkge1xuICAgIHZhciBfdGhpcyRwYXJ0TGlzdDtcbiAgICBpZiAoKF90aGlzJHBhcnRMaXN0ID0gdGhpcy5wYXJ0TGlzdCkgIT0gbnVsbCAmJiBfdGhpcyRwYXJ0TGlzdC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnRMaXN0W3RoaXMucGFydExpc3QubGVuZ3RoIC0gMV0uZW5kO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mcmFnbWVudEVuZDtcbiAgfVxuICBnZXQgZnJhZ21lbnRFbmQoKSB7XG4gICAgdmFyIF90aGlzJGZyYWdtZW50cztcbiAgICBpZiAoKF90aGlzJGZyYWdtZW50cyA9IHRoaXMuZnJhZ21lbnRzKSAhPSBudWxsICYmIF90aGlzJGZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLmZyYWdtZW50c1t0aGlzLmZyYWdtZW50cy5sZW5ndGggLSAxXS5lbmQ7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIGdldCBhZ2UoKSB7XG4gICAgaWYgKHRoaXMuYWR2YW5jZWREYXRlVGltZSkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KERhdGUubm93KCkgLSB0aGlzLmFkdmFuY2VkRGF0ZVRpbWUsIDApIC8gMTAwMDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZ2V0IGxhc3RQYXJ0SW5kZXgoKSB7XG4gICAgdmFyIF90aGlzJHBhcnRMaXN0MjtcbiAgICBpZiAoKF90aGlzJHBhcnRMaXN0MiA9IHRoaXMucGFydExpc3QpICE9IG51bGwgJiYgX3RoaXMkcGFydExpc3QyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFydExpc3RbdGhpcy5wYXJ0TGlzdC5sZW5ndGggLSAxXS5pbmRleDtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGdldCBsYXN0UGFydFNuKCkge1xuICAgIHZhciBfdGhpcyRwYXJ0TGlzdDM7XG4gICAgaWYgKChfdGhpcyRwYXJ0TGlzdDMgPSB0aGlzLnBhcnRMaXN0KSAhPSBudWxsICYmIF90aGlzJHBhcnRMaXN0My5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnRMaXN0W3RoaXMucGFydExpc3QubGVuZ3RoIC0gMV0uZnJhZ21lbnQuc247XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVuZFNOO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NERlY29kZShiYXNlNjRlbmNvZGVkU3RyKSB7XG4gIHJldHVybiBVaW50OEFycmF5LmZyb20oYXRvYihiYXNlNjRlbmNvZGVkU3RyKSwgYyA9PiBjLmNoYXJDb2RlQXQoMCkpO1xufVxuXG5mdW5jdGlvbiBnZXRLZXlJZEJ5dGVzKHN0cikge1xuICBjb25zdCBrZXlJZGJ5dGVzID0gc3RyVG9VdGY4YXJyYXkoc3RyKS5zdWJhcnJheSgwLCAxNik7XG4gIGNvbnN0IHBhZGRlZGtleUlkYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxNik7XG4gIHBhZGRlZGtleUlkYnl0ZXMuc2V0KGtleUlkYnl0ZXMsIDE2IC0ga2V5SWRieXRlcy5sZW5ndGgpO1xuICByZXR1cm4gcGFkZGVka2V5SWRieXRlcztcbn1cbmZ1bmN0aW9uIGNoYW5nZUVuZGlhbm5lc3Moa2V5SWQpIHtcbiAgY29uc3Qgc3dhcCA9IGZ1bmN0aW9uIHN3YXAoYXJyYXksIGZyb20sIHRvKSB7XG4gICAgY29uc3QgY3VyID0gYXJyYXlbZnJvbV07XG4gICAgYXJyYXlbZnJvbV0gPSBhcnJheVt0b107XG4gICAgYXJyYXlbdG9dID0gY3VyO1xuICB9O1xuICBzd2FwKGtleUlkLCAwLCAzKTtcbiAgc3dhcChrZXlJZCwgMSwgMik7XG4gIHN3YXAoa2V5SWQsIDQsIDUpO1xuICBzd2FwKGtleUlkLCA2LCA3KTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnREYXRhVXJpVG9BcnJheUJ5dGVzKHVyaSkge1xuICAvLyBkYXRhOls8bWVkaWEgdHlwZV1bO2F0dHJpYnV0ZT12YWx1ZV1bO2Jhc2U2NF0sPGRhdGE+XG4gIGNvbnN0IGNvbG9uc3BsaXQgPSB1cmkuc3BsaXQoJzonKTtcbiAgbGV0IGtleWRhdGEgPSBudWxsO1xuICBpZiAoY29sb25zcGxpdFswXSA9PT0gJ2RhdGEnICYmIGNvbG9uc3BsaXQubGVuZ3RoID09PSAyKSB7XG4gICAgY29uc3Qgc2VtaWNvbG9uc3BsaXQgPSBjb2xvbnNwbGl0WzFdLnNwbGl0KCc7Jyk7XG4gICAgY29uc3QgY29tbWFzcGxpdCA9IHNlbWljb2xvbnNwbGl0W3NlbWljb2xvbnNwbGl0Lmxlbmd0aCAtIDFdLnNwbGl0KCcsJyk7XG4gICAgaWYgKGNvbW1hc3BsaXQubGVuZ3RoID09PSAyKSB7XG4gICAgICBjb25zdCBpc2Jhc2U2NCA9IGNvbW1hc3BsaXRbMF0gPT09ICdiYXNlNjQnO1xuICAgICAgY29uc3QgZGF0YSA9IGNvbW1hc3BsaXRbMV07XG4gICAgICBpZiAoaXNiYXNlNjQpIHtcbiAgICAgICAgc2VtaWNvbG9uc3BsaXQuc3BsaWNlKC0xLCAxKTsgLy8gcmVtb3ZlIGZyb20gcHJvY2Vzc2luZ1xuICAgICAgICBrZXlkYXRhID0gYmFzZTY0RGVjb2RlKGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5ZGF0YSA9IGdldEtleUlkQnl0ZXMoZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBrZXlkYXRhO1xufVxuZnVuY3Rpb24gc3RyVG9VdGY4YXJyYXkoc3RyKSB7XG4gIHJldHVybiBVaW50OEFycmF5LmZyb20odW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpLCBjID0+IGMuY2hhckNvZGVBdCgwKSk7XG59XG5cbi8qKiByZXR1cm5zIGB1bmRlZmluZWRgIGlzIGBzZWxmYCBpcyBtaXNzaW5nLCBlLmcuIGluIG5vZGUgKi9cbmNvbnN0IG9wdGlvbmFsU2VsZiA9IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTmF2aWdhdG9yL3JlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc1xuICovXG52YXIgS2V5U3lzdGVtcyA9IHtcbiAgQ0xFQVJLRVk6IFwib3JnLnczLmNsZWFya2V5XCIsXG4gIEZBSVJQTEFZOiBcImNvbS5hcHBsZS5mcHNcIixcbiAgUExBWVJFQURZOiBcImNvbS5taWNyb3NvZnQucGxheXJlYWR5XCIsXG4gIFdJREVWSU5FOiBcImNvbS53aWRldmluZS5hbHBoYVwiXG59O1xuXG4vLyBQbGF5bGlzdCAjRVhULVgtS0VZIEtFWUZPUk1BVCB2YWx1ZXNcbnZhciBLZXlTeXN0ZW1Gb3JtYXRzID0ge1xuICBDTEVBUktFWTogXCJvcmcudzMuY2xlYXJrZXlcIixcbiAgRkFJUlBMQVk6IFwiY29tLmFwcGxlLnN0cmVhbWluZ2tleWRlbGl2ZXJ5XCIsXG4gIFBMQVlSRUFEWTogXCJjb20ubWljcm9zb2Z0LnBsYXlyZWFkeVwiLFxuICBXSURFVklORTogXCJ1cm46dXVpZDplZGVmOGJhOS03OWQ2LTRhY2UtYTNjOC0yN2RjZDUxZDIxZWRcIlxufTtcbmZ1bmN0aW9uIGtleVN5c3RlbUZvcm1hdFRvS2V5U3lzdGVtRG9tYWluKGZvcm1hdCkge1xuICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgIGNhc2UgS2V5U3lzdGVtRm9ybWF0cy5GQUlSUExBWTpcbiAgICAgIHJldHVybiBLZXlTeXN0ZW1zLkZBSVJQTEFZO1xuICAgIGNhc2UgS2V5U3lzdGVtRm9ybWF0cy5QTEFZUkVBRFk6XG4gICAgICByZXR1cm4gS2V5U3lzdGVtcy5QTEFZUkVBRFk7XG4gICAgY2FzZSBLZXlTeXN0ZW1Gb3JtYXRzLldJREVWSU5FOlxuICAgICAgcmV0dXJuIEtleVN5c3RlbXMuV0lERVZJTkU7XG4gICAgY2FzZSBLZXlTeXN0ZW1Gb3JtYXRzLkNMRUFSS0VZOlxuICAgICAgcmV0dXJuIEtleVN5c3RlbXMuQ0xFQVJLRVk7XG4gIH1cbn1cblxuLy8gU3lzdGVtIElEcyBmb3Igd2hpY2ggd2UgY2FuIGV4dHJhY3QgYSBrZXkgSUQgZnJvbSBcImVuY3J5cHRlZFwiIGV2ZW50IFBTU0hcbnZhciBLZXlTeXN0ZW1JZHMgPSB7XG4gIFdJREVWSU5FOiBcImVkZWY4YmE5NzlkNjRhY2VhM2M4MjdkY2Q1MWQyMWVkXCJcbn07XG5mdW5jdGlvbiBrZXlTeXN0ZW1JZFRvS2V5U3lzdGVtRG9tYWluKHN5c3RlbUlkKSB7XG4gIGlmIChzeXN0ZW1JZCA9PT0gS2V5U3lzdGVtSWRzLldJREVWSU5FKSB7XG4gICAgcmV0dXJuIEtleVN5c3RlbXMuV0lERVZJTkU7XG4gICAgLy8gfSBlbHNlIGlmIChzeXN0ZW1JZCA9PT0gS2V5U3lzdGVtSWRzLlBMQVlSRUFEWSkge1xuICAgIC8vICAgcmV0dXJuIEtleVN5c3RlbXMuUExBWVJFQURZO1xuICAgIC8vIH0gZWxzZSBpZiAoc3lzdGVtSWQgPT09IEtleVN5c3RlbUlkcy5DRU5DIHx8IHN5c3RlbUlkID09PSBLZXlTeXN0ZW1JZHMuQ0xFQVJLRVkpIHtcbiAgICAvLyAgIHJldHVybiBLZXlTeXN0ZW1zLkNMRUFSS0VZO1xuICB9XG59XG5mdW5jdGlvbiBrZXlTeXN0ZW1Eb21haW5Ub0tleVN5c3RlbUZvcm1hdChrZXlTeXN0ZW0pIHtcbiAgc3dpdGNoIChrZXlTeXN0ZW0pIHtcbiAgICBjYXNlIEtleVN5c3RlbXMuRkFJUlBMQVk6XG4gICAgICByZXR1cm4gS2V5U3lzdGVtRm9ybWF0cy5GQUlSUExBWTtcbiAgICBjYXNlIEtleVN5c3RlbXMuUExBWVJFQURZOlxuICAgICAgcmV0dXJuIEtleVN5c3RlbUZvcm1hdHMuUExBWVJFQURZO1xuICAgIGNhc2UgS2V5U3lzdGVtcy5XSURFVklORTpcbiAgICAgIHJldHVybiBLZXlTeXN0ZW1Gb3JtYXRzLldJREVWSU5FO1xuICAgIGNhc2UgS2V5U3lzdGVtcy5DTEVBUktFWTpcbiAgICAgIHJldHVybiBLZXlTeXN0ZW1Gb3JtYXRzLkNMRUFSS0VZO1xuICB9XG59XG5mdW5jdGlvbiBnZXRLZXlTeXN0ZW1zRm9yQ29uZmlnKGNvbmZpZykge1xuICBjb25zdCB7XG4gICAgZHJtU3lzdGVtcyxcbiAgICB3aWRldmluZUxpY2Vuc2VVcmxcbiAgfSA9IGNvbmZpZztcbiAgY29uc3Qga2V5U3lzdGVtc1RvQXR0ZW1wdCA9IGRybVN5c3RlbXMgPyBbS2V5U3lzdGVtcy5GQUlSUExBWSwgS2V5U3lzdGVtcy5XSURFVklORSwgS2V5U3lzdGVtcy5QTEFZUkVBRFksIEtleVN5c3RlbXMuQ0xFQVJLRVldLmZpbHRlcihrZXlTeXN0ZW0gPT4gISFkcm1TeXN0ZW1zW2tleVN5c3RlbV0pIDogW107XG4gIGlmICgha2V5U3lzdGVtc1RvQXR0ZW1wdFtLZXlTeXN0ZW1zLldJREVWSU5FXSAmJiB3aWRldmluZUxpY2Vuc2VVcmwpIHtcbiAgICBrZXlTeXN0ZW1zVG9BdHRlbXB0LnB1c2goS2V5U3lzdGVtcy5XSURFVklORSk7XG4gIH1cbiAgcmV0dXJuIGtleVN5c3RlbXNUb0F0dGVtcHQ7XG59XG5jb25zdCByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgPSBmdW5jdGlvbiAoX29wdGlvbmFsU2VsZiRuYXZpZ2F0KSB7XG4gIGlmIChvcHRpb25hbFNlbGYgIT0gbnVsbCAmJiAoX29wdGlvbmFsU2VsZiRuYXZpZ2F0ID0gb3B0aW9uYWxTZWxmLm5hdmlnYXRvcikgIT0gbnVsbCAmJiBfb3B0aW9uYWxTZWxmJG5hdmlnYXQucmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzKSB7XG4gICAgcmV0dXJuIHNlbGYubmF2aWdhdG9yLnJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzcy5iaW5kKHNlbGYubmF2aWdhdG9yKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufSgpO1xuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhS2V5U3lzdGVtQ29uZmlndXJhdGlvblxuICovXG5mdW5jdGlvbiBnZXRTdXBwb3J0ZWRNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25zKGtleVN5c3RlbSwgYXVkaW9Db2RlY3MsIHZpZGVvQ29kZWNzLCBkcm1TeXN0ZW1PcHRpb25zKSB7XG4gIGxldCBpbml0RGF0YVR5cGVzO1xuICBzd2l0Y2ggKGtleVN5c3RlbSkge1xuICAgIGNhc2UgS2V5U3lzdGVtcy5GQUlSUExBWTpcbiAgICAgIGluaXREYXRhVHlwZXMgPSBbJ2NlbmMnLCAnc2luZiddO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBLZXlTeXN0ZW1zLldJREVWSU5FOlxuICAgIGNhc2UgS2V5U3lzdGVtcy5QTEFZUkVBRFk6XG4gICAgICBpbml0RGF0YVR5cGVzID0gWydjZW5jJ107XG4gICAgICBicmVhaztcbiAgICBjYXNlIEtleVN5c3RlbXMuQ0xFQVJLRVk6XG4gICAgICBpbml0RGF0YVR5cGVzID0gWydjZW5jJywgJ2tleWlkcyddO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBrZXktc3lzdGVtOiAke2tleVN5c3RlbX1gKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9ucyhpbml0RGF0YVR5cGVzLCBhdWRpb0NvZGVjcywgdmlkZW9Db2RlY3MsIGRybVN5c3RlbU9wdGlvbnMpO1xufVxuZnVuY3Rpb24gY3JlYXRlTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9ucyhpbml0RGF0YVR5cGVzLCBhdWRpb0NvZGVjcywgdmlkZW9Db2RlY3MsIGRybVN5c3RlbU9wdGlvbnMpIHtcbiAgY29uc3QgYmFzZUNvbmZpZyA9IHtcbiAgICBpbml0RGF0YVR5cGVzOiBpbml0RGF0YVR5cGVzLFxuICAgIHBlcnNpc3RlbnRTdGF0ZTogZHJtU3lzdGVtT3B0aW9ucy5wZXJzaXN0ZW50U3RhdGUgfHwgJ29wdGlvbmFsJyxcbiAgICBkaXN0aW5jdGl2ZUlkZW50aWZpZXI6IGRybVN5c3RlbU9wdGlvbnMuZGlzdGluY3RpdmVJZGVudGlmaWVyIHx8ICdvcHRpb25hbCcsXG4gICAgc2Vzc2lvblR5cGVzOiBkcm1TeXN0ZW1PcHRpb25zLnNlc3Npb25UeXBlcyB8fCBbZHJtU3lzdGVtT3B0aW9ucy5zZXNzaW9uVHlwZSB8fCAndGVtcG9yYXJ5J10sXG4gICAgYXVkaW9DYXBhYmlsaXRpZXM6IGF1ZGlvQ29kZWNzLm1hcChjb2RlYyA9PiAoe1xuICAgICAgY29udGVudFR5cGU6IGBhdWRpby9tcDQ7IGNvZGVjcz1cIiR7Y29kZWN9XCJgLFxuICAgICAgcm9idXN0bmVzczogZHJtU3lzdGVtT3B0aW9ucy5hdWRpb1JvYnVzdG5lc3MgfHwgJycsXG4gICAgICBlbmNyeXB0aW9uU2NoZW1lOiBkcm1TeXN0ZW1PcHRpb25zLmF1ZGlvRW5jcnlwdGlvblNjaGVtZSB8fCBudWxsXG4gICAgfSkpLFxuICAgIHZpZGVvQ2FwYWJpbGl0aWVzOiB2aWRlb0NvZGVjcy5tYXAoY29kZWMgPT4gKHtcbiAgICAgIGNvbnRlbnRUeXBlOiBgdmlkZW8vbXA0OyBjb2RlY3M9XCIke2NvZGVjfVwiYCxcbiAgICAgIHJvYnVzdG5lc3M6IGRybVN5c3RlbU9wdGlvbnMudmlkZW9Sb2J1c3RuZXNzIHx8ICcnLFxuICAgICAgZW5jcnlwdGlvblNjaGVtZTogZHJtU3lzdGVtT3B0aW9ucy52aWRlb0VuY3J5cHRpb25TY2hlbWUgfHwgbnVsbFxuICAgIH0pKVxuICB9O1xuICByZXR1cm4gW2Jhc2VDb25maWddO1xufVxuXG5mdW5jdGlvbiBzbGljZVVpbnQ4KGFycmF5LCBzdGFydCwgZW5kKSB7XG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgVGhpcyBwb2x5ZmlsbHMgSUUxMSB1c2FnZSBvZiBVaW50OEFycmF5IHNsaWNlLlxuICAvLyBJdCBhbHdheXMgZXhpc3RzIGluIHRoZSBUeXBlU2NyaXB0IGRlZmluaXRpb24gc28gZmFpbHMsIGJ1dCBpdCBmYWlscyBhdCBydW50aW1lIG9uIElFMTEuXG4gIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5zbGljZSA/IGFycmF5LnNsaWNlKHN0YXJ0LCBlbmQpIDogbmV3IFVpbnQ4QXJyYXkoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyYXksIHN0YXJ0LCBlbmQpKTtcbn1cblxuLy8gYnJlYWtpbmcgdXAgdGhvc2UgdHdvIHR5cGVzIGluIG9yZGVyIHRvIGNsYXJpZnkgd2hhdCBpcyBoYXBwZW5pbmcgaW4gdGhlIGRlY29kaW5nIHBhdGguXG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGFuIElEMyBoZWFkZXIgY2FuIGJlIGZvdW5kIGF0IG9mZnNldCBpbiBkYXRhXG4gKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHNlYXJjaFxuICogQHBhcmFtIG9mZnNldCAtIFRoZSBvZmZzZXQgYXQgd2hpY2ggdG8gc3RhcnQgc2VhcmNoaW5nXG4gKi9cbmNvbnN0IGlzSGVhZGVyJDIgPSAoZGF0YSwgb2Zmc2V0KSA9PiB7XG4gIC8qXG4gICAqIGh0dHA6Ly9pZDMub3JnL2lkM3YyLjMuMFxuICAgKiBbMF0gICAgID0gJ0knXG4gICAqIFsxXSAgICAgPSAnRCdcbiAgICogWzJdICAgICA9ICczJ1xuICAgKiBbMyw0XSAgID0ge1ZlcnNpb259XG4gICAqIFs1XSAgICAgPSB7RmxhZ3N9XG4gICAqIFs2LTldICAgPSB7SUQzIFNpemV9XG4gICAqXG4gICAqIEFuIElEM3YyIHRhZyBjYW4gYmUgZGV0ZWN0ZWQgd2l0aCB0aGUgZm9sbG93aW5nIHBhdHRlcm46XG4gICAqICAkNDkgNDQgMzMgeXkgeXkgeHggenogenogenogenpcbiAgICogV2hlcmUgeXkgaXMgbGVzcyB0aGFuICRGRiwgeHggaXMgdGhlICdmbGFncycgYnl0ZSBhbmQgenogaXMgbGVzcyB0aGFuICQ4MFxuICAgKi9cbiAgaWYgKG9mZnNldCArIDEwIDw9IGRhdGEubGVuZ3RoKSB7XG4gICAgLy8gbG9vayBmb3IgJ0lEMycgaWRlbnRpZmllclxuICAgIGlmIChkYXRhW29mZnNldF0gPT09IDB4NDkgJiYgZGF0YVtvZmZzZXQgKyAxXSA9PT0gMHg0NCAmJiBkYXRhW29mZnNldCArIDJdID09PSAweDMzKSB7XG4gICAgICAvLyBjaGVjayB2ZXJzaW9uIGlzIHdpdGhpbiByYW5nZVxuICAgICAgaWYgKGRhdGFbb2Zmc2V0ICsgM10gPCAweGZmICYmIGRhdGFbb2Zmc2V0ICsgNF0gPCAweGZmKSB7XG4gICAgICAgIC8vIGNoZWNrIHNpemUgaXMgd2l0aGluIHJhbmdlXG4gICAgICAgIGlmIChkYXRhW29mZnNldCArIDZdIDwgMHg4MCAmJiBkYXRhW29mZnNldCArIDddIDwgMHg4MCAmJiBkYXRhW29mZnNldCArIDhdIDwgMHg4MCAmJiBkYXRhW29mZnNldCArIDldIDwgMHg4MCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGFuIElEMyBmb290ZXIgY2FuIGJlIGZvdW5kIGF0IG9mZnNldCBpbiBkYXRhXG4gKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHNlYXJjaFxuICogQHBhcmFtIG9mZnNldCAtIFRoZSBvZmZzZXQgYXQgd2hpY2ggdG8gc3RhcnQgc2VhcmNoaW5nXG4gKi9cbmNvbnN0IGlzRm9vdGVyID0gKGRhdGEsIG9mZnNldCkgPT4ge1xuICAvKlxuICAgKiBUaGUgZm9vdGVyIGlzIGEgY29weSBvZiB0aGUgaGVhZGVyLCBidXQgd2l0aCBhIGRpZmZlcmVudCBpZGVudGlmaWVyXG4gICAqL1xuICBpZiAob2Zmc2V0ICsgMTAgPD0gZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBsb29rIGZvciAnM0RJJyBpZGVudGlmaWVyXG4gICAgaWYgKGRhdGFbb2Zmc2V0XSA9PT0gMHgzMyAmJiBkYXRhW29mZnNldCArIDFdID09PSAweDQ0ICYmIGRhdGFbb2Zmc2V0ICsgMl0gPT09IDB4NDkpIHtcbiAgICAgIC8vIGNoZWNrIHZlcnNpb24gaXMgd2l0aGluIHJhbmdlXG4gICAgICBpZiAoZGF0YVtvZmZzZXQgKyAzXSA8IDB4ZmYgJiYgZGF0YVtvZmZzZXQgKyA0XSA8IDB4ZmYpIHtcbiAgICAgICAgLy8gY2hlY2sgc2l6ZSBpcyB3aXRoaW4gcmFuZ2VcbiAgICAgICAgaWYgKGRhdGFbb2Zmc2V0ICsgNl0gPCAweDgwICYmIGRhdGFbb2Zmc2V0ICsgN10gPCAweDgwICYmIGRhdGFbb2Zmc2V0ICsgOF0gPCAweDgwICYmIGRhdGFbb2Zmc2V0ICsgOV0gPCAweDgwKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFueSBhZGphY2VudCBJRDMgdGFncyBmb3VuZCBpbiBkYXRhIHN0YXJ0aW5nIGF0IG9mZnNldCwgYXMgb25lIGJsb2NrIG9mIGRhdGFcbiAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gc2VhcmNoIGluXG4gKiBAcGFyYW0gb2Zmc2V0IC0gVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCBzZWFyY2hpbmdcbiAqIEByZXR1cm5zIHRoZSBibG9jayBvZiBkYXRhIGNvbnRhaW5pbmcgYW55IElEMyB0YWdzIGZvdW5kXG4gKiBvciAqdW5kZWZpbmVkKiBpZiBubyBoZWFkZXIgaXMgZm91bmQgYXQgdGhlIHN0YXJ0aW5nIG9mZnNldFxuICovXG5jb25zdCBnZXRJRDNEYXRhID0gKGRhdGEsIG9mZnNldCkgPT4ge1xuICBjb25zdCBmcm9udCA9IG9mZnNldDtcbiAgbGV0IGxlbmd0aCA9IDA7XG4gIHdoaWxlIChpc0hlYWRlciQyKGRhdGEsIG9mZnNldCkpIHtcbiAgICAvLyBJRDMgaGVhZGVyIGlzIDEwIGJ5dGVzXG4gICAgbGVuZ3RoICs9IDEwO1xuICAgIGNvbnN0IHNpemUgPSByZWFkU2l6ZShkYXRhLCBvZmZzZXQgKyA2KTtcbiAgICBsZW5ndGggKz0gc2l6ZTtcbiAgICBpZiAoaXNGb290ZXIoZGF0YSwgb2Zmc2V0ICsgMTApKSB7XG4gICAgICAvLyBJRDMgZm9vdGVyIGlzIDEwIGJ5dGVzXG4gICAgICBsZW5ndGggKz0gMTA7XG4gICAgfVxuICAgIG9mZnNldCArPSBsZW5ndGg7XG4gIH1cbiAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gZGF0YS5zdWJhcnJheShmcm9udCwgZnJvbnQgKyBsZW5ndGgpO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuY29uc3QgcmVhZFNpemUgPSAoZGF0YSwgb2Zmc2V0KSA9PiB7XG4gIGxldCBzaXplID0gMDtcbiAgc2l6ZSA9IChkYXRhW29mZnNldF0gJiAweDdmKSA8PCAyMTtcbiAgc2l6ZSB8PSAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4N2YpIDw8IDE0O1xuICBzaXplIHw9IChkYXRhW29mZnNldCArIDJdICYgMHg3ZikgPDwgNztcbiAgc2l6ZSB8PSBkYXRhW29mZnNldCArIDNdICYgMHg3ZjtcbiAgcmV0dXJuIHNpemU7XG59O1xuY29uc3QgY2FuUGFyc2UkMiA9IChkYXRhLCBvZmZzZXQpID0+IHtcbiAgcmV0dXJuIGlzSGVhZGVyJDIoZGF0YSwgb2Zmc2V0KSAmJiByZWFkU2l6ZShkYXRhLCBvZmZzZXQgKyA2KSArIDEwIDw9IGRhdGEubGVuZ3RoIC0gb2Zmc2V0O1xufTtcblxuLyoqXG4gKiBTZWFyY2hlcyBmb3IgdGhlIEVsZW1lbnRhcnkgU3RyZWFtIHRpbWVzdGFtcCBmb3VuZCBpbiB0aGUgSUQzIGRhdGEgY2h1bmtcbiAqIEBwYXJhbSBkYXRhIC0gQmxvY2sgb2YgZGF0YSBjb250YWluaW5nIG9uZSBvciBtb3JlIElEMyB0YWdzXG4gKi9cbmNvbnN0IGdldFRpbWVTdGFtcCA9IGRhdGEgPT4ge1xuICBjb25zdCBmcmFtZXMgPSBnZXRJRDNGcmFtZXMoZGF0YSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZnJhbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZnJhbWUgPSBmcmFtZXNbaV07XG4gICAgaWYgKGlzVGltZVN0YW1wRnJhbWUoZnJhbWUpKSB7XG4gICAgICByZXR1cm4gcmVhZFRpbWVTdGFtcChmcmFtZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgSUQzIGZyYW1lIGlzIGFuIEVsZW1lbnRhcnkgU3RyZWFtIHRpbWVzdGFtcCBmcmFtZVxuICovXG5jb25zdCBpc1RpbWVTdGFtcEZyYW1lID0gZnJhbWUgPT4ge1xuICByZXR1cm4gZnJhbWUgJiYgZnJhbWUua2V5ID09PSAnUFJJVicgJiYgZnJhbWUuaW5mbyA9PT0gJ2NvbS5hcHBsZS5zdHJlYW1pbmcudHJhbnNwb3J0U3RyZWFtVGltZXN0YW1wJztcbn07XG5jb25zdCBnZXRGcmFtZURhdGEgPSBkYXRhID0+IHtcbiAgLypcbiAgRnJhbWUgSUQgICAgICAgJHh4IHh4IHh4IHh4IChmb3VyIGNoYXJhY3RlcnMpXG4gIFNpemUgICAgICAgICAgICR4eCB4eCB4eCB4eFxuICBGbGFncyAgICAgICAgICAkeHggeHhcbiAgKi9cbiAgY29uc3QgdHlwZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVswXSwgZGF0YVsxXSwgZGF0YVsyXSwgZGF0YVszXSk7XG4gIGNvbnN0IHNpemUgPSByZWFkU2l6ZShkYXRhLCA0KTtcblxuICAvLyBza2lwIGZyYW1lIGlkLCBzaXplLCBhbmQgZmxhZ3NcbiAgY29uc3Qgb2Zmc2V0ID0gMTA7XG4gIHJldHVybiB7XG4gICAgdHlwZSxcbiAgICBzaXplLFxuICAgIGRhdGE6IGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBzaXplKVxuICB9O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIElEMyBmcmFtZXMgZm91bmQgaW4gYWxsIHRoZSBJRDMgdGFncyBpbiB0aGUgaWQzRGF0YVxuICogQHBhcmFtIGlkM0RhdGEgLSBUaGUgSUQzIGRhdGEgY29udGFpbmluZyBvbmUgb3IgbW9yZSBJRDMgdGFnc1xuICovXG5jb25zdCBnZXRJRDNGcmFtZXMgPSBpZDNEYXRhID0+IHtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGNvbnN0IGZyYW1lcyA9IFtdO1xuICB3aGlsZSAoaXNIZWFkZXIkMihpZDNEYXRhLCBvZmZzZXQpKSB7XG4gICAgY29uc3Qgc2l6ZSA9IHJlYWRTaXplKGlkM0RhdGEsIG9mZnNldCArIDYpO1xuICAgIC8vIHNraXAgcGFzdCBJRDMgaGVhZGVyXG4gICAgb2Zmc2V0ICs9IDEwO1xuICAgIGNvbnN0IGVuZCA9IG9mZnNldCArIHNpemU7XG4gICAgLy8gbG9vcCB0aHJvdWdoIGZyYW1lcyBpbiB0aGUgSUQzIHRhZ1xuICAgIHdoaWxlIChvZmZzZXQgKyA4IDwgZW5kKSB7XG4gICAgICBjb25zdCBmcmFtZURhdGEgPSBnZXRGcmFtZURhdGEoaWQzRGF0YS5zdWJhcnJheShvZmZzZXQpKTtcbiAgICAgIGNvbnN0IGZyYW1lID0gZGVjb2RlRnJhbWUoZnJhbWVEYXRhKTtcbiAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICBmcmFtZXMucHVzaChmcmFtZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHNraXAgZnJhbWUgaGVhZGVyIGFuZCBmcmFtZSBkYXRhXG4gICAgICBvZmZzZXQgKz0gZnJhbWVEYXRhLnNpemUgKyAxMDtcbiAgICB9XG4gICAgaWYgKGlzRm9vdGVyKGlkM0RhdGEsIG9mZnNldCkpIHtcbiAgICAgIG9mZnNldCArPSAxMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZyYW1lcztcbn07XG5jb25zdCBkZWNvZGVGcmFtZSA9IGZyYW1lID0+IHtcbiAgaWYgKGZyYW1lLnR5cGUgPT09ICdQUklWJykge1xuICAgIHJldHVybiBkZWNvZGVQcml2RnJhbWUoZnJhbWUpO1xuICB9IGVsc2UgaWYgKGZyYW1lLnR5cGVbMF0gPT09ICdXJykge1xuICAgIHJldHVybiBkZWNvZGVVUkxGcmFtZShmcmFtZSk7XG4gIH1cbiAgcmV0dXJuIGRlY29kZVRleHRGcmFtZShmcmFtZSk7XG59O1xuY29uc3QgZGVjb2RlUHJpdkZyYW1lID0gZnJhbWUgPT4ge1xuICAvKlxuICBGb3JtYXQ6IDx0ZXh0IHN0cmluZz5cXDA8YmluYXJ5IGRhdGE+XG4gICovXG4gIGlmIChmcmFtZS5zaXplIDwgMikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3Qgb3duZXIgPSB1dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLCB0cnVlKTtcbiAgY29uc3QgcHJpdmF0ZURhdGEgPSBuZXcgVWludDhBcnJheShmcmFtZS5kYXRhLnN1YmFycmF5KG93bmVyLmxlbmd0aCArIDEpKTtcbiAgcmV0dXJuIHtcbiAgICBrZXk6IGZyYW1lLnR5cGUsXG4gICAgaW5mbzogb3duZXIsXG4gICAgZGF0YTogcHJpdmF0ZURhdGEuYnVmZmVyXG4gIH07XG59O1xuY29uc3QgZGVjb2RlVGV4dEZyYW1lID0gZnJhbWUgPT4ge1xuICBpZiAoZnJhbWUuc2l6ZSA8IDIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChmcmFtZS50eXBlID09PSAnVFhYWCcpIHtcbiAgICAvKlxuICAgIEZvcm1hdDpcbiAgICBbMF0gICA9IHtUZXh0IEVuY29kaW5nfVxuICAgIFsxLT9dID0ge0Rlc2NyaXB0aW9ufVxcMHtWYWx1ZX1cbiAgICAqL1xuICAgIGxldCBpbmRleCA9IDE7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSB1dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLnN1YmFycmF5KGluZGV4KSwgdHJ1ZSk7XG4gICAgaW5kZXggKz0gZGVzY3JpcHRpb24ubGVuZ3RoICsgMTtcbiAgICBjb25zdCB2YWx1ZSA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoaW5kZXgpKTtcbiAgICByZXR1cm4ge1xuICAgICAga2V5OiBmcmFtZS50eXBlLFxuICAgICAgaW5mbzogZGVzY3JpcHRpb24sXG4gICAgICBkYXRhOiB2YWx1ZVxuICAgIH07XG4gIH1cbiAgLypcbiAgRm9ybWF0OlxuICBbMF0gICA9IHtUZXh0IEVuY29kaW5nfVxuICBbMS0/XSA9IHtWYWx1ZX1cbiAgKi9cbiAgY29uc3QgdGV4dCA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoMSkpO1xuICByZXR1cm4ge1xuICAgIGtleTogZnJhbWUudHlwZSxcbiAgICBkYXRhOiB0ZXh0XG4gIH07XG59O1xuY29uc3QgZGVjb2RlVVJMRnJhbWUgPSBmcmFtZSA9PiB7XG4gIGlmIChmcmFtZS50eXBlID09PSAnV1hYWCcpIHtcbiAgICAvKlxuICAgIEZvcm1hdDpcbiAgICBbMF0gICA9IHtUZXh0IEVuY29kaW5nfVxuICAgIFsxLT9dID0ge0Rlc2NyaXB0aW9ufVxcMHtVUkx9XG4gICAgKi9cbiAgICBpZiAoZnJhbWUuc2l6ZSA8IDIpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGxldCBpbmRleCA9IDE7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSB1dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLnN1YmFycmF5KGluZGV4KSwgdHJ1ZSk7XG4gICAgaW5kZXggKz0gZGVzY3JpcHRpb24ubGVuZ3RoICsgMTtcbiAgICBjb25zdCB2YWx1ZSA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoaW5kZXgpKTtcbiAgICByZXR1cm4ge1xuICAgICAga2V5OiBmcmFtZS50eXBlLFxuICAgICAgaW5mbzogZGVzY3JpcHRpb24sXG4gICAgICBkYXRhOiB2YWx1ZVxuICAgIH07XG4gIH1cbiAgLypcbiAgRm9ybWF0OlxuICBbMC0/XSA9IHtVUkx9XG4gICovXG4gIGNvbnN0IHVybCA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEpO1xuICByZXR1cm4ge1xuICAgIGtleTogZnJhbWUudHlwZSxcbiAgICBkYXRhOiB1cmxcbiAgfTtcbn07XG5jb25zdCByZWFkVGltZVN0YW1wID0gdGltZVN0YW1wRnJhbWUgPT4ge1xuICBpZiAodGltZVN0YW1wRnJhbWUuZGF0YS5ieXRlTGVuZ3RoID09PSA4KSB7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KHRpbWVTdGFtcEZyYW1lLmRhdGEpO1xuICAgIC8vIHRpbWVzdGFtcCBpcyAzMyBiaXQgZXhwcmVzc2VkIGFzIGEgYmlnLWVuZGlhbiBlaWdodC1vY3RldCBudW1iZXIsXG4gICAgLy8gd2l0aCB0aGUgdXBwZXIgMzEgYml0cyBzZXQgdG8gemVyby5cbiAgICBjb25zdCBwdHMzM0JpdCA9IGRhdGFbM10gJiAweDE7XG4gICAgbGV0IHRpbWVzdGFtcCA9IChkYXRhWzRdIDw8IDIzKSArIChkYXRhWzVdIDw8IDE1KSArIChkYXRhWzZdIDw8IDcpICsgZGF0YVs3XTtcbiAgICB0aW1lc3RhbXAgLz0gNDU7XG4gICAgaWYgKHB0czMzQml0KSB7XG4gICAgICB0aW1lc3RhbXAgKz0gNDc3MjE4NTguODQ7XG4gICAgfSAvLyAyXjMyIC8gOTBcblxuICAgIHJldHVybiBNYXRoLnJvdW5kKHRpbWVzdGFtcCk7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODkzNjk4NC91aW50OGFycmF5LXRvLXN0cmluZy1pbi1qYXZhc2NyaXB0LzIyMzczMTk3XG4vLyBodHRwOi8vd3d3Lm9uaWNvcy5jb20vc3RhZmYvaXovYW11c2UvamF2YXNjcmlwdC9leHBlcnQvdXRmLnR4dFxuLyogdXRmLmpzIC0gVVRGLTggPD0+IFVURi0xNiBjb252ZXJ0aW9uXG4gKlxuICogQ29weXJpZ2h0IChDKSAxOTk5IE1hc2FuYW8gSXp1bW8gPGl6QG9uaWNvcy5jby5qcD5cbiAqIFZlcnNpb246IDEuMFxuICogTGFzdE1vZGlmaWVkOiBEZWMgMjUgMTk5OVxuICogVGhpcyBsaWJyYXJ5IGlzIGZyZWUuICBZb3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0LlxuICovXG5jb25zdCB1dGY4QXJyYXlUb1N0ciA9IChhcnJheSwgZXhpdE9uTnVsbCA9IGZhbHNlKSA9PiB7XG4gIGNvbnN0IGRlY29kZXIgPSBnZXRUZXh0RGVjb2RlcigpO1xuICBpZiAoZGVjb2Rlcikge1xuICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVyLmRlY29kZShhcnJheSk7XG4gICAgaWYgKGV4aXRPbk51bGwpIHtcbiAgICAgIC8vIGdyYWIgdXAgdG8gdGhlIGZpcnN0IG51bGxcbiAgICAgIGNvbnN0IGlkeCA9IGRlY29kZWQuaW5kZXhPZignXFwwJyk7XG4gICAgICByZXR1cm4gaWR4ICE9PSAtMSA/IGRlY29kZWQuc3Vic3RyaW5nKDAsIGlkeCkgOiBkZWNvZGVkO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBhbnkgbnVsbCBjaGFyYWN0ZXJzXG4gICAgcmV0dXJuIGRlY29kZWQucmVwbGFjZSgvXFwwL2csICcnKTtcbiAgfVxuICBjb25zdCBsZW4gPSBhcnJheS5sZW5ndGg7XG4gIGxldCBjO1xuICBsZXQgY2hhcjI7XG4gIGxldCBjaGFyMztcbiAgbGV0IG91dCA9ICcnO1xuICBsZXQgaSA9IDA7XG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgYyA9IGFycmF5W2krK107XG4gICAgaWYgKGMgPT09IDB4MDAgJiYgZXhpdE9uTnVsbCkge1xuICAgICAgcmV0dXJuIG91dDtcbiAgICB9IGVsc2UgaWYgKGMgPT09IDB4MDAgfHwgYyA9PT0gMHgwMykge1xuICAgICAgLy8gSWYgdGhlIGNoYXJhY3RlciBpcyAzIChFTkRfT0ZfVEVYVCkgb3IgMCAoTlVMTCkgdGhlbiBza2lwIGl0XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgc3dpdGNoIChjID4+IDQpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgIGNhc2UgMTpcbiAgICAgIGNhc2UgMjpcbiAgICAgIGNhc2UgMzpcbiAgICAgIGNhc2UgNDpcbiAgICAgIGNhc2UgNTpcbiAgICAgIGNhc2UgNjpcbiAgICAgIGNhc2UgNzpcbiAgICAgICAgLy8gMHh4eHh4eHhcbiAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjpcbiAgICAgIGNhc2UgMTM6XG4gICAgICAgIC8vIDExMHggeHh4eCAgIDEweHggeHh4eFxuICAgICAgICBjaGFyMiA9IGFycmF5W2krK107XG4gICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgMHgxZikgPDwgNiB8IGNoYXIyICYgMHgzZik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxNDpcbiAgICAgICAgLy8gMTExMCB4eHh4ICAxMHh4IHh4eHggIDEweHggeHh4eFxuICAgICAgICBjaGFyMiA9IGFycmF5W2krK107XG4gICAgICAgIGNoYXIzID0gYXJyYXlbaSsrXTtcbiAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgJiAweDBmKSA8PCAxMiB8IChjaGFyMiAmIDB4M2YpIDw8IDYgfCAoY2hhcjMgJiAweDNmKSA8PCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59O1xubGV0IGRlY29kZXI7XG5mdW5jdGlvbiBnZXRUZXh0RGVjb2RlcigpIHtcbiAgLy8gT24gUGxheSBTdGF0aW9uIDQsIFRleHREZWNvZGVyIGlzIGRlZmluZWQgYnV0IHBhcnRpYWxseSBpbXBsZW1lbnRlZC5cbiAgLy8gTWFudWFsIGRlY29kaW5nIG9wdGlvbiBpcyBwcmVmZXJhYmxlXG4gIGlmIChuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKCdQbGF5U3RhdGlvbiA0JykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFkZWNvZGVyICYmIHR5cGVvZiBzZWxmLlRleHREZWNvZGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgIGRlY29kZXIgPSBuZXcgc2VsZi5UZXh0RGVjb2RlcigndXRmLTgnKTtcbiAgfVxuICByZXR1cm4gZGVjb2Rlcjtcbn1cblxuLyoqXG4gKiAgaGV4IGR1bXAgaGVscGVyIGNsYXNzXG4gKi9cblxuY29uc3QgSGV4ID0ge1xuICBoZXhEdW1wOiBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGggPSBhcnJheVtpXS50b1N0cmluZygxNik7XG4gICAgICBpZiAoaC5sZW5ndGggPCAyKSB7XG4gICAgICAgIGggPSAnMCcgKyBoO1xuICAgICAgfVxuICAgICAgc3RyICs9IGg7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH1cbn07XG5cbmNvbnN0IFVJTlQzMl9NQVgkMSA9IE1hdGgucG93KDIsIDMyKSAtIDE7XG5jb25zdCBwdXNoID0gW10ucHVzaDtcblxuLy8gV2UgYXJlIHVzaW5nIGZpeGVkIHRyYWNrIElEcyBmb3IgZHJpdmluZyB0aGUgTVA0IHJlbXV4ZXJcbi8vIGluc3RlYWQgb2YgZm9sbG93aW5nIHRoZSBUUyBQSURzLlxuLy8gVGhlcmUgaXMgbm8gcmVhc29uIG5vdCB0byBkbyB0aGlzIGFuZCBzb21lIGJyb3dzZXJzL1NvdXJjZUJ1ZmZlci1kZW11eGVyc1xuLy8gbWF5IG5vdCBsaWtlIGlmIHRoZXJlIGFyZSBUcmFja0lEIFwic3dpdGNoZXNcIlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy8xMzMxXG4vLyBIZXJlIHdlIGFyZSBtYXBwaW5nIG91ciBpbnRlcm5hbCB0cmFjayB0eXBlcyB0byBjb25zdGFudCBNUDQgdHJhY2sgSURzXG4vLyBXaXRoIE1TRSBjdXJyZW50bHkgb25lIGNhbiBvbmx5IGhhdmUgb25lIHRyYWNrIG9mIGVhY2gsIGFuZCB3ZSBhcmUgbXV4aW5nXG4vLyB3aGF0ZXZlciB2aWRlby9hdWRpbyByZW5kaXRpb24gaW4gdGhlbS5cbmNvbnN0IFJlbXV4ZXJUcmFja0lkQ29uZmlnID0ge1xuICB2aWRlbzogMSxcbiAgYXVkaW86IDIsXG4gIGlkMzogMyxcbiAgdGV4dDogNFxufTtcbmZ1bmN0aW9uIGJpbjJzdHIoZGF0YSkge1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBkYXRhKTtcbn1cbmZ1bmN0aW9uIHJlYWRVaW50MTYoYnVmZmVyLCBvZmZzZXQpIHtcbiAgY29uc3QgdmFsID0gYnVmZmVyW29mZnNldF0gPDwgOCB8IGJ1ZmZlcltvZmZzZXQgKyAxXTtcbiAgcmV0dXJuIHZhbCA8IDAgPyA2NTUzNiArIHZhbCA6IHZhbDtcbn1cbmZ1bmN0aW9uIHJlYWRVaW50MzIoYnVmZmVyLCBvZmZzZXQpIHtcbiAgY29uc3QgdmFsID0gcmVhZFNpbnQzMihidWZmZXIsIG9mZnNldCk7XG4gIHJldHVybiB2YWwgPCAwID8gNDI5NDk2NzI5NiArIHZhbCA6IHZhbDtcbn1cbmZ1bmN0aW9uIHJlYWRVaW50NjQoYnVmZmVyLCBvZmZzZXQpIHtcbiAgbGV0IHJlc3VsdCA9IHJlYWRVaW50MzIoYnVmZmVyLCBvZmZzZXQpO1xuICByZXN1bHQgKj0gTWF0aC5wb3coMiwgMzIpO1xuICByZXN1bHQgKz0gcmVhZFVpbnQzMihidWZmZXIsIG9mZnNldCArIDQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcmVhZFNpbnQzMihidWZmZXIsIG9mZnNldCkge1xuICByZXR1cm4gYnVmZmVyW29mZnNldF0gPDwgMjQgfCBidWZmZXJbb2Zmc2V0ICsgMV0gPDwgMTYgfCBidWZmZXJbb2Zmc2V0ICsgMl0gPDwgOCB8IGJ1ZmZlcltvZmZzZXQgKyAzXTtcbn1cbmZ1bmN0aW9uIHdyaXRlVWludDMyKGJ1ZmZlciwgb2Zmc2V0LCB2YWx1ZSkge1xuICBidWZmZXJbb2Zmc2V0XSA9IHZhbHVlID4+IDI0O1xuICBidWZmZXJbb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+PiAxNiAmIDB4ZmY7XG4gIGJ1ZmZlcltvZmZzZXQgKyAyXSA9IHZhbHVlID4+IDggJiAweGZmO1xuICBidWZmZXJbb2Zmc2V0ICsgM10gPSB2YWx1ZSAmIDB4ZmY7XG59XG5cbi8vIEZpbmQgXCJtb29mXCIgYm94XG5mdW5jdGlvbiBoYXNNb29mRGF0YShkYXRhKSB7XG4gIGNvbnN0IGVuZCA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmQ7KSB7XG4gICAgY29uc3Qgc2l6ZSA9IHJlYWRVaW50MzIoZGF0YSwgaSk7XG4gICAgaWYgKHNpemUgPiA4ICYmIGRhdGFbaSArIDRdID09PSAweDZkICYmIGRhdGFbaSArIDVdID09PSAweDZmICYmIGRhdGFbaSArIDZdID09PSAweDZmICYmIGRhdGFbaSArIDddID09PSAweDY2KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaSA9IHNpemUgPiAxID8gaSArIHNpemUgOiBlbmQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBGaW5kIHRoZSBkYXRhIGZvciBhIGJveCBzcGVjaWZpZWQgYnkgaXRzIHBhdGhcbmZ1bmN0aW9uIGZpbmRCb3goZGF0YSwgcGF0aCkge1xuICBjb25zdCByZXN1bHRzID0gW107XG4gIGlmICghcGF0aC5sZW5ndGgpIHtcbiAgICAvLyBzaG9ydC1jaXJjdWl0IHRoZSBzZWFyY2ggZm9yIGVtcHR5IHBhdGhzXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbiAgY29uc3QgZW5kID0gZGF0YS5ieXRlTGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGVuZDspIHtcbiAgICBjb25zdCBzaXplID0gcmVhZFVpbnQzMihkYXRhLCBpKTtcbiAgICBjb25zdCB0eXBlID0gYmluMnN0cihkYXRhLnN1YmFycmF5KGkgKyA0LCBpICsgOCkpO1xuICAgIGNvbnN0IGVuZGJveCA9IHNpemUgPiAxID8gaSArIHNpemUgOiBlbmQ7XG4gICAgaWYgKHR5cGUgPT09IHBhdGhbMF0pIHtcbiAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyB0aGlzIGlzIHRoZSBlbmQgb2YgdGhlIHBhdGggYW5kIHdlJ3ZlIGZvdW5kIHRoZSBib3ggd2Ugd2VyZVxuICAgICAgICAvLyBsb29raW5nIGZvclxuICAgICAgICByZXN1bHRzLnB1c2goZGF0YS5zdWJhcnJheShpICsgOCwgZW5kYm94KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHRoZSBuZXh0IGJveCBhbG9uZyB0aGUgcGF0aFxuICAgICAgICBjb25zdCBzdWJyZXN1bHRzID0gZmluZEJveChkYXRhLnN1YmFycmF5KGkgKyA4LCBlbmRib3gpLCBwYXRoLnNsaWNlKDEpKTtcbiAgICAgICAgaWYgKHN1YnJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgICAgcHVzaC5hcHBseShyZXN1bHRzLCBzdWJyZXN1bHRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpID0gZW5kYm94O1xuICB9XG5cbiAgLy8gd2UndmUgZmluaXNoZWQgc2VhcmNoaW5nIGFsbCBvZiBkYXRhXG4gIHJldHVybiByZXN1bHRzO1xufVxuZnVuY3Rpb24gcGFyc2VTZWdtZW50SW5kZXgoc2lkeCkge1xuICBjb25zdCByZWZlcmVuY2VzID0gW107XG4gIGNvbnN0IHZlcnNpb24gPSBzaWR4WzBdO1xuXG4gIC8vIHNldCBpbml0aWFsIG9mZnNldCwgd2Ugc2tpcCB0aGUgcmVmZXJlbmNlIElEIChub3QgbmVlZGVkKVxuICBsZXQgaW5kZXggPSA4O1xuICBjb25zdCB0aW1lc2NhbGUgPSByZWFkVWludDMyKHNpZHgsIGluZGV4KTtcbiAgaW5kZXggKz0gNDtcbiAgbGV0IGVhcmxpZXN0UHJlc2VudGF0aW9uVGltZSA9IDA7XG4gIGxldCBmaXJzdE9mZnNldCA9IDA7XG4gIGlmICh2ZXJzaW9uID09PSAwKSB7XG4gICAgZWFybGllc3RQcmVzZW50YXRpb25UaW1lID0gcmVhZFVpbnQzMihzaWR4LCBpbmRleCk7XG4gICAgZmlyc3RPZmZzZXQgPSByZWFkVWludDMyKHNpZHgsIGluZGV4ICsgNCk7XG4gICAgaW5kZXggKz0gODtcbiAgfSBlbHNlIHtcbiAgICBlYXJsaWVzdFByZXNlbnRhdGlvblRpbWUgPSByZWFkVWludDY0KHNpZHgsIGluZGV4KTtcbiAgICBmaXJzdE9mZnNldCA9IHJlYWRVaW50NjQoc2lkeCwgaW5kZXggKyA4KTtcbiAgICBpbmRleCArPSAxNjtcbiAgfVxuXG4gIC8vIHNraXAgcmVzZXJ2ZWRcbiAgaW5kZXggKz0gMjtcbiAgbGV0IHN0YXJ0Qnl0ZSA9IHNpZHgubGVuZ3RoICsgZmlyc3RPZmZzZXQ7XG4gIGNvbnN0IHJlZmVyZW5jZXNDb3VudCA9IHJlYWRVaW50MTYoc2lkeCwgaW5kZXgpO1xuICBpbmRleCArPSAyO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJlZmVyZW5jZXNDb3VudDsgaSsrKSB7XG4gICAgbGV0IHJlZmVyZW5jZUluZGV4ID0gaW5kZXg7XG4gICAgY29uc3QgcmVmZXJlbmNlSW5mbyA9IHJlYWRVaW50MzIoc2lkeCwgcmVmZXJlbmNlSW5kZXgpO1xuICAgIHJlZmVyZW5jZUluZGV4ICs9IDQ7XG4gICAgY29uc3QgcmVmZXJlbmNlU2l6ZSA9IHJlZmVyZW5jZUluZm8gJiAweDdmZmZmZmZmO1xuICAgIGNvbnN0IHJlZmVyZW5jZVR5cGUgPSAocmVmZXJlbmNlSW5mbyAmIDB4ODAwMDAwMDApID4+PiAzMTtcbiAgICBpZiAocmVmZXJlbmNlVHlwZSA9PT0gMSkge1xuICAgICAgbG9nZ2VyLndhcm4oJ1NJRFggaGFzIGhpZXJhcmNoaWNhbCByZWZlcmVuY2VzIChub3Qgc3VwcG9ydGVkKScpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHN1YnNlZ21lbnREdXJhdGlvbiA9IHJlYWRVaW50MzIoc2lkeCwgcmVmZXJlbmNlSW5kZXgpO1xuICAgIHJlZmVyZW5jZUluZGV4ICs9IDQ7XG4gICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgIHJlZmVyZW5jZVNpemUsXG4gICAgICBzdWJzZWdtZW50RHVyYXRpb24sXG4gICAgICAvLyB1bnNjYWxlZFxuICAgICAgaW5mbzoge1xuICAgICAgICBkdXJhdGlvbjogc3Vic2VnbWVudER1cmF0aW9uIC8gdGltZXNjYWxlLFxuICAgICAgICBzdGFydDogc3RhcnRCeXRlLFxuICAgICAgICBlbmQ6IHN0YXJ0Qnl0ZSArIHJlZmVyZW5jZVNpemUgLSAxXG4gICAgICB9XG4gICAgfSk7XG4gICAgc3RhcnRCeXRlICs9IHJlZmVyZW5jZVNpemU7XG5cbiAgICAvLyBTa2lwcGluZyAxIGJpdCBmb3IgfHN0YXJ0c1dpdGhTYXB8LCAzIGJpdHMgZm9yIHxzYXBUeXBlfCwgYW5kIDI4IGJpdHNcbiAgICAvLyBmb3IgfHNhcERlbHRhfC5cbiAgICByZWZlcmVuY2VJbmRleCArPSA0O1xuXG4gICAgLy8gc2tpcCB0byBuZXh0IHJlZlxuICAgIGluZGV4ID0gcmVmZXJlbmNlSW5kZXg7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBlYXJsaWVzdFByZXNlbnRhdGlvblRpbWUsXG4gICAgdGltZXNjYWxlLFxuICAgIHZlcnNpb24sXG4gICAgcmVmZXJlbmNlc0NvdW50LFxuICAgIHJlZmVyZW5jZXNcbiAgfTtcbn1cblxuLyoqXG4gKiBQYXJzZXMgYW4gTVA0IGluaXRpYWxpemF0aW9uIHNlZ21lbnQgYW5kIGV4dHJhY3RzIHN0cmVhbSB0eXBlIGFuZFxuICogdGltZXNjYWxlIHZhbHVlcyBmb3IgYW55IGRlY2xhcmVkIHRyYWNrcy4gVGltZXNjYWxlIHZhbHVlcyBpbmRpY2F0ZSB0aGVcbiAqIG51bWJlciBvZiBjbG9jayB0aWNrcyBwZXIgc2Vjb25kIHRvIGFzc3VtZSBmb3IgdGltZS1iYXNlZCB2YWx1ZXNcbiAqIGVsc2V3aGVyZSBpbiB0aGUgTVA0LlxuICpcbiAqIFRvIGRldGVybWluZSB0aGUgc3RhcnQgdGltZSBvZiBhbiBNUDQsIHlvdSBuZWVkIHR3byBwaWVjZXMgb2ZcbiAqIGluZm9ybWF0aW9uOiB0aGUgdGltZXNjYWxlIHVuaXQgYW5kIHRoZSBlYXJsaWVzdCBiYXNlIG1lZGlhIGRlY29kZVxuICogdGltZS4gTXVsdGlwbGUgdGltZXNjYWxlcyBjYW4gYmUgc3BlY2lmaWVkIHdpdGhpbiBhbiBNUDQgYnV0IHRoZVxuICogYmFzZSBtZWRpYSBkZWNvZGUgdGltZSBpcyBhbHdheXMgZXhwcmVzc2VkIGluIHRoZSB0aW1lc2NhbGUgZnJvbVxuICogdGhlIG1lZGlhIGhlYWRlciBib3ggZm9yIHRoZSB0cmFjazpcbiAqIGBgYFxuICogbW9vdiA+IHRyYWsgPiBtZGlhID4gbWRoZC50aW1lc2NhbGVcbiAqIG1vb3YgPiB0cmFrID4gbWRpYSA+IGhkbHJcbiAqIGBgYFxuICogQHBhcmFtIGluaXRTZWdtZW50IHRoZSBieXRlcyBvZiB0aGUgaW5pdCBzZWdtZW50XG4gKiBAcmV0dXJucyBhIGhhc2ggb2YgdHJhY2sgdHlwZSB0byB0aW1lc2NhbGUgdmFsdWVzIG9yIG51bGwgaWZcbiAqIHRoZSBpbml0IHNlZ21lbnQgaXMgbWFsZm9ybWVkLlxuICovXG5cbmZ1bmN0aW9uIHBhcnNlSW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IHRyYWtzID0gZmluZEJveChpbml0U2VnbWVudCwgWydtb292JywgJ3RyYWsnXSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdHJha3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0cmFrID0gdHJha3NbaV07XG4gICAgY29uc3QgdGtoZCA9IGZpbmRCb3godHJhaywgWyd0a2hkJ10pWzBdO1xuICAgIGlmICh0a2hkKSB7XG4gICAgICBsZXQgdmVyc2lvbiA9IHRraGRbMF07XG4gICAgICBjb25zdCB0cmFja0lkID0gcmVhZFVpbnQzMih0a2hkLCB2ZXJzaW9uID09PSAwID8gMTIgOiAyMCk7XG4gICAgICBjb25zdCBtZGhkID0gZmluZEJveCh0cmFrLCBbJ21kaWEnLCAnbWRoZCddKVswXTtcbiAgICAgIGlmIChtZGhkKSB7XG4gICAgICAgIHZlcnNpb24gPSBtZGhkWzBdO1xuICAgICAgICBjb25zdCB0aW1lc2NhbGUgPSByZWFkVWludDMyKG1kaGQsIHZlcnNpb24gPT09IDAgPyAxMiA6IDIwKTtcbiAgICAgICAgY29uc3QgaGRsciA9IGZpbmRCb3godHJhaywgWydtZGlhJywgJ2hkbHInXSlbMF07XG4gICAgICAgIGlmIChoZGxyKSB7XG4gICAgICAgICAgY29uc3QgaGRsclR5cGUgPSBiaW4yc3RyKGhkbHIuc3ViYXJyYXkoOCwgMTIpKTtcbiAgICAgICAgICBjb25zdCB0eXBlID0ge1xuICAgICAgICAgICAgc291bjogRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPLFxuICAgICAgICAgICAgdmlkZTogRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPXG4gICAgICAgICAgfVtoZGxyVHlwZV07XG4gICAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgIC8vIFBhcnNlIGNvZGVjIGRldGFpbHNcbiAgICAgICAgICAgIGNvbnN0IHN0c2QgPSBmaW5kQm94KHRyYWssIFsnbWRpYScsICdtaW5mJywgJ3N0YmwnLCAnc3RzZCddKVswXTtcbiAgICAgICAgICAgIGNvbnN0IHN0c2REYXRhID0gcGFyc2VTdHNkKHN0c2QpO1xuICAgICAgICAgICAgcmVzdWx0W3RyYWNrSWRdID0ge1xuICAgICAgICAgICAgICB0aW1lc2NhbGUsXG4gICAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXN1bHRbdHlwZV0gPSBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgICAgIHRpbWVzY2FsZSxcbiAgICAgICAgICAgICAgaWQ6IHRyYWNrSWRcbiAgICAgICAgICAgIH0sIHN0c2REYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgdHJleCA9IGZpbmRCb3goaW5pdFNlZ21lbnQsIFsnbW9vdicsICdtdmV4JywgJ3RyZXgnXSk7XG4gIHRyZXguZm9yRWFjaCh0cmV4ID0+IHtcbiAgICBjb25zdCB0cmFja0lkID0gcmVhZFVpbnQzMih0cmV4LCA0KTtcbiAgICBjb25zdCB0cmFjayA9IHJlc3VsdFt0cmFja0lkXTtcbiAgICBpZiAodHJhY2spIHtcbiAgICAgIHRyYWNrLmRlZmF1bHQgPSB7XG4gICAgICAgIGR1cmF0aW9uOiByZWFkVWludDMyKHRyZXgsIDEyKSxcbiAgICAgICAgZmxhZ3M6IHJlYWRVaW50MzIodHJleCwgMjApXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZVN0c2Qoc3RzZCkge1xuICBjb25zdCBzYW1wbGVFbnRyaWVzID0gc3RzZC5zdWJhcnJheSg4KTtcbiAgY29uc3Qgc2FtcGxlRW50cmllc0VuZCA9IHNhbXBsZUVudHJpZXMuc3ViYXJyYXkoOCArIDc4KTtcbiAgY29uc3QgZm91ckNDID0gYmluMnN0cihzYW1wbGVFbnRyaWVzLnN1YmFycmF5KDQsIDgpKTtcbiAgbGV0IGNvZGVjID0gZm91ckNDO1xuICBjb25zdCBlbmNyeXB0ZWQgPSBmb3VyQ0MgPT09ICdlbmNhJyB8fCBmb3VyQ0MgPT09ICdlbmN2JztcbiAgaWYgKGVuY3J5cHRlZCkge1xuICAgIGNvbnN0IGVuY0JveCA9IGZpbmRCb3goc2FtcGxlRW50cmllcywgW2ZvdXJDQ10pWzBdO1xuICAgIGNvbnN0IGVuY0JveENoaWxkcmVuID0gZW5jQm94LnN1YmFycmF5KGZvdXJDQyA9PT0gJ2VuY2EnID8gMjggOiA3OCk7XG4gICAgY29uc3Qgc2luZnMgPSBmaW5kQm94KGVuY0JveENoaWxkcmVuLCBbJ3NpbmYnXSk7XG4gICAgc2luZnMuZm9yRWFjaChzaW5mID0+IHtcbiAgICAgIGNvbnN0IHNjaG0gPSBmaW5kQm94KHNpbmYsIFsnc2NobSddKVswXTtcbiAgICAgIGlmIChzY2htKSB7XG4gICAgICAgIGNvbnN0IHNjaGVtZSA9IGJpbjJzdHIoc2NobS5zdWJhcnJheSg0LCA4KSk7XG4gICAgICAgIGlmIChzY2hlbWUgPT09ICdjYmNzJyB8fCBzY2hlbWUgPT09ICdjZW5jJykge1xuICAgICAgICAgIGNvbnN0IGZybWEgPSBmaW5kQm94KHNpbmYsIFsnZnJtYSddKVswXTtcbiAgICAgICAgICBpZiAoZnJtYSkge1xuICAgICAgICAgICAgLy8gZm9yIGVuY3J5cHRlZCBjb250ZW50IGNvZGVjIGZvdXJDQyB3aWxsIGJlIGluIGZybWFcbiAgICAgICAgICAgIGNvZGVjID0gYmluMnN0cihmcm1hKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzd2l0Y2ggKGNvZGVjKSB7XG4gICAgY2FzZSAnYXZjMSc6XG4gICAgY2FzZSAnYXZjMic6XG4gICAgY2FzZSAnYXZjMyc6XG4gICAgY2FzZSAnYXZjNCc6XG4gICAgICB7XG4gICAgICAgIC8vIGV4dHJhY3QgcHJvZmlsZSArIGNvbXBhdGliaWxpdHkgKyBsZXZlbCBvdXQgb2YgYXZjQyBib3hcbiAgICAgICAgY29uc3QgYXZjQ0JveCA9IGZpbmRCb3goc2FtcGxlRW50cmllc0VuZCwgWydhdmNDJ10pWzBdO1xuICAgICAgICBjb2RlYyArPSAnLicgKyB0b0hleChhdmNDQm94WzFdKSArIHRvSGV4KGF2Y0NCb3hbMl0pICsgdG9IZXgoYXZjQ0JveFszXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgJ21wNGEnOlxuICAgICAge1xuICAgICAgICBjb25zdCBjb2RlY0JveCA9IGZpbmRCb3goc2FtcGxlRW50cmllcywgW2ZvdXJDQ10pWzBdO1xuICAgICAgICBjb25zdCBlc2RzQm94ID0gZmluZEJveChjb2RlY0JveC5zdWJhcnJheSgyOCksIFsnZXNkcyddKVswXTtcbiAgICAgICAgaWYgKGVzZHNCb3ggJiYgZXNkc0JveC5sZW5ndGggPiAxMikge1xuICAgICAgICAgIGxldCBpID0gNDtcbiAgICAgICAgICAvLyBFUyBEZXNjcmlwdG9yIHRhZ1xuICAgICAgICAgIGlmIChlc2RzQm94W2krK10gIT09IDB4MDMpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpID0gc2tpcEJFUkludGVnZXIoZXNkc0JveCwgaSk7XG4gICAgICAgICAgaSArPSAyOyAvLyBza2lwIGVzX2lkO1xuICAgICAgICAgIGNvbnN0IGZsYWdzID0gZXNkc0JveFtpKytdO1xuICAgICAgICAgIGlmIChmbGFncyAmIDB4ODApIHtcbiAgICAgICAgICAgIGkgKz0gMjsgLy8gc2tpcCBkZXBlbmRlbmN5IGVzX2lkXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmbGFncyAmIDB4NDApIHtcbiAgICAgICAgICAgIGkgKz0gZXNkc0JveFtpKytdOyAvLyBza2lwIFVSTFxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBEZWNvZGVyIGNvbmZpZyBkZXNjcmlwdG9yXG4gICAgICAgICAgaWYgKGVzZHNCb3hbaSsrXSAhPT0gMHgwNCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGkgPSBza2lwQkVSSW50ZWdlcihlc2RzQm94LCBpKTtcbiAgICAgICAgICBjb25zdCBvYmplY3RUeXBlID0gZXNkc0JveFtpKytdO1xuICAgICAgICAgIGlmIChvYmplY3RUeXBlID09PSAweDQwKSB7XG4gICAgICAgICAgICBjb2RlYyArPSAnLicgKyB0b0hleChvYmplY3RUeXBlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGkgKz0gMTI7XG4gICAgICAgICAgLy8gRGVjb2RlciBzcGVjaWZpYyBpbmZvXG4gICAgICAgICAgaWYgKGVzZHNCb3hbaSsrXSAhPT0gMHgwNSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGkgPSBza2lwQkVSSW50ZWdlcihlc2RzQm94LCBpKTtcbiAgICAgICAgICBjb25zdCBmaXJzdEJ5dGUgPSBlc2RzQm94W2krK107XG4gICAgICAgICAgbGV0IGF1ZGlvT2JqZWN0VHlwZSA9IChmaXJzdEJ5dGUgJiAweGY4KSA+PiAzO1xuICAgICAgICAgIGlmIChhdWRpb09iamVjdFR5cGUgPT09IDMxKSB7XG4gICAgICAgICAgICBhdWRpb09iamVjdFR5cGUgKz0gMSArICgoZmlyc3RCeXRlICYgMHg3KSA8PCAzKSArICgoZXNkc0JveFtpXSAmIDB4ZTApID4+IDUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb2RlYyArPSAnLicgKyBhdWRpb09iamVjdFR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSAnaHZjMSc6XG4gICAgY2FzZSAnaGV2MSc6XG4gICAgICB7XG4gICAgICAgIGNvbnN0IGh2Y0NCb3ggPSBmaW5kQm94KHNhbXBsZUVudHJpZXNFbmQsIFsnaHZjQyddKVswXTtcbiAgICAgICAgY29uc3QgcHJvZmlsZUJ5dGUgPSBodmNDQm94WzFdO1xuICAgICAgICBjb25zdCBwcm9maWxlU3BhY2UgPSBbJycsICdBJywgJ0InLCAnQyddW3Byb2ZpbGVCeXRlID4+IDZdO1xuICAgICAgICBjb25zdCBnZW5lcmFsUHJvZmlsZUlkYyA9IHByb2ZpbGVCeXRlICYgMHgxZjtcbiAgICAgICAgY29uc3QgcHJvZmlsZUNvbXBhdCA9IHJlYWRVaW50MzIoaHZjQ0JveCwgMik7XG4gICAgICAgIGNvbnN0IHRpZXJGbGFnID0gKHByb2ZpbGVCeXRlICYgMHgyMCkgPj4gNSA/ICdIJyA6ICdMJztcbiAgICAgICAgY29uc3QgbGV2ZWxJREMgPSBodmNDQm94WzEyXTtcbiAgICAgICAgY29uc3QgY29uc3RyYWludEluZGljYXRvciA9IGh2Y0NCb3guc3ViYXJyYXkoNiwgMTIpO1xuICAgICAgICBjb2RlYyArPSAnLicgKyBwcm9maWxlU3BhY2UgKyBnZW5lcmFsUHJvZmlsZUlkYztcbiAgICAgICAgY29kZWMgKz0gJy4nICsgcHJvZmlsZUNvbXBhdC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgICAgY29kZWMgKz0gJy4nICsgdGllckZsYWcgKyBsZXZlbElEQztcbiAgICAgICAgbGV0IGNvbnN0cmFpbnRTdHJpbmcgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IGNvbnN0cmFpbnRJbmRpY2F0b3IubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgY29uc3QgYnl0ZSA9IGNvbnN0cmFpbnRJbmRpY2F0b3JbaV07XG4gICAgICAgICAgaWYgKGJ5dGUgfHwgY29uc3RyYWludFN0cmluZykge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlZEJ5dGUgPSBieXRlLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgY29uc3RyYWludFN0cmluZyA9ICcuJyArIGVuY29kZWRCeXRlICsgY29uc3RyYWludFN0cmluZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29kZWMgKz0gY29uc3RyYWludFN0cmluZztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSAnZHZoMSc6XG4gICAgY2FzZSAnZHZoZSc6XG4gICAgICB7XG4gICAgICAgIGNvbnN0IGR2Y0NCb3ggPSBmaW5kQm94KHNhbXBsZUVudHJpZXNFbmQsIFsnZHZjQyddKVswXTtcbiAgICAgICAgY29uc3QgcHJvZmlsZSA9IGR2Y0NCb3hbMl0gPj4gMSAmIDB4N2Y7XG4gICAgICAgIGNvbnN0IGxldmVsID0gZHZjQ0JveFsyXSA8PCA1ICYgMHgyMCB8IGR2Y0NCb3hbM10gPj4gMyAmIDB4MWY7XG4gICAgICAgIGNvZGVjICs9ICcuJyArIGFkZExlYWRpbmdaZXJvKHByb2ZpbGUpICsgJy4nICsgYWRkTGVhZGluZ1plcm8obGV2ZWwpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlICd2cDA5JzpcbiAgICAgIHtcbiAgICAgICAgY29uc3QgdnBjQ0JveCA9IGZpbmRCb3goc2FtcGxlRW50cmllc0VuZCwgWyd2cGNDJ10pWzBdO1xuICAgICAgICBjb25zdCBwcm9maWxlID0gdnBjQ0JveFs0XTtcbiAgICAgICAgY29uc3QgbGV2ZWwgPSB2cGNDQm94WzVdO1xuICAgICAgICBjb25zdCBiaXREZXB0aCA9IHZwY0NCb3hbNl0gPj4gNCAmIDB4MGY7XG4gICAgICAgIGNvZGVjICs9ICcuJyArIGFkZExlYWRpbmdaZXJvKHByb2ZpbGUpICsgJy4nICsgYWRkTGVhZGluZ1plcm8obGV2ZWwpICsgJy4nICsgYWRkTGVhZGluZ1plcm8oYml0RGVwdGgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlICdhdjAxJzpcbiAgICAgIHtcbiAgICAgICAgY29uc3QgYXYxQ0JveCA9IGZpbmRCb3goc2FtcGxlRW50cmllc0VuZCwgWydhdjFDJ10pWzBdO1xuICAgICAgICBjb25zdCBwcm9maWxlID0gYXYxQ0JveFsxXSA+Pj4gNTtcbiAgICAgICAgY29uc3QgbGV2ZWwgPSBhdjFDQm94WzFdICYgMHgxZjtcbiAgICAgICAgY29uc3QgdGllckZsYWcgPSBhdjFDQm94WzJdID4+PiA3ID8gJ0gnIDogJ00nO1xuICAgICAgICBjb25zdCBoaWdoQml0RGVwdGggPSAoYXYxQ0JveFsyXSAmIDB4NDApID4+IDY7XG4gICAgICAgIGNvbnN0IHR3ZWx2ZUJpdCA9IChhdjFDQm94WzJdICYgMHgyMCkgPj4gNTtcbiAgICAgICAgY29uc3QgYml0RGVwdGggPSBwcm9maWxlID09PSAyICYmIGhpZ2hCaXREZXB0aCA/IHR3ZWx2ZUJpdCA/IDEyIDogMTAgOiBoaWdoQml0RGVwdGggPyAxMCA6IDg7XG4gICAgICAgIGNvbnN0IG1vbm9jaHJvbWUgPSAoYXYxQ0JveFsyXSAmIDB4MTApID4+IDQ7XG4gICAgICAgIGNvbnN0IGNocm9tYVN1YnNhbXBsaW5nWCA9IChhdjFDQm94WzJdICYgMHgwOCkgPj4gMztcbiAgICAgICAgY29uc3QgY2hyb21hU3Vic2FtcGxpbmdZID0gKGF2MUNCb3hbMl0gJiAweDA0KSA+PiAyO1xuICAgICAgICBjb25zdCBjaHJvbWFTYW1wbGVQb3NpdGlvbiA9IGF2MUNCb3hbMl0gJiAweDAzO1xuICAgICAgICAvLyBUT0RPOiBwYXJzZSBjb2xvcl9kZXNjcmlwdGlvbl9wcmVzZW50X2ZsYWdcbiAgICAgICAgLy8gZGVmYXVsdCBpdCB0byBCVC43MDkvbGltaXRlZCByYW5nZSBmb3Igbm93XG4gICAgICAgIC8vIG1vcmUgaW5mbyBodHRwczovL2FvbWVkaWFjb2RlYy5naXRodWIuaW8vYXYxLWlzb2JtZmYvI2F2MWNvZGVjY29uZmlndXJhdGlvbmJveC1zeW50YXhcbiAgICAgICAgY29uc3QgY29sb3JQcmltYXJpZXMgPSAxO1xuICAgICAgICBjb25zdCB0cmFuc2ZlckNoYXJhY3RlcmlzdGljcyA9IDE7XG4gICAgICAgIGNvbnN0IG1hdHJpeENvZWZmaWNpZW50cyA9IDE7XG4gICAgICAgIGNvbnN0IHZpZGVvRnVsbFJhbmdlRmxhZyA9IDA7XG4gICAgICAgIGNvZGVjICs9ICcuJyArIHByb2ZpbGUgKyAnLicgKyBhZGRMZWFkaW5nWmVybyhsZXZlbCkgKyB0aWVyRmxhZyArICcuJyArIGFkZExlYWRpbmdaZXJvKGJpdERlcHRoKSArICcuJyArIG1vbm9jaHJvbWUgKyAnLicgKyBjaHJvbWFTdWJzYW1wbGluZ1ggKyBjaHJvbWFTdWJzYW1wbGluZ1kgKyBjaHJvbWFTYW1wbGVQb3NpdGlvbiArICcuJyArIGFkZExlYWRpbmdaZXJvKGNvbG9yUHJpbWFyaWVzKSArICcuJyArIGFkZExlYWRpbmdaZXJvKHRyYW5zZmVyQ2hhcmFjdGVyaXN0aWNzKSArICcuJyArIGFkZExlYWRpbmdaZXJvKG1hdHJpeENvZWZmaWNpZW50cykgKyAnLicgKyB2aWRlb0Z1bGxSYW5nZUZsYWc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgY29kZWMsXG4gICAgZW5jcnlwdGVkXG4gIH07XG59XG5mdW5jdGlvbiBza2lwQkVSSW50ZWdlcihieXRlcywgaSkge1xuICBjb25zdCBsaW1pdCA9IGkgKyA1O1xuICB3aGlsZSAoYnl0ZXNbaSsrXSAmIDB4ODAgJiYgaSA8IGxpbWl0KSB7fVxuICByZXR1cm4gaTtcbn1cbmZ1bmN0aW9uIHRvSGV4KHgpIHtcbiAgcmV0dXJuICgnMCcgKyB4LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpKS5zbGljZSgtMik7XG59XG5mdW5jdGlvbiBhZGRMZWFkaW5nWmVybyhudW0pIHtcbiAgcmV0dXJuIChudW0gPCAxMCA/ICcwJyA6ICcnKSArIG51bTtcbn1cbmZ1bmN0aW9uIHBhdGNoRW5jeXB0aW9uRGF0YShpbml0U2VnbWVudCwgZGVjcnlwdGRhdGEpIHtcbiAgaWYgKCFpbml0U2VnbWVudCB8fCAhZGVjcnlwdGRhdGEpIHtcbiAgICByZXR1cm4gaW5pdFNlZ21lbnQ7XG4gIH1cbiAgY29uc3Qga2V5SWQgPSBkZWNyeXB0ZGF0YS5rZXlJZDtcbiAgaWYgKGtleUlkICYmIGRlY3J5cHRkYXRhLmlzQ29tbW9uRW5jcnlwdGlvbikge1xuICAgIGNvbnN0IHRyYWtzID0gZmluZEJveChpbml0U2VnbWVudCwgWydtb292JywgJ3RyYWsnXSk7XG4gICAgdHJha3MuZm9yRWFjaCh0cmFrID0+IHtcbiAgICAgIGNvbnN0IHN0c2QgPSBmaW5kQm94KHRyYWssIFsnbWRpYScsICdtaW5mJywgJ3N0YmwnLCAnc3RzZCddKVswXTtcblxuICAgICAgLy8gc2tpcCB0aGUgc2FtcGxlIGVudHJ5IGNvdW50XG4gICAgICBjb25zdCBzYW1wbGVFbnRyaWVzID0gc3RzZC5zdWJhcnJheSg4KTtcbiAgICAgIGxldCBlbmNCb3hlcyA9IGZpbmRCb3goc2FtcGxlRW50cmllcywgWydlbmNhJ10pO1xuICAgICAgY29uc3QgaXNBdWRpbyA9IGVuY0JveGVzLmxlbmd0aCA+IDA7XG4gICAgICBpZiAoIWlzQXVkaW8pIHtcbiAgICAgICAgZW5jQm94ZXMgPSBmaW5kQm94KHNhbXBsZUVudHJpZXMsIFsnZW5jdiddKTtcbiAgICAgIH1cbiAgICAgIGVuY0JveGVzLmZvckVhY2goZW5jID0+IHtcbiAgICAgICAgY29uc3QgZW5jQm94Q2hpbGRyZW4gPSBpc0F1ZGlvID8gZW5jLnN1YmFycmF5KDI4KSA6IGVuYy5zdWJhcnJheSg3OCk7XG4gICAgICAgIGNvbnN0IHNpbmZCb3hlcyA9IGZpbmRCb3goZW5jQm94Q2hpbGRyZW4sIFsnc2luZiddKTtcbiAgICAgICAgc2luZkJveGVzLmZvckVhY2goc2luZiA9PiB7XG4gICAgICAgICAgY29uc3QgdGVuYyA9IHBhcnNlU2luZihzaW5mKTtcbiAgICAgICAgICBpZiAodGVuYykge1xuICAgICAgICAgICAgLy8gTG9vayBmb3IgZGVmYXVsdCBrZXkgaWQgKGtleUlEIG9mZnNldCBpcyBhbHdheXMgOCB3aXRoaW4gdGhlIHRlbmMgYm94KTpcbiAgICAgICAgICAgIGNvbnN0IHRlbmNLZXlJZCA9IHRlbmMuc3ViYXJyYXkoOCwgMjQpO1xuICAgICAgICAgICAgaWYgKCF0ZW5jS2V5SWQuc29tZShiID0+IGIgIT09IDApKSB7XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coYFtlbWVdIFBhdGNoaW5nIGtleUlkIGluICdlbmMke2lzQXVkaW8gPyAnYScgOiAndid9PnNpbmY+PnRlbmMnIGJveDogJHtIZXguaGV4RHVtcCh0ZW5jS2V5SWQpfSAtPiAke0hleC5oZXhEdW1wKGtleUlkKX1gKTtcbiAgICAgICAgICAgICAgdGVuYy5zZXQoa2V5SWQsIDgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gaW5pdFNlZ21lbnQ7XG59XG5mdW5jdGlvbiBwYXJzZVNpbmYoc2luZikge1xuICBjb25zdCBzY2htID0gZmluZEJveChzaW5mLCBbJ3NjaG0nXSlbMF07XG4gIGlmIChzY2htKSB7XG4gICAgY29uc3Qgc2NoZW1lID0gYmluMnN0cihzY2htLnN1YmFycmF5KDQsIDgpKTtcbiAgICBpZiAoc2NoZW1lID09PSAnY2JjcycgfHwgc2NoZW1lID09PSAnY2VuYycpIHtcbiAgICAgIHJldHVybiBmaW5kQm94KHNpbmYsIFsnc2NoaScsICd0ZW5jJ10pWzBdO1xuICAgIH1cbiAgfVxuICBsb2dnZXIuZXJyb3IoYFtlbWVdIG1pc3NpbmcgJ3NjaG0nIGJveGApO1xuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIGJhc2UgbWVkaWEgZGVjb2RlIHN0YXJ0IHRpbWUsIGluIHNlY29uZHMsIGZvciBhbiBNUDRcbiAqIGZyYWdtZW50LiBJZiBtdWx0aXBsZSBmcmFnbWVudHMgYXJlIHNwZWNpZmllZCwgdGhlIGVhcmxpZXN0IHRpbWUgaXNcbiAqIHJldHVybmVkLlxuICpcbiAqIFRoZSBiYXNlIG1lZGlhIGRlY29kZSB0aW1lIGNhbiBiZSBwYXJzZWQgZnJvbSB0cmFjayBmcmFnbWVudFxuICogbWV0YWRhdGE6XG4gKiBgYGBcbiAqIG1vb2YgPiB0cmFmID4gdGZkdC5iYXNlTWVkaWFEZWNvZGVUaW1lXG4gKiBgYGBcbiAqIEl0IHJlcXVpcmVzIHRoZSB0aW1lc2NhbGUgdmFsdWUgZnJvbSB0aGUgbWRoZCB0byBpbnRlcnByZXQuXG4gKlxuICogQHBhcmFtIGluaXREYXRhIC0gYSBoYXNoIG9mIHRyYWNrIHR5cGUgdG8gdGltZXNjYWxlIHZhbHVlc1xuICogQHBhcmFtIGZtcDQgLSB0aGUgYnl0ZXMgb2YgdGhlIG1wNCBmcmFnbWVudFxuICogQHJldHVybnMgdGhlIGVhcmxpZXN0IGJhc2UgbWVkaWEgZGVjb2RlIHN0YXJ0IHRpbWUgZm9yIHRoZVxuICogZnJhZ21lbnQsIGluIHNlY29uZHNcbiAqL1xuZnVuY3Rpb24gZ2V0U3RhcnREVFMoaW5pdERhdGEsIGZtcDQpIHtcbiAgLy8gd2UgbmVlZCBpbmZvIGZyb20gdHdvIGNoaWxkcmVuIG9mIGVhY2ggdHJhY2sgZnJhZ21lbnQgYm94XG4gIHJldHVybiBmaW5kQm94KGZtcDQsIFsnbW9vZicsICd0cmFmJ10pLnJlZHVjZSgocmVzdWx0LCB0cmFmKSA9PiB7XG4gICAgY29uc3QgdGZkdCA9IGZpbmRCb3godHJhZiwgWyd0ZmR0J10pWzBdO1xuICAgIGNvbnN0IHZlcnNpb24gPSB0ZmR0WzBdO1xuICAgIGNvbnN0IHN0YXJ0ID0gZmluZEJveCh0cmFmLCBbJ3RmaGQnXSkucmVkdWNlKChyZXN1bHQsIHRmaGQpID0+IHtcbiAgICAgIC8vIGdldCB0aGUgdHJhY2sgaWQgZnJvbSB0aGUgdGZoZFxuICAgICAgY29uc3QgaWQgPSByZWFkVWludDMyKHRmaGQsIDQpO1xuICAgICAgY29uc3QgdHJhY2sgPSBpbml0RGF0YVtpZF07XG4gICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgbGV0IGJhc2VUaW1lID0gcmVhZFVpbnQzMih0ZmR0LCA0KTtcbiAgICAgICAgaWYgKHZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgICAvLyBJZiB2YWx1ZSBpcyB0b28gbGFyZ2UsIGFzc3VtZSBzaWduZWQgNjQtYml0LiBOZWdhdGl2ZSB0cmFjayBmcmFnbWVudCBkZWNvZGUgdGltZXMgYXJlIGludmFsaWQsIGJ1dCB0aGV5IGV4aXN0IGluIHRoZSB3aWxkLlxuICAgICAgICAgIC8vIFRoaXMgcHJldmVudHMgbGFyZ2UgdmFsdWVzIGZyb20gYmVpbmcgdXNlZCBmb3IgaW5pdFBUUywgd2hpY2ggY2FuIGNhdXNlIHBsYXlsaXN0IHN5bmMgaXNzdWVzLlxuICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy81MzAzXG4gICAgICAgICAgaWYgKGJhc2VUaW1lID09PSBVSU5UMzJfTUFYJDEpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBbbXA0LWRlbXV4ZXJdOiBJZ25vcmluZyBhc3N1bWVkIGludmFsaWQgc2lnbmVkIDY0LWJpdCB0cmFjayBmcmFnbWVudCBkZWNvZGUgdGltZWApO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYmFzZVRpbWUgKj0gVUlOVDMyX01BWCQxICsgMTtcbiAgICAgICAgICBiYXNlVGltZSArPSByZWFkVWludDMyKHRmZHQsIDgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFzc3VtZSBhIDkwa0h6IGNsb2NrIGlmIG5vIHRpbWVzY2FsZSB3YXMgc3BlY2lmaWVkXG4gICAgICAgIGNvbnN0IHNjYWxlID0gdHJhY2sudGltZXNjYWxlIHx8IDkwZTM7XG4gICAgICAgIC8vIGNvbnZlcnQgYmFzZSB0aW1lIHRvIHNlY29uZHNcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gYmFzZVRpbWUgLyBzY2FsZTtcbiAgICAgICAgaWYgKGlzRmluaXRlTnVtYmVyKHN0YXJ0VGltZSkgJiYgKHJlc3VsdCA9PT0gbnVsbCB8fCBzdGFydFRpbWUgPCByZXN1bHQpKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXJ0VGltZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCBudWxsKTtcbiAgICBpZiAoc3RhcnQgIT09IG51bGwgJiYgaXNGaW5pdGVOdW1iZXIoc3RhcnQpICYmIChyZXN1bHQgPT09IG51bGwgfHwgc3RhcnQgPCByZXN1bHQpKSB7XG4gICAgICByZXR1cm4gc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIG51bGwpO1xufVxuXG4vKlxuICBGb3IgUmVmZXJlbmNlOlxuICBhbGlnbmVkKDgpIGNsYXNzIFRyYWNrRnJhZ21lbnRIZWFkZXJCb3hcbiAgICAgICAgICAgZXh0ZW5kcyBGdWxsQm94KOKAmHRmaGTigJksIDAsIHRmX2ZsYWdzKXtcbiAgICAgdW5zaWduZWQgaW50KDMyKSAgdHJhY2tfSUQ7XG4gICAgIC8vIGFsbCB0aGUgZm9sbG93aW5nIGFyZSBvcHRpb25hbCBmaWVsZHNcbiAgICAgdW5zaWduZWQgaW50KDY0KSAgYmFzZV9kYXRhX29mZnNldDtcbiAgICAgdW5zaWduZWQgaW50KDMyKSAgc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4O1xuICAgICB1bnNpZ25lZCBpbnQoMzIpICBkZWZhdWx0X3NhbXBsZV9kdXJhdGlvbjtcbiAgICAgdW5zaWduZWQgaW50KDMyKSAgZGVmYXVsdF9zYW1wbGVfc2l6ZTtcbiAgICAgdW5zaWduZWQgaW50KDMyKSAgZGVmYXVsdF9zYW1wbGVfZmxhZ3NcbiAgfVxuICovXG5mdW5jdGlvbiBnZXREdXJhdGlvbihkYXRhLCBpbml0RGF0YSkge1xuICBsZXQgcmF3RHVyYXRpb24gPSAwO1xuICBsZXQgdmlkZW9EdXJhdGlvbiA9IDA7XG4gIGxldCBhdWRpb0R1cmF0aW9uID0gMDtcbiAgY29uc3QgdHJhZnMgPSBmaW5kQm94KGRhdGEsIFsnbW9vZicsICd0cmFmJ10pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdHJhZiA9IHRyYWZzW2ldO1xuICAgIC8vIFRoZXJlIGlzIG9ubHkgb25lIHRmaGQgJiB0cnVuIHBlciB0cmFmXG4gICAgLy8gVGhpcyBpcyB0cnVlIGZvciBDTUFGIHN0eWxlIGNvbnRlbnQsIGFuZCB3ZSBzaG91bGQgcGVyaGFwcyBjaGVjayB0aGUgZnR5cFxuICAgIC8vIGFuZCBvbmx5IGxvb2sgZm9yIGEgc2luZ2xlIHRydW4gdGhlbiwgYnV0IGZvciBJU09CTUZGIHdlIHNob3VsZCBjaGVja1xuICAgIC8vIGZvciBtdWx0aXBsZSB0cmFjayBydW5zLlxuICAgIGNvbnN0IHRmaGQgPSBmaW5kQm94KHRyYWYsIFsndGZoZCddKVswXTtcbiAgICAvLyBnZXQgdGhlIHRyYWNrIGlkIGZyb20gdGhlIHRmaGRcbiAgICBjb25zdCBpZCA9IHJlYWRVaW50MzIodGZoZCwgNCk7XG4gICAgY29uc3QgdHJhY2sgPSBpbml0RGF0YVtpZF07XG4gICAgaWYgKCF0cmFjaykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHRyYWNrRGVmYXVsdCA9IHRyYWNrLmRlZmF1bHQ7XG4gICAgY29uc3QgdGZoZEZsYWdzID0gcmVhZFVpbnQzMih0ZmhkLCAwKSB8ICh0cmFja0RlZmF1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHRyYWNrRGVmYXVsdC5mbGFncyk7XG4gICAgbGV0IHNhbXBsZUR1cmF0aW9uID0gdHJhY2tEZWZhdWx0ID09IG51bGwgPyB2b2lkIDAgOiB0cmFja0RlZmF1bHQuZHVyYXRpb247XG4gICAgaWYgKHRmaGRGbGFncyAmIDB4MDAwMDA4KSB7XG4gICAgICAvLyAweDAwMDAwOCBpbmRpY2F0ZXMgdGhlIHByZXNlbmNlIG9mIHRoZSBkZWZhdWx0X3NhbXBsZV9kdXJhdGlvbiBmaWVsZFxuICAgICAgaWYgKHRmaGRGbGFncyAmIDB4MDAwMDAyKSB7XG4gICAgICAgIC8vIDB4MDAwMDAyIGluZGljYXRlcyB0aGUgcHJlc2VuY2Ugb2YgdGhlIHNhbXBsZV9kZXNjcmlwdGlvbl9pbmRleCBmaWVsZCwgd2hpY2ggcHJlY2VkZXMgZGVmYXVsdF9zYW1wbGVfZHVyYXRpb25cbiAgICAgICAgLy8gSWYgcHJlc2VudCwgdGhlIGRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uIGV4aXN0cyBhdCBieXRlIG9mZnNldCAxMlxuICAgICAgICBzYW1wbGVEdXJhdGlvbiA9IHJlYWRVaW50MzIodGZoZCwgMTIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgZHVyYXRpb24gaXMgYXQgYnl0ZSBvZmZzZXQgOFxuICAgICAgICBzYW1wbGVEdXJhdGlvbiA9IHJlYWRVaW50MzIodGZoZCwgOCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGFzc3VtZSBhIDkwa0h6IGNsb2NrIGlmIG5vIHRpbWVzY2FsZSB3YXMgc3BlY2lmaWVkXG4gICAgY29uc3QgdGltZXNjYWxlID0gdHJhY2sudGltZXNjYWxlIHx8IDkwZTM7XG4gICAgY29uc3QgdHJ1bnMgPSBmaW5kQm94KHRyYWYsIFsndHJ1biddKTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRydW5zLmxlbmd0aDsgaisrKSB7XG4gICAgICByYXdEdXJhdGlvbiA9IGNvbXB1dGVSYXdEdXJhdGlvbkZyb21TYW1wbGVzKHRydW5zW2pdKTtcbiAgICAgIGlmICghcmF3RHVyYXRpb24gJiYgc2FtcGxlRHVyYXRpb24pIHtcbiAgICAgICAgY29uc3Qgc2FtcGxlQ291bnQgPSByZWFkVWludDMyKHRydW5zW2pdLCA0KTtcbiAgICAgICAgcmF3RHVyYXRpb24gPSBzYW1wbGVEdXJhdGlvbiAqIHNhbXBsZUNvdW50O1xuICAgICAgfVxuICAgICAgaWYgKHRyYWNrLnR5cGUgPT09IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFTykge1xuICAgICAgICB2aWRlb0R1cmF0aW9uICs9IHJhd0R1cmF0aW9uIC8gdGltZXNjYWxlO1xuICAgICAgfSBlbHNlIGlmICh0cmFjay50eXBlID09PSBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU8pIHtcbiAgICAgICAgYXVkaW9EdXJhdGlvbiArPSByYXdEdXJhdGlvbiAvIHRpbWVzY2FsZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHZpZGVvRHVyYXRpb24gPT09IDAgJiYgYXVkaW9EdXJhdGlvbiA9PT0gMCkge1xuICAgIC8vIElmIGR1cmF0aW9uIHNhbXBsZXMgYXJlIG5vdCBhdmFpbGFibGUgaW4gdGhlIHRyYWYgdXNlIHNpZHggc3Vic2VnbWVudF9kdXJhdGlvblxuICAgIGxldCBzaWR4TWluU3RhcnQgPSBJbmZpbml0eTtcbiAgICBsZXQgc2lkeE1heEVuZCA9IDA7XG4gICAgbGV0IHNpZHhEdXJhdGlvbiA9IDA7XG4gICAgY29uc3Qgc2lkeHMgPSBmaW5kQm94KGRhdGEsIFsnc2lkeCddKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzaWR4ID0gcGFyc2VTZWdtZW50SW5kZXgoc2lkeHNbaV0pO1xuICAgICAgaWYgKHNpZHggIT0gbnVsbCAmJiBzaWR4LnJlZmVyZW5jZXMpIHtcbiAgICAgICAgc2lkeE1pblN0YXJ0ID0gTWF0aC5taW4oc2lkeE1pblN0YXJ0LCBzaWR4LmVhcmxpZXN0UHJlc2VudGF0aW9uVGltZSAvIHNpZHgudGltZXNjYWxlKTtcbiAgICAgICAgY29uc3Qgc3ViU2VnbWVudER1cmF0aW9uID0gc2lkeC5yZWZlcmVuY2VzLnJlZHVjZSgoZHVyLCByZWYpID0+IGR1ciArIHJlZi5pbmZvLmR1cmF0aW9uIHx8IDAsIDApO1xuICAgICAgICBzaWR4TWF4RW5kID0gTWF0aC5tYXgoc2lkeE1heEVuZCwgc3ViU2VnbWVudER1cmF0aW9uICsgc2lkeC5lYXJsaWVzdFByZXNlbnRhdGlvblRpbWUgLyBzaWR4LnRpbWVzY2FsZSk7XG4gICAgICAgIHNpZHhEdXJhdGlvbiA9IHNpZHhNYXhFbmQgLSBzaWR4TWluU3RhcnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzaWR4RHVyYXRpb24gJiYgaXNGaW5pdGVOdW1iZXIoc2lkeER1cmF0aW9uKSkge1xuICAgICAgcmV0dXJuIHNpZHhEdXJhdGlvbjtcbiAgICB9XG4gIH1cbiAgaWYgKHZpZGVvRHVyYXRpb24pIHtcbiAgICByZXR1cm4gdmlkZW9EdXJhdGlvbjtcbiAgfVxuICByZXR1cm4gYXVkaW9EdXJhdGlvbjtcbn1cblxuLypcbiAgRm9yIFJlZmVyZW5jZTpcbiAgYWxpZ25lZCg4KSBjbGFzcyBUcmFja1J1bkJveFxuICAgICAgICAgICBleHRlbmRzIEZ1bGxCb3go4oCYdHJ1buKAmSwgdmVyc2lvbiwgdHJfZmxhZ3MpIHtcbiAgICAgdW5zaWduZWQgaW50KDMyKSAgc2FtcGxlX2NvdW50O1xuICAgICAvLyB0aGUgZm9sbG93aW5nIGFyZSBvcHRpb25hbCBmaWVsZHNcbiAgICAgc2lnbmVkIGludCgzMikgZGF0YV9vZmZzZXQ7XG4gICAgIHVuc2lnbmVkIGludCgzMikgIGZpcnN0X3NhbXBsZV9mbGFncztcbiAgICAgLy8gYWxsIGZpZWxkcyBpbiB0aGUgZm9sbG93aW5nIGFycmF5IGFyZSBvcHRpb25hbFxuICAgICB7XG4gICAgICAgIHVuc2lnbmVkIGludCgzMikgIHNhbXBsZV9kdXJhdGlvbjtcbiAgICAgICAgdW5zaWduZWQgaW50KDMyKSAgc2FtcGxlX3NpemU7XG4gICAgICAgIHVuc2lnbmVkIGludCgzMikgIHNhbXBsZV9mbGFnc1xuICAgICAgICBpZiAodmVyc2lvbiA9PSAwKVxuICAgICAgICAgICB7IHVuc2lnbmVkIGludCgzMilcbiAgICAgICAgZWxzZVxuICAgICAgICAgICB7IHNpZ25lZCBpbnQoMzIpXG4gICAgIH1bIHNhbXBsZV9jb3VudCBdXG4gIH1cbiAqL1xuZnVuY3Rpb24gY29tcHV0ZVJhd0R1cmF0aW9uRnJvbVNhbXBsZXModHJ1bikge1xuICBjb25zdCBmbGFncyA9IHJlYWRVaW50MzIodHJ1biwgMCk7XG4gIC8vIEZsYWdzIGFyZSBhdCBvZmZzZXQgMCwgbm9uLW9wdGlvbmFsIHNhbXBsZV9jb3VudCBpcyBhdCBvZmZzZXQgNC4gVGhlcmVmb3JlIHdlIHN0YXJ0IDggYnl0ZXMgaW4uXG4gIC8vIEVhY2ggZmllbGQgaXMgYW4gaW50MzIsIHdoaWNoIGlzIDQgYnl0ZXNcbiAgbGV0IG9mZnNldCA9IDg7XG4gIC8vIGRhdGEtb2Zmc2V0LXByZXNlbnQgZmxhZ1xuICBpZiAoZmxhZ3MgJiAweDAwMDAwMSkge1xuICAgIG9mZnNldCArPSA0O1xuICB9XG4gIC8vIGZpcnN0LXNhbXBsZS1mbGFncy1wcmVzZW50IGZsYWdcbiAgaWYgKGZsYWdzICYgMHgwMDAwMDQpIHtcbiAgICBvZmZzZXQgKz0gNDtcbiAgfVxuICBsZXQgZHVyYXRpb24gPSAwO1xuICBjb25zdCBzYW1wbGVDb3VudCA9IHJlYWRVaW50MzIodHJ1biwgNCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2FtcGxlQ291bnQ7IGkrKykge1xuICAgIC8vIHNhbXBsZS1kdXJhdGlvbi1wcmVzZW50IGZsYWdcbiAgICBpZiAoZmxhZ3MgJiAweDAwMDEwMCkge1xuICAgICAgY29uc3Qgc2FtcGxlRHVyYXRpb24gPSByZWFkVWludDMyKHRydW4sIG9mZnNldCk7XG4gICAgICBkdXJhdGlvbiArPSBzYW1wbGVEdXJhdGlvbjtcbiAgICAgIG9mZnNldCArPSA0O1xuICAgIH1cbiAgICAvLyBzYW1wbGUtc2l6ZS1wcmVzZW50IGZsYWdcbiAgICBpZiAoZmxhZ3MgJiAweDAwMDIwMCkge1xuICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgfVxuICAgIC8vIHNhbXBsZS1mbGFncy1wcmVzZW50IGZsYWdcbiAgICBpZiAoZmxhZ3MgJiAweDAwMDQwMCkge1xuICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgfVxuICAgIC8vIHNhbXBsZS1jb21wb3NpdGlvbi10aW1lLW9mZnNldHMtcHJlc2VudCBmbGFnXG4gICAgaWYgKGZsYWdzICYgMHgwMDA4MDApIHtcbiAgICAgIG9mZnNldCArPSA0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZHVyYXRpb247XG59XG5mdW5jdGlvbiBvZmZzZXRTdGFydERUUyhpbml0RGF0YSwgZm1wNCwgdGltZU9mZnNldCkge1xuICBmaW5kQm94KGZtcDQsIFsnbW9vZicsICd0cmFmJ10pLmZvckVhY2godHJhZiA9PiB7XG4gICAgZmluZEJveCh0cmFmLCBbJ3RmaGQnXSkuZm9yRWFjaCh0ZmhkID0+IHtcbiAgICAgIC8vIGdldCB0aGUgdHJhY2sgaWQgZnJvbSB0aGUgdGZoZFxuICAgICAgY29uc3QgaWQgPSByZWFkVWludDMyKHRmaGQsIDQpO1xuICAgICAgY29uc3QgdHJhY2sgPSBpbml0RGF0YVtpZF07XG4gICAgICBpZiAoIXRyYWNrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGFzc3VtZSBhIDkwa0h6IGNsb2NrIGlmIG5vIHRpbWVzY2FsZSB3YXMgc3BlY2lmaWVkXG4gICAgICBjb25zdCB0aW1lc2NhbGUgPSB0cmFjay50aW1lc2NhbGUgfHwgOTBlMztcbiAgICAgIC8vIGdldCB0aGUgYmFzZSBtZWRpYSBkZWNvZGUgdGltZSBmcm9tIHRoZSB0ZmR0XG4gICAgICBmaW5kQm94KHRyYWYsIFsndGZkdCddKS5mb3JFYWNoKHRmZHQgPT4ge1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gdGZkdFswXTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGltZU9mZnNldCAqIHRpbWVzY2FsZTtcbiAgICAgICAgaWYgKG9mZnNldCkge1xuICAgICAgICAgIGxldCBiYXNlTWVkaWFEZWNvZGVUaW1lID0gcmVhZFVpbnQzMih0ZmR0LCA0KTtcbiAgICAgICAgICBpZiAodmVyc2lvbiA9PT0gMCkge1xuICAgICAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZSAtPSBvZmZzZXQ7XG4gICAgICAgICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lID0gTWF0aC5tYXgoYmFzZU1lZGlhRGVjb2RlVGltZSwgMCk7XG4gICAgICAgICAgICB3cml0ZVVpbnQzMih0ZmR0LCA0LCBiYXNlTWVkaWFEZWNvZGVUaW1lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZSAqPSBNYXRoLnBvdygyLCAzMik7XG4gICAgICAgICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lICs9IHJlYWRVaW50MzIodGZkdCwgOCk7XG4gICAgICAgICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lIC09IG9mZnNldDtcbiAgICAgICAgICAgIGJhc2VNZWRpYURlY29kZVRpbWUgPSBNYXRoLm1heChiYXNlTWVkaWFEZWNvZGVUaW1lLCAwKTtcbiAgICAgICAgICAgIGNvbnN0IHVwcGVyID0gTWF0aC5mbG9vcihiYXNlTWVkaWFEZWNvZGVUaW1lIC8gKFVJTlQzMl9NQVgkMSArIDEpKTtcbiAgICAgICAgICAgIGNvbnN0IGxvd2VyID0gTWF0aC5mbG9vcihiYXNlTWVkaWFEZWNvZGVUaW1lICUgKFVJTlQzMl9NQVgkMSArIDEpKTtcbiAgICAgICAgICAgIHdyaXRlVWludDMyKHRmZHQsIDQsIHVwcGVyKTtcbiAgICAgICAgICAgIHdyaXRlVWludDMyKHRmZHQsIDgsIGxvd2VyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLy8gVE9ETzogQ2hlY2sgaWYgdGhlIGxhc3QgbW9vZittZGF0IHBhaXIgaXMgcGFydCBvZiB0aGUgdmFsaWQgcmFuZ2VcbmZ1bmN0aW9uIHNlZ21lbnRWYWxpZFJhbmdlKGRhdGEpIHtcbiAgY29uc3Qgc2VnbWVudGVkUmFuZ2UgPSB7XG4gICAgdmFsaWQ6IG51bGwsXG4gICAgcmVtYWluZGVyOiBudWxsXG4gIH07XG4gIGNvbnN0IG1vb2ZzID0gZmluZEJveChkYXRhLCBbJ21vb2YnXSk7XG4gIGlmIChtb29mcy5sZW5ndGggPCAyKSB7XG4gICAgc2VnbWVudGVkUmFuZ2UucmVtYWluZGVyID0gZGF0YTtcbiAgICByZXR1cm4gc2VnbWVudGVkUmFuZ2U7XG4gIH1cbiAgY29uc3QgbGFzdCA9IG1vb2ZzW21vb2ZzLmxlbmd0aCAtIDFdO1xuICAvLyBPZmZzZXQgYnkgOCBieXRlczsgZmluZEJveCBvZmZzZXRzIHRoZSBzdGFydCBieSBhcyBtdWNoXG4gIHNlZ21lbnRlZFJhbmdlLnZhbGlkID0gc2xpY2VVaW50OChkYXRhLCAwLCBsYXN0LmJ5dGVPZmZzZXQgLSA4KTtcbiAgc2VnbWVudGVkUmFuZ2UucmVtYWluZGVyID0gc2xpY2VVaW50OChkYXRhLCBsYXN0LmJ5dGVPZmZzZXQgLSA4KTtcbiAgcmV0dXJuIHNlZ21lbnRlZFJhbmdlO1xufVxuZnVuY3Rpb24gYXBwZW5kVWludDhBcnJheShkYXRhMSwgZGF0YTIpIHtcbiAgY29uc3QgdGVtcCA9IG5ldyBVaW50OEFycmF5KGRhdGExLmxlbmd0aCArIGRhdGEyLmxlbmd0aCk7XG4gIHRlbXAuc2V0KGRhdGExKTtcbiAgdGVtcC5zZXQoZGF0YTIsIGRhdGExLmxlbmd0aCk7XG4gIHJldHVybiB0ZW1wO1xufVxuZnVuY3Rpb24gcGFyc2VTYW1wbGVzKHRpbWVPZmZzZXQsIHRyYWNrKSB7XG4gIGNvbnN0IHNlaVNhbXBsZXMgPSBbXTtcbiAgY29uc3QgdmlkZW9EYXRhID0gdHJhY2suc2FtcGxlcztcbiAgY29uc3QgdGltZXNjYWxlID0gdHJhY2sudGltZXNjYWxlO1xuICBjb25zdCB0cmFja0lkID0gdHJhY2suaWQ7XG4gIGxldCBpc0hFVkNGbGF2b3IgPSBmYWxzZTtcbiAgY29uc3QgbW9vZnMgPSBmaW5kQm94KHZpZGVvRGF0YSwgWydtb29mJ10pO1xuICBtb29mcy5tYXAobW9vZiA9PiB7XG4gICAgY29uc3QgbW9vZk9mZnNldCA9IG1vb2YuYnl0ZU9mZnNldCAtIDg7XG4gICAgY29uc3QgdHJhZnMgPSBmaW5kQm94KG1vb2YsIFsndHJhZiddKTtcbiAgICB0cmFmcy5tYXAodHJhZiA9PiB7XG4gICAgICAvLyBnZXQgdGhlIGJhc2UgbWVkaWEgZGVjb2RlIHRpbWUgZnJvbSB0aGUgdGZkdFxuICAgICAgY29uc3QgYmFzZVRpbWUgPSBmaW5kQm94KHRyYWYsIFsndGZkdCddKS5tYXAodGZkdCA9PiB7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSB0ZmR0WzBdO1xuICAgICAgICBsZXQgcmVzdWx0ID0gcmVhZFVpbnQzMih0ZmR0LCA0KTtcbiAgICAgICAgaWYgKHZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgICByZXN1bHQgKj0gTWF0aC5wb3coMiwgMzIpO1xuICAgICAgICAgIHJlc3VsdCArPSByZWFkVWludDMyKHRmZHQsIDgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgLyB0aW1lc2NhbGU7XG4gICAgICB9KVswXTtcbiAgICAgIGlmIChiYXNlVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRpbWVPZmZzZXQgPSBiYXNlVGltZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmaW5kQm94KHRyYWYsIFsndGZoZCddKS5tYXAodGZoZCA9PiB7XG4gICAgICAgIGNvbnN0IGlkID0gcmVhZFVpbnQzMih0ZmhkLCA0KTtcbiAgICAgICAgY29uc3QgdGZoZEZsYWdzID0gcmVhZFVpbnQzMih0ZmhkLCAwKSAmIDB4ZmZmZmZmO1xuICAgICAgICBjb25zdCBiYXNlRGF0YU9mZnNldFByZXNlbnQgPSAodGZoZEZsYWdzICYgMHgwMDAwMDEpICE9PSAwO1xuICAgICAgICBjb25zdCBzYW1wbGVEZXNjcmlwdGlvbkluZGV4UHJlc2VudCA9ICh0ZmhkRmxhZ3MgJiAweDAwMDAwMikgIT09IDA7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRTYW1wbGVEdXJhdGlvblByZXNlbnQgPSAodGZoZEZsYWdzICYgMHgwMDAwMDgpICE9PSAwO1xuICAgICAgICBsZXQgZGVmYXVsdFNhbXBsZUR1cmF0aW9uID0gMDtcbiAgICAgICAgY29uc3QgZGVmYXVsdFNhbXBsZVNpemVQcmVzZW50ID0gKHRmaGRGbGFncyAmIDB4MDAwMDEwKSAhPT0gMDtcbiAgICAgICAgbGV0IGRlZmF1bHRTYW1wbGVTaXplID0gMDtcbiAgICAgICAgY29uc3QgZGVmYXVsdFNhbXBsZUZsYWdzUHJlc2VudCA9ICh0ZmhkRmxhZ3MgJiAweDAwMDAyMCkgIT09IDA7XG4gICAgICAgIGxldCB0ZmhkT2Zmc2V0ID0gODtcbiAgICAgICAgaWYgKGlkID09PSB0cmFja0lkKSB7XG4gICAgICAgICAgaWYgKGJhc2VEYXRhT2Zmc2V0UHJlc2VudCkge1xuICAgICAgICAgICAgdGZoZE9mZnNldCArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2FtcGxlRGVzY3JpcHRpb25JbmRleFByZXNlbnQpIHtcbiAgICAgICAgICAgIHRmaGRPZmZzZXQgKz0gNDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRlZmF1bHRTYW1wbGVEdXJhdGlvblByZXNlbnQpIHtcbiAgICAgICAgICAgIGRlZmF1bHRTYW1wbGVEdXJhdGlvbiA9IHJlYWRVaW50MzIodGZoZCwgdGZoZE9mZnNldCk7XG4gICAgICAgICAgICB0ZmhkT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWZhdWx0U2FtcGxlU2l6ZVByZXNlbnQpIHtcbiAgICAgICAgICAgIGRlZmF1bHRTYW1wbGVTaXplID0gcmVhZFVpbnQzMih0ZmhkLCB0ZmhkT2Zmc2V0KTtcbiAgICAgICAgICAgIHRmaGRPZmZzZXQgKz0gNDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRlZmF1bHRTYW1wbGVGbGFnc1ByZXNlbnQpIHtcbiAgICAgICAgICAgIHRmaGRPZmZzZXQgKz0gNDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRyYWNrLnR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICAgIGlzSEVWQ0ZsYXZvciA9IGlzSEVWQyh0cmFjay5jb2RlYyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpbmRCb3godHJhZiwgWyd0cnVuJ10pLm1hcCh0cnVuID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZlcnNpb24gPSB0cnVuWzBdO1xuICAgICAgICAgICAgY29uc3QgZmxhZ3MgPSByZWFkVWludDMyKHRydW4sIDApICYgMHhmZmZmZmY7XG4gICAgICAgICAgICBjb25zdCBkYXRhT2Zmc2V0UHJlc2VudCA9IChmbGFncyAmIDB4MDAwMDAxKSAhPT0gMDtcbiAgICAgICAgICAgIGxldCBkYXRhT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0U2FtcGxlRmxhZ3NQcmVzZW50ID0gKGZsYWdzICYgMHgwMDAwMDQpICE9PSAwO1xuICAgICAgICAgICAgY29uc3Qgc2FtcGxlRHVyYXRpb25QcmVzZW50ID0gKGZsYWdzICYgMHgwMDAxMDApICE9PSAwO1xuICAgICAgICAgICAgbGV0IHNhbXBsZUR1cmF0aW9uID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZVNpemVQcmVzZW50ID0gKGZsYWdzICYgMHgwMDAyMDApICE9PSAwO1xuICAgICAgICAgICAgbGV0IHNhbXBsZVNpemUgPSAwO1xuICAgICAgICAgICAgY29uc3Qgc2FtcGxlRmxhZ3NQcmVzZW50ID0gKGZsYWdzICYgMHgwMDA0MDApICE9PSAwO1xuICAgICAgICAgICAgY29uc3Qgc2FtcGxlQ29tcG9zaXRpb25PZmZzZXRzUHJlc2VudCA9IChmbGFncyAmIDB4MDAwODAwKSAhPT0gMDtcbiAgICAgICAgICAgIGxldCBjb21wb3NpdGlvbk9mZnNldCA9IDA7XG4gICAgICAgICAgICBjb25zdCBzYW1wbGVDb3VudCA9IHJlYWRVaW50MzIodHJ1biwgNCk7XG4gICAgICAgICAgICBsZXQgdHJ1bk9mZnNldCA9IDg7IC8vIHBhc3QgdmVyc2lvbiwgZmxhZ3MsIGFuZCBzYW1wbGUgY291bnRcblxuICAgICAgICAgICAgaWYgKGRhdGFPZmZzZXRQcmVzZW50KSB7XG4gICAgICAgICAgICAgIGRhdGFPZmZzZXQgPSByZWFkVWludDMyKHRydW4sIHRydW5PZmZzZXQpO1xuICAgICAgICAgICAgICB0cnVuT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlyc3RTYW1wbGVGbGFnc1ByZXNlbnQpIHtcbiAgICAgICAgICAgICAgdHJ1bk9mZnNldCArPSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNhbXBsZU9mZnNldCA9IGRhdGFPZmZzZXQgKyBtb29mT2Zmc2V0O1xuICAgICAgICAgICAgZm9yIChsZXQgaXggPSAwOyBpeCA8IHNhbXBsZUNvdW50OyBpeCsrKSB7XG4gICAgICAgICAgICAgIGlmIChzYW1wbGVEdXJhdGlvblByZXNlbnQpIHtcbiAgICAgICAgICAgICAgICBzYW1wbGVEdXJhdGlvbiA9IHJlYWRVaW50MzIodHJ1biwgdHJ1bk9mZnNldCk7XG4gICAgICAgICAgICAgICAgdHJ1bk9mZnNldCArPSA0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNhbXBsZUR1cmF0aW9uID0gZGVmYXVsdFNhbXBsZUR1cmF0aW9uO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzYW1wbGVTaXplUHJlc2VudCkge1xuICAgICAgICAgICAgICAgIHNhbXBsZVNpemUgPSByZWFkVWludDMyKHRydW4sIHRydW5PZmZzZXQpO1xuICAgICAgICAgICAgICAgIHRydW5PZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzYW1wbGVTaXplID0gZGVmYXVsdFNhbXBsZVNpemU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHNhbXBsZUZsYWdzUHJlc2VudCkge1xuICAgICAgICAgICAgICAgIHRydW5PZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoc2FtcGxlQ29tcG9zaXRpb25PZmZzZXRzUHJlc2VudCkge1xuICAgICAgICAgICAgICAgIGlmICh2ZXJzaW9uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBjb21wb3NpdGlvbk9mZnNldCA9IHJlYWRVaW50MzIodHJ1biwgdHJ1bk9mZnNldCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNvbXBvc2l0aW9uT2Zmc2V0ID0gcmVhZFNpbnQzMih0cnVuLCB0cnVuT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ1bk9mZnNldCArPSA0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0cmFjay50eXBlID09PSBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU8pIHtcbiAgICAgICAgICAgICAgICBsZXQgbmFsdVRvdGFsU2l6ZSA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5hbHVUb3RhbFNpemUgPCBzYW1wbGVTaXplKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBuYWx1U2l6ZSA9IHJlYWRVaW50MzIodmlkZW9EYXRhLCBzYW1wbGVPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgc2FtcGxlT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNTRUlNZXNzYWdlKGlzSEVWQ0ZsYXZvciwgdmlkZW9EYXRhW3NhbXBsZU9mZnNldF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB2aWRlb0RhdGEuc3ViYXJyYXkoc2FtcGxlT2Zmc2V0LCBzYW1wbGVPZmZzZXQgKyBuYWx1U2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU0VJTWVzc2FnZUZyb21OQUx1KGRhdGEsIGlzSEVWQ0ZsYXZvciA/IDIgOiAxLCB0aW1lT2Zmc2V0ICsgY29tcG9zaXRpb25PZmZzZXQgLyB0aW1lc2NhbGUsIHNlaVNhbXBsZXMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgc2FtcGxlT2Zmc2V0ICs9IG5hbHVTaXplO1xuICAgICAgICAgICAgICAgICAgbmFsdVRvdGFsU2l6ZSArPSBuYWx1U2l6ZSArIDQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRpbWVPZmZzZXQgKz0gc2FtcGxlRHVyYXRpb24gLyB0aW1lc2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHNlaVNhbXBsZXM7XG59XG5mdW5jdGlvbiBpc0hFVkMoY29kZWMpIHtcbiAgaWYgKCFjb2RlYykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBkZWxpbWl0ID0gY29kZWMuaW5kZXhPZignLicpO1xuICBjb25zdCBiYXNlQ29kZWMgPSBkZWxpbWl0IDwgMCA/IGNvZGVjIDogY29kZWMuc3Vic3RyaW5nKDAsIGRlbGltaXQpO1xuICByZXR1cm4gYmFzZUNvZGVjID09PSAnaHZjMScgfHwgYmFzZUNvZGVjID09PSAnaGV2MScgfHxcbiAgLy8gRG9sYnkgVmlzaW9uXG4gIGJhc2VDb2RlYyA9PT0gJ2R2aDEnIHx8IGJhc2VDb2RlYyA9PT0gJ2R2aGUnO1xufVxuZnVuY3Rpb24gaXNTRUlNZXNzYWdlKGlzSEVWQ0ZsYXZvciwgbmFsdUhlYWRlcikge1xuICBpZiAoaXNIRVZDRmxhdm9yKSB7XG4gICAgY29uc3QgbmFsdVR5cGUgPSBuYWx1SGVhZGVyID4+IDEgJiAweDNmO1xuICAgIHJldHVybiBuYWx1VHlwZSA9PT0gMzkgfHwgbmFsdVR5cGUgPT09IDQwO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG5hbHVUeXBlID0gbmFsdUhlYWRlciAmIDB4MWY7XG4gICAgcmV0dXJuIG5hbHVUeXBlID09PSA2O1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZVNFSU1lc3NhZ2VGcm9tTkFMdSh1bmVzY2FwZWREYXRhLCBoZWFkZXJTaXplLCBwdHMsIHNhbXBsZXMpIHtcbiAgY29uc3QgZGF0YSA9IGRpc2NhcmRFUEIodW5lc2NhcGVkRGF0YSk7XG4gIGxldCBzZWlQdHIgPSAwO1xuICAvLyBza2lwIG5hbCBoZWFkZXJcbiAgc2VpUHRyICs9IGhlYWRlclNpemU7XG4gIGxldCBwYXlsb2FkVHlwZSA9IDA7XG4gIGxldCBwYXlsb2FkU2l6ZSA9IDA7XG4gIGxldCBiID0gMDtcbiAgd2hpbGUgKHNlaVB0ciA8IGRhdGEubGVuZ3RoKSB7XG4gICAgcGF5bG9hZFR5cGUgPSAwO1xuICAgIGRvIHtcbiAgICAgIGlmIChzZWlQdHIgPj0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBiID0gZGF0YVtzZWlQdHIrK107XG4gICAgICBwYXlsb2FkVHlwZSArPSBiO1xuICAgIH0gd2hpbGUgKGIgPT09IDB4ZmYpO1xuXG4gICAgLy8gUGFyc2UgcGF5bG9hZCBzaXplLlxuICAgIHBheWxvYWRTaXplID0gMDtcbiAgICBkbyB7XG4gICAgICBpZiAoc2VpUHRyID49IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYiA9IGRhdGFbc2VpUHRyKytdO1xuICAgICAgcGF5bG9hZFNpemUgKz0gYjtcbiAgICB9IHdoaWxlIChiID09PSAweGZmKTtcbiAgICBjb25zdCBsZWZ0T3ZlciA9IGRhdGEubGVuZ3RoIC0gc2VpUHRyO1xuICAgIC8vIENyZWF0ZSBhIHZhcmlhYmxlIHRvIHByb2Nlc3MgdGhlIHBheWxvYWRcbiAgICBsZXQgcGF5UHRyID0gc2VpUHRyO1xuXG4gICAgLy8gSW5jcmVtZW50IHRoZSBzZWlQdHIgdG8gdGhlIGVuZCBvZiB0aGUgcGF5bG9hZFxuICAgIGlmIChwYXlsb2FkU2l6ZSA8IGxlZnRPdmVyKSB7XG4gICAgICBzZWlQdHIgKz0gcGF5bG9hZFNpemU7XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkU2l6ZSA+IGxlZnRPdmVyKSB7XG4gICAgICAvLyBTb21lIHR5cGUgb2YgY29ycnVwdGlvbiBoYXMgaGFwcGVuZWQ/XG4gICAgICBsb2dnZXIuZXJyb3IoYE1hbGZvcm1lZCBTRUkgcGF5bG9hZC4gJHtwYXlsb2FkU2l6ZX0gaXMgdG9vIHNtYWxsLCBvbmx5ICR7bGVmdE92ZXJ9IGJ5dGVzIGxlZnQgdG8gcGFyc2UuYCk7XG4gICAgICAvLyBXZSBtaWdodCBiZSBhYmxlIHRvIHBhcnNlIHNvbWUgZGF0YSwgYnV0IGxldCdzIGJlIHNhZmUgYW5kIGlnbm9yZSBpdC5cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAocGF5bG9hZFR5cGUgPT09IDQpIHtcbiAgICAgIGNvbnN0IGNvdW50cnlDb2RlID0gZGF0YVtwYXlQdHIrK107XG4gICAgICBpZiAoY291bnRyeUNvZGUgPT09IDE4MSkge1xuICAgICAgICBjb25zdCBwcm92aWRlckNvZGUgPSByZWFkVWludDE2KGRhdGEsIHBheVB0cik7XG4gICAgICAgIHBheVB0ciArPSAyO1xuICAgICAgICBpZiAocHJvdmlkZXJDb2RlID09PSA0OSkge1xuICAgICAgICAgIGNvbnN0IHVzZXJTdHJ1Y3R1cmUgPSByZWFkVWludDMyKGRhdGEsIHBheVB0cik7XG4gICAgICAgICAgcGF5UHRyICs9IDQ7XG4gICAgICAgICAgaWYgKHVzZXJTdHJ1Y3R1cmUgPT09IDB4NDc0MTM5MzQpIHtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJEYXRhVHlwZSA9IGRhdGFbcGF5UHRyKytdO1xuXG4gICAgICAgICAgICAvLyBSYXcgQ0VBLTYwOCBieXRlcyB3cmFwcGVkIGluIENFQS03MDggcGFja2V0XG4gICAgICAgICAgICBpZiAodXNlckRhdGFUeXBlID09PSAzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IGRhdGFbcGF5UHRyKytdO1xuICAgICAgICAgICAgICBjb25zdCB0b3RhbENDcyA9IDB4MWYgJiBmaXJzdEJ5dGU7XG4gICAgICAgICAgICAgIGNvbnN0IGVuYWJsZWQgPSAweDQwICYgZmlyc3RCeXRlO1xuICAgICAgICAgICAgICBjb25zdCB0b3RhbEJ5dGVzID0gZW5hYmxlZCA/IDIgKyB0b3RhbENDcyAqIDMgOiAwO1xuICAgICAgICAgICAgICBjb25zdCBieXRlQXJyYXkgPSBuZXcgVWludDhBcnJheSh0b3RhbEJ5dGVzKTtcbiAgICAgICAgICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBieXRlQXJyYXlbMF0gPSBmaXJzdEJ5dGU7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0b3RhbEJ5dGVzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGJ5dGVBcnJheVtpXSA9IGRhdGFbcGF5UHRyKytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzYW1wbGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IHVzZXJEYXRhVHlwZSxcbiAgICAgICAgICAgICAgICBwYXlsb2FkVHlwZSxcbiAgICAgICAgICAgICAgICBwdHMsXG4gICAgICAgICAgICAgICAgYnl0ZXM6IGJ5dGVBcnJheVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBheWxvYWRUeXBlID09PSA1KSB7XG4gICAgICBpZiAocGF5bG9hZFNpemUgPiAxNikge1xuICAgICAgICBjb25zdCB1dWlkU3RyQXJyYXkgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgX2IgPSBkYXRhW3BheVB0cisrXS50b1N0cmluZygxNik7XG4gICAgICAgICAgdXVpZFN0ckFycmF5LnB1c2goX2IubGVuZ3RoID09IDEgPyAnMCcgKyBfYiA6IF9iKTtcbiAgICAgICAgICBpZiAoaSA9PT0gMyB8fCBpID09PSA1IHx8IGkgPT09IDcgfHwgaSA9PT0gOSkge1xuICAgICAgICAgICAgdXVpZFN0ckFycmF5LnB1c2goJy0nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuZ3RoID0gcGF5bG9hZFNpemUgLSAxNjtcbiAgICAgICAgY29uc3QgdXNlckRhdGFCeXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB1c2VyRGF0YUJ5dGVzW2ldID0gZGF0YVtwYXlQdHIrK107XG4gICAgICAgIH1cbiAgICAgICAgc2FtcGxlcy5wdXNoKHtcbiAgICAgICAgICBwYXlsb2FkVHlwZSxcbiAgICAgICAgICBwdHMsXG4gICAgICAgICAgdXVpZDogdXVpZFN0ckFycmF5LmpvaW4oJycpLFxuICAgICAgICAgIHVzZXJEYXRhOiB1dGY4QXJyYXlUb1N0cih1c2VyRGF0YUJ5dGVzKSxcbiAgICAgICAgICB1c2VyRGF0YUJ5dGVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIHJlbW92ZSBFbXVsYXRpb24gUHJldmVudGlvbiBieXRlcyBmcm9tIGEgUkJTUFxuICovXG5mdW5jdGlvbiBkaXNjYXJkRVBCKGRhdGEpIHtcbiAgY29uc3QgbGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoO1xuICBjb25zdCBFUEJQb3NpdGlvbnMgPSBbXTtcbiAgbGV0IGkgPSAxO1xuXG4gIC8vIEZpbmQgYWxsIGBFbXVsYXRpb24gUHJldmVudGlvbiBCeXRlc2BcbiAgd2hpbGUgKGkgPCBsZW5ndGggLSAyKSB7XG4gICAgaWYgKGRhdGFbaV0gPT09IDAgJiYgZGF0YVtpICsgMV0gPT09IDAgJiYgZGF0YVtpICsgMl0gPT09IDB4MDMpIHtcbiAgICAgIEVQQlBvc2l0aW9ucy5wdXNoKGkgKyAyKTtcbiAgICAgIGkgKz0gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgaSsrO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIG5vIEVtdWxhdGlvbiBQcmV2ZW50aW9uIEJ5dGVzIHdlcmUgZm91bmQganVzdCByZXR1cm4gdGhlIG9yaWdpbmFsXG4gIC8vIGFycmF5XG4gIGlmIChFUEJQb3NpdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICAvLyBDcmVhdGUgYSBuZXcgYXJyYXkgdG8gaG9sZCB0aGUgTkFMIHVuaXQgZGF0YVxuICBjb25zdCBuZXdMZW5ndGggPSBsZW5ndGggLSBFUEJQb3NpdGlvbnMubGVuZ3RoO1xuICBjb25zdCBuZXdEYXRhID0gbmV3IFVpbnQ4QXJyYXkobmV3TGVuZ3RoKTtcbiAgbGV0IHNvdXJjZUluZGV4ID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IG5ld0xlbmd0aDsgc291cmNlSW5kZXgrKywgaSsrKSB7XG4gICAgaWYgKHNvdXJjZUluZGV4ID09PSBFUEJQb3NpdGlvbnNbMF0pIHtcbiAgICAgIC8vIFNraXAgdGhpcyBieXRlXG4gICAgICBzb3VyY2VJbmRleCsrO1xuICAgICAgLy8gUmVtb3ZlIHRoaXMgcG9zaXRpb24gaW5kZXhcbiAgICAgIEVQQlBvc2l0aW9ucy5zaGlmdCgpO1xuICAgIH1cbiAgICBuZXdEYXRhW2ldID0gZGF0YVtzb3VyY2VJbmRleF07XG4gIH1cbiAgcmV0dXJuIG5ld0RhdGE7XG59XG5mdW5jdGlvbiBwYXJzZUVtc2coZGF0YSkge1xuICBjb25zdCB2ZXJzaW9uID0gZGF0YVswXTtcbiAgbGV0IHNjaGVtZUlkVXJpID0gJyc7XG4gIGxldCB2YWx1ZSA9ICcnO1xuICBsZXQgdGltZVNjYWxlID0gMDtcbiAgbGV0IHByZXNlbnRhdGlvblRpbWVEZWx0YSA9IDA7XG4gIGxldCBwcmVzZW50YXRpb25UaW1lID0gMDtcbiAgbGV0IGV2ZW50RHVyYXRpb24gPSAwO1xuICBsZXQgaWQgPSAwO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICB3aGlsZSAoYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpICE9PSAnXFwwJykge1xuICAgICAgc2NoZW1lSWRVcmkgKz0gYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpO1xuICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgfVxuICAgIHNjaGVtZUlkVXJpICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICBvZmZzZXQgKz0gMTtcbiAgICB3aGlsZSAoYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpICE9PSAnXFwwJykge1xuICAgICAgdmFsdWUgKz0gYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpO1xuICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgfVxuICAgIHZhbHVlICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICBvZmZzZXQgKz0gMTtcbiAgICB0aW1lU2NhbGUgPSByZWFkVWludDMyKGRhdGEsIDEyKTtcbiAgICBwcmVzZW50YXRpb25UaW1lRGVsdGEgPSByZWFkVWludDMyKGRhdGEsIDE2KTtcbiAgICBldmVudER1cmF0aW9uID0gcmVhZFVpbnQzMihkYXRhLCAyMCk7XG4gICAgaWQgPSByZWFkVWludDMyKGRhdGEsIDI0KTtcbiAgICBvZmZzZXQgPSAyODtcbiAgfSBlbHNlIGlmICh2ZXJzaW9uID09PSAxKSB7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgdGltZVNjYWxlID0gcmVhZFVpbnQzMihkYXRhLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0O1xuICAgIGNvbnN0IGxlZnRQcmVzZW50YXRpb25UaW1lID0gcmVhZFVpbnQzMihkYXRhLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0O1xuICAgIGNvbnN0IHJpZ2h0UHJlc2VudGF0aW9uVGltZSA9IHJlYWRVaW50MzIoZGF0YSwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICBwcmVzZW50YXRpb25UaW1lID0gMiAqKiAzMiAqIGxlZnRQcmVzZW50YXRpb25UaW1lICsgcmlnaHRQcmVzZW50YXRpb25UaW1lO1xuICAgIGlmICghaXNTYWZlSW50ZWdlcihwcmVzZW50YXRpb25UaW1lKSkge1xuICAgICAgcHJlc2VudGF0aW9uVGltZSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgbG9nZ2VyLndhcm4oJ1ByZXNlbnRhdGlvbiB0aW1lIGV4Y2VlZHMgc2FmZSBpbnRlZ2VyIGxpbWl0IGFuZCB3cmFwcGVkIHRvIG1heCBzYWZlIGludGVnZXIgaW4gcGFyc2luZyBlbXNnIGJveCcpO1xuICAgIH1cbiAgICBldmVudER1cmF0aW9uID0gcmVhZFVpbnQzMihkYXRhLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0O1xuICAgIGlkID0gcmVhZFVpbnQzMihkYXRhLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0O1xuICAgIHdoaWxlIChiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSkgIT09ICdcXDAnKSB7XG4gICAgICBzY2hlbWVJZFVyaSArPSBiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSk7XG4gICAgICBvZmZzZXQgKz0gMTtcbiAgICB9XG4gICAgc2NoZW1lSWRVcmkgKz0gYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpO1xuICAgIG9mZnNldCArPSAxO1xuICAgIHdoaWxlIChiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSkgIT09ICdcXDAnKSB7XG4gICAgICB2YWx1ZSArPSBiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSk7XG4gICAgICBvZmZzZXQgKz0gMTtcbiAgICB9XG4gICAgdmFsdWUgKz0gYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpO1xuICAgIG9mZnNldCArPSAxO1xuICB9XG4gIGNvbnN0IHBheWxvYWQgPSBkYXRhLnN1YmFycmF5KG9mZnNldCwgZGF0YS5ieXRlTGVuZ3RoKTtcbiAgcmV0dXJuIHtcbiAgICBzY2hlbWVJZFVyaSxcbiAgICB2YWx1ZSxcbiAgICB0aW1lU2NhbGUsXG4gICAgcHJlc2VudGF0aW9uVGltZSxcbiAgICBwcmVzZW50YXRpb25UaW1lRGVsdGEsXG4gICAgZXZlbnREdXJhdGlvbixcbiAgICBpZCxcbiAgICBwYXlsb2FkXG4gIH07XG59XG5mdW5jdGlvbiBtcDRCb3godHlwZSwgLi4ucGF5bG9hZCkge1xuICBjb25zdCBsZW4gPSBwYXlsb2FkLmxlbmd0aDtcbiAgbGV0IHNpemUgPSA4O1xuICBsZXQgaSA9IGxlbjtcbiAgd2hpbGUgKGktLSkge1xuICAgIHNpemUgKz0gcGF5bG9hZFtpXS5ieXRlTGVuZ3RoO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICByZXN1bHRbMF0gPSBzaXplID4+IDI0ICYgMHhmZjtcbiAgcmVzdWx0WzFdID0gc2l6ZSA+PiAxNiAmIDB4ZmY7XG4gIHJlc3VsdFsyXSA9IHNpemUgPj4gOCAmIDB4ZmY7XG4gIHJlc3VsdFszXSA9IHNpemUgJiAweGZmO1xuICByZXN1bHQuc2V0KHR5cGUsIDQpO1xuICBmb3IgKGkgPSAwLCBzaXplID0gODsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzdWx0LnNldChwYXlsb2FkW2ldLCBzaXplKTtcbiAgICBzaXplICs9IHBheWxvYWRbaV0uYnl0ZUxlbmd0aDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbXA0cHNzaChzeXN0ZW1JZCwga2V5aWRzLCBkYXRhKSB7XG4gIGlmIChzeXN0ZW1JZC5ieXRlTGVuZ3RoICE9PSAxNikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHN5c3RlbSBpZCcpO1xuICB9XG4gIGxldCB2ZXJzaW9uO1xuICBsZXQga2lkcztcbiAgaWYgKGtleWlkcykge1xuICAgIHZlcnNpb24gPSAxO1xuICAgIGtpZHMgPSBuZXcgVWludDhBcnJheShrZXlpZHMubGVuZ3RoICogMTYpO1xuICAgIGZvciAobGV0IGl4ID0gMDsgaXggPCBrZXlpZHMubGVuZ3RoOyBpeCsrKSB7XG4gICAgICBjb25zdCBrID0ga2V5aWRzW2l4XTsgLy8gdWludDhhcnJheVxuICAgICAgaWYgKGsuYnl0ZUxlbmd0aCAhPT0gMTYpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQga2V5Jyk7XG4gICAgICB9XG4gICAgICBraWRzLnNldChrLCBpeCAqIDE2KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmVyc2lvbiA9IDA7XG4gICAga2lkcyA9IG5ldyBVaW50OEFycmF5KCk7XG4gIH1cbiAgbGV0IGtpZENvdW50O1xuICBpZiAodmVyc2lvbiA+IDApIHtcbiAgICBraWRDb3VudCA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIGlmIChrZXlpZHMubGVuZ3RoID4gMCkge1xuICAgICAgbmV3IERhdGFWaWV3KGtpZENvdW50LmJ1ZmZlcikuc2V0VWludDMyKDAsIGtleWlkcy5sZW5ndGgsIGZhbHNlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAga2lkQ291bnQgPSBuZXcgVWludDhBcnJheSgpO1xuICB9XG4gIGNvbnN0IGRhdGFTaXplID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gIGlmIChkYXRhICYmIGRhdGEuYnl0ZUxlbmd0aCA+IDApIHtcbiAgICBuZXcgRGF0YVZpZXcoZGF0YVNpemUuYnVmZmVyKS5zZXRVaW50MzIoMCwgZGF0YS5ieXRlTGVuZ3RoLCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIG1wNEJveChbMTEyLCAxMTUsIDExNSwgMTA0XSwgbmV3IFVpbnQ4QXJyYXkoW3ZlcnNpb24sIDB4MDAsIDB4MDAsIDB4MDAgLy8gRmxhZ3NcbiAgXSksIHN5c3RlbUlkLFxuICAvLyAxNiBieXRlc1xuICBraWRDb3VudCwga2lkcywgZGF0YVNpemUsIGRhdGEgfHwgbmV3IFVpbnQ4QXJyYXkoKSk7XG59XG5mdW5jdGlvbiBwYXJzZVBzc2goaW5pdERhdGEpIHtcbiAgaWYgKCEoaW5pdERhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgaW5pdERhdGEuYnl0ZUxlbmd0aCA8IDMyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHZlcnNpb246IDAsXG4gICAgc3lzdGVtSWQ6ICcnLFxuICAgIGtpZHM6IG51bGwsXG4gICAgZGF0YTogbnVsbFxuICB9O1xuICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGluaXREYXRhKTtcbiAgY29uc3QgYm94U2l6ZSA9IHZpZXcuZ2V0VWludDMyKDApO1xuICBpZiAoaW5pdERhdGEuYnl0ZUxlbmd0aCAhPT0gYm94U2l6ZSAmJiBib3hTaXplID4gNDQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCB0eXBlID0gdmlldy5nZXRVaW50MzIoNCk7XG4gIGlmICh0eXBlICE9PSAweDcwNzM3MzY4KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmVzdWx0LnZlcnNpb24gPSB2aWV3LmdldFVpbnQzMig4KSA+Pj4gMjQ7XG4gIGlmIChyZXN1bHQudmVyc2lvbiA+IDEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXN1bHQuc3lzdGVtSWQgPSBIZXguaGV4RHVtcChuZXcgVWludDhBcnJheShpbml0RGF0YSwgMTIsIDE2KSk7XG4gIGNvbnN0IGRhdGFTaXplT3JLaWRDb3VudCA9IHZpZXcuZ2V0VWludDMyKDI4KTtcbiAgaWYgKHJlc3VsdC52ZXJzaW9uID09PSAwKSB7XG4gICAgaWYgKGJveFNpemUgLSAzMiA8IGRhdGFTaXplT3JLaWRDb3VudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5kYXRhID0gbmV3IFVpbnQ4QXJyYXkoaW5pdERhdGEsIDMyLCBkYXRhU2l6ZU9yS2lkQ291bnQpO1xuICB9IGVsc2UgaWYgKHJlc3VsdC52ZXJzaW9uID09PSAxKSB7XG4gICAgcmVzdWx0LmtpZHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFTaXplT3JLaWRDb3VudDsgaSsrKSB7XG4gICAgICByZXN1bHQua2lkcy5wdXNoKG5ldyBVaW50OEFycmF5KGluaXREYXRhLCAzMiArIGkgKiAxNiwgMTYpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubGV0IGtleVVyaVRvS2V5SWRNYXAgPSB7fTtcbmNsYXNzIExldmVsS2V5IHtcbiAgc3RhdGljIGNsZWFyS2V5VXJpVG9LZXlJZE1hcCgpIHtcbiAgICBrZXlVcmlUb0tleUlkTWFwID0ge307XG4gIH1cbiAgY29uc3RydWN0b3IobWV0aG9kLCB1cmksIGZvcm1hdCwgZm9ybWF0dmVyc2lvbnMgPSBbMV0sIGl2ID0gbnVsbCkge1xuICAgIHRoaXMudXJpID0gdm9pZCAwO1xuICAgIHRoaXMubWV0aG9kID0gdm9pZCAwO1xuICAgIHRoaXMua2V5Rm9ybWF0ID0gdm9pZCAwO1xuICAgIHRoaXMua2V5Rm9ybWF0VmVyc2lvbnMgPSB2b2lkIDA7XG4gICAgdGhpcy5lbmNyeXB0ZWQgPSB2b2lkIDA7XG4gICAgdGhpcy5pc0NvbW1vbkVuY3J5cHRpb24gPSB2b2lkIDA7XG4gICAgdGhpcy5pdiA9IG51bGw7XG4gICAgdGhpcy5rZXkgPSBudWxsO1xuICAgIHRoaXMua2V5SWQgPSBudWxsO1xuICAgIHRoaXMucHNzaCA9IG51bGw7XG4gICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgdGhpcy51cmkgPSB1cmk7XG4gICAgdGhpcy5rZXlGb3JtYXQgPSBmb3JtYXQ7XG4gICAgdGhpcy5rZXlGb3JtYXRWZXJzaW9ucyA9IGZvcm1hdHZlcnNpb25zO1xuICAgIHRoaXMuaXYgPSBpdjtcbiAgICB0aGlzLmVuY3J5cHRlZCA9IG1ldGhvZCA/IG1ldGhvZCAhPT0gJ05PTkUnIDogZmFsc2U7XG4gICAgdGhpcy5pc0NvbW1vbkVuY3J5cHRpb24gPSB0aGlzLmVuY3J5cHRlZCAmJiBtZXRob2QgIT09ICdBRVMtMTI4JztcbiAgfVxuICBpc1N1cHBvcnRlZCgpIHtcbiAgICAvLyBJZiBpdCdzIFNlZ21lbnQgZW5jcnlwdGlvbiBvciBObyBlbmNyeXB0aW9uLCBqdXN0IHNlbGVjdCB0aGF0IGtleSBzeXN0ZW1cbiAgICBpZiAodGhpcy5tZXRob2QpIHtcbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gJ0FFUy0xMjgnIHx8IHRoaXMubWV0aG9kID09PSAnTk9ORScpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5rZXlGb3JtYXQgPT09ICdpZGVudGl0eScpIHtcbiAgICAgICAgLy8gTWFpbnRhaW4gc3VwcG9ydCBmb3IgY2xlYXIgU0FNUExFLUFFUyB3aXRoIE1QRUctMyBUU1xuICAgICAgICByZXR1cm4gdGhpcy5tZXRob2QgPT09ICdTQU1QTEUtQUVTJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5rZXlGb3JtYXQpIHtcbiAgICAgICAgICBjYXNlIEtleVN5c3RlbUZvcm1hdHMuRkFJUlBMQVk6XG4gICAgICAgICAgY2FzZSBLZXlTeXN0ZW1Gb3JtYXRzLldJREVWSU5FOlxuICAgICAgICAgIGNhc2UgS2V5U3lzdGVtRm9ybWF0cy5QTEFZUkVBRFk6XG4gICAgICAgICAgY2FzZSBLZXlTeXN0ZW1Gb3JtYXRzLkNMRUFSS0VZOlxuICAgICAgICAgICAgcmV0dXJuIFsnSVNPLTIzMDAxLTcnLCAnU0FNUExFLUFFUycsICdTQU1QTEUtQUVTLUNFTkMnLCAnU0FNUExFLUFFUy1DVFInXS5pbmRleE9mKHRoaXMubWV0aG9kKSAhPT0gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGdldERlY3J5cHREYXRhKHNuKSB7XG4gICAgaWYgKCF0aGlzLmVuY3J5cHRlZCB8fCAhdGhpcy51cmkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5tZXRob2QgPT09ICdBRVMtMTI4JyAmJiB0aGlzLnVyaSAmJiAhdGhpcy5pdikge1xuICAgICAgaWYgKHR5cGVvZiBzbiAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgLy8gV2UgYXJlIGZldGNoaW5nIGRlY3J5cHRpb24gZGF0YSBmb3IgYSBpbml0aWFsaXphdGlvbiBzZWdtZW50XG4gICAgICAgIC8vIElmIHRoZSBzZWdtZW50IHdhcyBlbmNyeXB0ZWQgd2l0aCBBRVMtMTI4XG4gICAgICAgIC8vIEl0IG11c3QgaGF2ZSBhbiBJViBkZWZpbmVkLiBXZSBjYW5ub3Qgc3Vic3RpdHV0ZSB0aGUgU2VnbWVudCBOdW1iZXIgaW4uXG4gICAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gJ0FFUy0xMjgnICYmICF0aGlzLml2KSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYG1pc3NpbmcgSVYgZm9yIGluaXRpYWxpemF0aW9uIHNlZ21lbnQgd2l0aCBtZXRob2Q9XCIke3RoaXMubWV0aG9kfVwiIC0gY29tcGxpYW5jZSBpc3N1ZWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV4cGxpY2l0bHkgc2V0IHNuIHRvIHJlc3VsdGluZyB2YWx1ZSBmcm9tIGltcGxpY2l0IGNvbnZlcnNpb25zICdpbml0U2VnbWVudCcgdmFsdWVzIGZvciBJViBnZW5lcmF0aW9uLlxuICAgICAgICBzbiA9IDA7XG4gICAgICB9XG4gICAgICBjb25zdCBpdiA9IGNyZWF0ZUluaXRpYWxpemF0aW9uVmVjdG9yKHNuKTtcbiAgICAgIGNvbnN0IGRlY3J5cHRkYXRhID0gbmV3IExldmVsS2V5KHRoaXMubWV0aG9kLCB0aGlzLnVyaSwgJ2lkZW50aXR5JywgdGhpcy5rZXlGb3JtYXRWZXJzaW9ucywgaXYpO1xuICAgICAgcmV0dXJuIGRlY3J5cHRkYXRhO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUga2V5SWQgaWYgcG9zc2libGVcbiAgICBjb25zdCBrZXlCeXRlcyA9IGNvbnZlcnREYXRhVXJpVG9BcnJheUJ5dGVzKHRoaXMudXJpKTtcbiAgICBpZiAoa2V5Qnl0ZXMpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5rZXlGb3JtYXQpIHtcbiAgICAgICAgY2FzZSBLZXlTeXN0ZW1Gb3JtYXRzLldJREVWSU5FOlxuICAgICAgICAgIHRoaXMucHNzaCA9IGtleUJ5dGVzO1xuICAgICAgICAgIC8vIEluIGNhc2Ugb2Ygd2lkZXZpbmUga2V5SUQgaXMgZW1iZWRkZWQgaW4gUFNTSCBib3guIFJlYWQgS2V5IElELlxuICAgICAgICAgIGlmIChrZXlCeXRlcy5sZW5ndGggPj0gMjIpIHtcbiAgICAgICAgICAgIHRoaXMua2V5SWQgPSBrZXlCeXRlcy5zdWJhcnJheShrZXlCeXRlcy5sZW5ndGggLSAyMiwga2V5Qnl0ZXMubGVuZ3RoIC0gNik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEtleVN5c3RlbUZvcm1hdHMuUExBWVJFQURZOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IFBsYXlSZWFkeUtleVN5c3RlbVVVSUQgPSBuZXcgVWludDhBcnJheShbMHg5YSwgMHgwNCwgMHhmMCwgMHg3OSwgMHg5OCwgMHg0MCwgMHg0MiwgMHg4NiwgMHhhYiwgMHg5MiwgMHhlNiwgMHg1YiwgMHhlMCwgMHg4OCwgMHg1ZiwgMHg5NV0pO1xuICAgICAgICAgICAgdGhpcy5wc3NoID0gbXA0cHNzaChQbGF5UmVhZHlLZXlTeXN0ZW1VVUlELCBudWxsLCBrZXlCeXRlcyk7XG4gICAgICAgICAgICBjb25zdCBrZXlCeXRlc1V0ZjE2ID0gbmV3IFVpbnQxNkFycmF5KGtleUJ5dGVzLmJ1ZmZlciwga2V5Qnl0ZXMuYnl0ZU9mZnNldCwga2V5Qnl0ZXMuYnl0ZUxlbmd0aCAvIDIpO1xuICAgICAgICAgICAgY29uc3Qga2V5Qnl0ZVN0ciA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgQXJyYXkuZnJvbShrZXlCeXRlc1V0ZjE2KSk7XG5cbiAgICAgICAgICAgIC8vIFBhcnNlIFBsYXlyZWFkeSBXUk1IZWFkZXIgWE1MXG4gICAgICAgICAgICBjb25zdCB4bWxLZXlCeXRlcyA9IGtleUJ5dGVTdHIuc3Vic3RyaW5nKGtleUJ5dGVTdHIuaW5kZXhPZignPCcpLCBrZXlCeXRlU3RyLmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgICAgICAgICBjb25zdCB4bWxEb2MgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHhtbEtleUJ5dGVzLCAndGV4dC94bWwnKTtcbiAgICAgICAgICAgIGNvbnN0IGtleURhdGEgPSB4bWxEb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ0tJRCcpWzBdO1xuICAgICAgICAgICAgaWYgKGtleURhdGEpIHtcbiAgICAgICAgICAgICAgY29uc3Qga2V5SWQgPSBrZXlEYXRhLmNoaWxkTm9kZXNbMF0gPyBrZXlEYXRhLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlIDoga2V5RGF0YS5nZXRBdHRyaWJ1dGUoJ1ZBTFVFJyk7XG4gICAgICAgICAgICAgIGlmIChrZXlJZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleUlkQXJyYXkgPSBiYXNlNjREZWNvZGUoa2V5SWQpLnN1YmFycmF5KDAsIDE2KTtcbiAgICAgICAgICAgICAgICAvLyBLSUQgdmFsdWUgaW4gUFJPIGlzIGEgYmFzZTY0LWVuY29kZWQgbGl0dGxlIGVuZGlhbiBHVUlEIGludGVycHJldGF0aW9uIG9mIFVVSURcbiAgICAgICAgICAgICAgICAvLyBLSUQgdmFsdWUgaW4g4oCYdGVuY+KAmSBpcyBhIGJpZyBlbmRpYW4gVVVJRCBHVUlEIGludGVycHJldGF0aW9uIG9mIFVVSURcbiAgICAgICAgICAgICAgICBjaGFuZ2VFbmRpYW5uZXNzKGtleUlkQXJyYXkpO1xuICAgICAgICAgICAgICAgIHRoaXMua2V5SWQgPSBrZXlJZEFycmF5O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgbGV0IGtleWRhdGEgPSBrZXlCeXRlcy5zdWJhcnJheSgwLCAxNik7XG4gICAgICAgICAgICBpZiAoa2V5ZGF0YS5sZW5ndGggIT09IDE2KSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhZGRlZCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICAgICAgICAgICAgcGFkZGVkLnNldChrZXlkYXRhLCAxNiAtIGtleWRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgICAga2V5ZGF0YSA9IHBhZGRlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMua2V5SWQgPSBrZXlkYXRhO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlZmF1bHQgYmVoYXZpb3I6IGFzc2lnbiBhIG5ldyBrZXlJZCBmb3IgZWFjaCB1cmlcbiAgICBpZiAoIXRoaXMua2V5SWQgfHwgdGhpcy5rZXlJZC5ieXRlTGVuZ3RoICE9PSAxNikge1xuICAgICAgbGV0IGtleUlkID0ga2V5VXJpVG9LZXlJZE1hcFt0aGlzLnVyaV07XG4gICAgICBpZiAoIWtleUlkKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IE9iamVjdC5rZXlzKGtleVVyaVRvS2V5SWRNYXApLmxlbmd0aCAlIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICBrZXlJZCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICAgICAgY29uc3QgZHYgPSBuZXcgRGF0YVZpZXcoa2V5SWQuYnVmZmVyLCAxMiwgNCk7IC8vIEp1c3Qgc2V0IHRoZSBsYXN0IDQgYnl0ZXNcbiAgICAgICAgZHYuc2V0VWludDMyKDAsIHZhbCk7XG4gICAgICAgIGtleVVyaVRvS2V5SWRNYXBbdGhpcy51cmldID0ga2V5SWQ7XG4gICAgICB9XG4gICAgICB0aGlzLmtleUlkID0ga2V5SWQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVJbml0aWFsaXphdGlvblZlY3RvcihzZWdtZW50TnVtYmVyKSB7XG4gIGNvbnN0IHVpbnQ4VmlldyA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgZm9yIChsZXQgaSA9IDEyOyBpIDwgMTY7IGkrKykge1xuICAgIHVpbnQ4Vmlld1tpXSA9IHNlZ21lbnROdW1iZXIgPj4gOCAqICgxNSAtIGkpICYgMHhmZjtcbiAgfVxuICByZXR1cm4gdWludDhWaWV3O1xufVxuXG5jb25zdCBWQVJJQUJMRV9SRVBMQUNFTUVOVF9SRUdFWCA9IC9cXHtcXCQoW2EtekEtWjAtOS1fXSspXFx9L2c7XG5mdW5jdGlvbiBoYXNWYXJpYWJsZVJlZmVyZW5jZXMoc3RyKSB7XG4gIHJldHVybiBWQVJJQUJMRV9SRVBMQUNFTUVOVF9SRUdFWC50ZXN0KHN0cik7XG59XG5mdW5jdGlvbiBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKHBhcnNlZCwgYXR0ciwgYXR0cmlidXRlTmFtZXMpIHtcbiAgaWYgKHBhcnNlZC52YXJpYWJsZUxpc3QgIT09IG51bGwgfHwgcGFyc2VkLmhhc1ZhcmlhYmxlUmVmcykge1xuICAgIGZvciAobGV0IGkgPSBhdHRyaWJ1dGVOYW1lcy5sZW5ndGg7IGktLTspIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBhdHRyaWJ1dGVOYW1lc1tpXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gYXR0cltuYW1lXTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBhdHRyW25hbWVdID0gc3Vic3RpdHV0ZVZhcmlhYmxlcyhwYXJzZWQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHN1YnN0aXR1dGVWYXJpYWJsZXMocGFyc2VkLCB2YWx1ZSkge1xuICBpZiAocGFyc2VkLnZhcmlhYmxlTGlzdCAhPT0gbnVsbCB8fCBwYXJzZWQuaGFzVmFyaWFibGVSZWZzKSB7XG4gICAgY29uc3QgdmFyaWFibGVMaXN0ID0gcGFyc2VkLnZhcmlhYmxlTGlzdDtcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZShWQVJJQUJMRV9SRVBMQUNFTUVOVF9SRUdFWCwgdmFyaWFibGVSZWZlcmVuY2UgPT4ge1xuICAgICAgY29uc3QgdmFyaWFibGVOYW1lID0gdmFyaWFibGVSZWZlcmVuY2Uuc3Vic3RyaW5nKDIsIHZhcmlhYmxlUmVmZXJlbmNlLmxlbmd0aCAtIDEpO1xuICAgICAgY29uc3QgdmFyaWFibGVWYWx1ZSA9IHZhcmlhYmxlTGlzdCA9PSBudWxsID8gdm9pZCAwIDogdmFyaWFibGVMaXN0W3ZhcmlhYmxlTmFtZV07XG4gICAgICBpZiAodmFyaWFibGVWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcnNlZC5wbGF5bGlzdFBhcnNpbmdFcnJvciB8fCAocGFyc2VkLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKGBNaXNzaW5nIHByZWNlZGluZyBFWFQtWC1ERUZJTkUgdGFnIGZvciBWYXJpYWJsZSBSZWZlcmVuY2U6IFwiJHt2YXJpYWJsZU5hbWV9XCJgKSk7XG4gICAgICAgIHJldHVybiB2YXJpYWJsZVJlZmVyZW5jZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YXJpYWJsZVZhbHVlO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGFkZFZhcmlhYmxlRGVmaW5pdGlvbihwYXJzZWQsIGF0dHIsIHBhcmVudFVybCkge1xuICBsZXQgdmFyaWFibGVMaXN0ID0gcGFyc2VkLnZhcmlhYmxlTGlzdDtcbiAgaWYgKCF2YXJpYWJsZUxpc3QpIHtcbiAgICBwYXJzZWQudmFyaWFibGVMaXN0ID0gdmFyaWFibGVMaXN0ID0ge307XG4gIH1cbiAgbGV0IE5BTUU7XG4gIGxldCBWQUxVRTtcbiAgaWYgKCdRVUVSWVBBUkFNJyBpbiBhdHRyKSB7XG4gICAgTkFNRSA9IGF0dHIuUVVFUllQQVJBTTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2VhcmNoUGFyYW1zID0gbmV3IHNlbGYuVVJMKHBhcmVudFVybCkuc2VhcmNoUGFyYW1zO1xuICAgICAgaWYgKHNlYXJjaFBhcmFtcy5oYXMoTkFNRSkpIHtcbiAgICAgICAgVkFMVUUgPSBzZWFyY2hQYXJhbXMuZ2V0KE5BTUUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7TkFNRX1cIiBkb2VzIG5vdCBtYXRjaCBhbnkgcXVlcnkgcGFyYW1ldGVyIGluIFVSSTogXCIke3BhcmVudFVybH1cImApO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBwYXJzZWQucGxheWxpc3RQYXJzaW5nRXJyb3IgfHwgKHBhcnNlZC5wbGF5bGlzdFBhcnNpbmdFcnJvciA9IG5ldyBFcnJvcihgRVhULVgtREVGSU5FIFFVRVJZUEFSQU06ICR7ZXJyb3IubWVzc2FnZX1gKSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIE5BTUUgPSBhdHRyLk5BTUU7XG4gICAgVkFMVUUgPSBhdHRyLlZBTFVFO1xuICB9XG4gIGlmIChOQU1FIGluIHZhcmlhYmxlTGlzdCkge1xuICAgIHBhcnNlZC5wbGF5bGlzdFBhcnNpbmdFcnJvciB8fCAocGFyc2VkLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKGBFWFQtWC1ERUZJTkUgZHVwbGljYXRlIFZhcmlhYmxlIE5hbWUgZGVjbGFyYXRpb25zOiBcIiR7TkFNRX1cImApKTtcbiAgfSBlbHNlIHtcbiAgICB2YXJpYWJsZUxpc3RbTkFNRV0gPSBWQUxVRSB8fCAnJztcbiAgfVxufVxuZnVuY3Rpb24gaW1wb3J0VmFyaWFibGVEZWZpbml0aW9uKHBhcnNlZCwgYXR0ciwgc291cmNlVmFyaWFibGVMaXN0KSB7XG4gIGNvbnN0IElNUE9SVCA9IGF0dHIuSU1QT1JUO1xuICBpZiAoc291cmNlVmFyaWFibGVMaXN0ICYmIElNUE9SVCBpbiBzb3VyY2VWYXJpYWJsZUxpc3QpIHtcbiAgICBsZXQgdmFyaWFibGVMaXN0ID0gcGFyc2VkLnZhcmlhYmxlTGlzdDtcbiAgICBpZiAoIXZhcmlhYmxlTGlzdCkge1xuICAgICAgcGFyc2VkLnZhcmlhYmxlTGlzdCA9IHZhcmlhYmxlTGlzdCA9IHt9O1xuICAgIH1cbiAgICB2YXJpYWJsZUxpc3RbSU1QT1JUXSA9IHNvdXJjZVZhcmlhYmxlTGlzdFtJTVBPUlRdO1xuICB9IGVsc2Uge1xuICAgIHBhcnNlZC5wbGF5bGlzdFBhcnNpbmdFcnJvciB8fCAocGFyc2VkLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKGBFWFQtWC1ERUZJTkUgSU1QT1JUIGF0dHJpYnV0ZSBub3QgZm91bmQgaW4gTXVsdGl2YXJpYW50IFBsYXlsaXN0OiBcIiR7SU1QT1JUfVwiYCkpO1xuICB9XG59XG5cbi8qKlxuICogTWVkaWFTb3VyY2UgaGVscGVyXG4gKi9cblxuZnVuY3Rpb24gZ2V0TWVkaWFTb3VyY2UocHJlZmVyTWFuYWdlZE1lZGlhU291cmNlID0gdHJ1ZSkge1xuICBpZiAodHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gdW5kZWZpbmVkO1xuICBjb25zdCBtbXMgPSAocHJlZmVyTWFuYWdlZE1lZGlhU291cmNlIHx8ICFzZWxmLk1lZGlhU291cmNlKSAmJiBzZWxmLk1hbmFnZWRNZWRpYVNvdXJjZTtcbiAgcmV0dXJuIG1tcyB8fCBzZWxmLk1lZGlhU291cmNlIHx8IHNlbGYuV2ViS2l0TWVkaWFTb3VyY2U7XG59XG5cbi8vIGZyb20gaHR0cDovL21wNHJhLm9yZy9jb2RlY3MuaHRtbFxuLy8gdmFsdWVzIGluZGljYXRlIGNvZGVjIHNlbGVjdGlvbiBwcmVmZXJlbmNlIChsb3dlciBpcyBoaWdoZXIgcHJpb3JpdHkpXG5jb25zdCBzYW1wbGVFbnRyeUNvZGVzSVNPID0ge1xuICBhdWRpbzoge1xuICAgIGEzZHM6IDEsXG4gICAgJ2FjLTMnOiAwLjk1LFxuICAgICdhYy00JzogMSxcbiAgICBhbGFjOiAwLjksXG4gICAgYWxhdzogMSxcbiAgICBkcmExOiAxLFxuICAgICdkdHMrJzogMSxcbiAgICAnZHRzLSc6IDEsXG4gICAgZHRzYzogMSxcbiAgICBkdHNlOiAxLFxuICAgIGR0c2g6IDEsXG4gICAgJ2VjLTMnOiAwLjksXG4gICAgZW5jYTogMSxcbiAgICBmTGFDOiAwLjksXG4gICAgLy8gTVA0LVJBIGxpc3RlZCBjb2RlYyBlbnRyeSBmb3IgRkxBQ1xuICAgIGZsYWM6IDAuOSxcbiAgICAvLyBsZWdhY3kgYnJvd3NlciBjb2RlYyBuYW1lIGZvciBGTEFDXG4gICAgRkxBQzogMC45LFxuICAgIC8vIHNvbWUgbWFuaWZlc3RzIG1heSBsaXN0IFwiRkxBQ1wiIHdpdGggQXBwbGUncyB0b29sc1xuICAgIGc3MTk6IDEsXG4gICAgZzcyNjogMSxcbiAgICBtNGFlOiAxLFxuICAgIG1oYTE6IDEsXG4gICAgbWhhMjogMSxcbiAgICBtaG0xOiAxLFxuICAgIG1obTI6IDEsXG4gICAgbWxwYTogMSxcbiAgICBtcDRhOiAxLFxuICAgICdyYXcgJzogMSxcbiAgICBPcHVzOiAxLFxuICAgIG9wdXM6IDEsXG4gICAgLy8gYnJvd3NlcnMgZXhwZWN0IHRoaXMgdG8gYmUgbG93ZXJjYXNlIGRlc3BpdGUgTVA0UkEgc2F5cyAnT3B1cydcbiAgICBzYW1yOiAxLFxuICAgIHNhd2I6IDEsXG4gICAgc2F3cDogMSxcbiAgICBzZXZjOiAxLFxuICAgIHNxY3A6IDEsXG4gICAgc3NtdjogMSxcbiAgICB0d29zOiAxLFxuICAgIHVsYXc6IDFcbiAgfSxcbiAgdmlkZW86IHtcbiAgICBhdmMxOiAxLFxuICAgIGF2YzI6IDEsXG4gICAgYXZjMzogMSxcbiAgICBhdmM0OiAxLFxuICAgIGF2Y3A6IDEsXG4gICAgYXYwMTogMC44LFxuICAgIGRyYWM6IDEsXG4gICAgZHZhMTogMSxcbiAgICBkdmF2OiAxLFxuICAgIGR2aDE6IDAuNyxcbiAgICBkdmhlOiAwLjcsXG4gICAgZW5jdjogMSxcbiAgICBoZXYxOiAwLjc1LFxuICAgIGh2YzE6IDAuNzUsXG4gICAgbWpwMjogMSxcbiAgICBtcDR2OiAxLFxuICAgIG12YzE6IDEsXG4gICAgbXZjMjogMSxcbiAgICBtdmMzOiAxLFxuICAgIG12YzQ6IDEsXG4gICAgcmVzdjogMSxcbiAgICBydjYwOiAxLFxuICAgIHMyNjM6IDEsXG4gICAgc3ZjMTogMSxcbiAgICBzdmMyOiAxLFxuICAgICd2Yy0xJzogMSxcbiAgICB2cDA4OiAxLFxuICAgIHZwMDk6IDAuOVxuICB9LFxuICB0ZXh0OiB7XG4gICAgc3RwcDogMSxcbiAgICB3dnR0OiAxXG4gIH1cbn07XG5mdW5jdGlvbiBpc0NvZGVjVHlwZShjb2RlYywgdHlwZSkge1xuICBjb25zdCB0eXBlQ29kZXMgPSBzYW1wbGVFbnRyeUNvZGVzSVNPW3R5cGVdO1xuICByZXR1cm4gISF0eXBlQ29kZXMgJiYgISF0eXBlQ29kZXNbY29kZWMuc2xpY2UoMCwgNCldO1xufVxuZnVuY3Rpb24gYXJlQ29kZWNzTWVkaWFTb3VyY2VTdXBwb3J0ZWQoY29kZWNzLCB0eXBlLCBwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UgPSB0cnVlKSB7XG4gIHJldHVybiAhY29kZWNzLnNwbGl0KCcsJykuc29tZShjb2RlYyA9PiAhaXNDb2RlY01lZGlhU291cmNlU3VwcG9ydGVkKGNvZGVjLCB0eXBlLCBwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UpKTtcbn1cbmZ1bmN0aW9uIGlzQ29kZWNNZWRpYVNvdXJjZVN1cHBvcnRlZChjb2RlYywgdHlwZSwgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlID0gdHJ1ZSkge1xuICB2YXIgX01lZGlhU291cmNlJGlzVHlwZVN1O1xuICBjb25zdCBNZWRpYVNvdXJjZSA9IGdldE1lZGlhU291cmNlKHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSk7XG4gIHJldHVybiAoX01lZGlhU291cmNlJGlzVHlwZVN1ID0gTWVkaWFTb3VyY2UgPT0gbnVsbCA/IHZvaWQgMCA6IE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZChtaW1lVHlwZUZvckNvZGVjKGNvZGVjLCB0eXBlKSkpICE9IG51bGwgPyBfTWVkaWFTb3VyY2UkaXNUeXBlU3UgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG1pbWVUeXBlRm9yQ29kZWMoY29kZWMsIHR5cGUpIHtcbiAgcmV0dXJuIGAke3R5cGV9L21wNDtjb2RlY3M9XCIke2NvZGVjfVwiYDtcbn1cbmZ1bmN0aW9uIHZpZGVvQ29kZWNQcmVmZXJlbmNlVmFsdWUodmlkZW9Db2RlYykge1xuICBpZiAodmlkZW9Db2RlYykge1xuICAgIGNvbnN0IGZvdXJDQyA9IHZpZGVvQ29kZWMuc3Vic3RyaW5nKDAsIDQpO1xuICAgIHJldHVybiBzYW1wbGVFbnRyeUNvZGVzSVNPLnZpZGVvW2ZvdXJDQ107XG4gIH1cbiAgcmV0dXJuIDI7XG59XG5mdW5jdGlvbiBjb2RlY3NTZXRTZWxlY3Rpb25QcmVmZXJlbmNlVmFsdWUoY29kZWNTZXQpIHtcbiAgcmV0dXJuIGNvZGVjU2V0LnNwbGl0KCcsJykucmVkdWNlKChudW0sIGZvdXJDQykgPT4ge1xuICAgIGNvbnN0IHByZWZlcmVuY2VWYWx1ZSA9IHNhbXBsZUVudHJ5Q29kZXNJU08udmlkZW9bZm91ckNDXTtcbiAgICBpZiAocHJlZmVyZW5jZVZhbHVlKSB7XG4gICAgICByZXR1cm4gKHByZWZlcmVuY2VWYWx1ZSAqIDIgKyBudW0pIC8gKG51bSA/IDMgOiAyKTtcbiAgICB9XG4gICAgcmV0dXJuIChzYW1wbGVFbnRyeUNvZGVzSVNPLmF1ZGlvW2ZvdXJDQ10gKyBudW0pIC8gKG51bSA/IDIgOiAxKTtcbiAgfSwgMCk7XG59XG5jb25zdCBDT0RFQ19DT01QQVRJQkxFX05BTUVTID0ge307XG5mdW5jdGlvbiBnZXRDb2RlY0NvbXBhdGlibGVOYW1lTG93ZXIobG93ZXJDYXNlQ29kZWMsIHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSA9IHRydWUpIHtcbiAgaWYgKENPREVDX0NPTVBBVElCTEVfTkFNRVNbbG93ZXJDYXNlQ29kZWNdKSB7XG4gICAgcmV0dXJuIENPREVDX0NPTVBBVElCTEVfTkFNRVNbbG93ZXJDYXNlQ29kZWNdO1xuICB9XG5cbiAgLy8gSWRlYWx5IGZMYUMgYW5kIE9wdXMgd291bGQgYmUgZmlyc3QgKHNwZWMtY29tcGxpYW50KSBidXRcbiAgLy8gc29tZSBicm93c2VycyB3aWxsIHJlcG9ydCB0aGF0IGZMYUMgaXMgc3VwcG9ydGVkIHRoZW4gZmFpbC5cbiAgLy8gc2VlOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xNDIyNzI4XG4gIGNvbnN0IGNvZGVjc1RvQ2hlY2sgPSB7XG4gICAgZmxhYzogWydmbGFjJywgJ2ZMYUMnLCAnRkxBQyddLFxuICAgIG9wdXM6IFsnb3B1cycsICdPcHVzJ11cbiAgfVtsb3dlckNhc2VDb2RlY107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29kZWNzVG9DaGVjay5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpc0NvZGVjTWVkaWFTb3VyY2VTdXBwb3J0ZWQoY29kZWNzVG9DaGVja1tpXSwgJ2F1ZGlvJywgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlKSkge1xuICAgICAgQ09ERUNfQ09NUEFUSUJMRV9OQU1FU1tsb3dlckNhc2VDb2RlY10gPSBjb2RlY3NUb0NoZWNrW2ldO1xuICAgICAgcmV0dXJuIGNvZGVjc1RvQ2hlY2tbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiBsb3dlckNhc2VDb2RlYztcbn1cbmNvbnN0IEFVRElPX0NPREVDX1JFR0VYUCA9IC9mbGFjfG9wdXMvaTtcbmZ1bmN0aW9uIGdldENvZGVjQ29tcGF0aWJsZU5hbWUoY29kZWMsIHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSA9IHRydWUpIHtcbiAgcmV0dXJuIGNvZGVjLnJlcGxhY2UoQVVESU9fQ09ERUNfUkVHRVhQLCBtID0+IGdldENvZGVjQ29tcGF0aWJsZU5hbWVMb3dlcihtLnRvTG93ZXJDYXNlKCksIHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSkpO1xufVxuZnVuY3Rpb24gcGlja01vc3RDb21wbGV0ZUNvZGVjTmFtZShwYXJzZWRDb2RlYywgbGV2ZWxDb2RlYykge1xuICAvLyBQYXJzaW5nIG9mIG1wNGEgY29kZWNzIHN0cmluZ3MgaW4gbXA0LXRvb2xzIGZyb20gbWVkaWEgaXMgaW5jb21wbGV0ZSBhcyBvZiBkOGM2YzdhXG4gIC8vIHNvIHVzZSBsZXZlbCBjb2RlYyBpcyBwYXJzZWQgY29kZWMgaXMgdW5hdmFpbGFibGUgb3IgaW5jb21wbGV0ZVxuICBpZiAocGFyc2VkQ29kZWMgJiYgcGFyc2VkQ29kZWMgIT09ICdtcDRhJykge1xuICAgIHJldHVybiBwYXJzZWRDb2RlYztcbiAgfVxuICByZXR1cm4gbGV2ZWxDb2RlYztcbn1cbmZ1bmN0aW9uIGNvbnZlcnRBVkMxVG9BVkNPVEkoY29kZWMpIHtcbiAgLy8gQ29udmVydCBhdmMxIGNvZGVjIHN0cmluZyBmcm9tIFJGQy00MjgxIHRvIFJGQy02MzgxIGZvciBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWRcbiAgY29uc3QgYXZjZGF0YSA9IGNvZGVjLnNwbGl0KCcuJyk7XG4gIGlmIChhdmNkYXRhLmxlbmd0aCA+IDIpIHtcbiAgICBsZXQgcmVzdWx0ID0gYXZjZGF0YS5zaGlmdCgpICsgJy4nO1xuICAgIHJlc3VsdCArPSBwYXJzZUludChhdmNkYXRhLnNoaWZ0KCkpLnRvU3RyaW5nKDE2KTtcbiAgICByZXN1bHQgKz0gKCcwMDAnICsgcGFyc2VJbnQoYXZjZGF0YS5zaGlmdCgpKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHJldHVybiBjb2RlYztcbn1cblxuY29uc3QgTUFTVEVSX1BMQVlMSVNUX1JFR0VYID0gLyNFWFQtWC1TVFJFQU0tSU5GOihbXlxcclxcbl0qKSg/OltcXHJcXG5dKD86I1teXFxyXFxuXSopPykqKFteXFxyXFxuXSspfCNFWFQtWC0oU0VTU0lPTi1EQVRBfFNFU1NJT04tS0VZfERFRklORXxDT05URU5ULVNURUVSSU5HfFNUQVJUKTooW15cXHJcXG5dKilbXFxyXFxuXSsvZztcbmNvbnN0IE1BU1RFUl9QTEFZTElTVF9NRURJQV9SRUdFWCA9IC8jRVhULVgtTUVESUE6KC4qKS9nO1xuY29uc3QgSVNfTUVESUFfUExBWUxJU1QgPSAvXiNFWFQoPzpJTkZ8LVgtVEFSR0VURFVSQVRJT04pOi9tOyAvLyBIYW5kbGUgZW1wdHkgTWVkaWEgUGxheWxpc3QgKGZpcnN0IEVYVElORiBub3Qgc2lnbmFsZWQsIGJ1dCBUQVJHRVREVVJBVElPTiBwcmVzZW50KVxuXG5jb25zdCBMRVZFTF9QTEFZTElTVF9SRUdFWF9GQVNUID0gbmV3IFJlZ0V4cChbLyNFWFRJTkY6XFxzKihcXGQqKD86XFwuXFxkKyk/KSg/OiwoLiopXFxzKyk/Ly5zb3VyY2UsXG4vLyBkdXJhdGlvbiAoI0VYVElORjo8ZHVyYXRpb24+LDx0aXRsZT4pLCBncm91cCAxID0+IGR1cmF0aW9uLCBncm91cCAyID0+IHRpdGxlXG4vKD8hIykgKihcXFNbXFxTIF0qKS8uc291cmNlLFxuLy8gc2VnbWVudCBVUkksIGdyb3VwIDMgPT4gdGhlIFVSSSAobm90ZSBuZXdsaW5lIGlzIG5vdCBlYXRlbilcbi8jRVhULVgtQllURVJBTkdFOiooLispLy5zb3VyY2UsXG4vLyBuZXh0IHNlZ21lbnQncyBieXRlcmFuZ2UsIGdyb3VwIDQgPT4gcmFuZ2Ugc3BlYyAoeEB5KVxuLyNFWFQtWC1QUk9HUkFNLURBVEUtVElNRTooLispLy5zb3VyY2UsXG4vLyBuZXh0IHNlZ21lbnQncyBwcm9ncmFtIGRhdGUvdGltZSBncm91cCA1ID0+IHRoZSBkYXRldGltZSBzcGVjXG4vIy4qLy5zb3VyY2UgLy8gQWxsIG90aGVyIG5vbi1zZWdtZW50IG9yaWVudGVkIHRhZ3Mgd2lsbCBtYXRjaCB3aXRoIGFsbCBncm91cHMgZW1wdHlcbl0uam9pbignfCcpLCAnZycpO1xuY29uc3QgTEVWRUxfUExBWUxJU1RfUkVHRVhfU0xPVyA9IG5ldyBSZWdFeHAoWy8jKEVYVE0zVSkvLnNvdXJjZSwgLyNFWFQtWC0oREFURVJBTkdFfERFRklORXxLRVl8TUFQfFBBUlR8UEFSVC1JTkZ8UExBWUxJU1QtVFlQRXxQUkVMT0FELUhJTlR8UkVORElUSU9OLVJFUE9SVHxTRVJWRVItQ09OVFJPTHxTS0lQfFNUQVJUKTooLispLy5zb3VyY2UsIC8jRVhULVgtKEJJVFJBVEV8RElTQ09OVElOVUlUWS1TRVFVRU5DRXxNRURJQS1TRVFVRU5DRXxUQVJHRVREVVJBVElPTnxWRVJTSU9OKTogKihcXGQrKS8uc291cmNlLCAvI0VYVC1YLShESVNDT05USU5VSVRZfEVORExJU1R8R0FQfElOREVQRU5ERU5ULVNFR01FTlRTKS8uc291cmNlLCAvKCMpKFteOl0qKTooLiopLy5zb3VyY2UsIC8oIykoLiopKD86LiopXFxyP1xcbj8vLnNvdXJjZV0uam9pbignfCcpKTtcbmNsYXNzIE0zVThQYXJzZXIge1xuICBzdGF0aWMgZmluZEdyb3VwKGdyb3VwcywgbWVkaWFHcm91cElkKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGdyb3VwID0gZ3JvdXBzW2ldO1xuICAgICAgaWYgKGdyb3VwLmlkID09PSBtZWRpYUdyb3VwSWQpIHtcbiAgICAgICAgcmV0dXJuIGdyb3VwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdGF0aWMgcmVzb2x2ZSh1cmwsIGJhc2VVcmwpIHtcbiAgICByZXR1cm4gdXJsVG9vbGtpdEV4cG9ydHMuYnVpbGRBYnNvbHV0ZVVSTChiYXNlVXJsLCB1cmwsIHtcbiAgICAgIGFsd2F5c05vcm1hbGl6ZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBpc01lZGlhUGxheWxpc3Qoc3RyKSB7XG4gICAgcmV0dXJuIElTX01FRElBX1BMQVlMSVNULnRlc3Qoc3RyKTtcbiAgfVxuICBzdGF0aWMgcGFyc2VNYXN0ZXJQbGF5bGlzdChzdHJpbmcsIGJhc2V1cmwpIHtcbiAgICBjb25zdCBoYXNWYXJpYWJsZVJlZnMgPSBoYXNWYXJpYWJsZVJlZmVyZW5jZXMoc3RyaW5nKSA7XG4gICAgY29uc3QgcGFyc2VkID0ge1xuICAgICAgY29udGVudFN0ZWVyaW5nOiBudWxsLFxuICAgICAgbGV2ZWxzOiBbXSxcbiAgICAgIHBsYXlsaXN0UGFyc2luZ0Vycm9yOiBudWxsLFxuICAgICAgc2Vzc2lvbkRhdGE6IG51bGwsXG4gICAgICBzZXNzaW9uS2V5czogbnVsbCxcbiAgICAgIHN0YXJ0VGltZU9mZnNldDogbnVsbCxcbiAgICAgIHZhcmlhYmxlTGlzdDogbnVsbCxcbiAgICAgIGhhc1ZhcmlhYmxlUmVmc1xuICAgIH07XG4gICAgY29uc3QgbGV2ZWxzV2l0aEtub3duQ29kZWNzID0gW107XG4gICAgTUFTVEVSX1BMQVlMSVNUX1JFR0VYLmxhc3RJbmRleCA9IDA7XG4gICAgbGV0IHJlc3VsdDtcbiAgICB3aGlsZSAoKHJlc3VsdCA9IE1BU1RFUl9QTEFZTElTVF9SRUdFWC5leGVjKHN0cmluZykpICE9IG51bGwpIHtcbiAgICAgIGlmIChyZXN1bHRbMV0pIHtcbiAgICAgICAgdmFyIF9sZXZlbCR1bmtub3duQ29kZWNzO1xuICAgICAgICAvLyAnI0VYVC1YLVNUUkVBTS1JTkYnIGlzIGZvdW5kLCBwYXJzZSBsZXZlbCB0YWcgIGluIGdyb3VwIDFcbiAgICAgICAgY29uc3QgYXR0cnMgPSBuZXcgQXR0ckxpc3QocmVzdWx0WzFdKTtcbiAgICAgICAge1xuICAgICAgICAgIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMocGFyc2VkLCBhdHRycywgWydDT0RFQ1MnLCAnU1VQUExFTUVOVEFMLUNPREVDUycsICdBTExPV0VELUNQQycsICdQQVRIV0FZLUlEJywgJ1NUQUJMRS1WQVJJQU5ULUlEJywgJ0FVRElPJywgJ1ZJREVPJywgJ1NVQlRJVExFUycsICdDTE9TRUQtQ0FQVElPTlMnLCAnTkFNRSddKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBzdWJzdGl0dXRlVmFyaWFibGVzKHBhcnNlZCwgcmVzdWx0WzJdKSA7XG4gICAgICAgIGNvbnN0IGxldmVsID0ge1xuICAgICAgICAgIGF0dHJzLFxuICAgICAgICAgIGJpdHJhdGU6IGF0dHJzLmRlY2ltYWxJbnRlZ2VyKCdCQU5EV0lEVEgnKSB8fCBhdHRycy5kZWNpbWFsSW50ZWdlcignQVZFUkFHRS1CQU5EV0lEVEgnKSxcbiAgICAgICAgICBuYW1lOiBhdHRycy5OQU1FLFxuICAgICAgICAgIHVybDogTTNVOFBhcnNlci5yZXNvbHZlKHVyaSwgYmFzZXVybClcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzb2x1dGlvbiA9IGF0dHJzLmRlY2ltYWxSZXNvbHV0aW9uKCdSRVNPTFVUSU9OJyk7XG4gICAgICAgIGlmIChyZXNvbHV0aW9uKSB7XG4gICAgICAgICAgbGV2ZWwud2lkdGggPSByZXNvbHV0aW9uLndpZHRoO1xuICAgICAgICAgIGxldmVsLmhlaWdodCA9IHJlc29sdXRpb24uaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHNldENvZGVjcyhhdHRycy5DT0RFQ1MsIGxldmVsKTtcbiAgICAgICAgaWYgKCEoKF9sZXZlbCR1bmtub3duQ29kZWNzID0gbGV2ZWwudW5rbm93bkNvZGVjcykgIT0gbnVsbCAmJiBfbGV2ZWwkdW5rbm93bkNvZGVjcy5sZW5ndGgpKSB7XG4gICAgICAgICAgbGV2ZWxzV2l0aEtub3duQ29kZWNzLnB1c2gobGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlZC5sZXZlbHMucHVzaChsZXZlbCk7XG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdFszXSkge1xuICAgICAgICBjb25zdCB0YWcgPSByZXN1bHRbM107XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSByZXN1bHRbNF07XG4gICAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgICAgY2FzZSAnU0VTU0lPTi1EQVRBJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gI0VYVC1YLVNFU1NJT04tREFUQVxuICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uQXR0cnMgPSBuZXcgQXR0ckxpc3QoYXR0cmlidXRlcyk7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKHBhcnNlZCwgc2Vzc2lvbkF0dHJzLCBbJ0RBVEEtSUQnLCAnTEFOR1VBR0UnLCAnVkFMVUUnLCAnVVJJJ10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IGRhdGFJZCA9IHNlc3Npb25BdHRyc1snREFUQS1JRCddO1xuICAgICAgICAgICAgICBpZiAoZGF0YUlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZC5zZXNzaW9uRGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcGFyc2VkLnNlc3Npb25EYXRhID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcnNlZC5zZXNzaW9uRGF0YVtkYXRhSWRdID0gc2Vzc2lvbkF0dHJzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ1NFU1NJT04tS0VZJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gI0VYVC1YLVNFU1NJT04tS0VZXG4gICAgICAgICAgICAgIGNvbnN0IHNlc3Npb25LZXkgPSBwYXJzZUtleShhdHRyaWJ1dGVzLCBiYXNldXJsLCBwYXJzZWQpO1xuICAgICAgICAgICAgICBpZiAoc2Vzc2lvbktleS5lbmNyeXB0ZWQgJiYgc2Vzc2lvbktleS5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZC5zZXNzaW9uS2V5cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcGFyc2VkLnNlc3Npb25LZXlzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcnNlZC5zZXNzaW9uS2V5cy5wdXNoKHNlc3Npb25LZXkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBbS2V5c10gSWdub3JpbmcgaW52YWxpZCBFWFQtWC1TRVNTSU9OLUtFWSB0YWc6IFwiJHthdHRyaWJ1dGVzfVwiYCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnREVGSU5FJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gI0VYVC1YLURFRklORVxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFyaWFibGVBdHRyaWJ1dGVzID0gbmV3IEF0dHJMaXN0KGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgICAgIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMocGFyc2VkLCB2YXJpYWJsZUF0dHJpYnV0ZXMsIFsnTkFNRScsICdWQUxVRScsICdRVUVSWVBBUkFNJ10pO1xuICAgICAgICAgICAgICAgIGFkZFZhcmlhYmxlRGVmaW5pdGlvbihwYXJzZWQsIHZhcmlhYmxlQXR0cmlidXRlcywgYmFzZXVybCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnQ09OVEVOVC1TVEVFUklORyc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC8vICNFWFQtWC1DT05URU5ULVNURUVSSU5HXG4gICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRTdGVlcmluZ0F0dHJpYnV0ZXMgPSBuZXcgQXR0ckxpc3QoYXR0cmlidXRlcyk7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKHBhcnNlZCwgY29udGVudFN0ZWVyaW5nQXR0cmlidXRlcywgWydTRVJWRVItVVJJJywgJ1BBVEhXQVktSUQnXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGFyc2VkLmNvbnRlbnRTdGVlcmluZyA9IHtcbiAgICAgICAgICAgICAgICB1cmk6IE0zVThQYXJzZXIucmVzb2x2ZShjb250ZW50U3RlZXJpbmdBdHRyaWJ1dGVzWydTRVJWRVItVVJJJ10sIGJhc2V1cmwpLFxuICAgICAgICAgICAgICAgIHBhdGh3YXlJZDogY29udGVudFN0ZWVyaW5nQXR0cmlidXRlc1snUEFUSFdBWS1JRCddIHx8ICcuJ1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdTVEFSVCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC8vICNFWFQtWC1TVEFSVFxuICAgICAgICAgICAgICBwYXJzZWQuc3RhcnRUaW1lT2Zmc2V0ID0gcGFyc2VTdGFydFRpbWVPZmZzZXQoYXR0cmlidXRlcyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEZpbHRlciBvdXQgbGV2ZWxzIHdpdGggdW5rbm93biBjb2RlY3MgaWYgaXQgZG9lcyBub3QgcmVtb3ZlIGFsbCBsZXZlbHNcbiAgICBjb25zdCBzdHJpcFVua25vd25Db2RlY0xldmVscyA9IGxldmVsc1dpdGhLbm93bkNvZGVjcy5sZW5ndGggPiAwICYmIGxldmVsc1dpdGhLbm93bkNvZGVjcy5sZW5ndGggPCBwYXJzZWQubGV2ZWxzLmxlbmd0aDtcbiAgICBwYXJzZWQubGV2ZWxzID0gc3RyaXBVbmtub3duQ29kZWNMZXZlbHMgPyBsZXZlbHNXaXRoS25vd25Db2RlY3MgOiBwYXJzZWQubGV2ZWxzO1xuICAgIGlmIChwYXJzZWQubGV2ZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcGFyc2VkLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKCdubyBsZXZlbHMgZm91bmQgaW4gbWFuaWZlc3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBzdGF0aWMgcGFyc2VNYXN0ZXJQbGF5bGlzdE1lZGlhKHN0cmluZywgYmFzZXVybCwgcGFyc2VkKSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBjb25zdCByZXN1bHRzID0ge307XG4gICAgY29uc3QgbGV2ZWxzID0gcGFyc2VkLmxldmVscztcbiAgICBjb25zdCBncm91cHNCeVR5cGUgPSB7XG4gICAgICBBVURJTzogbGV2ZWxzLm1hcChsZXZlbCA9PiAoe1xuICAgICAgICBpZDogbGV2ZWwuYXR0cnMuQVVESU8sXG4gICAgICAgIGF1ZGlvQ29kZWM6IGxldmVsLmF1ZGlvQ29kZWNcbiAgICAgIH0pKSxcbiAgICAgIFNVQlRJVExFUzogbGV2ZWxzLm1hcChsZXZlbCA9PiAoe1xuICAgICAgICBpZDogbGV2ZWwuYXR0cnMuU1VCVElUTEVTLFxuICAgICAgICB0ZXh0Q29kZWM6IGxldmVsLnRleHRDb2RlY1xuICAgICAgfSkpLFxuICAgICAgJ0NMT1NFRC1DQVBUSU9OUyc6IFtdXG4gICAgfTtcbiAgICBsZXQgaWQgPSAwO1xuICAgIE1BU1RFUl9QTEFZTElTVF9NRURJQV9SRUdFWC5sYXN0SW5kZXggPSAwO1xuICAgIHdoaWxlICgocmVzdWx0ID0gTUFTVEVSX1BMQVlMSVNUX01FRElBX1JFR0VYLmV4ZWMoc3RyaW5nKSkgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGF0dHJzID0gbmV3IEF0dHJMaXN0KHJlc3VsdFsxXSk7XG4gICAgICBjb25zdCB0eXBlID0gYXR0cnMuVFlQRTtcbiAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgIGNvbnN0IGdyb3VwcyA9IGdyb3Vwc0J5VHlwZVt0eXBlXTtcbiAgICAgICAgY29uc3QgbWVkaWFzID0gcmVzdWx0c1t0eXBlXSB8fCBbXTtcbiAgICAgICAgcmVzdWx0c1t0eXBlXSA9IG1lZGlhcztcbiAgICAgICAge1xuICAgICAgICAgIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMocGFyc2VkLCBhdHRycywgWydVUkknLCAnR1JPVVAtSUQnLCAnTEFOR1VBR0UnLCAnQVNTT0MtTEFOR1VBR0UnLCAnU1RBQkxFLVJFTkRJVElPTi1JRCcsICdOQU1FJywgJ0lOU1RSRUFNLUlEJywgJ0NIQVJBQ1RFUklTVElDUycsICdDSEFOTkVMUyddKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYW5nID0gYXR0cnMuTEFOR1VBR0U7XG4gICAgICAgIGNvbnN0IGFzc29jTGFuZyA9IGF0dHJzWydBU1NPQy1MQU5HVUFHRSddO1xuICAgICAgICBjb25zdCBjaGFubmVscyA9IGF0dHJzLkNIQU5ORUxTO1xuICAgICAgICBjb25zdCBjaGFyYWN0ZXJpc3RpY3MgPSBhdHRycy5DSEFSQUNURVJJU1RJQ1M7XG4gICAgICAgIGNvbnN0IGluc3RyZWFtSWQgPSBhdHRyc1snSU5TVFJFQU0tSUQnXTtcbiAgICAgICAgY29uc3QgbWVkaWEgPSB7XG4gICAgICAgICAgYXR0cnMsXG4gICAgICAgICAgYml0cmF0ZTogMCxcbiAgICAgICAgICBpZDogaWQrKyxcbiAgICAgICAgICBncm91cElkOiBhdHRyc1snR1JPVVAtSUQnXSB8fCAnJyxcbiAgICAgICAgICBuYW1lOiBhdHRycy5OQU1FIHx8IGxhbmcgfHwgJycsXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBkZWZhdWx0OiBhdHRycy5ib29sKCdERUZBVUxUJyksXG4gICAgICAgICAgYXV0b3NlbGVjdDogYXR0cnMuYm9vbCgnQVVUT1NFTEVDVCcpLFxuICAgICAgICAgIGZvcmNlZDogYXR0cnMuYm9vbCgnRk9SQ0VEJyksXG4gICAgICAgICAgbGFuZyxcbiAgICAgICAgICB1cmw6IGF0dHJzLlVSSSA/IE0zVThQYXJzZXIucmVzb2x2ZShhdHRycy5VUkksIGJhc2V1cmwpIDogJydcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGFzc29jTGFuZykge1xuICAgICAgICAgIG1lZGlhLmFzc29jTGFuZyA9IGFzc29jTGFuZztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbm5lbHMpIHtcbiAgICAgICAgICBtZWRpYS5jaGFubmVscyA9IGNoYW5uZWxzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyYWN0ZXJpc3RpY3MpIHtcbiAgICAgICAgICBtZWRpYS5jaGFyYWN0ZXJpc3RpY3MgPSBjaGFyYWN0ZXJpc3RpY3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluc3RyZWFtSWQpIHtcbiAgICAgICAgICBtZWRpYS5pbnN0cmVhbUlkID0gaW5zdHJlYW1JZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXBzICE9IG51bGwgJiYgZ3JvdXBzLmxlbmd0aCkge1xuICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBhdWRpbyBvciB0ZXh0IGdyb3VwcyBzaWduYWxsZWQgaW4gdGhlIG1hbmlmZXN0LCBsZXQncyBsb29rIGZvciBhIG1hdGNoaW5nIGNvZGVjIHN0cmluZyBmb3IgdGhpcyB0cmFja1xuICAgICAgICAgIC8vIElmIHdlIGRvbid0IGZpbmQgdGhlIHRyYWNrIHNpZ25hbGxlZCwgbGV0cyB1c2UgdGhlIGZpcnN0IGF1ZGlvIGdyb3VwcyBjb2RlYyB3ZSBoYXZlXG4gICAgICAgICAgLy8gQWN0aW5nIGFzIGEgYmVzdCBndWVzc1xuICAgICAgICAgIGNvbnN0IGdyb3VwQ29kZWMgPSBNM1U4UGFyc2VyLmZpbmRHcm91cChncm91cHMsIG1lZGlhLmdyb3VwSWQpIHx8IGdyb3Vwc1swXTtcbiAgICAgICAgICBhc3NpZ25Db2RlYyhtZWRpYSwgZ3JvdXBDb2RlYywgJ2F1ZGlvQ29kZWMnKTtcbiAgICAgICAgICBhc3NpZ25Db2RlYyhtZWRpYSwgZ3JvdXBDb2RlYywgJ3RleHRDb2RlYycpO1xuICAgICAgICB9XG4gICAgICAgIG1lZGlhcy5wdXNoKG1lZGlhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbiAgc3RhdGljIHBhcnNlTGV2ZWxQbGF5bGlzdChzdHJpbmcsIGJhc2V1cmwsIGlkLCB0eXBlLCBsZXZlbFVybElkLCBtdWx0aXZhcmlhbnRWYXJpYWJsZUxpc3QpIHtcbiAgICBjb25zdCBsZXZlbCA9IG5ldyBMZXZlbERldGFpbHMoYmFzZXVybCk7XG4gICAgY29uc3QgZnJhZ21lbnRzID0gbGV2ZWwuZnJhZ21lbnRzO1xuICAgIC8vIFRoZSBtb3N0IHJlY2VudCBpbml0IHNlZ21lbnQgc2VlbiAoYXBwbGllcyB0byBhbGwgc3Vic2VxdWVudCBzZWdtZW50cylcbiAgICBsZXQgY3VycmVudEluaXRTZWdtZW50ID0gbnVsbDtcbiAgICBsZXQgY3VycmVudFNOID0gMDtcbiAgICBsZXQgY3VycmVudFBhcnQgPSAwO1xuICAgIGxldCB0b3RhbGR1cmF0aW9uID0gMDtcbiAgICBsZXQgZGlzY29udGludWl0eUNvdW50ZXIgPSAwO1xuICAgIGxldCBwcmV2RnJhZyA9IG51bGw7XG4gICAgbGV0IGZyYWcgPSBuZXcgRnJhZ21lbnQodHlwZSwgYmFzZXVybCk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBsZXQgaTtcbiAgICBsZXQgbGV2ZWxrZXlzO1xuICAgIGxldCBmaXJzdFBkdEluZGV4ID0gLTE7XG4gICAgbGV0IGNyZWF0ZU5leHRGcmFnID0gZmFsc2U7XG4gICAgbGV0IG5leHRCeXRlUmFuZ2UgPSBudWxsO1xuICAgIExFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QubGFzdEluZGV4ID0gMDtcbiAgICBsZXZlbC5tM3U4ID0gc3RyaW5nO1xuICAgIGxldmVsLmhhc1ZhcmlhYmxlUmVmcyA9IGhhc1ZhcmlhYmxlUmVmZXJlbmNlcyhzdHJpbmcpIDtcbiAgICB3aGlsZSAoKHJlc3VsdCA9IExFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QuZXhlYyhzdHJpbmcpKSAhPT0gbnVsbCkge1xuICAgICAgaWYgKGNyZWF0ZU5leHRGcmFnKSB7XG4gICAgICAgIGNyZWF0ZU5leHRGcmFnID0gZmFsc2U7XG4gICAgICAgIGZyYWcgPSBuZXcgRnJhZ21lbnQodHlwZSwgYmFzZXVybCk7XG4gICAgICAgIC8vIHNldHVwIHRoZSBuZXh0IGZyYWdtZW50IGZvciBwYXJ0IGxvYWRpbmdcbiAgICAgICAgZnJhZy5zdGFydCA9IHRvdGFsZHVyYXRpb247XG4gICAgICAgIGZyYWcuc24gPSBjdXJyZW50U047XG4gICAgICAgIGZyYWcuY2MgPSBkaXNjb250aW51aXR5Q291bnRlcjtcbiAgICAgICAgZnJhZy5sZXZlbCA9IGlkO1xuICAgICAgICBpZiAoY3VycmVudEluaXRTZWdtZW50KSB7XG4gICAgICAgICAgZnJhZy5pbml0U2VnbWVudCA9IGN1cnJlbnRJbml0U2VnbWVudDtcbiAgICAgICAgICBmcmFnLnJhd1Byb2dyYW1EYXRlVGltZSA9IGN1cnJlbnRJbml0U2VnbWVudC5yYXdQcm9ncmFtRGF0ZVRpbWU7XG4gICAgICAgICAgY3VycmVudEluaXRTZWdtZW50LnJhd1Byb2dyYW1EYXRlVGltZSA9IG51bGw7XG4gICAgICAgICAgaWYgKG5leHRCeXRlUmFuZ2UpIHtcbiAgICAgICAgICAgIGZyYWcuc2V0Qnl0ZVJhbmdlKG5leHRCeXRlUmFuZ2UpO1xuICAgICAgICAgICAgbmV4dEJ5dGVSYW5nZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IHJlc3VsdFsxXTtcbiAgICAgIGlmIChkdXJhdGlvbikge1xuICAgICAgICAvLyBJTkZcbiAgICAgICAgZnJhZy5kdXJhdGlvbiA9IHBhcnNlRmxvYXQoZHVyYXRpb24pO1xuICAgICAgICAvLyBhdm9pZCBzbGljZWQgc3RyaW5ncyAgICBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvOTM5XG4gICAgICAgIGNvbnN0IHRpdGxlID0gKCcgJyArIHJlc3VsdFsyXSkuc2xpY2UoMSk7XG4gICAgICAgIGZyYWcudGl0bGUgPSB0aXRsZSB8fCBudWxsO1xuICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaCh0aXRsZSA/IFsnSU5GJywgZHVyYXRpb24sIHRpdGxlXSA6IFsnSU5GJywgZHVyYXRpb25dKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0WzNdKSB7XG4gICAgICAgIC8vIHVybFxuICAgICAgICBpZiAoaXNGaW5pdGVOdW1iZXIoZnJhZy5kdXJhdGlvbikpIHtcbiAgICAgICAgICBmcmFnLnN0YXJ0ID0gdG90YWxkdXJhdGlvbjtcbiAgICAgICAgICBpZiAobGV2ZWxrZXlzKSB7XG4gICAgICAgICAgICBzZXRGcmFnTGV2ZWxLZXlzKGZyYWcsIGxldmVsa2V5cywgbGV2ZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmcmFnLnNuID0gY3VycmVudFNOO1xuICAgICAgICAgIGZyYWcubGV2ZWwgPSBpZDtcbiAgICAgICAgICBmcmFnLmNjID0gZGlzY29udGludWl0eUNvdW50ZXI7XG4gICAgICAgICAgZnJhZ21lbnRzLnB1c2goZnJhZyk7XG4gICAgICAgICAgLy8gYXZvaWQgc2xpY2VkIHN0cmluZ3MgICAgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzkzOVxuICAgICAgICAgIGNvbnN0IHVyaSA9ICgnICcgKyByZXN1bHRbM10pLnNsaWNlKDEpO1xuICAgICAgICAgIGZyYWcucmVsdXJsID0gc3Vic3RpdHV0ZVZhcmlhYmxlcyhsZXZlbCwgdXJpKSA7XG4gICAgICAgICAgYXNzaWduUHJvZ3JhbURhdGVUaW1lKGZyYWcsIHByZXZGcmFnKTtcbiAgICAgICAgICBwcmV2RnJhZyA9IGZyYWc7XG4gICAgICAgICAgdG90YWxkdXJhdGlvbiArPSBmcmFnLmR1cmF0aW9uO1xuICAgICAgICAgIGN1cnJlbnRTTisrO1xuICAgICAgICAgIGN1cnJlbnRQYXJ0ID0gMDtcbiAgICAgICAgICBjcmVhdGVOZXh0RnJhZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0WzRdKSB7XG4gICAgICAgIC8vIFgtQllURVJBTkdFXG4gICAgICAgIGNvbnN0IGRhdGEgPSAoJyAnICsgcmVzdWx0WzRdKS5zbGljZSgxKTtcbiAgICAgICAgaWYgKHByZXZGcmFnKSB7XG4gICAgICAgICAgZnJhZy5zZXRCeXRlUmFuZ2UoZGF0YSwgcHJldkZyYWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZyYWcuc2V0Qnl0ZVJhbmdlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdFs1XSkge1xuICAgICAgICAvLyBQUk9HUkFNLURBVEUtVElNRVxuICAgICAgICAvLyBhdm9pZCBzbGljZWQgc3RyaW5ncyAgICBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvOTM5XG4gICAgICAgIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lID0gKCcgJyArIHJlc3VsdFs1XSkuc2xpY2UoMSk7XG4gICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKFsnUFJPR1JBTS1EQVRFLVRJTUUnLCBmcmFnLnJhd1Byb2dyYW1EYXRlVGltZV0pO1xuICAgICAgICBpZiAoZmlyc3RQZHRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICBmaXJzdFBkdEluZGV4ID0gZnJhZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0WzBdLm1hdGNoKExFVkVMX1BMQVlMSVNUX1JFR0VYX1NMT1cpO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgIGxvZ2dlci53YXJuKCdObyBtYXRjaGVzIG9uIHNsb3cgcmVnZXggbWF0Y2ggZm9yIGxldmVsIHBsYXlsaXN0IScpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdFtpXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGF2b2lkIHNsaWNlZCBzdHJpbmdzICAgIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy85MzlcbiAgICAgICAgY29uc3QgdGFnID0gKCcgJyArIHJlc3VsdFtpXSkuc2xpY2UoMSk7XG4gICAgICAgIGNvbnN0IHZhbHVlMSA9ICgnICcgKyByZXN1bHRbaSArIDFdKS5zbGljZSgxKTtcbiAgICAgICAgY29uc3QgdmFsdWUyID0gcmVzdWx0W2kgKyAyXSA/ICgnICcgKyByZXN1bHRbaSArIDJdKS5zbGljZSgxKSA6ICcnO1xuICAgICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICAgIGNhc2UgJ1BMQVlMSVNULVRZUEUnOlxuICAgICAgICAgICAgbGV2ZWwudHlwZSA9IHZhbHVlMS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnTUVESUEtU0VRVUVOQ0UnOlxuICAgICAgICAgICAgY3VycmVudFNOID0gbGV2ZWwuc3RhcnRTTiA9IHBhcnNlSW50KHZhbHVlMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdTS0lQJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3Qgc2tpcEF0dHJzID0gbmV3IEF0dHJMaXN0KHZhbHVlMSk7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKGxldmVsLCBza2lwQXR0cnMsIFsnUkVDRU5UTFktUkVNT1ZFRC1EQVRFUkFOR0VTJ10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHNraXBwZWRTZWdtZW50cyA9IHNraXBBdHRycy5kZWNpbWFsSW50ZWdlcignU0tJUFBFRC1TRUdNRU5UUycpO1xuICAgICAgICAgICAgICBpZiAoaXNGaW5pdGVOdW1iZXIoc2tpcHBlZFNlZ21lbnRzKSkge1xuICAgICAgICAgICAgICAgIGxldmVsLnNraXBwZWRTZWdtZW50cyA9IHNraXBwZWRTZWdtZW50cztcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgcmVzdWx0IGluIGZyYWdtZW50c1tdIGNvbnRhaW5pbmcgdW5kZWZpbmVkIHZhbHVlcywgd2hpY2ggd2Ugd2lsbCBmaWxsIGluIHdpdGggYG1lcmdlRGV0YWlsc2BcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBfaSA9IHNraXBwZWRTZWdtZW50czsgX2ktLTspIHtcbiAgICAgICAgICAgICAgICAgIGZyYWdtZW50cy51bnNoaWZ0KG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50U04gKz0gc2tpcHBlZFNlZ21lbnRzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHJlY2VudGx5UmVtb3ZlZERhdGVyYW5nZXMgPSBza2lwQXR0cnMuZW51bWVyYXRlZFN0cmluZygnUkVDRU5UTFktUkVNT1ZFRC1EQVRFUkFOR0VTJyk7XG4gICAgICAgICAgICAgIGlmIChyZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgbGV2ZWwucmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcyA9IHJlY2VudGx5UmVtb3ZlZERhdGVyYW5nZXMuc3BsaXQoJ1xcdCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ1RBUkdFVERVUkFUSU9OJzpcbiAgICAgICAgICAgIGxldmVsLnRhcmdldGR1cmF0aW9uID0gTWF0aC5tYXgocGFyc2VJbnQodmFsdWUxKSwgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdWRVJTSU9OJzpcbiAgICAgICAgICAgIGxldmVsLnZlcnNpb24gPSBwYXJzZUludCh2YWx1ZTEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnSU5ERVBFTkRFTlQtU0VHTUVOVFMnOlxuICAgICAgICAgIGNhc2UgJ0VYVE0zVSc6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdFTkRMSVNUJzpcbiAgICAgICAgICAgIGxldmVsLmxpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJyMnOlxuICAgICAgICAgICAgaWYgKHZhbHVlMSB8fCB2YWx1ZTIpIHtcbiAgICAgICAgICAgICAgZnJhZy50YWdMaXN0LnB1c2godmFsdWUyID8gW3ZhbHVlMSwgdmFsdWUyXSA6IFt2YWx1ZTFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0RJU0NPTlRJTlVJVFknOlxuICAgICAgICAgICAgZGlzY29udGludWl0eUNvdW50ZXIrKztcbiAgICAgICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKFsnRElTJ10pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnR0FQJzpcbiAgICAgICAgICAgIGZyYWcuZ2FwID0gdHJ1ZTtcbiAgICAgICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKFt0YWddKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0JJVFJBVEUnOlxuICAgICAgICAgICAgZnJhZy50YWdMaXN0LnB1c2goW3RhZywgdmFsdWUxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdEQVRFUkFOR0UnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCBkYXRlUmFuZ2VBdHRyID0gbmV3IEF0dHJMaXN0KHZhbHVlMSk7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKGxldmVsLCBkYXRlUmFuZ2VBdHRyLCBbJ0lEJywgJ0NMQVNTJywgJ1NUQVJULURBVEUnLCAnRU5ELURBVEUnLCAnU0NURTM1LUNNRCcsICdTQ1RFMzUtT1VUJywgJ1NDVEUzNS1JTiddKTtcbiAgICAgICAgICAgICAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKGxldmVsLCBkYXRlUmFuZ2VBdHRyLCBkYXRlUmFuZ2VBdHRyLmNsaWVudEF0dHJzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBkYXRlUmFuZ2UgPSBuZXcgRGF0ZVJhbmdlKGRhdGVSYW5nZUF0dHIsIGxldmVsLmRhdGVSYW5nZXNbZGF0ZVJhbmdlQXR0ci5JRF0pO1xuICAgICAgICAgICAgICBpZiAoZGF0ZVJhbmdlLmlzVmFsaWQgfHwgbGV2ZWwuc2tpcHBlZFNlZ21lbnRzKSB7XG4gICAgICAgICAgICAgICAgbGV2ZWwuZGF0ZVJhbmdlc1tkYXRlUmFuZ2UuaWRdID0gZGF0ZVJhbmdlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBJZ25vcmluZyBpbnZhbGlkIERBVEVSQU5HRSB0YWc6IFwiJHt2YWx1ZTF9XCJgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBBZGQgdG8gZnJhZ21lbnQgdGFnIGxpc3QgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5ICg8IHYxLjIuMClcbiAgICAgICAgICAgICAgZnJhZy50YWdMaXN0LnB1c2goWydFWFQtWC1EQVRFUkFOR0UnLCB2YWx1ZTFdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnREVGSU5FJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlQXR0cmlidXRlcyA9IG5ldyBBdHRyTGlzdCh2YWx1ZTEpO1xuICAgICAgICAgICAgICAgIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMobGV2ZWwsIHZhcmlhYmxlQXR0cmlidXRlcywgWydOQU1FJywgJ1ZBTFVFJywgJ0lNUE9SVCcsICdRVUVSWVBBUkFNJ10pO1xuICAgICAgICAgICAgICAgIGlmICgnSU1QT1JUJyBpbiB2YXJpYWJsZUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgIGltcG9ydFZhcmlhYmxlRGVmaW5pdGlvbihsZXZlbCwgdmFyaWFibGVBdHRyaWJ1dGVzLCBtdWx0aXZhcmlhbnRWYXJpYWJsZUxpc3QpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBhZGRWYXJpYWJsZURlZmluaXRpb24obGV2ZWwsIHZhcmlhYmxlQXR0cmlidXRlcywgYmFzZXVybCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ0RJU0NPTlRJTlVJVFktU0VRVUVOQ0UnOlxuICAgICAgICAgICAgZGlzY29udGludWl0eUNvdW50ZXIgPSBwYXJzZUludCh2YWx1ZTEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnS0VZJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgbGV2ZWxLZXkgPSBwYXJzZUtleSh2YWx1ZTEsIGJhc2V1cmwsIGxldmVsKTtcbiAgICAgICAgICAgICAgaWYgKGxldmVsS2V5LmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAobGV2ZWxLZXkubWV0aG9kID09PSAnTk9ORScpIHtcbiAgICAgICAgICAgICAgICAgIGxldmVsa2V5cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWxldmVsa2V5cykge1xuICAgICAgICAgICAgICAgICAgbGV2ZWxrZXlzID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsZXZlbGtleXNbbGV2ZWxLZXkua2V5Rm9ybWF0XSkge1xuICAgICAgICAgICAgICAgICAgbGV2ZWxrZXlzID0gX2V4dGVuZHMoe30sIGxldmVsa2V5cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldmVsa2V5c1tsZXZlbEtleS5rZXlGb3JtYXRdID0gbGV2ZWxLZXk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYFtLZXlzXSBJZ25vcmluZyBpbnZhbGlkIEVYVC1YLUtFWSB0YWc6IFwiJHt2YWx1ZTF9XCJgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdTVEFSVCc6XG4gICAgICAgICAgICBsZXZlbC5zdGFydFRpbWVPZmZzZXQgPSBwYXJzZVN0YXJ0VGltZU9mZnNldCh2YWx1ZTEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnTUFQJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgbWFwQXR0cnMgPSBuZXcgQXR0ckxpc3QodmFsdWUxKTtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMobGV2ZWwsIG1hcEF0dHJzLCBbJ0JZVEVSQU5HRScsICdVUkknXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGZyYWcuZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBJbml0aWFsIHNlZ21lbnQgdGFnIGlzIGFmdGVyIHNlZ21lbnQgZHVyYXRpb24gdGFnLlxuICAgICAgICAgICAgICAgIC8vICAgI0VYVElORjogNi4wXG4gICAgICAgICAgICAgICAgLy8gICAjRVhULVgtTUFQOlVSST1cImluaXQubXA0XG4gICAgICAgICAgICAgICAgY29uc3QgaW5pdCA9IG5ldyBGcmFnbWVudCh0eXBlLCBiYXNldXJsKTtcbiAgICAgICAgICAgICAgICBzZXRJbml0U2VnbWVudChpbml0LCBtYXBBdHRycywgaWQsIGxldmVsa2V5cyk7XG4gICAgICAgICAgICAgICAgY3VycmVudEluaXRTZWdtZW50ID0gaW5pdDtcbiAgICAgICAgICAgICAgICBmcmFnLmluaXRTZWdtZW50ID0gY3VycmVudEluaXRTZWdtZW50O1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SW5pdFNlZ21lbnQucmF3UHJvZ3JhbURhdGVUaW1lICYmICFmcmFnLnJhd1Byb2dyYW1EYXRlVGltZSkge1xuICAgICAgICAgICAgICAgICAgZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUgPSBjdXJyZW50SW5pdFNlZ21lbnQucmF3UHJvZ3JhbURhdGVUaW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJbml0aWFsIHNlZ21lbnQgdGFnIGlzIGJlZm9yZSBzZWdtZW50IGR1cmF0aW9uIHRhZ1xuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZXJlIEVYVC1YLU1BUCBpcyBkZWNsYXJlZCBhZnRlciBFWFQtWC1CWVRFUkFOR0VcbiAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSBmcmFnLmJ5dGVSYW5nZUVuZE9mZnNldDtcbiAgICAgICAgICAgICAgICBpZiAoZW5kKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IGZyYWcuYnl0ZVJhbmdlU3RhcnRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICBuZXh0Qnl0ZVJhbmdlID0gYCR7ZW5kIC0gc3RhcnR9QCR7c3RhcnR9YDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbmV4dEJ5dGVSYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldEluaXRTZWdtZW50KGZyYWcsIG1hcEF0dHJzLCBpZCwgbGV2ZWxrZXlzKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50SW5pdFNlZ21lbnQgPSBmcmFnO1xuICAgICAgICAgICAgICAgIGNyZWF0ZU5leHRGcmFnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdTRVJWRVItQ09OVFJPTCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IHNlcnZlckNvbnRyb2xBdHRycyA9IG5ldyBBdHRyTGlzdCh2YWx1ZTEpO1xuICAgICAgICAgICAgICBsZXZlbC5jYW5CbG9ja1JlbG9hZCA9IHNlcnZlckNvbnRyb2xBdHRycy5ib29sKCdDQU4tQkxPQ0stUkVMT0FEJyk7XG4gICAgICAgICAgICAgIGxldmVsLmNhblNraXBVbnRpbCA9IHNlcnZlckNvbnRyb2xBdHRycy5vcHRpb25hbEZsb2F0KCdDQU4tU0tJUC1VTlRJTCcsIDApO1xuICAgICAgICAgICAgICBsZXZlbC5jYW5Ta2lwRGF0ZVJhbmdlcyA9IGxldmVsLmNhblNraXBVbnRpbCA+IDAgJiYgc2VydmVyQ29udHJvbEF0dHJzLmJvb2woJ0NBTi1TS0lQLURBVEVSQU5HRVMnKTtcbiAgICAgICAgICAgICAgbGV2ZWwucGFydEhvbGRCYWNrID0gc2VydmVyQ29udHJvbEF0dHJzLm9wdGlvbmFsRmxvYXQoJ1BBUlQtSE9MRC1CQUNLJywgMCk7XG4gICAgICAgICAgICAgIGxldmVsLmhvbGRCYWNrID0gc2VydmVyQ29udHJvbEF0dHJzLm9wdGlvbmFsRmxvYXQoJ0hPTEQtQkFDSycsIDApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdQQVJULUlORic6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnRJbmZBdHRycyA9IG5ldyBBdHRyTGlzdCh2YWx1ZTEpO1xuICAgICAgICAgICAgICBsZXZlbC5wYXJ0VGFyZ2V0ID0gcGFydEluZkF0dHJzLmRlY2ltYWxGbG9hdGluZ1BvaW50KCdQQVJULVRBUkdFVCcpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdQQVJUJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbGV0IHBhcnRMaXN0ID0gbGV2ZWwucGFydExpc3Q7XG4gICAgICAgICAgICAgIGlmICghcGFydExpc3QpIHtcbiAgICAgICAgICAgICAgICBwYXJ0TGlzdCA9IGxldmVsLnBhcnRMaXN0ID0gW107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNGcmFnbWVudFBhcnQgPSBjdXJyZW50UGFydCA+IDAgPyBwYXJ0TGlzdFtwYXJ0TGlzdC5sZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBjdXJyZW50UGFydCsrO1xuICAgICAgICAgICAgICBjb25zdCBwYXJ0QXR0cnMgPSBuZXcgQXR0ckxpc3QodmFsdWUxKTtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMobGV2ZWwsIHBhcnRBdHRycywgWydCWVRFUkFOR0UnLCAnVVJJJ10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnQgPSBuZXcgUGFydChwYXJ0QXR0cnMsIGZyYWcsIGJhc2V1cmwsIGluZGV4LCBwcmV2aW91c0ZyYWdtZW50UGFydCk7XG4gICAgICAgICAgICAgIHBhcnRMaXN0LnB1c2gocGFydCk7XG4gICAgICAgICAgICAgIGZyYWcuZHVyYXRpb24gKz0gcGFydC5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnUFJFTE9BRC1ISU5UJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgcHJlbG9hZEhpbnRBdHRycyA9IG5ldyBBdHRyTGlzdCh2YWx1ZTEpO1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3Vic3RpdHV0ZVZhcmlhYmxlc0luQXR0cmlidXRlcyhsZXZlbCwgcHJlbG9hZEhpbnRBdHRycywgWydVUkknXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV2ZWwucHJlbG9hZEhpbnQgPSBwcmVsb2FkSGludEF0dHJzO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdSRU5ESVRJT04tUkVQT1JUJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgcmVuZGl0aW9uUmVwb3J0QXR0cnMgPSBuZXcgQXR0ckxpc3QodmFsdWUxKTtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMobGV2ZWwsIHJlbmRpdGlvblJlcG9ydEF0dHJzLCBbJ1VSSSddKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXZlbC5yZW5kaXRpb25SZXBvcnRzID0gbGV2ZWwucmVuZGl0aW9uUmVwb3J0cyB8fCBbXTtcbiAgICAgICAgICAgICAgbGV2ZWwucmVuZGl0aW9uUmVwb3J0cy5wdXNoKHJlbmRpdGlvblJlcG9ydEF0dHJzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBsaW5lIHBhcnNlZCBidXQgbm90IGhhbmRsZWQ6ICR7cmVzdWx0fWApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByZXZGcmFnICYmICFwcmV2RnJhZy5yZWx1cmwpIHtcbiAgICAgIGZyYWdtZW50cy5wb3AoKTtcbiAgICAgIHRvdGFsZHVyYXRpb24gLT0gcHJldkZyYWcuZHVyYXRpb247XG4gICAgICBpZiAobGV2ZWwucGFydExpc3QpIHtcbiAgICAgICAgbGV2ZWwuZnJhZ21lbnRIaW50ID0gcHJldkZyYWc7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsZXZlbC5wYXJ0TGlzdCkge1xuICAgICAgYXNzaWduUHJvZ3JhbURhdGVUaW1lKGZyYWcsIHByZXZGcmFnKTtcbiAgICAgIGZyYWcuY2MgPSBkaXNjb250aW51aXR5Q291bnRlcjtcbiAgICAgIGxldmVsLmZyYWdtZW50SGludCA9IGZyYWc7XG4gICAgICBpZiAobGV2ZWxrZXlzKSB7XG4gICAgICAgIHNldEZyYWdMZXZlbEtleXMoZnJhZywgbGV2ZWxrZXlzLCBsZXZlbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZyYWdtZW50TGVuZ3RoID0gZnJhZ21lbnRzLmxlbmd0aDtcbiAgICBjb25zdCBmaXJzdEZyYWdtZW50ID0gZnJhZ21lbnRzWzBdO1xuICAgIGNvbnN0IGxhc3RGcmFnbWVudCA9IGZyYWdtZW50c1tmcmFnbWVudExlbmd0aCAtIDFdO1xuICAgIHRvdGFsZHVyYXRpb24gKz0gbGV2ZWwuc2tpcHBlZFNlZ21lbnRzICogbGV2ZWwudGFyZ2V0ZHVyYXRpb247XG4gICAgaWYgKHRvdGFsZHVyYXRpb24gPiAwICYmIGZyYWdtZW50TGVuZ3RoICYmIGxhc3RGcmFnbWVudCkge1xuICAgICAgbGV2ZWwuYXZlcmFnZXRhcmdldGR1cmF0aW9uID0gdG90YWxkdXJhdGlvbiAvIGZyYWdtZW50TGVuZ3RoO1xuICAgICAgY29uc3QgbGFzdFNuID0gbGFzdEZyYWdtZW50LnNuO1xuICAgICAgbGV2ZWwuZW5kU04gPSBsYXN0U24gIT09ICdpbml0U2VnbWVudCcgPyBsYXN0U24gOiAwO1xuICAgICAgaWYgKCFsZXZlbC5saXZlKSB7XG4gICAgICAgIGxhc3RGcmFnbWVudC5lbmRMaXN0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChmaXJzdEZyYWdtZW50KSB7XG4gICAgICAgIGxldmVsLnN0YXJ0Q0MgPSBmaXJzdEZyYWdtZW50LmNjO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXZlbC5lbmRTTiA9IDA7XG4gICAgICBsZXZlbC5zdGFydENDID0gMDtcbiAgICB9XG4gICAgaWYgKGxldmVsLmZyYWdtZW50SGludCkge1xuICAgICAgdG90YWxkdXJhdGlvbiArPSBsZXZlbC5mcmFnbWVudEhpbnQuZHVyYXRpb247XG4gICAgfVxuICAgIGxldmVsLnRvdGFsZHVyYXRpb24gPSB0b3RhbGR1cmF0aW9uO1xuICAgIGxldmVsLmVuZENDID0gZGlzY29udGludWl0eUNvdW50ZXI7XG5cbiAgICAvKipcbiAgICAgKiBCYWNrZmlsbCBhbnkgbWlzc2luZyBQRFQgdmFsdWVzXG4gICAgICogXCJJZiB0aGUgZmlyc3QgRVhULVgtUFJPR1JBTS1EQVRFLVRJTUUgdGFnIGluIGEgUGxheWxpc3QgYXBwZWFycyBhZnRlclxuICAgICAqIG9uZSBvciBtb3JlIE1lZGlhIFNlZ21lbnQgVVJJcywgdGhlIGNsaWVudCBTSE9VTEQgZXh0cmFwb2xhdGVcbiAgICAgKiBiYWNrd2FyZCBmcm9tIHRoYXQgdGFnICh1c2luZyBFWFRJTkYgZHVyYXRpb25zIGFuZC9vciBtZWRpYVxuICAgICAqIHRpbWVzdGFtcHMpIHRvIGFzc29jaWF0ZSBkYXRlcyB3aXRoIHRob3NlIHNlZ21lbnRzLlwiXG4gICAgICogV2UgaGF2ZSBhbHJlYWR5IGV4dHJhcG9sYXRlZCBmb3J3YXJkLCBidXQgYWxsIGZyYWdtZW50cyB1cCB0byB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgUERUIGRvIG5vdCBoYXZlIHRoZWlyIFBEVHNcbiAgICAgKiBjb21wdXRlZC5cbiAgICAgKi9cbiAgICBpZiAoZmlyc3RQZHRJbmRleCA+IDApIHtcbiAgICAgIGJhY2tmaWxsUHJvZ3JhbURhdGVUaW1lcyhmcmFnbWVudHMsIGZpcnN0UGR0SW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gbGV2ZWw7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlS2V5KGtleVRhZ0F0dHJpYnV0ZXMsIGJhc2V1cmwsIHBhcnNlZCkge1xuICB2YXIgX2tleUF0dHJzJE1FVEhPRCwgX2tleUF0dHJzJEtFWUZPUk1BVDtcbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzgyMTYjc2VjdGlvbi00LjMuMi40XG4gIGNvbnN0IGtleUF0dHJzID0gbmV3IEF0dHJMaXN0KGtleVRhZ0F0dHJpYnV0ZXMpO1xuICB7XG4gICAgc3Vic3RpdHV0ZVZhcmlhYmxlc0luQXR0cmlidXRlcyhwYXJzZWQsIGtleUF0dHJzLCBbJ0tFWUZPUk1BVCcsICdLRVlGT1JNQVRWRVJTSU9OUycsICdVUkknLCAnSVYnLCAnVVJJJ10pO1xuICB9XG4gIGNvbnN0IGRlY3J5cHRtZXRob2QgPSAoX2tleUF0dHJzJE1FVEhPRCA9IGtleUF0dHJzLk1FVEhPRCkgIT0gbnVsbCA/IF9rZXlBdHRycyRNRVRIT0QgOiAnJztcbiAgY29uc3QgZGVjcnlwdHVyaSA9IGtleUF0dHJzLlVSSTtcbiAgY29uc3QgZGVjcnlwdGl2ID0ga2V5QXR0cnMuaGV4YWRlY2ltYWxJbnRlZ2VyKCdJVicpO1xuICBjb25zdCBkZWNyeXB0a2V5Zm9ybWF0dmVyc2lvbnMgPSBrZXlBdHRycy5LRVlGT1JNQVRWRVJTSU9OUztcbiAgLy8gRnJvbSBSRkM6IFRoaXMgYXR0cmlidXRlIGlzIE9QVElPTkFMOyBpdHMgYWJzZW5jZSBpbmRpY2F0ZXMgYW4gaW1wbGljaXQgdmFsdWUgb2YgXCJpZGVudGl0eVwiLlxuICBjb25zdCBkZWNyeXB0a2V5Zm9ybWF0ID0gKF9rZXlBdHRycyRLRVlGT1JNQVQgPSBrZXlBdHRycy5LRVlGT1JNQVQpICE9IG51bGwgPyBfa2V5QXR0cnMkS0VZRk9STUFUIDogJ2lkZW50aXR5JztcbiAgaWYgKGRlY3J5cHR1cmkgJiYga2V5QXR0cnMuSVYgJiYgIWRlY3J5cHRpdikge1xuICAgIGxvZ2dlci5lcnJvcihgSW52YWxpZCBJVjogJHtrZXlBdHRycy5JVn1gKTtcbiAgfVxuICAvLyBJZiBkZWNyeXB0dXJpIGlzIGEgVVJJIHdpdGggYSBzY2hlbWUsIHRoZW4gYmFzZXVybCB3aWxsIGJlIGlnbm9yZWRcbiAgLy8gTm8gdXJpIGlzIGFsbG93ZWQgd2hlbiBNRVRIT0QgaXMgTk9ORVxuICBjb25zdCByZXNvbHZlZFVyaSA9IGRlY3J5cHR1cmkgPyBNM1U4UGFyc2VyLnJlc29sdmUoZGVjcnlwdHVyaSwgYmFzZXVybCkgOiAnJztcbiAgY29uc3Qga2V5Rm9ybWF0VmVyc2lvbnMgPSAoZGVjcnlwdGtleWZvcm1hdHZlcnNpb25zID8gZGVjcnlwdGtleWZvcm1hdHZlcnNpb25zIDogJzEnKS5zcGxpdCgnLycpLm1hcChOdW1iZXIpLmZpbHRlcihOdW1iZXIuaXNGaW5pdGUpO1xuICByZXR1cm4gbmV3IExldmVsS2V5KGRlY3J5cHRtZXRob2QsIHJlc29sdmVkVXJpLCBkZWNyeXB0a2V5Zm9ybWF0LCBrZXlGb3JtYXRWZXJzaW9ucywgZGVjcnlwdGl2KTtcbn1cbmZ1bmN0aW9uIHBhcnNlU3RhcnRUaW1lT2Zmc2V0KHN0YXJ0QXR0cmlidXRlcykge1xuICBjb25zdCBzdGFydEF0dHJzID0gbmV3IEF0dHJMaXN0KHN0YXJ0QXR0cmlidXRlcyk7XG4gIGNvbnN0IHN0YXJ0VGltZU9mZnNldCA9IHN0YXJ0QXR0cnMuZGVjaW1hbEZsb2F0aW5nUG9pbnQoJ1RJTUUtT0ZGU0VUJyk7XG4gIGlmIChpc0Zpbml0ZU51bWJlcihzdGFydFRpbWVPZmZzZXQpKSB7XG4gICAgcmV0dXJuIHN0YXJ0VGltZU9mZnNldDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHNldENvZGVjcyhjb2RlY3NBdHRyaWJ1dGVWYWx1ZSwgbGV2ZWwpIHtcbiAgbGV0IGNvZGVjcyA9IChjb2RlY3NBdHRyaWJ1dGVWYWx1ZSB8fCAnJykuc3BsaXQoL1sgLF0rLykuZmlsdGVyKGMgPT4gYyk7XG4gIFsndmlkZW8nLCAnYXVkaW8nLCAndGV4dCddLmZvckVhY2godHlwZSA9PiB7XG4gICAgY29uc3QgZmlsdGVyZWQgPSBjb2RlY3MuZmlsdGVyKGNvZGVjID0+IGlzQ29kZWNUeXBlKGNvZGVjLCB0eXBlKSk7XG4gICAgaWYgKGZpbHRlcmVkLmxlbmd0aCkge1xuICAgICAgLy8gQ29tbWEgc2VwYXJhdGVkIGxpc3Qgb2YgYWxsIGNvZGVjcyBmb3IgdHlwZVxuICAgICAgbGV2ZWxbYCR7dHlwZX1Db2RlY2BdID0gZmlsdGVyZWQuam9pbignLCcpO1xuICAgICAgLy8gUmVtb3ZlIGtub3duIGNvZGVjcyBzbyB0aGF0IG9ubHkgdW5rbm93bkNvZGVjcyBhcmUgbGVmdCBhZnRlciBpdGVyYXRpbmcgdGhyb3VnaCBlYWNoIHR5cGVcbiAgICAgIGNvZGVjcyA9IGNvZGVjcy5maWx0ZXIoY29kZWMgPT4gZmlsdGVyZWQuaW5kZXhPZihjb2RlYykgPT09IC0xKTtcbiAgICB9XG4gIH0pO1xuICBsZXZlbC51bmtub3duQ29kZWNzID0gY29kZWNzO1xufVxuZnVuY3Rpb24gYXNzaWduQ29kZWMobWVkaWEsIGdyb3VwSXRlbSwgY29kZWNQcm9wZXJ0eSkge1xuICBjb25zdCBjb2RlY1ZhbHVlID0gZ3JvdXBJdGVtW2NvZGVjUHJvcGVydHldO1xuICBpZiAoY29kZWNWYWx1ZSkge1xuICAgIG1lZGlhW2NvZGVjUHJvcGVydHldID0gY29kZWNWYWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gYmFja2ZpbGxQcm9ncmFtRGF0ZVRpbWVzKGZyYWdtZW50cywgZmlyc3RQZHRJbmRleCkge1xuICBsZXQgZnJhZ1ByZXYgPSBmcmFnbWVudHNbZmlyc3RQZHRJbmRleF07XG4gIGZvciAobGV0IGkgPSBmaXJzdFBkdEluZGV4OyBpLS07KSB7XG4gICAgY29uc3QgZnJhZyA9IGZyYWdtZW50c1tpXTtcbiAgICAvLyBFeGl0IG9uIGRlbHRhLXBsYXlsaXN0IHNraXBwZWQgc2VnbWVudHNcbiAgICBpZiAoIWZyYWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZnJhZy5wcm9ncmFtRGF0ZVRpbWUgPSBmcmFnUHJldi5wcm9ncmFtRGF0ZVRpbWUgLSBmcmFnLmR1cmF0aW9uICogMTAwMDtcbiAgICBmcmFnUHJldiA9IGZyYWc7XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2lnblByb2dyYW1EYXRlVGltZShmcmFnLCBwcmV2RnJhZykge1xuICBpZiAoZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICBmcmFnLnByb2dyYW1EYXRlVGltZSA9IERhdGUucGFyc2UoZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUpO1xuICB9IGVsc2UgaWYgKHByZXZGcmFnICE9IG51bGwgJiYgcHJldkZyYWcucHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgZnJhZy5wcm9ncmFtRGF0ZVRpbWUgPSBwcmV2RnJhZy5lbmRQcm9ncmFtRGF0ZVRpbWU7XG4gIH1cbiAgaWYgKCFpc0Zpbml0ZU51bWJlcihmcmFnLnByb2dyYW1EYXRlVGltZSkpIHtcbiAgICBmcmFnLnByb2dyYW1EYXRlVGltZSA9IG51bGw7XG4gICAgZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUgPSBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBzZXRJbml0U2VnbWVudChmcmFnLCBtYXBBdHRycywgaWQsIGxldmVsa2V5cykge1xuICBmcmFnLnJlbHVybCA9IG1hcEF0dHJzLlVSSTtcbiAgaWYgKG1hcEF0dHJzLkJZVEVSQU5HRSkge1xuICAgIGZyYWcuc2V0Qnl0ZVJhbmdlKG1hcEF0dHJzLkJZVEVSQU5HRSk7XG4gIH1cbiAgZnJhZy5sZXZlbCA9IGlkO1xuICBmcmFnLnNuID0gJ2luaXRTZWdtZW50JztcbiAgaWYgKGxldmVsa2V5cykge1xuICAgIGZyYWcubGV2ZWxrZXlzID0gbGV2ZWxrZXlzO1xuICB9XG4gIGZyYWcuaW5pdFNlZ21lbnQgPSBudWxsO1xufVxuZnVuY3Rpb24gc2V0RnJhZ0xldmVsS2V5cyhmcmFnLCBsZXZlbGtleXMsIGxldmVsKSB7XG4gIGZyYWcubGV2ZWxrZXlzID0gbGV2ZWxrZXlzO1xuICBjb25zdCB7XG4gICAgZW5jcnlwdGVkRnJhZ21lbnRzXG4gIH0gPSBsZXZlbDtcbiAgaWYgKCghZW5jcnlwdGVkRnJhZ21lbnRzLmxlbmd0aCB8fCBlbmNyeXB0ZWRGcmFnbWVudHNbZW5jcnlwdGVkRnJhZ21lbnRzLmxlbmd0aCAtIDFdLmxldmVsa2V5cyAhPT0gbGV2ZWxrZXlzKSAmJiBPYmplY3Qua2V5cyhsZXZlbGtleXMpLnNvbWUoZm9ybWF0ID0+IGxldmVsa2V5c1tmb3JtYXRdLmlzQ29tbW9uRW5jcnlwdGlvbikpIHtcbiAgICBlbmNyeXB0ZWRGcmFnbWVudHMucHVzaChmcmFnKTtcbiAgfVxufVxuXG52YXIgUGxheWxpc3RDb250ZXh0VHlwZSA9IHtcbiAgTUFOSUZFU1Q6IFwibWFuaWZlc3RcIixcbiAgTEVWRUw6IFwibGV2ZWxcIixcbiAgQVVESU9fVFJBQ0s6IFwiYXVkaW9UcmFja1wiLFxuICBTVUJUSVRMRV9UUkFDSzogXCJzdWJ0aXRsZVRyYWNrXCJcbn07XG52YXIgUGxheWxpc3RMZXZlbFR5cGUgPSB7XG4gIE1BSU46IFwibWFpblwiLFxuICBBVURJTzogXCJhdWRpb1wiLFxuICBTVUJUSVRMRTogXCJzdWJ0aXRsZVwiXG59O1xuXG5mdW5jdGlvbiBtYXBDb250ZXh0VG9MZXZlbFR5cGUoY29udGV4dCkge1xuICBjb25zdCB7XG4gICAgdHlwZVxuICB9ID0gY29udGV4dDtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBQbGF5bGlzdENvbnRleHRUeXBlLkFVRElPX1RSQUNLOlxuICAgICAgcmV0dXJuIFBsYXlsaXN0TGV2ZWxUeXBlLkFVRElPO1xuICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSzpcbiAgICAgIHJldHVybiBQbGF5bGlzdExldmVsVHlwZS5TVUJUSVRMRTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU47XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFJlc3BvbnNlVXJsKHJlc3BvbnNlLCBjb250ZXh0KSB7XG4gIGxldCB1cmwgPSByZXNwb25zZS51cmw7XG4gIC8vIHJlc3BvbnNlVVJMIG5vdCBzdXBwb3J0ZWQgb24gc29tZSBicm93c2VycyAoaXQgaXMgdXNlZCB0byBkZXRlY3QgVVJMIHJlZGlyZWN0aW9uKVxuICAvLyBkYXRhLXVyaSBtb2RlIGFsc28gbm90IHN1cHBvcnRlZCAoYnV0IG5vIG5lZWQgdG8gZGV0ZWN0IHJlZGlyZWN0aW9uKVxuICBpZiAodXJsID09PSB1bmRlZmluZWQgfHwgdXJsLmluZGV4T2YoJ2RhdGE6JykgPT09IDApIHtcbiAgICAvLyBmYWxsYmFjayB0byBpbml0aWFsIFVSTFxuICAgIHVybCA9IGNvbnRleHQudXJsO1xuICB9XG4gIHJldHVybiB1cmw7XG59XG5jbGFzcyBQbGF5bGlzdExvYWRlciB7XG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMubG9hZGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy52YXJpYWJsZUxpc3QgPSBudWxsO1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICBzdGFydExvYWQoc3RhcnRQb3NpdGlvbikge31cbiAgc3RvcExvYWQoKSB7XG4gICAgdGhpcy5kZXN0cm95SW50ZXJuYWxMb2FkZXJzKCk7XG4gIH1cbiAgcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX0xPQURJTkcsIHRoaXMub25MZXZlbExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQVVESU9fVFJBQ0tfTE9BRElORywgdGhpcy5vbkF1ZGlvVHJhY2tMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLlNVQlRJVExFX1RSQUNLX0xPQURJTkcsIHRoaXMub25TdWJ0aXRsZVRyYWNrTG9hZGluZywgdGhpcyk7XG4gIH1cbiAgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5BVURJT19UUkFDS19MT0FESU5HLCB0aGlzLm9uQXVkaW9UcmFja0xvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLlNVQlRJVExFX1RSQUNLX0xPQURJTkcsIHRoaXMub25TdWJ0aXRsZVRyYWNrTG9hZGluZywgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBkZWZhdWx0cyBvciBjb25maWd1cmVkIGxvYWRlci10eXBlIG92ZXJsb2FkcyAocExvYWRlciBhbmQgbG9hZGVyIGNvbmZpZyBwYXJhbXMpXG4gICAqL1xuICBjcmVhdGVJbnRlcm5hbExvYWRlcihjb250ZXh0KSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuICAgIGNvbnN0IFBMb2FkZXIgPSBjb25maWcucExvYWRlcjtcbiAgICBjb25zdCBMb2FkZXIgPSBjb25maWcubG9hZGVyO1xuICAgIGNvbnN0IEludGVybmFsTG9hZGVyID0gUExvYWRlciB8fCBMb2FkZXI7XG4gICAgY29uc3QgbG9hZGVyID0gbmV3IEludGVybmFsTG9hZGVyKGNvbmZpZyk7XG4gICAgdGhpcy5sb2FkZXJzW2NvbnRleHQudHlwZV0gPSBsb2FkZXI7XG4gICAgcmV0dXJuIGxvYWRlcjtcbiAgfVxuICBnZXRJbnRlcm5hbExvYWRlcihjb250ZXh0KSB7XG4gICAgcmV0dXJuIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdO1xuICB9XG4gIHJlc2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dFR5cGUpIHtcbiAgICBpZiAodGhpcy5sb2FkZXJzW2NvbnRleHRUeXBlXSkge1xuICAgICAgZGVsZXRlIHRoaXMubG9hZGVyc1tjb250ZXh0VHlwZV07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGwgYGRlc3Ryb3lgIG9uIGFsbCBpbnRlcm5hbCBsb2FkZXIgaW5zdGFuY2VzIG1hcHBlZCAob25lIHBlciBjb250ZXh0IHR5cGUpXG4gICAqL1xuICBkZXN0cm95SW50ZXJuYWxMb2FkZXJzKCkge1xuICAgIGZvciAoY29uc3QgY29udGV4dFR5cGUgaW4gdGhpcy5sb2FkZXJzKSB7XG4gICAgICBjb25zdCBsb2FkZXIgPSB0aGlzLmxvYWRlcnNbY29udGV4dFR5cGVdO1xuICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICBsb2FkZXIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXNldEludGVybmFsTG9hZGVyKGNvbnRleHRUeXBlKTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnZhcmlhYmxlTGlzdCA9IG51bGw7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5kZXN0cm95SW50ZXJuYWxMb2FkZXJzKCk7XG4gIH1cbiAgb25NYW5pZmVzdExvYWRpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICB1cmxcbiAgICB9ID0gZGF0YTtcbiAgICB0aGlzLnZhcmlhYmxlTGlzdCA9IG51bGw7XG4gICAgdGhpcy5sb2FkKHtcbiAgICAgIGlkOiBudWxsLFxuICAgICAgbGV2ZWw6IDAsXG4gICAgICByZXNwb25zZVR5cGU6ICd0ZXh0JyxcbiAgICAgIHR5cGU6IFBsYXlsaXN0Q29udGV4dFR5cGUuTUFOSUZFU1QsXG4gICAgICB1cmwsXG4gICAgICBkZWxpdmVyeURpcmVjdGl2ZXM6IG51bGxcbiAgICB9KTtcbiAgfVxuICBvbkxldmVsTG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkLFxuICAgICAgbGV2ZWwsXG4gICAgICBwYXRod2F5SWQsXG4gICAgICB1cmwsXG4gICAgICBkZWxpdmVyeURpcmVjdGl2ZXNcbiAgICB9ID0gZGF0YTtcbiAgICB0aGlzLmxvYWQoe1xuICAgICAgaWQsXG4gICAgICBsZXZlbCxcbiAgICAgIHBhdGh3YXlJZCxcbiAgICAgIHJlc3BvbnNlVHlwZTogJ3RleHQnLFxuICAgICAgdHlwZTogUGxheWxpc3RDb250ZXh0VHlwZS5MRVZFTCxcbiAgICAgIHVybCxcbiAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlc1xuICAgIH0pO1xuICB9XG4gIG9uQXVkaW9UcmFja0xvYWRpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIGdyb3VwSWQsXG4gICAgICB1cmwsXG4gICAgICBkZWxpdmVyeURpcmVjdGl2ZXNcbiAgICB9ID0gZGF0YTtcbiAgICB0aGlzLmxvYWQoe1xuICAgICAgaWQsXG4gICAgICBncm91cElkLFxuICAgICAgbGV2ZWw6IG51bGwsXG4gICAgICByZXNwb25zZVR5cGU6ICd0ZXh0JyxcbiAgICAgIHR5cGU6IFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0ssXG4gICAgICB1cmwsXG4gICAgICBkZWxpdmVyeURpcmVjdGl2ZXNcbiAgICB9KTtcbiAgfVxuICBvblN1YnRpdGxlVHJhY2tMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgaWQsXG4gICAgICBncm91cElkLFxuICAgICAgdXJsLFxuICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzXG4gICAgfSA9IGRhdGE7XG4gICAgdGhpcy5sb2FkKHtcbiAgICAgIGlkLFxuICAgICAgZ3JvdXBJZCxcbiAgICAgIGxldmVsOiBudWxsLFxuICAgICAgcmVzcG9uc2VUeXBlOiAndGV4dCcsXG4gICAgICB0eXBlOiBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLLFxuICAgICAgdXJsLFxuICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzXG4gICAgfSk7XG4gIH1cbiAgbG9hZChjb250ZXh0KSB7XG4gICAgdmFyIF9jb250ZXh0JGRlbGl2ZXJ5RGlyZTtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG5cbiAgICAvLyBsb2dnZXIuZGVidWcoYFtwbGF5bGlzdC1sb2FkZXJdOiBMb2FkaW5nIHBsYXlsaXN0IG9mIHR5cGUgJHtjb250ZXh0LnR5cGV9LCBsZXZlbDogJHtjb250ZXh0LmxldmVsfSwgaWQ6ICR7Y29udGV4dC5pZH1gKTtcblxuICAgIC8vIENoZWNrIGlmIGEgbG9hZGVyIGZvciB0aGlzIGNvbnRleHQgYWxyZWFkeSBleGlzdHNcbiAgICBsZXQgbG9hZGVyID0gdGhpcy5nZXRJbnRlcm5hbExvYWRlcihjb250ZXh0KTtcbiAgICBpZiAobG9hZGVyKSB7XG4gICAgICBjb25zdCBsb2FkZXJDb250ZXh0ID0gbG9hZGVyLmNvbnRleHQ7XG4gICAgICBpZiAobG9hZGVyQ29udGV4dCAmJiBsb2FkZXJDb250ZXh0LnVybCA9PT0gY29udGV4dC51cmwgJiYgbG9hZGVyQ29udGV4dC5sZXZlbCA9PT0gY29udGV4dC5sZXZlbCkge1xuICAgICAgICAvLyBzYW1lIFVSTCBjYW4ndCBvdmVybGFwXG4gICAgICAgIGxvZ2dlci50cmFjZSgnW3BsYXlsaXN0LWxvYWRlcl06IHBsYXlsaXN0IHJlcXVlc3Qgb25nb2luZycpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsb2dnZXIubG9nKGBbcGxheWxpc3QtbG9hZGVyXTogYWJvcnRpbmcgcHJldmlvdXMgbG9hZGVyIGZvciB0eXBlOiAke2NvbnRleHQudHlwZX1gKTtcbiAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IGRpZmZlcmVudCBjb25maWdzIGZvciByZXRyaWVzIGRlcGVuZGluZyBvblxuICAgIC8vIGNvbnRleHQgKG1hbmlmZXN0LCBsZXZlbCwgYXVkaW8vc3VicyBwbGF5bGlzdClcbiAgICBsZXQgbG9hZFBvbGljeTtcbiAgICBpZiAoY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLk1BTklGRVNUKSB7XG4gICAgICBsb2FkUG9saWN5ID0gY29uZmlnLm1hbmlmZXN0TG9hZFBvbGljeS5kZWZhdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2FkUG9saWN5ID0gX2V4dGVuZHMoe30sIGNvbmZpZy5wbGF5bGlzdExvYWRQb2xpY3kuZGVmYXVsdCwge1xuICAgICAgICB0aW1lb3V0UmV0cnk6IG51bGwsXG4gICAgICAgIGVycm9yUmV0cnk6IG51bGxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsb2FkZXIgPSB0aGlzLmNyZWF0ZUludGVybmFsTG9hZGVyKGNvbnRleHQpO1xuXG4gICAgLy8gT3ZlcnJpZGUgbGV2ZWwvdHJhY2sgdGltZW91dCBmb3IgTEwtSExTIHJlcXVlc3RzXG4gICAgLy8gKHRoZSBkZWZhdWx0IG9mIDEwMDAwbXMgaXMgY291bnRlciBwcm9kdWN0aXZlIHRvIGJsb2NraW5nIHBsYXlsaXN0IHJlbG9hZCByZXF1ZXN0cylcbiAgICBpZiAoaXNGaW5pdGVOdW1iZXIoKF9jb250ZXh0JGRlbGl2ZXJ5RGlyZSA9IGNvbnRleHQuZGVsaXZlcnlEaXJlY3RpdmVzKSA9PSBudWxsID8gdm9pZCAwIDogX2NvbnRleHQkZGVsaXZlcnlEaXJlLnBhcnQpKSB7XG4gICAgICBsZXQgbGV2ZWxEZXRhaWxzO1xuICAgICAgaWYgKGNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5MRVZFTCAmJiBjb250ZXh0LmxldmVsICE9PSBudWxsKSB7XG4gICAgICAgIGxldmVsRGV0YWlscyA9IHRoaXMuaGxzLmxldmVsc1tjb250ZXh0LmxldmVsXS5kZXRhaWxzO1xuICAgICAgfSBlbHNlIGlmIChjb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0sgJiYgY29udGV4dC5pZCAhPT0gbnVsbCkge1xuICAgICAgICBsZXZlbERldGFpbHMgPSB0aGlzLmhscy5hdWRpb1RyYWNrc1tjb250ZXh0LmlkXS5kZXRhaWxzO1xuICAgICAgfSBlbHNlIGlmIChjb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuU1VCVElUTEVfVFJBQ0sgJiYgY29udGV4dC5pZCAhPT0gbnVsbCkge1xuICAgICAgICBsZXZlbERldGFpbHMgPSB0aGlzLmhscy5zdWJ0aXRsZVRyYWNrc1tjb250ZXh0LmlkXS5kZXRhaWxzO1xuICAgICAgfVxuICAgICAgaWYgKGxldmVsRGV0YWlscykge1xuICAgICAgICBjb25zdCBwYXJ0VGFyZ2V0ID0gbGV2ZWxEZXRhaWxzLnBhcnRUYXJnZXQ7XG4gICAgICAgIGNvbnN0IHRhcmdldER1cmF0aW9uID0gbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uO1xuICAgICAgICBpZiAocGFydFRhcmdldCAmJiB0YXJnZXREdXJhdGlvbikge1xuICAgICAgICAgIGNvbnN0IG1heExvd0xhdGVuY3lQbGF5bGlzdFJlZnJlc2ggPSBNYXRoLm1heChwYXJ0VGFyZ2V0ICogMywgdGFyZ2V0RHVyYXRpb24gKiAwLjgpICogMTAwMDtcbiAgICAgICAgICBsb2FkUG9saWN5ID0gX2V4dGVuZHMoe30sIGxvYWRQb2xpY3ksIHtcbiAgICAgICAgICAgIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zOiBNYXRoLm1pbihtYXhMb3dMYXRlbmN5UGxheWxpc3RSZWZyZXNoLCBsb2FkUG9saWN5Lm1heFRpbWVUb0ZpcnN0Qnl0ZU1zKSxcbiAgICAgICAgICAgIG1heExvYWRUaW1lTXM6IE1hdGgubWluKG1heExvd0xhdGVuY3lQbGF5bGlzdFJlZnJlc2gsIGxvYWRQb2xpY3kubWF4VGltZVRvRmlyc3RCeXRlTXMpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbGVnYWN5UmV0cnlDb21wYXRpYmlsaXR5ID0gbG9hZFBvbGljeS5lcnJvclJldHJ5IHx8IGxvYWRQb2xpY3kudGltZW91dFJldHJ5IHx8IHt9O1xuICAgIGNvbnN0IGxvYWRlckNvbmZpZyA9IHtcbiAgICAgIGxvYWRQb2xpY3ksXG4gICAgICB0aW1lb3V0OiBsb2FkUG9saWN5Lm1heExvYWRUaW1lTXMsXG4gICAgICBtYXhSZXRyeTogbGVnYWN5UmV0cnlDb21wYXRpYmlsaXR5Lm1heE51bVJldHJ5IHx8IDAsXG4gICAgICByZXRyeURlbGF5OiBsZWdhY3lSZXRyeUNvbXBhdGliaWxpdHkucmV0cnlEZWxheU1zIHx8IDAsXG4gICAgICBtYXhSZXRyeURlbGF5OiBsZWdhY3lSZXRyeUNvbXBhdGliaWxpdHkubWF4UmV0cnlEZWxheU1zIHx8IDBcbiAgICB9O1xuICAgIGNvbnN0IGxvYWRlckNhbGxiYWNrcyA9IHtcbiAgICAgIG9uU3VjY2VzczogKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpID0+IHtcbiAgICAgICAgY29uc3QgbG9hZGVyID0gdGhpcy5nZXRJbnRlcm5hbExvYWRlcihjb250ZXh0KTtcbiAgICAgICAgdGhpcy5yZXNldEludGVybmFsTG9hZGVyKGNvbnRleHQudHlwZSk7XG4gICAgICAgIGNvbnN0IHN0cmluZyA9IHJlc3BvbnNlLmRhdGE7XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgaWYgaXQgaXMgYW4gTTNVOCBhdCBhbGxcbiAgICAgICAgaWYgKHN0cmluZy5pbmRleE9mKCcjRVhUTTNVJykgIT09IDApIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZU1hbmlmZXN0UGFyc2luZ0Vycm9yKHJlc3BvbnNlLCBjb250ZXh0LCBuZXcgRXJyb3IoJ25vIEVYVE0zVSBkZWxpbWl0ZXInKSwgbmV0d29ya0RldGFpbHMgfHwgbnVsbCwgc3RhdHMpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdGF0cy5wYXJzaW5nLnN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGlmIChNM1U4UGFyc2VyLmlzTWVkaWFQbGF5bGlzdChzdHJpbmcpKSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVUcmFja09yTGV2ZWxQbGF5bGlzdChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzIHx8IG51bGwsIGxvYWRlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVNYXN0ZXJQbGF5bGlzdChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uRXJyb3I6IChyZXNwb25zZSwgY29udGV4dCwgbmV0d29ya0RldGFpbHMsIHN0YXRzKSA9PiB7XG4gICAgICAgIHRoaXMuaGFuZGxlTmV0d29ya0Vycm9yKGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCBmYWxzZSwgcmVzcG9uc2UsIHN0YXRzKTtcbiAgICAgIH0sXG4gICAgICBvblRpbWVvdXQ6IChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpID0+IHtcbiAgICAgICAgdGhpcy5oYW5kbGVOZXR3b3JrRXJyb3IoY29udGV4dCwgbmV0d29ya0RldGFpbHMsIHRydWUsIHVuZGVmaW5lZCwgc3RhdHMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBsb2dnZXIuZGVidWcoYFtwbGF5bGlzdC1sb2FkZXJdOiBDYWxsaW5nIGludGVybmFsIGxvYWRlciBkZWxlZ2F0ZSBmb3IgVVJMOiAke2NvbnRleHQudXJsfWApO1xuXG4gICAgbG9hZGVyLmxvYWQoY29udGV4dCwgbG9hZGVyQ29uZmlnLCBsb2FkZXJDYWxsYmFja3MpO1xuICB9XG4gIGhhbmRsZU1hc3RlclBsYXlsaXN0KHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBjb25zdCBzdHJpbmcgPSByZXNwb25zZS5kYXRhO1xuICAgIGNvbnN0IHVybCA9IGdldFJlc3BvbnNlVXJsKHJlc3BvbnNlLCBjb250ZXh0KTtcbiAgICBjb25zdCBwYXJzZWRSZXN1bHQgPSBNM1U4UGFyc2VyLnBhcnNlTWFzdGVyUGxheWxpc3Qoc3RyaW5nLCB1cmwpO1xuICAgIGlmIChwYXJzZWRSZXN1bHQucGxheWxpc3RQYXJzaW5nRXJyb3IpIHtcbiAgICAgIHRoaXMuaGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3IocmVzcG9uc2UsIGNvbnRleHQsIHBhcnNlZFJlc3VsdC5wbGF5bGlzdFBhcnNpbmdFcnJvciwgbmV0d29ya0RldGFpbHMsIHN0YXRzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY29udGVudFN0ZWVyaW5nLFxuICAgICAgbGV2ZWxzLFxuICAgICAgc2Vzc2lvbkRhdGEsXG4gICAgICBzZXNzaW9uS2V5cyxcbiAgICAgIHN0YXJ0VGltZU9mZnNldCxcbiAgICAgIHZhcmlhYmxlTGlzdFxuICAgIH0gPSBwYXJzZWRSZXN1bHQ7XG4gICAgdGhpcy52YXJpYWJsZUxpc3QgPSB2YXJpYWJsZUxpc3Q7XG4gICAgY29uc3Qge1xuICAgICAgQVVESU86IGF1ZGlvVHJhY2tzID0gW10sXG4gICAgICBTVUJUSVRMRVM6IHN1YnRpdGxlcyxcbiAgICAgICdDTE9TRUQtQ0FQVElPTlMnOiBjYXB0aW9uc1xuICAgIH0gPSBNM1U4UGFyc2VyLnBhcnNlTWFzdGVyUGxheWxpc3RNZWRpYShzdHJpbmcsIHVybCwgcGFyc2VkUmVzdWx0KTtcbiAgICBpZiAoYXVkaW9UcmFja3MubGVuZ3RoKSB7XG4gICAgICAvLyBjaGVjayBpZiB3ZSBoYXZlIGZvdW5kIGFuIGF1ZGlvIHRyYWNrIGVtYmVkZGVkIGluIG1haW4gcGxheWxpc3QgKGF1ZGlvIHRyYWNrIHdpdGhvdXQgVVJJIGF0dHJpYnV0ZSlcbiAgICAgIGNvbnN0IGVtYmVkZGVkQXVkaW9Gb3VuZCA9IGF1ZGlvVHJhY2tzLnNvbWUoYXVkaW9UcmFjayA9PiAhYXVkaW9UcmFjay51cmwpO1xuXG4gICAgICAvLyBpZiBubyBlbWJlZGRlZCBhdWRpbyB0cmFjayBkZWZpbmVkLCBidXQgYXVkaW8gY29kZWMgc2lnbmFsZWQgaW4gcXVhbGl0eSBsZXZlbCxcbiAgICAgIC8vIHdlIG5lZWQgdG8gc2lnbmFsIHRoaXMgbWFpbiBhdWRpbyB0cmFjayB0aGlzIGNvdWxkIGhhcHBlbiB3aXRoIHBsYXlsaXN0cyB3aXRoXG4gICAgICAvLyBhbHQgYXVkaW8gcmVuZGl0aW9uIGluIHdoaWNoIHF1YWxpdHkgbGV2ZWxzIChtYWluKVxuICAgICAgLy8gY29udGFpbnMgYm90aCBhdWRpbyt2aWRlby4gYnV0IHdpdGggbWl4ZWQgYXVkaW8gdHJhY2sgbm90IHNpZ25hbGVkXG4gICAgICBpZiAoIWVtYmVkZGVkQXVkaW9Gb3VuZCAmJiBsZXZlbHNbMF0uYXVkaW9Db2RlYyAmJiAhbGV2ZWxzWzBdLmF0dHJzLkFVRElPKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ1twbGF5bGlzdC1sb2FkZXJdOiBhdWRpbyBjb2RlYyBzaWduYWxlZCBpbiBxdWFsaXR5IGxldmVsLCBidXQgbm8gZW1iZWRkZWQgYXVkaW8gdHJhY2sgc2lnbmFsZWQsIGNyZWF0ZSBvbmUnKTtcbiAgICAgICAgYXVkaW9UcmFja3MudW5zaGlmdCh7XG4gICAgICAgICAgdHlwZTogJ21haW4nLFxuICAgICAgICAgIG5hbWU6ICdtYWluJyxcbiAgICAgICAgICBncm91cElkOiAnbWFpbicsXG4gICAgICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICAgICAgYXV0b3NlbGVjdDogZmFsc2UsXG4gICAgICAgICAgZm9yY2VkOiBmYWxzZSxcbiAgICAgICAgICBpZDogLTEsXG4gICAgICAgICAgYXR0cnM6IG5ldyBBdHRyTGlzdCh7fSksXG4gICAgICAgICAgYml0cmF0ZTogMCxcbiAgICAgICAgICB1cmw6ICcnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBobHMudHJpZ2dlcihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB7XG4gICAgICBsZXZlbHMsXG4gICAgICBhdWRpb1RyYWNrcyxcbiAgICAgIHN1YnRpdGxlcyxcbiAgICAgIGNhcHRpb25zLFxuICAgICAgY29udGVudFN0ZWVyaW5nLFxuICAgICAgdXJsLFxuICAgICAgc3RhdHMsXG4gICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgIHNlc3Npb25EYXRhLFxuICAgICAgc2Vzc2lvbktleXMsXG4gICAgICBzdGFydFRpbWVPZmZzZXQsXG4gICAgICB2YXJpYWJsZUxpc3RcbiAgICB9KTtcbiAgfVxuICBoYW5kbGVUcmFja09yTGV2ZWxQbGF5bGlzdChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCBsb2FkZXIpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIGxldmVsLFxuICAgICAgdHlwZVxuICAgIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IHVybCA9IGdldFJlc3BvbnNlVXJsKHJlc3BvbnNlLCBjb250ZXh0KTtcbiAgICBjb25zdCBsZXZlbFVybElkID0gMDtcbiAgICBjb25zdCBsZXZlbElkID0gaXNGaW5pdGVOdW1iZXIobGV2ZWwpID8gbGV2ZWwgOiBpc0Zpbml0ZU51bWJlcihpZCkgPyBpZCA6IDA7XG4gICAgY29uc3QgbGV2ZWxUeXBlID0gbWFwQ29udGV4dFRvTGV2ZWxUeXBlKGNvbnRleHQpO1xuICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IE0zVThQYXJzZXIucGFyc2VMZXZlbFBsYXlsaXN0KHJlc3BvbnNlLmRhdGEsIHVybCwgbGV2ZWxJZCwgbGV2ZWxUeXBlLCBsZXZlbFVybElkLCB0aGlzLnZhcmlhYmxlTGlzdCk7XG5cbiAgICAvLyBXZSBoYXZlIGRvbmUgb3VyIGZpcnN0IHJlcXVlc3QgKE1hbmlmZXN0LXR5cGUpIGFuZCByZWNlaXZlXG4gICAgLy8gbm90IGEgbWFzdGVyIHBsYXlsaXN0IGJ1dCBhIGNodW5rLWxpc3QgKHRyYWNrL2xldmVsKVxuICAgIC8vIFdlIGZpcmUgdGhlIG1hbmlmZXN0LWxvYWRlZCBldmVudCBhbnl3YXkgd2l0aCB0aGUgcGFyc2VkIGxldmVsLWRldGFpbHNcbiAgICAvLyBieSBjcmVhdGluZyBhIHNpbmdsZS1sZXZlbCBzdHJ1Y3R1cmUgZm9yIGl0LlxuICAgIGlmICh0eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLk1BTklGRVNUKSB7XG4gICAgICBjb25zdCBzaW5nbGVMZXZlbCA9IHtcbiAgICAgICAgYXR0cnM6IG5ldyBBdHRyTGlzdCh7fSksXG4gICAgICAgIGJpdHJhdGU6IDAsXG4gICAgICAgIGRldGFpbHM6IGxldmVsRGV0YWlscyxcbiAgICAgICAgbmFtZTogJycsXG4gICAgICAgIHVybFxuICAgICAgfTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5NQU5JRkVTVF9MT0FERUQsIHtcbiAgICAgICAgbGV2ZWxzOiBbc2luZ2xlTGV2ZWxdLFxuICAgICAgICBhdWRpb1RyYWNrczogW10sXG4gICAgICAgIHVybCxcbiAgICAgICAgc3RhdHMsXG4gICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICBzZXNzaW9uRGF0YTogbnVsbCxcbiAgICAgICAgc2Vzc2lvbktleXM6IG51bGwsXG4gICAgICAgIGNvbnRlbnRTdGVlcmluZzogbnVsbCxcbiAgICAgICAgc3RhcnRUaW1lT2Zmc2V0OiBudWxsLFxuICAgICAgICB2YXJpYWJsZUxpc3Q6IG51bGxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHNhdmUgcGFyc2luZyB0aW1lXG4gICAgc3RhdHMucGFyc2luZy5lbmQgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAgIC8vIGV4dGVuZCB0aGUgY29udGV4dCB3aXRoIHRoZSBuZXcgbGV2ZWxEZXRhaWxzIHByb3BlcnR5XG4gICAgY29udGV4dC5sZXZlbERldGFpbHMgPSBsZXZlbERldGFpbHM7XG4gICAgdGhpcy5oYW5kbGVQbGF5bGlzdExvYWRlZChsZXZlbERldGFpbHMsIHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMsIGxvYWRlcik7XG4gIH1cbiAgaGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3IocmVzcG9uc2UsIGNvbnRleHQsIGVycm9yLCBuZXR3b3JrRGV0YWlscywgc3RhdHMpIHtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLk1BTklGRVNUX1BBUlNJTkdfRVJST1IsXG4gICAgICBmYXRhbDogY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLk1BTklGRVNULFxuICAgICAgdXJsOiByZXNwb25zZS51cmwsXG4gICAgICBlcnI6IGVycm9yLFxuICAgICAgZXJyb3IsXG4gICAgICByZWFzb246IGVycm9yLm1lc3NhZ2UsXG4gICAgICByZXNwb25zZSxcbiAgICAgIGNvbnRleHQsXG4gICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgIHN0YXRzXG4gICAgfSk7XG4gIH1cbiAgaGFuZGxlTmV0d29ya0Vycm9yKGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCB0aW1lb3V0ID0gZmFsc2UsIHJlc3BvbnNlLCBzdGF0cykge1xuICAgIGxldCBtZXNzYWdlID0gYEEgbmV0d29yayAke3RpbWVvdXQgPyAndGltZW91dCcgOiAnZXJyb3InICsgKHJlc3BvbnNlID8gJyAoc3RhdHVzICcgKyByZXNwb25zZS5jb2RlICsgJyknIDogJycpfSBvY2N1cnJlZCB3aGlsZSBsb2FkaW5nICR7Y29udGV4dC50eXBlfWA7XG4gICAgaWYgKGNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5MRVZFTCkge1xuICAgICAgbWVzc2FnZSArPSBgOiAke2NvbnRleHQubGV2ZWx9IGlkOiAke2NvbnRleHQuaWR9YDtcbiAgICB9IGVsc2UgaWYgKGNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSyB8fCBjb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuU1VCVElUTEVfVFJBQ0spIHtcbiAgICAgIG1lc3NhZ2UgKz0gYCBpZDogJHtjb250ZXh0LmlkfSBncm91cC1pZDogXCIke2NvbnRleHQuZ3JvdXBJZH1cImA7XG4gICAgfVxuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIGxvZ2dlci53YXJuKGBbcGxheWxpc3QtbG9hZGVyXTogJHttZXNzYWdlfWApO1xuICAgIGxldCBkZXRhaWxzID0gRXJyb3JEZXRhaWxzLlVOS05PV047XG4gICAgbGV0IGZhdGFsID0gZmFsc2U7XG4gICAgY29uc3QgbG9hZGVyID0gdGhpcy5nZXRJbnRlcm5hbExvYWRlcihjb250ZXh0KTtcbiAgICBzd2l0Y2ggKGNvbnRleHQudHlwZSkge1xuICAgICAgY2FzZSBQbGF5bGlzdENvbnRleHRUeXBlLk1BTklGRVNUOlxuICAgICAgICBkZXRhaWxzID0gdGltZW91dCA/IEVycm9yRGV0YWlscy5NQU5JRkVTVF9MT0FEX1RJTUVPVVQgOiBFcnJvckRldGFpbHMuTUFOSUZFU1RfTE9BRF9FUlJPUjtcbiAgICAgICAgZmF0YWwgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5MRVZFTDpcbiAgICAgICAgZGV0YWlscyA9IHRpbWVvdXQgPyBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9USU1FT1VUIDogRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfRVJST1I7XG4gICAgICAgIGZhdGFsID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQbGF5bGlzdENvbnRleHRUeXBlLkFVRElPX1RSQUNLOlxuICAgICAgICBkZXRhaWxzID0gdGltZW91dCA/IEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX1RJTUVPVVQgOiBFcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9FUlJPUjtcbiAgICAgICAgZmF0YWwgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBsYXlsaXN0Q29udGV4dFR5cGUuU1VCVElUTEVfVFJBQ0s6XG4gICAgICAgIGRldGFpbHMgPSB0aW1lb3V0ID8gRXJyb3JEZXRhaWxzLlNVQlRJVExFX1RSQUNLX0xPQURfVElNRU9VVCA6IEVycm9yRGV0YWlscy5TVUJUSVRMRV9MT0FEX0VSUk9SO1xuICAgICAgICBmYXRhbCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgdGhpcy5yZXNldEludGVybmFsTG9hZGVyKGNvbnRleHQudHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGVycm9yRGF0YSA9IHtcbiAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgIGRldGFpbHMsXG4gICAgICBmYXRhbCxcbiAgICAgIHVybDogY29udGV4dC51cmwsXG4gICAgICBsb2FkZXIsXG4gICAgICBjb250ZXh0LFxuICAgICAgZXJyb3IsXG4gICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgIHN0YXRzXG4gICAgfTtcbiAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgIGNvbnN0IHVybCA9IChuZXR3b3JrRGV0YWlscyA9PSBudWxsID8gdm9pZCAwIDogbmV0d29ya0RldGFpbHMudXJsKSB8fCBjb250ZXh0LnVybDtcbiAgICAgIGVycm9yRGF0YS5yZXNwb25zZSA9IF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgdXJsLFxuICAgICAgICBkYXRhOiB1bmRlZmluZWRcbiAgICAgIH0sIHJlc3BvbnNlKTtcbiAgICB9XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIGVycm9yRGF0YSk7XG4gIH1cbiAgaGFuZGxlUGxheWxpc3RMb2FkZWQobGV2ZWxEZXRhaWxzLCByZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCBsb2FkZXIpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBjb25zdCB7XG4gICAgICB0eXBlLFxuICAgICAgbGV2ZWwsXG4gICAgICBpZCxcbiAgICAgIGdyb3VwSWQsXG4gICAgICBkZWxpdmVyeURpcmVjdGl2ZXNcbiAgICB9ID0gY29udGV4dDtcbiAgICBjb25zdCB1cmwgPSBnZXRSZXNwb25zZVVybChyZXNwb25zZSwgY29udGV4dCk7XG4gICAgY29uc3QgcGFyZW50ID0gbWFwQ29udGV4dFRvTGV2ZWxUeXBlKGNvbnRleHQpO1xuICAgIGNvbnN0IGxldmVsSW5kZXggPSB0eXBlb2YgY29udGV4dC5sZXZlbCA9PT0gJ251bWJlcicgJiYgcGFyZW50ID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOID8gbGV2ZWwgOiB1bmRlZmluZWQ7XG4gICAgaWYgKCFsZXZlbERldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgY29uc3QgX2Vycm9yID0gbmV3IEVycm9yKCdObyBTZWdtZW50cyBmb3VuZCBpbiBQbGF5bGlzdCcpO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkxFVkVMX0VNUFRZX0VSUk9SLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIHVybCxcbiAgICAgICAgZXJyb3I6IF9lcnJvcixcbiAgICAgICAgcmVhc29uOiBfZXJyb3IubWVzc2FnZSxcbiAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGxldmVsOiBsZXZlbEluZGV4LFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICBzdGF0c1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uKSB7XG4gICAgICBsZXZlbERldGFpbHMucGxheWxpc3RQYXJzaW5nRXJyb3IgPSBuZXcgRXJyb3IoJ01pc3NpbmcgVGFyZ2V0IER1cmF0aW9uJyk7XG4gICAgfVxuICAgIGNvbnN0IGVycm9yID0gbGV2ZWxEZXRhaWxzLnBsYXlsaXN0UGFyc2luZ0Vycm9yO1xuICAgIGlmIChlcnJvcikge1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkxFVkVMX1BBUlNJTkdfRVJST1IsXG4gICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgdXJsLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgcmVhc29uOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICByZXNwb25zZSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgbGV2ZWw6IGxldmVsSW5kZXgsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICAgIHN0YXRzXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGxldmVsRGV0YWlscy5saXZlICYmIGxvYWRlcikge1xuICAgICAgaWYgKGxvYWRlci5nZXRDYWNoZUFnZSkge1xuICAgICAgICBsZXZlbERldGFpbHMuYWdlSGVhZGVyID0gbG9hZGVyLmdldENhY2hlQWdlKCkgfHwgMDtcbiAgICAgIH1cbiAgICAgIGlmICghbG9hZGVyLmdldENhY2hlQWdlIHx8IGlzTmFOKGxldmVsRGV0YWlscy5hZ2VIZWFkZXIpKSB7XG4gICAgICAgIGxldmVsRGV0YWlscy5hZ2VIZWFkZXIgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5NQU5JRkVTVDpcbiAgICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5MRVZFTDpcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkxFVkVMX0xPQURFRCwge1xuICAgICAgICAgIGRldGFpbHM6IGxldmVsRGV0YWlscyxcbiAgICAgICAgICBsZXZlbDogbGV2ZWxJbmRleCB8fCAwLFxuICAgICAgICAgIGlkOiBpZCB8fCAwLFxuICAgICAgICAgIHN0YXRzLFxuICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlc1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0s6XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5BVURJT19UUkFDS19MT0FERUQsIHtcbiAgICAgICAgICBkZXRhaWxzOiBsZXZlbERldGFpbHMsXG4gICAgICAgICAgaWQ6IGlkIHx8IDAsXG4gICAgICAgICAgZ3JvdXBJZDogZ3JvdXBJZCB8fCAnJyxcbiAgICAgICAgICBzdGF0cyxcbiAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXNcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLOlxuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuU1VCVElUTEVfVFJBQ0tfTE9BREVELCB7XG4gICAgICAgICAgZGV0YWlsczogbGV2ZWxEZXRhaWxzLFxuICAgICAgICAgIGlkOiBpZCB8fCAwLFxuICAgICAgICAgIGdyb3VwSWQ6IGdyb3VwSWQgfHwgJycsXG4gICAgICAgICAgc3RhdHMsXG4gICAgICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2VuZEFkZFRyYWNrRXZlbnQodHJhY2ssIHZpZGVvRWwpIHtcbiAgbGV0IGV2ZW50O1xuICB0cnkge1xuICAgIGV2ZW50ID0gbmV3IEV2ZW50KCdhZGR0cmFjaycpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBmb3IgSUUxMVxuICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZXZlbnQuaW5pdEV2ZW50KCdhZGR0cmFjaycsIGZhbHNlLCBmYWxzZSk7XG4gIH1cbiAgZXZlbnQudHJhY2sgPSB0cmFjaztcbiAgdmlkZW9FbC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbn1cbmZ1bmN0aW9uIGFkZEN1ZVRvVHJhY2sodHJhY2ssIGN1ZSkge1xuICAvLyBTb21ldGltZXMgdGhlcmUgYXJlIGN1ZSBvdmVybGFwcyBvbiBzZWdtZW50ZWQgdnR0cyBzbyB0aGUgc2FtZVxuICAvLyBjdWUgY2FuIGFwcGVhciBtb3JlIHRoYW4gb25jZSBpbiBkaWZmZXJlbnQgdnR0IGZpbGVzLlxuICAvLyBUaGlzIGF2b2lkIHNob3dpbmcgZHVwbGljYXRlZCBjdWVzIHdpdGggc2FtZSB0aW1lY29kZSBhbmQgdGV4dC5cbiAgY29uc3QgbW9kZSA9IHRyYWNrLm1vZGU7XG4gIGlmIChtb2RlID09PSAnZGlzYWJsZWQnKSB7XG4gICAgdHJhY2subW9kZSA9ICdoaWRkZW4nO1xuICB9XG4gIGlmICh0cmFjay5jdWVzICYmICF0cmFjay5jdWVzLmdldEN1ZUJ5SWQoY3VlLmlkKSkge1xuICAgIHRyeSB7XG4gICAgICB0cmFjay5hZGRDdWUoY3VlKTtcbiAgICAgIGlmICghdHJhY2suY3Vlcy5nZXRDdWVCeUlkKGN1ZS5pZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhZGRDdWUgaXMgZmFpbGVkIGZvcjogJHtjdWV9YCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2dnZXIuZGVidWcoYFt0ZXh0dHJhY2stdXRpbHNdOiAke2Vycn1gKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHRleHRUcmFja0N1ZSA9IG5ldyBzZWxmLlRleHRUcmFja0N1ZShjdWUuc3RhcnRUaW1lLCBjdWUuZW5kVGltZSwgY3VlLnRleHQpO1xuICAgICAgICB0ZXh0VHJhY2tDdWUuaWQgPSBjdWUuaWQ7XG4gICAgICAgIHRyYWNrLmFkZEN1ZSh0ZXh0VHJhY2tDdWUpO1xuICAgICAgfSBjYXRjaCAoZXJyMikge1xuICAgICAgICBsb2dnZXIuZGVidWcoYFt0ZXh0dHJhY2stdXRpbHNdOiBMZWdhY3kgVGV4dFRyYWNrQ3VlIGZhbGxiYWNrIGZhaWxlZDogJHtlcnIyfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAobW9kZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgIHRyYWNrLm1vZGUgPSBtb2RlO1xuICB9XG59XG5mdW5jdGlvbiBjbGVhckN1cnJlbnRDdWVzKHRyYWNrKSB7XG4gIC8vIFdoZW4gdHJhY2subW9kZSBpcyBkaXNhYmxlZCwgdHJhY2suY3VlcyB3aWxsIGJlIG51bGwuXG4gIC8vIFRvIGd1YXJhbnRlZSB0aGUgcmVtb3ZhbCBvZiBjdWVzLCB3ZSBuZWVkIHRvIHRlbXBvcmFyaWx5XG4gIC8vIGNoYW5nZSB0aGUgbW9kZSB0byBoaWRkZW5cbiAgY29uc3QgbW9kZSA9IHRyYWNrLm1vZGU7XG4gIGlmIChtb2RlID09PSAnZGlzYWJsZWQnKSB7XG4gICAgdHJhY2subW9kZSA9ICdoaWRkZW4nO1xuICB9XG4gIGlmICh0cmFjay5jdWVzKSB7XG4gICAgZm9yIChsZXQgaSA9IHRyYWNrLmN1ZXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICB0cmFjay5yZW1vdmVDdWUodHJhY2suY3Vlc1tpXSk7XG4gICAgfVxuICB9XG4gIGlmIChtb2RlID09PSAnZGlzYWJsZWQnKSB7XG4gICAgdHJhY2subW9kZSA9IG1vZGU7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZUN1ZXNJblJhbmdlKHRyYWNrLCBzdGFydCwgZW5kLCBwcmVkaWNhdGUpIHtcbiAgY29uc3QgbW9kZSA9IHRyYWNrLm1vZGU7XG4gIGlmIChtb2RlID09PSAnZGlzYWJsZWQnKSB7XG4gICAgdHJhY2subW9kZSA9ICdoaWRkZW4nO1xuICB9XG4gIGlmICh0cmFjay5jdWVzICYmIHRyYWNrLmN1ZXMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGN1ZXMgPSBnZXRDdWVzSW5SYW5nZSh0cmFjay5jdWVzLCBzdGFydCwgZW5kKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghcHJlZGljYXRlIHx8IHByZWRpY2F0ZShjdWVzW2ldKSkge1xuICAgICAgICB0cmFjay5yZW1vdmVDdWUoY3Vlc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChtb2RlID09PSAnZGlzYWJsZWQnKSB7XG4gICAgdHJhY2subW9kZSA9IG1vZGU7XG4gIH1cbn1cblxuLy8gRmluZCBmaXJzdCBjdWUgc3RhcnRpbmcgYWZ0ZXIgZ2l2ZW4gdGltZS5cbi8vIE1vZGlmaWVkIHZlcnNpb24gb2YgYmluYXJ5IHNlYXJjaCBPKGxvZyhuKSkuXG5mdW5jdGlvbiBnZXRGaXJzdEN1ZUluZGV4QWZ0ZXJUaW1lKGN1ZXMsIHRpbWUpIHtcbiAgLy8gSWYgZmlyc3QgY3VlIHN0YXJ0cyBhZnRlciB0aW1lLCBzdGFydCB0aGVyZVxuICBpZiAodGltZSA8IGN1ZXNbMF0uc3RhcnRUaW1lKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgLy8gSWYgdGhlIGxhc3QgY3VlIGVuZHMgYmVmb3JlIHRpbWUgdGhlcmUgaXMgbm8gb3ZlcmxhcFxuICBjb25zdCBsZW4gPSBjdWVzLmxlbmd0aCAtIDE7XG4gIGlmICh0aW1lID4gY3Vlc1tsZW5dLmVuZFRpbWUpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgbGV0IGxlZnQgPSAwO1xuICBsZXQgcmlnaHQgPSBsZW47XG4gIHdoaWxlIChsZWZ0IDw9IHJpZ2h0KSB7XG4gICAgY29uc3QgbWlkID0gTWF0aC5mbG9vcigocmlnaHQgKyBsZWZ0KSAvIDIpO1xuICAgIGlmICh0aW1lIDwgY3Vlc1ttaWRdLnN0YXJ0VGltZSkge1xuICAgICAgcmlnaHQgPSBtaWQgLSAxO1xuICAgIH0gZWxzZSBpZiAodGltZSA+IGN1ZXNbbWlkXS5zdGFydFRpbWUgJiYgbGVmdCA8IGxlbikge1xuICAgICAgbGVmdCA9IG1pZCArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGl0J3Mgbm90IGxvd2VyIG9yIGhpZ2hlciwgaXQgbXVzdCBiZSBlcXVhbC5cbiAgICAgIHJldHVybiBtaWQ7XG4gICAgfVxuICB9XG4gIC8vIEF0IHRoaXMgcG9pbnQsIGxlZnQgYW5kIHJpZ2h0IGhhdmUgc3dhcHBlZC5cbiAgLy8gTm8gZGlyZWN0IG1hdGNoIHdhcyBmb3VuZCwgbGVmdCBvciByaWdodCBlbGVtZW50IG11c3QgYmUgdGhlIGNsb3Nlc3QuIENoZWNrIHdoaWNoIG9uZSBoYXMgdGhlIHNtYWxsZXN0IGRpZmYuXG4gIHJldHVybiBjdWVzW2xlZnRdLnN0YXJ0VGltZSAtIHRpbWUgPCB0aW1lIC0gY3Vlc1tyaWdodF0uc3RhcnRUaW1lID8gbGVmdCA6IHJpZ2h0O1xufVxuZnVuY3Rpb24gZ2V0Q3Vlc0luUmFuZ2UoY3Vlcywgc3RhcnQsIGVuZCkge1xuICBjb25zdCBjdWVzRm91bmQgPSBbXTtcbiAgY29uc3QgZmlyc3RDdWVJblJhbmdlID0gZ2V0Rmlyc3RDdWVJbmRleEFmdGVyVGltZShjdWVzLCBzdGFydCk7XG4gIGlmIChmaXJzdEN1ZUluUmFuZ2UgPiAtMSkge1xuICAgIGZvciAobGV0IGkgPSBmaXJzdEN1ZUluUmFuZ2UsIGxlbiA9IGN1ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGN1ZSA9IGN1ZXNbaV07XG4gICAgICBpZiAoY3VlLnN0YXJ0VGltZSA+PSBzdGFydCAmJiBjdWUuZW5kVGltZSA8PSBlbmQpIHtcbiAgICAgICAgY3Vlc0ZvdW5kLnB1c2goY3VlKTtcbiAgICAgIH0gZWxzZSBpZiAoY3VlLnN0YXJ0VGltZSA+IGVuZCkge1xuICAgICAgICByZXR1cm4gY3Vlc0ZvdW5kO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY3Vlc0ZvdW5kO1xufVxuZnVuY3Rpb24gZmlsdGVyU3VidGl0bGVUcmFja3ModGV4dFRyYWNrTGlzdCkge1xuICBjb25zdCB0cmFja3MgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0VHJhY2tMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdHJhY2sgPSB0ZXh0VHJhY2tMaXN0W2ldO1xuICAgIC8vIEVkZ2UgYWRkcyBhIHRyYWNrIHdpdGhvdXQgYSBsYWJlbDsgd2UgZG9uJ3Qgd2FudCB0byB1c2UgaXRcbiAgICBpZiAoKHRyYWNrLmtpbmQgPT09ICdzdWJ0aXRsZXMnIHx8IHRyYWNrLmtpbmQgPT09ICdjYXB0aW9ucycpICYmIHRyYWNrLmxhYmVsKSB7XG4gICAgICB0cmFja3MucHVzaCh0ZXh0VHJhY2tMaXN0W2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRyYWNrcztcbn1cblxudmFyIE1ldGFkYXRhU2NoZW1hID0ge1xuICBhdWRpb0lkMzogXCJvcmcuaWQzXCIsXG4gIGRhdGVSYW5nZTogXCJjb20uYXBwbGUucXVpY2t0aW1lLkhMU1wiLFxuICBlbXNnOiBcImh0dHBzOi8vYW9tZWRpYS5vcmcvZW1zZy9JRDNcIlxufTtcblxuY29uc3QgTUlOX0NVRV9EVVJBVElPTiA9IDAuMjU7XG5mdW5jdGlvbiBnZXRDdWVDbGFzcygpIHtcbiAgaWYgKHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgcmV0dXJuIHNlbGYuVlRUQ3VlIHx8IHNlbGYuVGV4dFRyYWNrQ3VlO1xufVxuZnVuY3Rpb24gY3JlYXRlQ3VlV2l0aERhdGFGaWVsZHMoQ3VlLCBzdGFydFRpbWUsIGVuZFRpbWUsIGRhdGEsIHR5cGUpIHtcbiAgbGV0IGN1ZSA9IG5ldyBDdWUoc3RhcnRUaW1lLCBlbmRUaW1lLCAnJyk7XG4gIHRyeSB7XG4gICAgY3VlLnZhbHVlID0gZGF0YTtcbiAgICBpZiAodHlwZSkge1xuICAgICAgY3VlLnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGN1ZSA9IG5ldyBDdWUoc3RhcnRUaW1lLCBlbmRUaW1lLCBKU09OLnN0cmluZ2lmeSh0eXBlID8gX29iamVjdFNwcmVhZDIoe1xuICAgICAgdHlwZVxuICAgIH0sIGRhdGEpIDogZGF0YSkpO1xuICB9XG4gIHJldHVybiBjdWU7XG59XG5cbi8vIFZUVEN1ZSBsYXRlc3QgZHJhZnQgYWxsb3dzIGFuIGluZmluaXRlIGR1cmF0aW9uLCBmYWxsYmFja1xuLy8gdG8gTUFYX1ZBTFVFIGlmIG5lY2Vzc2FyeVxuY29uc3QgTUFYX0NVRV9FTkRUSU1FID0gKCgpID0+IHtcbiAgY29uc3QgQ3VlID0gZ2V0Q3VlQ2xhc3MoKTtcbiAgdHJ5IHtcbiAgICBDdWUgJiYgbmV3IEN1ZSgwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksICcnKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xuICB9XG4gIHJldHVybiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG59KSgpO1xuZnVuY3Rpb24gZGF0ZVJhbmdlRGF0ZVRvVGltZWxpbmVTZWNvbmRzKGRhdGUsIG9mZnNldCkge1xuICByZXR1cm4gZGF0ZS5nZXRUaW1lKCkgLyAxMDAwIC0gb2Zmc2V0O1xufVxuZnVuY3Rpb24gaGV4VG9BcnJheUJ1ZmZlcihzdHIpIHtcbiAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShzdHIucmVwbGFjZSgvXjB4LywgJycpLnJlcGxhY2UoLyhbXFxkYS1mQS1GXXsyfSkgPy9nLCAnMHgkMSAnKS5yZXBsYWNlKC8gKyQvLCAnJykuc3BsaXQoJyAnKSkuYnVmZmVyO1xufVxuY2xhc3MgSUQzVHJhY2tDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5pZDNUcmFjayA9IG51bGw7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5kYXRlUmFuZ2VDdWVzQXBwZW5kZWQgPSB7fTtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLl9yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fdW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHRoaXMuaWQzVHJhY2sgPSBudWxsO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMuZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkID0ge307XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuaGxzID0gbnVsbDtcbiAgfVxuICBfcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX1BBUlNJTkdfTUVUQURBVEEsIHRoaXMub25GcmFnUGFyc2luZ01ldGFkYXRhLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX1VQREFURUQsIHRoaXMub25MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICB9XG4gIF91bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfUEFSU0lOR19NRVRBREFUQSwgdGhpcy5vbkZyYWdQYXJzaW5nTWV0YWRhdGEsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgfVxuXG4gIC8vIEFkZCBJRDMgbWV0YXRhZGF0YSB0ZXh0IHRyYWNrLlxuICBvbk1lZGlhQXR0YWNoZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgfVxuICBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgIGlmICghdGhpcy5pZDNUcmFjaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjbGVhckN1cnJlbnRDdWVzKHRoaXMuaWQzVHJhY2spO1xuICAgIHRoaXMuaWQzVHJhY2sgPSBudWxsO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMuZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkID0ge307XG4gIH1cbiAgb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgdGhpcy5kYXRlUmFuZ2VDdWVzQXBwZW5kZWQgPSB7fTtcbiAgfVxuICBjcmVhdGVUcmFjayhtZWRpYSkge1xuICAgIGNvbnN0IHRyYWNrID0gdGhpcy5nZXRJRDNUcmFjayhtZWRpYS50ZXh0VHJhY2tzKTtcbiAgICB0cmFjay5tb2RlID0gJ2hpZGRlbic7XG4gICAgcmV0dXJuIHRyYWNrO1xuICB9XG4gIGdldElEM1RyYWNrKHRleHRUcmFja3MpIHtcbiAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0VHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB0ZXh0VHJhY2sgPSB0ZXh0VHJhY2tzW2ldO1xuICAgICAgaWYgKHRleHRUcmFjay5raW5kID09PSAnbWV0YWRhdGEnICYmIHRleHRUcmFjay5sYWJlbCA9PT0gJ2lkMycpIHtcbiAgICAgICAgLy8gc2VuZCAnYWRkdHJhY2snIHdoZW4gcmV1c2luZyB0aGUgdGV4dFRyYWNrIGZvciBtZXRhZGF0YSxcbiAgICAgICAgLy8gc2FtZSBhcyB3aGF0IHdlIGRvIGZvciBjYXB0aW9uc1xuICAgICAgICBzZW5kQWRkVHJhY2tFdmVudCh0ZXh0VHJhY2ssIHRoaXMubWVkaWEpO1xuICAgICAgICByZXR1cm4gdGV4dFRyYWNrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tZWRpYS5hZGRUZXh0VHJhY2soJ21ldGFkYXRhJywgJ2lkMycpO1xuICB9XG4gIG9uRnJhZ1BhcnNpbmdNZXRhZGF0YShldmVudCwgZGF0YSkge1xuICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBobHM6IHtcbiAgICAgICAgY29uZmlnOiB7XG4gICAgICAgICAgZW5hYmxlRW1zZ01ldGFkYXRhQ3VlcyxcbiAgICAgICAgICBlbmFibGVJRDNNZXRhZGF0YUN1ZXNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghZW5hYmxlRW1zZ01ldGFkYXRhQ3VlcyAmJiAhZW5hYmxlSUQzTWV0YWRhdGFDdWVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHNhbXBsZXNcbiAgICB9ID0gZGF0YTtcblxuICAgIC8vIGNyZWF0ZSB0cmFjayBkeW5hbWljYWxseVxuICAgIGlmICghdGhpcy5pZDNUcmFjaykge1xuICAgICAgdGhpcy5pZDNUcmFjayA9IHRoaXMuY3JlYXRlVHJhY2sodGhpcy5tZWRpYSk7XG4gICAgfVxuICAgIGNvbnN0IEN1ZSA9IGdldEN1ZUNsYXNzKCk7XG4gICAgaWYgKCFDdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB0eXBlID0gc2FtcGxlc1tpXS50eXBlO1xuICAgICAgaWYgKHR5cGUgPT09IE1ldGFkYXRhU2NoZW1hLmVtc2cgJiYgIWVuYWJsZUVtc2dNZXRhZGF0YUN1ZXMgfHwgIWVuYWJsZUlEM01ldGFkYXRhQ3Vlcykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZyYW1lcyA9IGdldElEM0ZyYW1lcyhzYW1wbGVzW2ldLmRhdGEpO1xuICAgICAgaWYgKGZyYW1lcykge1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBzYW1wbGVzW2ldLnB0cztcbiAgICAgICAgbGV0IGVuZFRpbWUgPSBzdGFydFRpbWUgKyBzYW1wbGVzW2ldLmR1cmF0aW9uO1xuICAgICAgICBpZiAoZW5kVGltZSA+IE1BWF9DVUVfRU5EVElNRSkge1xuICAgICAgICAgIGVuZFRpbWUgPSBNQVhfQ1VFX0VORFRJTUU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZURpZmYgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgICBpZiAodGltZURpZmYgPD0gMCkge1xuICAgICAgICAgIGVuZFRpbWUgPSBzdGFydFRpbWUgKyBNSU5fQ1VFX0RVUkFUSU9OO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZnJhbWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY29uc3QgZnJhbWUgPSBmcmFtZXNbal07XG4gICAgICAgICAgLy8gU2FmYXJpIGRvZXNuJ3QgcHV0IHRoZSB0aW1lc3RhbXAgZnJhbWUgaW4gdGhlIFRleHRUcmFja1xuICAgICAgICAgIGlmICghaXNUaW1lU3RhbXBGcmFtZShmcmFtZSkpIHtcbiAgICAgICAgICAgIC8vIGFkZCBhIGJvdW5kcyB0byBhbnkgdW5ib3VuZGVkIGN1ZXNcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSWQzQ3VlRW5kcyhzdGFydFRpbWUsIHR5cGUpO1xuICAgICAgICAgICAgY29uc3QgY3VlID0gY3JlYXRlQ3VlV2l0aERhdGFGaWVsZHMoQ3VlLCBzdGFydFRpbWUsIGVuZFRpbWUsIGZyYW1lLCB0eXBlKTtcbiAgICAgICAgICAgIGlmIChjdWUpIHtcbiAgICAgICAgICAgICAgdGhpcy5pZDNUcmFjay5hZGRDdWUoY3VlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdXBkYXRlSWQzQ3VlRW5kcyhzdGFydFRpbWUsIHR5cGUpIHtcbiAgICB2YXIgX3RoaXMkaWQzVHJhY2s7XG4gICAgY29uc3QgY3VlcyA9IChfdGhpcyRpZDNUcmFjayA9IHRoaXMuaWQzVHJhY2spID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRpZDNUcmFjay5jdWVzO1xuICAgIGlmIChjdWVzKSB7XG4gICAgICBmb3IgKGxldCBpID0gY3Vlcy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgY29uc3QgY3VlID0gY3Vlc1tpXTtcbiAgICAgICAgaWYgKGN1ZS50eXBlID09PSB0eXBlICYmIGN1ZS5zdGFydFRpbWUgPCBzdGFydFRpbWUgJiYgY3VlLmVuZFRpbWUgPT09IE1BWF9DVUVfRU5EVElNRSkge1xuICAgICAgICAgIGN1ZS5lbmRUaW1lID0gc3RhcnRUaW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG9uQnVmZmVyRmx1c2hpbmcoZXZlbnQsIHtcbiAgICBzdGFydE9mZnNldCxcbiAgICBlbmRPZmZzZXQsXG4gICAgdHlwZVxuICB9KSB7XG4gICAgY29uc3Qge1xuICAgICAgaWQzVHJhY2ssXG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWhscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjb25maWc6IHtcbiAgICAgICAgZW5hYmxlRW1zZ01ldGFkYXRhQ3VlcyxcbiAgICAgICAgZW5hYmxlSUQzTWV0YWRhdGFDdWVzXG4gICAgICB9XG4gICAgfSA9IGhscztcbiAgICBpZiAoaWQzVHJhY2sgJiYgKGVuYWJsZUVtc2dNZXRhZGF0YUN1ZXMgfHwgZW5hYmxlSUQzTWV0YWRhdGFDdWVzKSkge1xuICAgICAgbGV0IHByZWRpY2F0ZTtcbiAgICAgIGlmICh0eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IGN1ZSA9PiBjdWUudHlwZSA9PT0gTWV0YWRhdGFTY2hlbWEuYXVkaW9JZDMgJiYgZW5hYmxlSUQzTWV0YWRhdGFDdWVzO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IGN1ZSA9PiBjdWUudHlwZSA9PT0gTWV0YWRhdGFTY2hlbWEuZW1zZyAmJiBlbmFibGVFbXNnTWV0YWRhdGFDdWVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJlZGljYXRlID0gY3VlID0+IGN1ZS50eXBlID09PSBNZXRhZGF0YVNjaGVtYS5hdWRpb0lkMyAmJiBlbmFibGVJRDNNZXRhZGF0YUN1ZXMgfHwgY3VlLnR5cGUgPT09IE1ldGFkYXRhU2NoZW1hLmVtc2cgJiYgZW5hYmxlRW1zZ01ldGFkYXRhQ3VlcztcbiAgICAgIH1cbiAgICAgIHJlbW92ZUN1ZXNJblJhbmdlKGlkM1RyYWNrLCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0LCBwcmVkaWNhdGUpO1xuICAgIH1cbiAgfVxuICBvbkxldmVsVXBkYXRlZChldmVudCwge1xuICAgIGRldGFpbHNcbiAgfSkge1xuICAgIGlmICghdGhpcy5tZWRpYSB8fCAhZGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUgfHwgIXRoaXMuaGxzLmNvbmZpZy5lbmFibGVEYXRlUmFuZ2VNZXRhZGF0YUN1ZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkLFxuICAgICAgaWQzVHJhY2tcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBkYXRlUmFuZ2VzXG4gICAgfSA9IGRldGFpbHM7XG4gICAgY29uc3QgaWRzID0gT2JqZWN0LmtleXMoZGF0ZVJhbmdlcyk7XG4gICAgLy8gUmVtb3ZlIGN1ZXMgZnJvbSB0cmFjayBub3QgZm91bmQgaW4gZGV0YWlscy5kYXRlUmFuZ2VzXG4gICAgaWYgKGlkM1RyYWNrKSB7XG4gICAgICBjb25zdCBpZHNUb1JlbW92ZSA9IE9iamVjdC5rZXlzKGRhdGVSYW5nZUN1ZXNBcHBlbmRlZCkuZmlsdGVyKGlkID0+ICFpZHMuaW5jbHVkZXMoaWQpKTtcbiAgICAgIGZvciAobGV0IGkgPSBpZHNUb1JlbW92ZS5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgY29uc3QgaWQgPSBpZHNUb1JlbW92ZVtpXTtcbiAgICAgICAgT2JqZWN0LmtleXMoZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkW2lkXS5jdWVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgaWQzVHJhY2sucmVtb3ZlQ3VlKGRhdGVSYW5nZUN1ZXNBcHBlbmRlZFtpZF0uY3Vlc1trZXldKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlbGV0ZSBkYXRlUmFuZ2VDdWVzQXBwZW5kZWRbaWRdO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBFeGl0IGlmIHRoZSBwbGF5bGlzdCBkb2VzIG5vdCBoYXZlIERhdGUgUmFuZ2VzIG9yIGRvZXMgbm90IGhhdmUgUHJvZ3JhbSBEYXRlIFRpbWVcbiAgICBjb25zdCBsYXN0RnJhZ21lbnQgPSBkZXRhaWxzLmZyYWdtZW50c1tkZXRhaWxzLmZyYWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICBpZiAoaWRzLmxlbmd0aCA9PT0gMCB8fCAhaXNGaW5pdGVOdW1iZXIobGFzdEZyYWdtZW50ID09IG51bGwgPyB2b2lkIDAgOiBsYXN0RnJhZ21lbnQucHJvZ3JhbURhdGVUaW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaWQzVHJhY2spIHtcbiAgICAgIHRoaXMuaWQzVHJhY2sgPSB0aGlzLmNyZWF0ZVRyYWNrKHRoaXMubWVkaWEpO1xuICAgIH1cbiAgICBjb25zdCBkYXRlVGltZU9mZnNldCA9IGxhc3RGcmFnbWVudC5wcm9ncmFtRGF0ZVRpbWUgLyAxMDAwIC0gbGFzdEZyYWdtZW50LnN0YXJ0O1xuICAgIGNvbnN0IEN1ZSA9IGdldEN1ZUNsYXNzKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGlkID0gaWRzW2ldO1xuICAgICAgY29uc3QgZGF0ZVJhbmdlID0gZGF0ZVJhbmdlc1tpZF07XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBkYXRlUmFuZ2VEYXRlVG9UaW1lbGluZVNlY29uZHMoZGF0ZVJhbmdlLnN0YXJ0RGF0ZSwgZGF0ZVRpbWVPZmZzZXQpO1xuXG4gICAgICAvLyBQcm9jZXNzIERhdGVSYW5nZXMgdG8gZGV0ZXJtaW5lIGVuZC10aW1lIChrbm93biBEVVJBVElPTiwgRU5ELURBVEUsIG9yIEVORC1PTi1ORVhUKVxuICAgICAgY29uc3QgYXBwZW5kZWREYXRlUmFuZ2VDdWVzID0gZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkW2lkXTtcbiAgICAgIGNvbnN0IGN1ZXMgPSAoYXBwZW5kZWREYXRlUmFuZ2VDdWVzID09IG51bGwgPyB2b2lkIDAgOiBhcHBlbmRlZERhdGVSYW5nZUN1ZXMuY3VlcykgfHwge307XG4gICAgICBsZXQgZHVyYXRpb25Lbm93biA9IChhcHBlbmRlZERhdGVSYW5nZUN1ZXMgPT0gbnVsbCA/IHZvaWQgMCA6IGFwcGVuZGVkRGF0ZVJhbmdlQ3Vlcy5kdXJhdGlvbktub3duKSB8fCBmYWxzZTtcbiAgICAgIGxldCBlbmRUaW1lID0gTUFYX0NVRV9FTkRUSU1FO1xuICAgICAgY29uc3QgZW5kRGF0ZSA9IGRhdGVSYW5nZS5lbmREYXRlO1xuICAgICAgaWYgKGVuZERhdGUpIHtcbiAgICAgICAgZW5kVGltZSA9IGRhdGVSYW5nZURhdGVUb1RpbWVsaW5lU2Vjb25kcyhlbmREYXRlLCBkYXRlVGltZU9mZnNldCk7XG4gICAgICAgIGR1cmF0aW9uS25vd24gPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChkYXRlUmFuZ2UuZW5kT25OZXh0ICYmICFkdXJhdGlvbktub3duKSB7XG4gICAgICAgIGNvbnN0IG5leHREYXRlUmFuZ2VXaXRoU2FtZUNsYXNzID0gaWRzLnJlZHVjZSgoY2FuZGlkYXRlRGF0ZVJhbmdlLCBpZCkgPT4ge1xuICAgICAgICAgIGlmIChpZCAhPT0gZGF0ZVJhbmdlLmlkKSB7XG4gICAgICAgICAgICBjb25zdCBvdGhlckRhdGVSYW5nZSA9IGRhdGVSYW5nZXNbaWRdO1xuICAgICAgICAgICAgaWYgKG90aGVyRGF0ZVJhbmdlLmNsYXNzID09PSBkYXRlUmFuZ2UuY2xhc3MgJiYgb3RoZXJEYXRlUmFuZ2Uuc3RhcnREYXRlID4gZGF0ZVJhbmdlLnN0YXJ0RGF0ZSAmJiAoIWNhbmRpZGF0ZURhdGVSYW5nZSB8fCBkYXRlUmFuZ2Uuc3RhcnREYXRlIDwgY2FuZGlkYXRlRGF0ZVJhbmdlLnN0YXJ0RGF0ZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG90aGVyRGF0ZVJhbmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2FuZGlkYXRlRGF0ZVJhbmdlO1xuICAgICAgICB9LCBudWxsKTtcbiAgICAgICAgaWYgKG5leHREYXRlUmFuZ2VXaXRoU2FtZUNsYXNzKSB7XG4gICAgICAgICAgZW5kVGltZSA9IGRhdGVSYW5nZURhdGVUb1RpbWVsaW5lU2Vjb25kcyhuZXh0RGF0ZVJhbmdlV2l0aFNhbWVDbGFzcy5zdGFydERhdGUsIGRhdGVUaW1lT2Zmc2V0KTtcbiAgICAgICAgICBkdXJhdGlvbktub3duID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgVGV4dFRyYWNrIEN1ZXMgZm9yIGVhY2ggTWV0YWRhdGFHcm91cCBJdGVtIChzZWxlY3QgRGF0ZVJhbmdlIGF0dHJpYnV0ZSlcbiAgICAgIC8vIFRoaXMgaXMgdG8gZW11bGF0ZSBTYWZhcmkgSExTIHBsYXliYWNrIGhhbmRsaW5nIG9mIERhdGVSYW5nZSB0YWdzXG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gT2JqZWN0LmtleXMoZGF0ZVJhbmdlLmF0dHIpO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGF0dHJpYnV0ZXNbal07XG4gICAgICAgIGlmICghaXNEYXRlUmFuZ2VDdWVBdHRyaWJ1dGUoa2V5KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1ZSA9IGN1ZXNba2V5XTtcbiAgICAgICAgaWYgKGN1ZSkge1xuICAgICAgICAgIGlmIChkdXJhdGlvbktub3duICYmICFhcHBlbmRlZERhdGVSYW5nZUN1ZXMuZHVyYXRpb25Lbm93bikge1xuICAgICAgICAgICAgY3VlLmVuZFRpbWUgPSBlbmRUaW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChDdWUpIHtcbiAgICAgICAgICBsZXQgZGF0YSA9IGRhdGVSYW5nZS5hdHRyW2tleV07XG4gICAgICAgICAgaWYgKGlzU0NURTM1QXR0cmlidXRlKGtleSkpIHtcbiAgICAgICAgICAgIGRhdGEgPSBoZXhUb0FycmF5QnVmZmVyKGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBfY3VlID0gY3JlYXRlQ3VlV2l0aERhdGFGaWVsZHMoQ3VlLCBzdGFydFRpbWUsIGVuZFRpbWUsIHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICB9LCBNZXRhZGF0YVNjaGVtYS5kYXRlUmFuZ2UpO1xuICAgICAgICAgIGlmIChfY3VlKSB7XG4gICAgICAgICAgICBfY3VlLmlkID0gaWQ7XG4gICAgICAgICAgICB0aGlzLmlkM1RyYWNrLmFkZEN1ZShfY3VlKTtcbiAgICAgICAgICAgIGN1ZXNba2V5XSA9IF9jdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEtlZXAgdHJhY2sgb2YgcHJvY2Vzc2VkIERhdGVSYW5nZXMgYnkgSUQgZm9yIHVwZGF0aW5nIGN1ZXMgd2l0aCBuZXcgRGF0ZVJhbmdlIHRhZyBhdHRyaWJ1dGVzXG4gICAgICBkYXRlUmFuZ2VDdWVzQXBwZW5kZWRbaWRdID0ge1xuICAgICAgICBjdWVzLFxuICAgICAgICBkYXRlUmFuZ2UsXG4gICAgICAgIGR1cmF0aW9uS25vd25cbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIExhdGVuY3lDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5sZXZlbERldGFpbHMgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudFRpbWUgPSAwO1xuICAgIHRoaXMuc3RhbGxDb3VudCA9IDA7XG4gICAgdGhpcy5fbGF0ZW5jeSA9IG51bGw7XG4gICAgdGhpcy50aW1ldXBkYXRlSGFuZGxlciA9ICgpID0+IHRoaXMudGltZXVwZGF0ZSgpO1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgZ2V0IGxhdGVuY3koKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xhdGVuY3kgfHwgMDtcbiAgfVxuICBnZXQgbWF4TGF0ZW5jeSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb25maWcsXG4gICAgICBsZXZlbERldGFpbHNcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gbGV2ZWxEZXRhaWxzID8gY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCAqIGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbiA6IDA7XG4gIH1cbiAgZ2V0IHRhcmdldExhdGVuY3koKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWxEZXRhaWxzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGxldmVsRGV0YWlscyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGhvbGRCYWNrLFxuICAgICAgcGFydEhvbGRCYWNrLFxuICAgICAgdGFyZ2V0ZHVyYXRpb25cbiAgICB9ID0gbGV2ZWxEZXRhaWxzO1xuICAgIGNvbnN0IHtcbiAgICAgIGxpdmVTeW5jRHVyYXRpb24sXG4gICAgICBsaXZlU3luY0R1cmF0aW9uQ291bnQsXG4gICAgICBsb3dMYXRlbmN5TW9kZVxuICAgIH0gPSB0aGlzLmNvbmZpZztcbiAgICBjb25zdCB1c2VyQ29uZmlnID0gdGhpcy5obHMudXNlckNvbmZpZztcbiAgICBsZXQgdGFyZ2V0TGF0ZW5jeSA9IGxvd0xhdGVuY3lNb2RlID8gcGFydEhvbGRCYWNrIHx8IGhvbGRCYWNrIDogaG9sZEJhY2s7XG4gICAgaWYgKHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbiB8fCB1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCB8fCB0YXJnZXRMYXRlbmN5ID09PSAwKSB7XG4gICAgICB0YXJnZXRMYXRlbmN5ID0gbGl2ZVN5bmNEdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gbGl2ZVN5bmNEdXJhdGlvbiA6IGxpdmVTeW5jRHVyYXRpb25Db3VudCAqIHRhcmdldGR1cmF0aW9uO1xuICAgIH1cbiAgICBjb25zdCBtYXhMaXZlU3luY09uU3RhbGxJbmNyZWFzZSA9IHRhcmdldGR1cmF0aW9uO1xuICAgIGNvbnN0IGxpdmVTeW5jT25TdGFsbEluY3JlYXNlID0gMS4wO1xuICAgIHJldHVybiB0YXJnZXRMYXRlbmN5ICsgTWF0aC5taW4odGhpcy5zdGFsbENvdW50ICogbGl2ZVN5bmNPblN0YWxsSW5jcmVhc2UsIG1heExpdmVTeW5jT25TdGFsbEluY3JlYXNlKTtcbiAgfVxuICBnZXQgbGl2ZVN5bmNQb3NpdGlvbigpIHtcbiAgICBjb25zdCBsaXZlRWRnZSA9IHRoaXMuZXN0aW1hdGVMaXZlRWRnZSgpO1xuICAgIGNvbnN0IHRhcmdldExhdGVuY3kgPSB0aGlzLnRhcmdldExhdGVuY3k7XG4gICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gdGhpcy5sZXZlbERldGFpbHM7XG4gICAgaWYgKGxpdmVFZGdlID09PSBudWxsIHx8IHRhcmdldExhdGVuY3kgPT09IG51bGwgfHwgbGV2ZWxEZXRhaWxzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZWRnZSA9IGxldmVsRGV0YWlscy5lZGdlO1xuICAgIGNvbnN0IHN5bmNQb3NpdGlvbiA9IGxpdmVFZGdlIC0gdGFyZ2V0TGF0ZW5jeSAtIHRoaXMuZWRnZVN0YWxsZWQ7XG4gICAgY29uc3QgbWluID0gZWRnZSAtIGxldmVsRGV0YWlscy50b3RhbGR1cmF0aW9uO1xuICAgIGNvbnN0IG1heCA9IGVkZ2UgLSAodGhpcy5jb25maWcubG93TGF0ZW5jeU1vZGUgJiYgbGV2ZWxEZXRhaWxzLnBhcnRUYXJnZXQgfHwgbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uKTtcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobWluLCBzeW5jUG9zaXRpb24pLCBtYXgpO1xuICB9XG4gIGdldCBkcmlmdCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBsZXZlbERldGFpbHNcbiAgICB9ID0gdGhpcztcbiAgICBpZiAobGV2ZWxEZXRhaWxzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIGxldmVsRGV0YWlscy5kcmlmdDtcbiAgfVxuICBnZXQgZWRnZVN0YWxsZWQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWxEZXRhaWxzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGxldmVsRGV0YWlscyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNvbnN0IG1heExldmVsVXBkYXRlQWdlID0gKHRoaXMuY29uZmlnLmxvd0xhdGVuY3lNb2RlICYmIGxldmVsRGV0YWlscy5wYXJ0VGFyZ2V0IHx8IGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbikgKiAzO1xuICAgIHJldHVybiBNYXRoLm1heChsZXZlbERldGFpbHMuYWdlIC0gbWF4TGV2ZWxVcGRhdGVBZ2UsIDApO1xuICB9XG4gIGdldCBmb3J3YXJkQnVmZmVyTGVuZ3RoKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lZGlhLFxuICAgICAgbGV2ZWxEZXRhaWxzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFtZWRpYSB8fCAhbGV2ZWxEZXRhaWxzKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVyZWRSYW5nZXMgPSBtZWRpYS5idWZmZXJlZC5sZW5ndGg7XG4gICAgcmV0dXJuIChidWZmZXJlZFJhbmdlcyA/IG1lZGlhLmJ1ZmZlcmVkLmVuZChidWZmZXJlZFJhbmdlcyAtIDEpIDogbGV2ZWxEZXRhaWxzLmVkZ2UpIC0gdGhpcy5jdXJyZW50VGltZTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHRoaXMub25NZWRpYURldGFjaGluZygpO1xuICAgIHRoaXMubGV2ZWxEZXRhaWxzID0gbnVsbDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSB0aGlzLnRpbWV1cGRhdGVIYW5kbGVyID0gbnVsbDtcbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB0aGlzLmhscy5vbihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vbihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vbihFdmVudHMuTEVWRUxfVVBEQVRFRCwgdGhpcy5vbkxldmVsVXBkYXRlZCwgdGhpcyk7XG4gICAgdGhpcy5obHMub24oRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9XG4gIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5obHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9mZihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgdGhpcy5obHMub2ZmKEV2ZW50cy5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vZmYoRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9XG4gIG9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuICAgIHRoaXMubWVkaWEuYWRkRXZlbnRMaXN0ZW5lcigndGltZXVwZGF0ZScsIHRoaXMudGltZXVwZGF0ZUhhbmRsZXIpO1xuICB9XG4gIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgaWYgKHRoaXMubWVkaWEpIHtcbiAgICAgIHRoaXMubWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGltZXVwZGF0ZScsIHRoaXMudGltZXVwZGF0ZUhhbmRsZXIpO1xuICAgICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgfVxuICB9XG4gIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMubGV2ZWxEZXRhaWxzID0gbnVsbDtcbiAgICB0aGlzLl9sYXRlbmN5ID0gbnVsbDtcbiAgICB0aGlzLnN0YWxsQ291bnQgPSAwO1xuICB9XG4gIG9uTGV2ZWxVcGRhdGVkKGV2ZW50LCB7XG4gICAgZGV0YWlsc1xuICB9KSB7XG4gICAgdGhpcy5sZXZlbERldGFpbHMgPSBkZXRhaWxzO1xuICAgIGlmIChkZXRhaWxzLmFkdmFuY2VkKSB7XG4gICAgICB0aGlzLnRpbWV1cGRhdGUoKTtcbiAgICB9XG4gICAgaWYgKCFkZXRhaWxzLmxpdmUgJiYgdGhpcy5tZWRpYSkge1xuICAgICAgdGhpcy5tZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCd0aW1ldXBkYXRlJywgdGhpcy50aW1ldXBkYXRlSGFuZGxlcik7XG4gICAgfVxuICB9XG4gIG9uRXJyb3IoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgX3RoaXMkbGV2ZWxEZXRhaWxzO1xuICAgIGlmIChkYXRhLmRldGFpbHMgIT09IEVycm9yRGV0YWlscy5CVUZGRVJfU1RBTExFRF9FUlJPUikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnN0YWxsQ291bnQrKztcbiAgICBpZiAoKF90aGlzJGxldmVsRGV0YWlscyA9IHRoaXMubGV2ZWxEZXRhaWxzKSAhPSBudWxsICYmIF90aGlzJGxldmVsRGV0YWlscy5saXZlKSB7XG4gICAgICBsb2dnZXIud2FybignW3BsYXliYWNrLXJhdGUtY29udHJvbGxlcl06IFN0YWxsIGRldGVjdGVkLCBhZGp1c3RpbmcgdGFyZ2V0IGxhdGVuY3knKTtcbiAgICB9XG4gIH1cbiAgdGltZXVwZGF0ZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZWRpYSxcbiAgICAgIGxldmVsRGV0YWlsc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmICghbWVkaWEgfHwgIWxldmVsRGV0YWlscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgY29uc3QgbGF0ZW5jeSA9IHRoaXMuY29tcHV0ZUxhdGVuY3koKTtcbiAgICBpZiAobGF0ZW5jeSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9sYXRlbmN5ID0gbGF0ZW5jeTtcblxuICAgIC8vIEFkYXB0IHBsYXliYWNrUmF0ZSB0byBtZWV0IHRhcmdldCBsYXRlbmN5IGluIGxvdy1sYXRlbmN5IG1vZGVcbiAgICBjb25zdCB7XG4gICAgICBsb3dMYXRlbmN5TW9kZSxcbiAgICAgIG1heExpdmVTeW5jUGxheWJhY2tSYXRlXG4gICAgfSA9IHRoaXMuY29uZmlnO1xuICAgIGlmICghbG93TGF0ZW5jeU1vZGUgfHwgbWF4TGl2ZVN5bmNQbGF5YmFja1JhdGUgPT09IDEgfHwgIWxldmVsRGV0YWlscy5saXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldExhdGVuY3kgPSB0aGlzLnRhcmdldExhdGVuY3k7XG4gICAgaWYgKHRhcmdldExhdGVuY3kgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGlzdGFuY2VGcm9tVGFyZ2V0ID0gbGF0ZW5jeSAtIHRhcmdldExhdGVuY3k7XG4gICAgLy8gT25seSBhZGp1c3QgcGxheWJhY2tSYXRlIHdoZW4gd2l0aGluIG9uZSB0YXJnZXQgZHVyYXRpb24gb2YgdGFyZ2V0TGF0ZW5jeVxuICAgIC8vIGFuZCBtb3JlIHRoYW4gb25lIHNlY29uZCBmcm9tIHVuZGVyLWJ1ZmZlcmluZy5cbiAgICAvLyBQbGF5YmFjayBmdXJ0aGVyIHRoYW4gb25lIHRhcmdldCBkdXJhdGlvbiBmcm9tIHRhcmdldCBjYW4gYmUgY29uc2lkZXJlZCBEVlIgcGxheWJhY2suXG4gICAgY29uc3QgbGl2ZU1pbkxhdGVuY3lEdXJhdGlvbiA9IE1hdGgubWluKHRoaXMubWF4TGF0ZW5jeSwgdGFyZ2V0TGF0ZW5jeSArIGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbik7XG4gICAgY29uc3QgaW5MaXZlUmFuZ2UgPSBkaXN0YW5jZUZyb21UYXJnZXQgPCBsaXZlTWluTGF0ZW5jeUR1cmF0aW9uO1xuICAgIGlmIChpbkxpdmVSYW5nZSAmJiBkaXN0YW5jZUZyb21UYXJnZXQgPiAwLjA1ICYmIHRoaXMuZm9yd2FyZEJ1ZmZlckxlbmd0aCA+IDEpIHtcbiAgICAgIGNvbnN0IG1heCA9IE1hdGgubWluKDIsIE1hdGgubWF4KDEuMCwgbWF4TGl2ZVN5bmNQbGF5YmFja1JhdGUpKTtcbiAgICAgIGNvbnN0IHJhdGUgPSBNYXRoLnJvdW5kKDIgLyAoMSArIE1hdGguZXhwKC0wLjc1ICogZGlzdGFuY2VGcm9tVGFyZ2V0IC0gdGhpcy5lZGdlU3RhbGxlZCkpICogMjApIC8gMjA7XG4gICAgICBtZWRpYS5wbGF5YmFja1JhdGUgPSBNYXRoLm1pbihtYXgsIE1hdGgubWF4KDEsIHJhdGUpKTtcbiAgICB9IGVsc2UgaWYgKG1lZGlhLnBsYXliYWNrUmF0ZSAhPT0gMSAmJiBtZWRpYS5wbGF5YmFja1JhdGUgIT09IDApIHtcbiAgICAgIG1lZGlhLnBsYXliYWNrUmF0ZSA9IDE7XG4gICAgfVxuICB9XG4gIGVzdGltYXRlTGl2ZUVkZ2UoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWxEZXRhaWxzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGxldmVsRGV0YWlscyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBsZXZlbERldGFpbHMuZWRnZSArIGxldmVsRGV0YWlscy5hZ2U7XG4gIH1cbiAgY29tcHV0ZUxhdGVuY3koKSB7XG4gICAgY29uc3QgbGl2ZUVkZ2UgPSB0aGlzLmVzdGltYXRlTGl2ZUVkZ2UoKTtcbiAgICBpZiAobGl2ZUVkZ2UgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbGl2ZUVkZ2UgLSB0aGlzLmN1cnJlbnRUaW1lO1xuICB9XG59XG5cbmNvbnN0IEhkY3BMZXZlbHMgPSBbJ05PTkUnLCAnVFlQRS0wJywgJ1RZUEUtMScsIG51bGxdO1xuZnVuY3Rpb24gaXNIZGNwTGV2ZWwodmFsdWUpIHtcbiAgcmV0dXJuIEhkY3BMZXZlbHMuaW5kZXhPZih2YWx1ZSkgPiAtMTtcbn1cbmNvbnN0IFZpZGVvUmFuZ2VWYWx1ZXMgPSBbJ1NEUicsICdQUScsICdITEcnXTtcbmZ1bmN0aW9uIGlzVmlkZW9SYW5nZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiBWaWRlb1JhbmdlVmFsdWVzLmluZGV4T2YodmFsdWUpID4gLTE7XG59XG52YXIgSGxzU2tpcCA9IHtcbiAgTm86IFwiXCIsXG4gIFllczogXCJZRVNcIixcbiAgdjI6IFwidjJcIlxufTtcbmZ1bmN0aW9uIGdldFNraXBWYWx1ZShkZXRhaWxzLCBtc24pIHtcbiAgY29uc3Qge1xuICAgIGNhblNraXBVbnRpbCxcbiAgICBjYW5Ta2lwRGF0ZVJhbmdlcyxcbiAgICBlbmRTTlxuICB9ID0gZGV0YWlscztcbiAgY29uc3Qgc25DaGFuZ2VHb2FsID0gbXNuICE9PSB1bmRlZmluZWQgPyBtc24gLSBlbmRTTiA6IDA7XG4gIGlmIChjYW5Ta2lwVW50aWwgJiYgc25DaGFuZ2VHb2FsIDwgY2FuU2tpcFVudGlsKSB7XG4gICAgaWYgKGNhblNraXBEYXRlUmFuZ2VzKSB7XG4gICAgICByZXR1cm4gSGxzU2tpcC52MjtcbiAgICB9XG4gICAgcmV0dXJuIEhsc1NraXAuWWVzO1xuICB9XG4gIHJldHVybiBIbHNTa2lwLk5vO1xufVxuY2xhc3MgSGxzVXJsUGFyYW1ldGVycyB7XG4gIGNvbnN0cnVjdG9yKG1zbiwgcGFydCwgc2tpcCkge1xuICAgIHRoaXMubXNuID0gdm9pZCAwO1xuICAgIHRoaXMucGFydCA9IHZvaWQgMDtcbiAgICB0aGlzLnNraXAgPSB2b2lkIDA7XG4gICAgdGhpcy5tc24gPSBtc247XG4gICAgdGhpcy5wYXJ0ID0gcGFydDtcbiAgICB0aGlzLnNraXAgPSBza2lwO1xuICB9XG4gIGFkZERpcmVjdGl2ZXModXJpKSB7XG4gICAgY29uc3QgdXJsID0gbmV3IHNlbGYuVVJMKHVyaSk7XG4gICAgaWYgKHRoaXMubXNuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdfSExTX21zbicsIHRoaXMubXNuLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5wYXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdfSExTX3BhcnQnLCB0aGlzLnBhcnQudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnNraXApIHtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdfSExTX3NraXAnLCB0aGlzLnNraXApO1xuICAgIH1cbiAgICByZXR1cm4gdXJsLmhyZWY7XG4gIH1cbn1cbmNsYXNzIExldmVsIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHRoaXMuX2F0dHJzID0gdm9pZCAwO1xuICAgIHRoaXMuYXVkaW9Db2RlYyA9IHZvaWQgMDtcbiAgICB0aGlzLmJpdHJhdGUgPSB2b2lkIDA7XG4gICAgdGhpcy5jb2RlY1NldCA9IHZvaWQgMDtcbiAgICB0aGlzLnVybCA9IHZvaWQgMDtcbiAgICB0aGlzLmZyYW1lUmF0ZSA9IHZvaWQgMDtcbiAgICB0aGlzLmhlaWdodCA9IHZvaWQgMDtcbiAgICB0aGlzLmlkID0gdm9pZCAwO1xuICAgIHRoaXMubmFtZSA9IHZvaWQgMDtcbiAgICB0aGlzLnZpZGVvQ29kZWMgPSB2b2lkIDA7XG4gICAgdGhpcy53aWR0aCA9IHZvaWQgMDtcbiAgICB0aGlzLmRldGFpbHMgPSB2b2lkIDA7XG4gICAgdGhpcy5mcmFnbWVudEVycm9yID0gMDtcbiAgICB0aGlzLmxvYWRFcnJvciA9IDA7XG4gICAgdGhpcy5sb2FkZWQgPSB2b2lkIDA7XG4gICAgdGhpcy5yZWFsQml0cmF0ZSA9IDA7XG4gICAgdGhpcy5zdXBwb3J0ZWRQcm9taXNlID0gdm9pZCAwO1xuICAgIHRoaXMuc3VwcG9ydGVkUmVzdWx0ID0gdm9pZCAwO1xuICAgIHRoaXMuX2F2Z0JpdHJhdGUgPSAwO1xuICAgIHRoaXMuX2F1ZGlvR3JvdXBzID0gdm9pZCAwO1xuICAgIHRoaXMuX3N1YnRpdGxlR3JvdXBzID0gdm9pZCAwO1xuICAgIC8vIERlcHJlY2F0ZWQgKHJldGFpbmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSlcbiAgICB0aGlzLl91cmxJZCA9IDA7XG4gICAgdGhpcy51cmwgPSBbZGF0YS51cmxdO1xuICAgIHRoaXMuX2F0dHJzID0gW2RhdGEuYXR0cnNdO1xuICAgIHRoaXMuYml0cmF0ZSA9IGRhdGEuYml0cmF0ZTtcbiAgICBpZiAoZGF0YS5kZXRhaWxzKSB7XG4gICAgICB0aGlzLmRldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgfVxuICAgIHRoaXMuaWQgPSBkYXRhLmlkIHx8IDA7XG4gICAgdGhpcy5uYW1lID0gZGF0YS5uYW1lO1xuICAgIHRoaXMud2lkdGggPSBkYXRhLndpZHRoIHx8IDA7XG4gICAgdGhpcy5oZWlnaHQgPSBkYXRhLmhlaWdodCB8fCAwO1xuICAgIHRoaXMuZnJhbWVSYXRlID0gZGF0YS5hdHRycy5vcHRpb25hbEZsb2F0KCdGUkFNRS1SQVRFJywgMCk7XG4gICAgdGhpcy5fYXZnQml0cmF0ZSA9IGRhdGEuYXR0cnMuZGVjaW1hbEludGVnZXIoJ0FWRVJBR0UtQkFORFdJRFRIJyk7XG4gICAgdGhpcy5hdWRpb0NvZGVjID0gZGF0YS5hdWRpb0NvZGVjO1xuICAgIHRoaXMudmlkZW9Db2RlYyA9IGRhdGEudmlkZW9Db2RlYztcbiAgICB0aGlzLmNvZGVjU2V0ID0gW2RhdGEudmlkZW9Db2RlYywgZGF0YS5hdWRpb0NvZGVjXS5maWx0ZXIoYyA9PiAhIWMpLm1hcChzID0+IHMuc3Vic3RyaW5nKDAsIDQpKS5qb2luKCcsJyk7XG4gICAgdGhpcy5hZGRHcm91cElkKCdhdWRpbycsIGRhdGEuYXR0cnMuQVVESU8pO1xuICAgIHRoaXMuYWRkR3JvdXBJZCgndGV4dCcsIGRhdGEuYXR0cnMuU1VCVElUTEVTKTtcbiAgfVxuICBnZXQgbWF4Qml0cmF0ZSgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5yZWFsQml0cmF0ZSwgdGhpcy5iaXRyYXRlKTtcbiAgfVxuICBnZXQgYXZlcmFnZUJpdHJhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F2Z0JpdHJhdGUgfHwgdGhpcy5yZWFsQml0cmF0ZSB8fCB0aGlzLmJpdHJhdGU7XG4gIH1cbiAgZ2V0IGF0dHJzKCkge1xuICAgIHJldHVybiB0aGlzLl9hdHRyc1swXTtcbiAgfVxuICBnZXQgY29kZWNzKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJzLkNPREVDUyB8fCAnJztcbiAgfVxuICBnZXQgcGF0aHdheUlkKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJzWydQQVRIV0FZLUlEJ10gfHwgJy4nO1xuICB9XG4gIGdldCB2aWRlb1JhbmdlKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJzWydWSURFTy1SQU5HRSddIHx8ICdTRFInO1xuICB9XG4gIGdldCBzY29yZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRycy5vcHRpb25hbEZsb2F0KCdTQ09SRScsIDApO1xuICB9XG4gIGdldCB1cmkoKSB7XG4gICAgcmV0dXJuIHRoaXMudXJsWzBdIHx8ICcnO1xuICB9XG4gIGhhc0F1ZGlvR3JvdXAoZ3JvdXBJZCkge1xuICAgIHJldHVybiBoYXNHcm91cCh0aGlzLl9hdWRpb0dyb3VwcywgZ3JvdXBJZCk7XG4gIH1cbiAgaGFzU3VidGl0bGVHcm91cChncm91cElkKSB7XG4gICAgcmV0dXJuIGhhc0dyb3VwKHRoaXMuX3N1YnRpdGxlR3JvdXBzLCBncm91cElkKTtcbiAgfVxuICBnZXQgYXVkaW9Hcm91cHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F1ZGlvR3JvdXBzO1xuICB9XG4gIGdldCBzdWJ0aXRsZUdyb3VwcygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3VidGl0bGVHcm91cHM7XG4gIH1cbiAgYWRkR3JvdXBJZCh0eXBlLCBncm91cElkKSB7XG4gICAgaWYgKCFncm91cElkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICBsZXQgYXVkaW9Hcm91cHMgPSB0aGlzLl9hdWRpb0dyb3VwcztcbiAgICAgIGlmICghYXVkaW9Hcm91cHMpIHtcbiAgICAgICAgYXVkaW9Hcm91cHMgPSB0aGlzLl9hdWRpb0dyb3VwcyA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKGF1ZGlvR3JvdXBzLmluZGV4T2YoZ3JvdXBJZCkgPT09IC0xKSB7XG4gICAgICAgIGF1ZGlvR3JvdXBzLnB1c2goZ3JvdXBJZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAndGV4dCcpIHtcbiAgICAgIGxldCBzdWJ0aXRsZUdyb3VwcyA9IHRoaXMuX3N1YnRpdGxlR3JvdXBzO1xuICAgICAgaWYgKCFzdWJ0aXRsZUdyb3Vwcykge1xuICAgICAgICBzdWJ0aXRsZUdyb3VwcyA9IHRoaXMuX3N1YnRpdGxlR3JvdXBzID0gW107XG4gICAgICB9XG4gICAgICBpZiAoc3VidGl0bGVHcm91cHMuaW5kZXhPZihncm91cElkKSA9PT0gLTEpIHtcbiAgICAgICAgc3VidGl0bGVHcm91cHMucHVzaChncm91cElkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBEZXByZWNhdGVkIG1ldGhvZHMgKHJldGFpbmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSlcbiAgZ2V0IHVybElkKCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHNldCB1cmxJZCh2YWx1ZSkge31cbiAgZ2V0IGF1ZGlvR3JvdXBJZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXVkaW9Hcm91cHMgPyBbdGhpcy5hdWRpb0dyb3VwSWRdIDogdW5kZWZpbmVkO1xuICB9XG4gIGdldCB0ZXh0R3JvdXBJZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3VidGl0bGVHcm91cHMgPyBbdGhpcy50ZXh0R3JvdXBJZF0gOiB1bmRlZmluZWQ7XG4gIH1cbiAgZ2V0IGF1ZGlvR3JvdXBJZCgpIHtcbiAgICB2YXIgX3RoaXMkYXVkaW9Hcm91cHM7XG4gICAgcmV0dXJuIChfdGhpcyRhdWRpb0dyb3VwcyA9IHRoaXMuYXVkaW9Hcm91cHMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRhdWRpb0dyb3Vwc1swXTtcbiAgfVxuICBnZXQgdGV4dEdyb3VwSWQoKSB7XG4gICAgdmFyIF90aGlzJHN1YnRpdGxlR3JvdXBzO1xuICAgIHJldHVybiAoX3RoaXMkc3VidGl0bGVHcm91cHMgPSB0aGlzLnN1YnRpdGxlR3JvdXBzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkc3VidGl0bGVHcm91cHNbMF07XG4gIH1cbiAgYWRkRmFsbGJhY2soKSB7fVxufVxuZnVuY3Rpb24gaGFzR3JvdXAoZ3JvdXBzLCBncm91cElkKSB7XG4gIGlmICghZ3JvdXBJZCB8fCAhZ3JvdXBzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBncm91cHMuaW5kZXhPZihncm91cElkKSAhPT0gLTE7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUZyb21Ub1BUUyhmcmFnRnJvbSwgZnJhZ1RvKSB7XG4gIGNvbnN0IGZyYWdUb1BUUyA9IGZyYWdUby5zdGFydFBUUztcbiAgLy8gaWYgd2Uga25vdyBzdGFydFBUU1t0b0lkeF1cbiAgaWYgKGlzRmluaXRlTnVtYmVyKGZyYWdUb1BUUykpIHtcbiAgICAvLyB1cGRhdGUgZnJhZ21lbnQgZHVyYXRpb24uXG4gICAgLy8gaXQgaGVscHMgdG8gZml4IGRyaWZ0cyBiZXR3ZWVuIHBsYXlsaXN0IHJlcG9ydGVkIGR1cmF0aW9uIGFuZCBmcmFnbWVudCByZWFsIGR1cmF0aW9uXG4gICAgbGV0IGR1cmF0aW9uID0gMDtcbiAgICBsZXQgZnJhZztcbiAgICBpZiAoZnJhZ1RvLnNuID4gZnJhZ0Zyb20uc24pIHtcbiAgICAgIGR1cmF0aW9uID0gZnJhZ1RvUFRTIC0gZnJhZ0Zyb20uc3RhcnQ7XG4gICAgICBmcmFnID0gZnJhZ0Zyb207XG4gICAgfSBlbHNlIHtcbiAgICAgIGR1cmF0aW9uID0gZnJhZ0Zyb20uc3RhcnQgLSBmcmFnVG9QVFM7XG4gICAgICBmcmFnID0gZnJhZ1RvO1xuICAgIH1cbiAgICBpZiAoZnJhZy5kdXJhdGlvbiAhPT0gZHVyYXRpb24pIHtcbiAgICAgIGZyYWcuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICB9XG4gICAgLy8gd2UgZG9udCBrbm93IHN0YXJ0UFRTW3RvSWR4XVxuICB9IGVsc2UgaWYgKGZyYWdUby5zbiA+IGZyYWdGcm9tLnNuKSB7XG4gICAgY29uc3QgY29udGlndW91cyA9IGZyYWdGcm9tLmNjID09PSBmcmFnVG8uY2M7XG4gICAgLy8gVE9ETzogV2l0aCBwYXJ0LWxvYWRpbmcgZW5kL2R1cmF0aW9ucyB3ZSBuZWVkIHRvIGNvbmZpcm0gdGhlIHdob2xlIGZyYWdtZW50IGlzIGxvYWRlZCBiZWZvcmUgdXNpbmcgKG9yIHNldHRpbmcpIG1pbkVuZFBUU1xuICAgIGlmIChjb250aWd1b3VzICYmIGZyYWdGcm9tLm1pbkVuZFBUUykge1xuICAgICAgZnJhZ1RvLnN0YXJ0ID0gZnJhZ0Zyb20uc3RhcnQgKyAoZnJhZ0Zyb20ubWluRW5kUFRTIC0gZnJhZ0Zyb20uc3RhcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcmFnVG8uc3RhcnQgPSBmcmFnRnJvbS5zdGFydCArIGZyYWdGcm9tLmR1cmF0aW9uO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmcmFnVG8uc3RhcnQgPSBNYXRoLm1heChmcmFnRnJvbS5zdGFydCAtIGZyYWdUby5kdXJhdGlvbiwgMCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZUZyYWdQVFNEVFMoZGV0YWlscywgZnJhZywgc3RhcnRQVFMsIGVuZFBUUywgc3RhcnREVFMsIGVuZERUUykge1xuICBjb25zdCBwYXJzZWRNZWRpYUR1cmF0aW9uID0gZW5kUFRTIC0gc3RhcnRQVFM7XG4gIGlmIChwYXJzZWRNZWRpYUR1cmF0aW9uIDw9IDApIHtcbiAgICBsb2dnZXIud2FybignRnJhZ21lbnQgc2hvdWxkIGhhdmUgYSBwb3NpdGl2ZSBkdXJhdGlvbicsIGZyYWcpO1xuICAgIGVuZFBUUyA9IHN0YXJ0UFRTICsgZnJhZy5kdXJhdGlvbjtcbiAgICBlbmREVFMgPSBzdGFydERUUyArIGZyYWcuZHVyYXRpb247XG4gIH1cbiAgbGV0IG1heFN0YXJ0UFRTID0gc3RhcnRQVFM7XG4gIGxldCBtaW5FbmRQVFMgPSBlbmRQVFM7XG4gIGNvbnN0IGZyYWdTdGFydFB0cyA9IGZyYWcuc3RhcnRQVFM7XG4gIGNvbnN0IGZyYWdFbmRQdHMgPSBmcmFnLmVuZFBUUztcbiAgaWYgKGlzRmluaXRlTnVtYmVyKGZyYWdTdGFydFB0cykpIHtcbiAgICAvLyBkZWx0YSBQVFMgYmV0d2VlbiBhdWRpbyBhbmQgdmlkZW9cbiAgICBjb25zdCBkZWx0YVBUUyA9IE1hdGguYWJzKGZyYWdTdGFydFB0cyAtIHN0YXJ0UFRTKTtcbiAgICBpZiAoIWlzRmluaXRlTnVtYmVyKGZyYWcuZGVsdGFQVFMpKSB7XG4gICAgICBmcmFnLmRlbHRhUFRTID0gZGVsdGFQVFM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWcuZGVsdGFQVFMgPSBNYXRoLm1heChkZWx0YVBUUywgZnJhZy5kZWx0YVBUUyk7XG4gICAgfVxuICAgIG1heFN0YXJ0UFRTID0gTWF0aC5tYXgoc3RhcnRQVFMsIGZyYWdTdGFydFB0cyk7XG4gICAgc3RhcnRQVFMgPSBNYXRoLm1pbihzdGFydFBUUywgZnJhZ1N0YXJ0UHRzKTtcbiAgICBzdGFydERUUyA9IE1hdGgubWluKHN0YXJ0RFRTLCBmcmFnLnN0YXJ0RFRTKTtcbiAgICBtaW5FbmRQVFMgPSBNYXRoLm1pbihlbmRQVFMsIGZyYWdFbmRQdHMpO1xuICAgIGVuZFBUUyA9IE1hdGgubWF4KGVuZFBUUywgZnJhZ0VuZFB0cyk7XG4gICAgZW5kRFRTID0gTWF0aC5tYXgoZW5kRFRTLCBmcmFnLmVuZERUUyk7XG4gIH1cbiAgY29uc3QgZHJpZnQgPSBzdGFydFBUUyAtIGZyYWcuc3RhcnQ7XG4gIGlmIChmcmFnLnN0YXJ0ICE9PSAwKSB7XG4gICAgZnJhZy5zdGFydCA9IHN0YXJ0UFRTO1xuICB9XG4gIGZyYWcuZHVyYXRpb24gPSBlbmRQVFMgLSBmcmFnLnN0YXJ0O1xuICBmcmFnLnN0YXJ0UFRTID0gc3RhcnRQVFM7XG4gIGZyYWcubWF4U3RhcnRQVFMgPSBtYXhTdGFydFBUUztcbiAgZnJhZy5zdGFydERUUyA9IHN0YXJ0RFRTO1xuICBmcmFnLmVuZFBUUyA9IGVuZFBUUztcbiAgZnJhZy5taW5FbmRQVFMgPSBtaW5FbmRQVFM7XG4gIGZyYWcuZW5kRFRTID0gZW5kRFRTO1xuICBjb25zdCBzbiA9IGZyYWcuc247IC8vICdpbml0U2VnbWVudCdcbiAgLy8gZXhpdCBpZiBzbiBvdXQgb2YgcmFuZ2VcbiAgaWYgKCFkZXRhaWxzIHx8IHNuIDwgZGV0YWlscy5zdGFydFNOIHx8IHNuID4gZGV0YWlscy5lbmRTTikge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGxldCBpO1xuICBjb25zdCBmcmFnSWR4ID0gc24gLSBkZXRhaWxzLnN0YXJ0U047XG4gIGNvbnN0IGZyYWdtZW50cyA9IGRldGFpbHMuZnJhZ21lbnRzO1xuICAvLyB1cGRhdGUgZnJhZyByZWZlcmVuY2UgaW4gZnJhZ21lbnRzIGFycmF5XG4gIC8vIHJhdGlvbmFsZSBpcyB0aGF0IGZyYWdtZW50cyBhcnJheSBtaWdodCBub3QgY29udGFpbiB0aGlzIGZyYWcgb2JqZWN0LlxuICAvLyB0aGlzIHdpbGwgaGFwcGVuIGlmIHBsYXlsaXN0IGhhcyBiZWVuIHJlZnJlc2hlZCBiZXR3ZWVuIGZyYWcgbG9hZGluZyBhbmQgY2FsbCB0byB1cGRhdGVGcmFnUFRTRFRTKClcbiAgLy8gaWYgd2UgZG9uJ3QgdXBkYXRlIGZyYWcsIHdlIHdvbid0IGJlIGFibGUgdG8gcHJvcGFnYXRlIFBUUyBpbmZvIG9uIHRoZSBwbGF5bGlzdFxuICAvLyByZXN1bHRpbmcgaW4gaW52YWxpZCBzbGlkaW5nIGNvbXB1dGF0aW9uXG4gIGZyYWdtZW50c1tmcmFnSWR4XSA9IGZyYWc7XG4gIC8vIGFkanVzdCBmcmFnbWVudCBQVFMvZHVyYXRpb24gZnJvbSBzZXFudW0tMSB0byBmcmFnIDBcbiAgZm9yIChpID0gZnJhZ0lkeDsgaSA+IDA7IGktLSkge1xuICAgIHVwZGF0ZUZyb21Ub1BUUyhmcmFnbWVudHNbaV0sIGZyYWdtZW50c1tpIC0gMV0pO1xuICB9XG5cbiAgLy8gYWRqdXN0IGZyYWdtZW50IFBUUy9kdXJhdGlvbiBmcm9tIHNlcW51bSB0byBsYXN0IGZyYWdcbiAgZm9yIChpID0gZnJhZ0lkeDsgaSA8IGZyYWdtZW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICB1cGRhdGVGcm9tVG9QVFMoZnJhZ21lbnRzW2ldLCBmcmFnbWVudHNbaSArIDFdKTtcbiAgfVxuICBpZiAoZGV0YWlscy5mcmFnbWVudEhpbnQpIHtcbiAgICB1cGRhdGVGcm9tVG9QVFMoZnJhZ21lbnRzW2ZyYWdtZW50cy5sZW5ndGggLSAxXSwgZGV0YWlscy5mcmFnbWVudEhpbnQpO1xuICB9XG4gIGRldGFpbHMuUFRTS25vd24gPSBkZXRhaWxzLmFsaWduZWRTbGlkaW5nID0gdHJ1ZTtcbiAgcmV0dXJuIGRyaWZ0O1xufVxuZnVuY3Rpb24gbWVyZ2VEZXRhaWxzKG9sZERldGFpbHMsIG5ld0RldGFpbHMpIHtcbiAgLy8gVHJhY2sgdGhlIGxhc3QgaW5pdFNlZ21lbnQgcHJvY2Vzc2VkLiBJbml0aWFsaXplIGl0IHRvIHRoZSBsYXN0IG9uZSBvbiB0aGUgdGltZWxpbmUuXG4gIGxldCBjdXJyZW50SW5pdFNlZ21lbnQgPSBudWxsO1xuICBjb25zdCBvbGRGcmFnbWVudHMgPSBvbGREZXRhaWxzLmZyYWdtZW50cztcbiAgZm9yIChsZXQgaSA9IG9sZEZyYWdtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IG9sZEluaXQgPSBvbGRGcmFnbWVudHNbaV0uaW5pdFNlZ21lbnQ7XG4gICAgaWYgKG9sZEluaXQpIHtcbiAgICAgIGN1cnJlbnRJbml0U2VnbWVudCA9IG9sZEluaXQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKG9sZERldGFpbHMuZnJhZ21lbnRIaW50KSB7XG4gICAgLy8gcHJldmVudCBQVFMgYW5kIGR1cmF0aW9uIGZyb20gYmVpbmcgYWRqdXN0ZWQgb24gdGhlIG5leHQgaGludFxuICAgIGRlbGV0ZSBvbGREZXRhaWxzLmZyYWdtZW50SGludC5lbmRQVFM7XG4gIH1cbiAgLy8gY2hlY2sgaWYgb2xkL25ldyBwbGF5bGlzdHMgaGF2ZSBmcmFnbWVudHMgaW4gY29tbW9uXG4gIC8vIGxvb3AgdGhyb3VnaCBvdmVybGFwcGluZyBTTiBhbmQgdXBkYXRlIHN0YXJ0UFRTICwgY2MsIGFuZCBkdXJhdGlvbiBpZiBhbnkgZm91bmRcbiAgbGV0IGNjT2Zmc2V0ID0gMDtcbiAgbGV0IFBUU0ZyYWc7XG4gIG1hcEZyYWdtZW50SW50ZXJzZWN0aW9uKG9sZERldGFpbHMsIG5ld0RldGFpbHMsIChvbGRGcmFnLCBuZXdGcmFnKSA9PiB7XG4gICAgaWYgKG9sZEZyYWcucmVsdXJsKSB7XG4gICAgICAvLyBEbyBub3QgY29tcGFyZSBDQyBpZiB0aGUgb2xkIGZyYWdtZW50IGhhcyBubyB1cmwuIFRoaXMgaXMgYSBsZXZlbC5mcmFnbWVudEhpbnQgdXNlZCBieSBMTC1ITFMgcGFydHMuXG4gICAgICAvLyBJdCBtYXliZSBiZSBvZmYgYnkgMSBpZiBpdCB3YXMgY3JlYXRlZCBiZWZvcmUgYW55IHBhcnRzIG9yIGRpc2NvbnRpbnVpdHkgdGFncyB3ZXJlIGFwcGVuZGVkIHRvIHRoZSBlbmRcbiAgICAgIC8vIG9mIHRoZSBwbGF5bGlzdC5cbiAgICAgIGNjT2Zmc2V0ID0gb2xkRnJhZy5jYyAtIG5ld0ZyYWcuY2M7XG4gICAgfVxuICAgIGlmIChpc0Zpbml0ZU51bWJlcihvbGRGcmFnLnN0YXJ0UFRTKSAmJiBpc0Zpbml0ZU51bWJlcihvbGRGcmFnLmVuZFBUUykpIHtcbiAgICAgIG5ld0ZyYWcuc3RhcnQgPSBuZXdGcmFnLnN0YXJ0UFRTID0gb2xkRnJhZy5zdGFydFBUUztcbiAgICAgIG5ld0ZyYWcuc3RhcnREVFMgPSBvbGRGcmFnLnN0YXJ0RFRTO1xuICAgICAgbmV3RnJhZy5tYXhTdGFydFBUUyA9IG9sZEZyYWcubWF4U3RhcnRQVFM7XG4gICAgICBuZXdGcmFnLmVuZFBUUyA9IG9sZEZyYWcuZW5kUFRTO1xuICAgICAgbmV3RnJhZy5lbmREVFMgPSBvbGRGcmFnLmVuZERUUztcbiAgICAgIG5ld0ZyYWcubWluRW5kUFRTID0gb2xkRnJhZy5taW5FbmRQVFM7XG4gICAgICBuZXdGcmFnLmR1cmF0aW9uID0gb2xkRnJhZy5lbmRQVFMgLSBvbGRGcmFnLnN0YXJ0UFRTO1xuICAgICAgaWYgKG5ld0ZyYWcuZHVyYXRpb24pIHtcbiAgICAgICAgUFRTRnJhZyA9IG5ld0ZyYWc7XG4gICAgICB9XG5cbiAgICAgIC8vIFBUUyBpcyBrbm93biB3aGVuIGFueSBzZWdtZW50IGhhcyBzdGFydFBUUyBhbmQgZW5kUFRTXG4gICAgICBuZXdEZXRhaWxzLlBUU0tub3duID0gbmV3RGV0YWlscy5hbGlnbmVkU2xpZGluZyA9IHRydWU7XG4gICAgfVxuICAgIG5ld0ZyYWcuZWxlbWVudGFyeVN0cmVhbXMgPSBvbGRGcmFnLmVsZW1lbnRhcnlTdHJlYW1zO1xuICAgIG5ld0ZyYWcubG9hZGVyID0gb2xkRnJhZy5sb2FkZXI7XG4gICAgbmV3RnJhZy5zdGF0cyA9IG9sZEZyYWcuc3RhdHM7XG4gICAgaWYgKG9sZEZyYWcuaW5pdFNlZ21lbnQpIHtcbiAgICAgIG5ld0ZyYWcuaW5pdFNlZ21lbnQgPSBvbGRGcmFnLmluaXRTZWdtZW50O1xuICAgICAgY3VycmVudEluaXRTZWdtZW50ID0gb2xkRnJhZy5pbml0U2VnbWVudDtcbiAgICB9XG4gIH0pO1xuICBpZiAoY3VycmVudEluaXRTZWdtZW50KSB7XG4gICAgY29uc3QgZnJhZ21lbnRzVG9DaGVjayA9IG5ld0RldGFpbHMuZnJhZ21lbnRIaW50ID8gbmV3RGV0YWlscy5mcmFnbWVudHMuY29uY2F0KG5ld0RldGFpbHMuZnJhZ21lbnRIaW50KSA6IG5ld0RldGFpbHMuZnJhZ21lbnRzO1xuICAgIGZyYWdtZW50c1RvQ2hlY2suZm9yRWFjaChmcmFnID0+IHtcbiAgICAgIHZhciBfY3VycmVudEluaXRTZWdtZW50O1xuICAgICAgaWYgKGZyYWcgJiYgKCFmcmFnLmluaXRTZWdtZW50IHx8IGZyYWcuaW5pdFNlZ21lbnQucmVsdXJsID09PSAoKF9jdXJyZW50SW5pdFNlZ21lbnQgPSBjdXJyZW50SW5pdFNlZ21lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfY3VycmVudEluaXRTZWdtZW50LnJlbHVybCkpKSB7XG4gICAgICAgIGZyYWcuaW5pdFNlZ21lbnQgPSBjdXJyZW50SW5pdFNlZ21lbnQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgaWYgKG5ld0RldGFpbHMuc2tpcHBlZFNlZ21lbnRzKSB7XG4gICAgbmV3RGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCA9IG5ld0RldGFpbHMuZnJhZ21lbnRzLnNvbWUoZnJhZyA9PiAhZnJhZyk7XG4gICAgaWYgKG5ld0RldGFpbHMuZGVsdGFVcGRhdGVGYWlsZWQpIHtcbiAgICAgIGxvZ2dlci53YXJuKCdbbGV2ZWwtaGVscGVyXSBQcmV2aW91cyBwbGF5bGlzdCBtaXNzaW5nIHNlZ21lbnRzIHNraXBwZWQgaW4gZGVsdGEgcGxheWxpc3QnKTtcbiAgICAgIGZvciAobGV0IGkgPSBuZXdEZXRhaWxzLnNraXBwZWRTZWdtZW50czsgaS0tOykge1xuICAgICAgICBuZXdEZXRhaWxzLmZyYWdtZW50cy5zaGlmdCgpO1xuICAgICAgfVxuICAgICAgbmV3RGV0YWlscy5zdGFydFNOID0gbmV3RGV0YWlscy5mcmFnbWVudHNbMF0uc247XG4gICAgICBuZXdEZXRhaWxzLnN0YXJ0Q0MgPSBuZXdEZXRhaWxzLmZyYWdtZW50c1swXS5jYztcbiAgICB9IGVsc2UgaWYgKG5ld0RldGFpbHMuY2FuU2tpcERhdGVSYW5nZXMpIHtcbiAgICAgIG5ld0RldGFpbHMuZGF0ZVJhbmdlcyA9IG1lcmdlRGF0ZVJhbmdlcyhvbGREZXRhaWxzLmRhdGVSYW5nZXMsIG5ld0RldGFpbHMuZGF0ZVJhbmdlcywgbmV3RGV0YWlscy5yZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgbmV3RnJhZ21lbnRzID0gbmV3RGV0YWlscy5mcmFnbWVudHM7XG4gIGlmIChjY09mZnNldCkge1xuICAgIGxvZ2dlci53YXJuKCdkaXNjb250aW51aXR5IHNsaWRpbmcgZnJvbSBwbGF5bGlzdCwgdGFrZSBkcmlmdCBpbnRvIGFjY291bnQnKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld0ZyYWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgbmV3RnJhZ21lbnRzW2ldLmNjICs9IGNjT2Zmc2V0O1xuICAgIH1cbiAgfVxuICBpZiAobmV3RGV0YWlscy5za2lwcGVkU2VnbWVudHMpIHtcbiAgICBuZXdEZXRhaWxzLnN0YXJ0Q0MgPSBuZXdEZXRhaWxzLmZyYWdtZW50c1swXS5jYztcbiAgfVxuXG4gIC8vIE1lcmdlIHBhcnRzXG4gIG1hcFBhcnRJbnRlcnNlY3Rpb24ob2xkRGV0YWlscy5wYXJ0TGlzdCwgbmV3RGV0YWlscy5wYXJ0TGlzdCwgKG9sZFBhcnQsIG5ld1BhcnQpID0+IHtcbiAgICBuZXdQYXJ0LmVsZW1lbnRhcnlTdHJlYW1zID0gb2xkUGFydC5lbGVtZW50YXJ5U3RyZWFtcztcbiAgICBuZXdQYXJ0LnN0YXRzID0gb2xkUGFydC5zdGF0cztcbiAgfSk7XG5cbiAgLy8gaWYgYXQgbGVhc3Qgb25lIGZyYWdtZW50IGNvbnRhaW5zIFBUUyBpbmZvLCByZWNvbXB1dGUgUFRTIGluZm9ybWF0aW9uIGZvciBhbGwgZnJhZ21lbnRzXG4gIGlmIChQVFNGcmFnKSB7XG4gICAgdXBkYXRlRnJhZ1BUU0RUUyhuZXdEZXRhaWxzLCBQVFNGcmFnLCBQVFNGcmFnLnN0YXJ0UFRTLCBQVFNGcmFnLmVuZFBUUywgUFRTRnJhZy5zdGFydERUUywgUFRTRnJhZy5lbmREVFMpO1xuICB9IGVsc2Uge1xuICAgIC8vIGVuc3VyZSB0aGF0IGRlbHRhIGlzIHdpdGhpbiBvbGRGcmFnbWVudHMgcmFuZ2VcbiAgICAvLyBhbHNvIGFkanVzdCBzbGlkaW5nIGluIGNhc2UgZGVsdGEgaXMgMCAod2UgY291bGQgaGF2ZSBvbGQ9WzUwLTYwXSBhbmQgbmV3PW9sZD1bNTAtNjFdKVxuICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBhbHNvIG5lZWQgdG8gYWRqdXN0IHN0YXJ0IG9mZnNldCBvZiBhbGwgZnJhZ21lbnRzXG4gICAgYWRqdXN0U2xpZGluZyhvbGREZXRhaWxzLCBuZXdEZXRhaWxzKTtcbiAgfVxuICBpZiAobmV3RnJhZ21lbnRzLmxlbmd0aCkge1xuICAgIG5ld0RldGFpbHMudG90YWxkdXJhdGlvbiA9IG5ld0RldGFpbHMuZWRnZSAtIG5ld0ZyYWdtZW50c1swXS5zdGFydDtcbiAgfVxuICBuZXdEZXRhaWxzLmRyaWZ0U3RhcnRUaW1lID0gb2xkRGV0YWlscy5kcmlmdFN0YXJ0VGltZTtcbiAgbmV3RGV0YWlscy5kcmlmdFN0YXJ0ID0gb2xkRGV0YWlscy5kcmlmdFN0YXJ0O1xuICBjb25zdCBhZHZhbmNlZERhdGVUaW1lID0gbmV3RGV0YWlscy5hZHZhbmNlZERhdGVUaW1lO1xuICBpZiAobmV3RGV0YWlscy5hZHZhbmNlZCAmJiBhZHZhbmNlZERhdGVUaW1lKSB7XG4gICAgY29uc3QgZWRnZSA9IG5ld0RldGFpbHMuZWRnZTtcbiAgICBpZiAoIW5ld0RldGFpbHMuZHJpZnRTdGFydCkge1xuICAgICAgbmV3RGV0YWlscy5kcmlmdFN0YXJ0VGltZSA9IGFkdmFuY2VkRGF0ZVRpbWU7XG4gICAgICBuZXdEZXRhaWxzLmRyaWZ0U3RhcnQgPSBlZGdlO1xuICAgIH1cbiAgICBuZXdEZXRhaWxzLmRyaWZ0RW5kVGltZSA9IGFkdmFuY2VkRGF0ZVRpbWU7XG4gICAgbmV3RGV0YWlscy5kcmlmdEVuZCA9IGVkZ2U7XG4gIH0gZWxzZSB7XG4gICAgbmV3RGV0YWlscy5kcmlmdEVuZFRpbWUgPSBvbGREZXRhaWxzLmRyaWZ0RW5kVGltZTtcbiAgICBuZXdEZXRhaWxzLmRyaWZ0RW5kID0gb2xkRGV0YWlscy5kcmlmdEVuZDtcbiAgICBuZXdEZXRhaWxzLmFkdmFuY2VkRGF0ZVRpbWUgPSBvbGREZXRhaWxzLmFkdmFuY2VkRGF0ZVRpbWU7XG4gIH1cbn1cbmZ1bmN0aW9uIG1lcmdlRGF0ZVJhbmdlcyhvbGREYXRlUmFuZ2VzLCBkZWx0YURhdGVSYW5nZXMsIHJlY2VudGx5UmVtb3ZlZERhdGVyYW5nZXMpIHtcbiAgY29uc3QgZGF0ZVJhbmdlcyA9IF9leHRlbmRzKHt9LCBvbGREYXRlUmFuZ2VzKTtcbiAgaWYgKHJlY2VudGx5UmVtb3ZlZERhdGVyYW5nZXMpIHtcbiAgICByZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzLmZvckVhY2goaWQgPT4ge1xuICAgICAgZGVsZXRlIGRhdGVSYW5nZXNbaWRdO1xuICAgIH0pO1xuICB9XG4gIE9iamVjdC5rZXlzKGRlbHRhRGF0ZVJhbmdlcykuZm9yRWFjaChpZCA9PiB7XG4gICAgY29uc3QgZGF0ZVJhbmdlID0gbmV3IERhdGVSYW5nZShkZWx0YURhdGVSYW5nZXNbaWRdLmF0dHIsIGRhdGVSYW5nZXNbaWRdKTtcbiAgICBpZiAoZGF0ZVJhbmdlLmlzVmFsaWQpIHtcbiAgICAgIGRhdGVSYW5nZXNbaWRdID0gZGF0ZVJhbmdlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIud2FybihgSWdub3JpbmcgaW52YWxpZCBQbGF5bGlzdCBEZWx0YSBVcGRhdGUgREFURVJBTkdFIHRhZzogXCIke0pTT04uc3RyaW5naWZ5KGRlbHRhRGF0ZVJhbmdlc1tpZF0uYXR0cil9XCJgKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZGF0ZVJhbmdlcztcbn1cbmZ1bmN0aW9uIG1hcFBhcnRJbnRlcnNlY3Rpb24ob2xkUGFydHMsIG5ld1BhcnRzLCBpbnRlcnNlY3Rpb25Gbikge1xuICBpZiAob2xkUGFydHMgJiYgbmV3UGFydHMpIHtcbiAgICBsZXQgZGVsdGEgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBvbGRQYXJ0cy5sZW5ndGg7IGkgPD0gbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IG9sZFBhcnQgPSBvbGRQYXJ0c1tpXTtcbiAgICAgIGNvbnN0IG5ld1BhcnQgPSBuZXdQYXJ0c1tpICsgZGVsdGFdO1xuICAgICAgaWYgKG9sZFBhcnQgJiYgbmV3UGFydCAmJiBvbGRQYXJ0LmluZGV4ID09PSBuZXdQYXJ0LmluZGV4ICYmIG9sZFBhcnQuZnJhZ21lbnQuc24gPT09IG5ld1BhcnQuZnJhZ21lbnQuc24pIHtcbiAgICAgICAgaW50ZXJzZWN0aW9uRm4ob2xkUGFydCwgbmV3UGFydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWx0YS0tO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFwRnJhZ21lbnRJbnRlcnNlY3Rpb24ob2xkRGV0YWlscywgbmV3RGV0YWlscywgaW50ZXJzZWN0aW9uRm4pIHtcbiAgY29uc3Qgc2tpcHBlZFNlZ21lbnRzID0gbmV3RGV0YWlscy5za2lwcGVkU2VnbWVudHM7XG4gIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgob2xkRGV0YWlscy5zdGFydFNOLCBuZXdEZXRhaWxzLnN0YXJ0U04pIC0gbmV3RGV0YWlscy5zdGFydFNOO1xuICBjb25zdCBlbmQgPSAob2xkRGV0YWlscy5mcmFnbWVudEhpbnQgPyAxIDogMCkgKyAoc2tpcHBlZFNlZ21lbnRzID8gbmV3RGV0YWlscy5lbmRTTiA6IE1hdGgubWluKG9sZERldGFpbHMuZW5kU04sIG5ld0RldGFpbHMuZW5kU04pKSAtIG5ld0RldGFpbHMuc3RhcnRTTjtcbiAgY29uc3QgZGVsdGEgPSBuZXdEZXRhaWxzLnN0YXJ0U04gLSBvbGREZXRhaWxzLnN0YXJ0U047XG4gIGNvbnN0IG5ld0ZyYWdzID0gbmV3RGV0YWlscy5mcmFnbWVudEhpbnQgPyBuZXdEZXRhaWxzLmZyYWdtZW50cy5jb25jYXQobmV3RGV0YWlscy5mcmFnbWVudEhpbnQpIDogbmV3RGV0YWlscy5mcmFnbWVudHM7XG4gIGNvbnN0IG9sZEZyYWdzID0gb2xkRGV0YWlscy5mcmFnbWVudEhpbnQgPyBvbGREZXRhaWxzLmZyYWdtZW50cy5jb25jYXQob2xkRGV0YWlscy5mcmFnbWVudEhpbnQpIDogb2xkRGV0YWlscy5mcmFnbWVudHM7XG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8PSBlbmQ7IGkrKykge1xuICAgIGNvbnN0IG9sZEZyYWcgPSBvbGRGcmFnc1tkZWx0YSArIGldO1xuICAgIGxldCBuZXdGcmFnID0gbmV3RnJhZ3NbaV07XG4gICAgaWYgKHNraXBwZWRTZWdtZW50cyAmJiAhbmV3RnJhZyAmJiBpIDwgc2tpcHBlZFNlZ21lbnRzKSB7XG4gICAgICAvLyBGaWxsIGluIHNraXBwZWQgc2VnbWVudHMgaW4gZGVsdGEgcGxheWxpc3RcbiAgICAgIG5ld0ZyYWcgPSBuZXdEZXRhaWxzLmZyYWdtZW50c1tpXSA9IG9sZEZyYWc7XG4gICAgfVxuICAgIGlmIChvbGRGcmFnICYmIG5ld0ZyYWcpIHtcbiAgICAgIGludGVyc2VjdGlvbkZuKG9sZEZyYWcsIG5ld0ZyYWcpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYWRqdXN0U2xpZGluZyhvbGREZXRhaWxzLCBuZXdEZXRhaWxzKSB7XG4gIGNvbnN0IGRlbHRhID0gbmV3RGV0YWlscy5zdGFydFNOICsgbmV3RGV0YWlscy5za2lwcGVkU2VnbWVudHMgLSBvbGREZXRhaWxzLnN0YXJ0U047XG4gIGNvbnN0IG9sZEZyYWdtZW50cyA9IG9sZERldGFpbHMuZnJhZ21lbnRzO1xuICBpZiAoZGVsdGEgPCAwIHx8IGRlbHRhID49IG9sZEZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYWRkU2xpZGluZyhuZXdEZXRhaWxzLCBvbGRGcmFnbWVudHNbZGVsdGFdLnN0YXJ0KTtcbn1cbmZ1bmN0aW9uIGFkZFNsaWRpbmcoZGV0YWlscywgc3RhcnQpIHtcbiAgaWYgKHN0YXJ0KSB7XG4gICAgY29uc3QgZnJhZ21lbnRzID0gZGV0YWlscy5mcmFnbWVudHM7XG4gICAgZm9yIChsZXQgaSA9IGRldGFpbHMuc2tpcHBlZFNlZ21lbnRzOyBpIDwgZnJhZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmcmFnbWVudHNbaV0uc3RhcnQgKz0gc3RhcnQ7XG4gICAgfVxuICAgIGlmIChkZXRhaWxzLmZyYWdtZW50SGludCkge1xuICAgICAgZGV0YWlscy5mcmFnbWVudEhpbnQuc3RhcnQgKz0gc3RhcnQ7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjb21wdXRlUmVsb2FkSW50ZXJ2YWwobmV3RGV0YWlscywgZGlzdGFuY2VUb0xpdmVFZGdlTXMgPSBJbmZpbml0eSkge1xuICBsZXQgcmVsb2FkSW50ZXJ2YWwgPSAxMDAwICogbmV3RGV0YWlscy50YXJnZXRkdXJhdGlvbjtcbiAgaWYgKG5ld0RldGFpbHMudXBkYXRlZCkge1xuICAgIC8vIFVzZSBsYXN0IHNlZ21lbnQgZHVyYXRpb24gd2hlbiBzaG9ydGVyIHRoYW4gdGFyZ2V0IGR1cmF0aW9uIGFuZCBuZWFyIGxpdmUgZWRnZVxuICAgIGNvbnN0IGZyYWdtZW50cyA9IG5ld0RldGFpbHMuZnJhZ21lbnRzO1xuICAgIGNvbnN0IGxpdmVFZGdlTWF4VGFyZ2V0RHVyYXRpb25zID0gNDtcbiAgICBpZiAoZnJhZ21lbnRzLmxlbmd0aCAmJiByZWxvYWRJbnRlcnZhbCAqIGxpdmVFZGdlTWF4VGFyZ2V0RHVyYXRpb25zID4gZGlzdGFuY2VUb0xpdmVFZGdlTXMpIHtcbiAgICAgIGNvbnN0IGxhc3RTZWdtZW50RHVyYXRpb24gPSBmcmFnbWVudHNbZnJhZ21lbnRzLmxlbmd0aCAtIDFdLmR1cmF0aW9uICogMTAwMDtcbiAgICAgIGlmIChsYXN0U2VnbWVudER1cmF0aW9uIDwgcmVsb2FkSW50ZXJ2YWwpIHtcbiAgICAgICAgcmVsb2FkSW50ZXJ2YWwgPSBsYXN0U2VnbWVudER1cmF0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBlc3RpbWF0ZSA9ICdtaXNzIGhhbGYgYXZlcmFnZSc7XG4gICAgLy8gZm9sbG93IEhMUyBTcGVjLCBJZiB0aGUgY2xpZW50IHJlbG9hZHMgYSBQbGF5bGlzdCBmaWxlIGFuZCBmaW5kcyB0aGF0IGl0IGhhcyBub3RcbiAgICAvLyBjaGFuZ2VkIHRoZW4gaXQgTVVTVCB3YWl0IGZvciBhIHBlcmlvZCBvZiBvbmUtaGFsZiB0aGUgdGFyZ2V0XG4gICAgLy8gZHVyYXRpb24gYmVmb3JlIHJldHJ5aW5nLlxuICAgIHJlbG9hZEludGVydmFsIC89IDI7XG4gIH1cbiAgcmV0dXJuIE1hdGgucm91bmQocmVsb2FkSW50ZXJ2YWwpO1xufVxuZnVuY3Rpb24gZ2V0RnJhZ21lbnRXaXRoU04obGV2ZWwsIHNuLCBmcmFnQ3VycmVudCkge1xuICBpZiAoIShsZXZlbCAhPSBudWxsICYmIGxldmVsLmRldGFpbHMpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgbGV2ZWxEZXRhaWxzID0gbGV2ZWwuZGV0YWlscztcbiAgbGV0IGZyYWdtZW50ID0gbGV2ZWxEZXRhaWxzLmZyYWdtZW50c1tzbiAtIGxldmVsRGV0YWlscy5zdGFydFNOXTtcbiAgaWYgKGZyYWdtZW50KSB7XG4gICAgcmV0dXJuIGZyYWdtZW50O1xuICB9XG4gIGZyYWdtZW50ID0gbGV2ZWxEZXRhaWxzLmZyYWdtZW50SGludDtcbiAgaWYgKGZyYWdtZW50ICYmIGZyYWdtZW50LnNuID09PSBzbikge1xuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfVxuICBpZiAoc24gPCBsZXZlbERldGFpbHMuc3RhcnRTTiAmJiBmcmFnQ3VycmVudCAmJiBmcmFnQ3VycmVudC5zbiA9PT0gc24pIHtcbiAgICByZXR1cm4gZnJhZ0N1cnJlbnQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRQYXJ0V2l0aChsZXZlbCwgc24sIHBhcnRJbmRleCkge1xuICB2YXIgX2xldmVsJGRldGFpbHM7XG4gIGlmICghKGxldmVsICE9IG51bGwgJiYgbGV2ZWwuZGV0YWlscykpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gZmluZFBhcnQoKF9sZXZlbCRkZXRhaWxzID0gbGV2ZWwuZGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9sZXZlbCRkZXRhaWxzLnBhcnRMaXN0LCBzbiwgcGFydEluZGV4KTtcbn1cbmZ1bmN0aW9uIGZpbmRQYXJ0KHBhcnRMaXN0LCBzbiwgcGFydEluZGV4KSB7XG4gIGlmIChwYXJ0TGlzdCkge1xuICAgIGZvciAobGV0IGkgPSBwYXJ0TGlzdC5sZW5ndGg7IGktLTspIHtcbiAgICAgIGNvbnN0IHBhcnQgPSBwYXJ0TGlzdFtpXTtcbiAgICAgIGlmIChwYXJ0LmluZGV4ID09PSBwYXJ0SW5kZXggJiYgcGFydC5mcmFnbWVudC5zbiA9PT0gc24pIHtcbiAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcmVhc3NpZ25GcmFnbWVudExldmVsSW5kZXhlcyhsZXZlbHMpIHtcbiAgbGV2ZWxzLmZvckVhY2goKGxldmVsLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGRldGFpbHNcbiAgICB9ID0gbGV2ZWw7XG4gICAgaWYgKGRldGFpbHMgIT0gbnVsbCAmJiBkZXRhaWxzLmZyYWdtZW50cykge1xuICAgICAgZGV0YWlscy5mcmFnbWVudHMuZm9yRWFjaChmcmFnbWVudCA9PiB7XG4gICAgICAgIGZyYWdtZW50LmxldmVsID0gaW5kZXg7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpc1RpbWVvdXRFcnJvcihlcnJvcikge1xuICBzd2l0Y2ggKGVycm9yLmRldGFpbHMpIHtcbiAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVDpcbiAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfTE9BRF9USU1FT1VUOlxuICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfVElNRU9VVDpcbiAgICBjYXNlIEVycm9yRGV0YWlscy5NQU5JRkVTVF9MT0FEX1RJTUVPVVQ6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRSZXRyeUNvbmZpZyhsb2FkUG9saWN5LCBlcnJvcikge1xuICBjb25zdCBpc1RpbWVvdXQgPSBpc1RpbWVvdXRFcnJvcihlcnJvcik7XG4gIHJldHVybiBsb2FkUG9saWN5LmRlZmF1bHRbYCR7aXNUaW1lb3V0ID8gJ3RpbWVvdXQnIDogJ2Vycm9yJ31SZXRyeWBdO1xufVxuZnVuY3Rpb24gZ2V0UmV0cnlEZWxheShyZXRyeUNvbmZpZywgcmV0cnlDb3VudCkge1xuICAvLyBleHBvbmVudGlhbCBiYWNrb2ZmIGNhcHBlZCB0byBtYXggcmV0cnkgZGVsYXlcbiAgY29uc3QgYmFja29mZkZhY3RvciA9IHJldHJ5Q29uZmlnLmJhY2tvZmYgPT09ICdsaW5lYXInID8gMSA6IE1hdGgucG93KDIsIHJldHJ5Q291bnQpO1xuICByZXR1cm4gTWF0aC5taW4oYmFja29mZkZhY3RvciAqIHJldHJ5Q29uZmlnLnJldHJ5RGVsYXlNcywgcmV0cnlDb25maWcubWF4UmV0cnlEZWxheU1zKTtcbn1cbmZ1bmN0aW9uIGdldExvYWRlckNvbmZpZ1dpdGhvdXRSZXRpZXMobG9kZXJDb25maWcpIHtcbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBsb2RlckNvbmZpZyksIHtcbiAgICBlcnJvclJldHJ5OiBudWxsLFxuICAgIHRpbWVvdXRSZXRyeTogbnVsbFxuICB9KTtcbn1cbmZ1bmN0aW9uIHNob3VsZFJldHJ5KHJldHJ5Q29uZmlnLCByZXRyeUNvdW50LCBpc1RpbWVvdXQsIGxvYWRlclJlc3BvbnNlKSB7XG4gIGlmICghcmV0cnlDb25maWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgaHR0cFN0YXR1cyA9IGxvYWRlclJlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiBsb2FkZXJSZXNwb25zZS5jb2RlO1xuICBjb25zdCByZXRyeSA9IHJldHJ5Q291bnQgPCByZXRyeUNvbmZpZy5tYXhOdW1SZXRyeSAmJiAocmV0cnlGb3JIdHRwU3RhdHVzKGh0dHBTdGF0dXMpIHx8ICEhaXNUaW1lb3V0KTtcbiAgcmV0dXJuIHJldHJ5Q29uZmlnLnNob3VsZFJldHJ5ID8gcmV0cnlDb25maWcuc2hvdWxkUmV0cnkocmV0cnlDb25maWcsIHJldHJ5Q291bnQsIGlzVGltZW91dCwgbG9hZGVyUmVzcG9uc2UsIHJldHJ5KSA6IHJldHJ5O1xufVxuZnVuY3Rpb24gcmV0cnlGb3JIdHRwU3RhdHVzKGh0dHBTdGF0dXMpIHtcbiAgLy8gRG8gbm90IHJldHJ5IG9uIHN0YXR1cyA0eHgsIHN0YXR1cyAwIChDT1JTIGVycm9yKSwgb3IgdW5kZWZpbmVkIChkZWNyeXB0L2dhcC9wYXJzZSBlcnJvcilcbiAgcmV0dXJuIGh0dHBTdGF0dXMgPT09IDAgJiYgbmF2aWdhdG9yLm9uTGluZSA9PT0gZmFsc2UgfHwgISFodHRwU3RhdHVzICYmIChodHRwU3RhdHVzIDwgNDAwIHx8IGh0dHBTdGF0dXMgPiA0OTkpO1xufVxuXG5jb25zdCBCaW5hcnlTZWFyY2ggPSB7XG4gIC8qKlxuICAgKiBTZWFyY2hlcyBmb3IgYW4gaXRlbSBpbiBhbiBhcnJheSB3aGljaCBtYXRjaGVzIGEgY2VydGFpbiBjb25kaXRpb24uXG4gICAqIFRoaXMgcmVxdWlyZXMgdGhlIGNvbmRpdGlvbiB0byBvbmx5IG1hdGNoIG9uZSBpdGVtIGluIHRoZSBhcnJheSxcbiAgICogYW5kIGZvciB0aGUgYXJyYXkgdG8gYmUgb3JkZXJlZC5cbiAgICpcbiAgICogQHBhcmFtIGxpc3QgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICogQHBhcmFtIGNvbXBhcmlzb25GblxuICAgKiAgICAgIENhbGxlZCBhbmQgcHJvdmlkZWQgYSBjYW5kaWRhdGUgaXRlbSBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXG4gICAqICAgICAgU2hvdWxkIHJldHVybjpcbiAgICogICAgICAgICAgPiAtMSBpZiB0aGUgaXRlbSBzaG91bGQgYmUgbG9jYXRlZCBhdCBhIGxvd2VyIGluZGV4IHRoYW4gdGhlIHByb3ZpZGVkIGl0ZW0uXG4gICAqICAgICAgICAgID4gMSBpZiB0aGUgaXRlbSBzaG91bGQgYmUgbG9jYXRlZCBhdCBhIGhpZ2hlciBpbmRleCB0aGFuIHRoZSBwcm92aWRlZCBpdGVtLlxuICAgKiAgICAgICAgICA+IDAgaWYgdGhlIGl0ZW0gaXMgdGhlIGl0ZW0geW91J3JlIGxvb2tpbmcgZm9yLlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgb2JqZWN0IGlmIGZvdW5kLCBvdGhlcndpc2UgcmV0dXJucyBudWxsXG4gICAqL1xuICBzZWFyY2g6IGZ1bmN0aW9uIChsaXN0LCBjb21wYXJpc29uRm4pIHtcbiAgICBsZXQgbWluSW5kZXggPSAwO1xuICAgIGxldCBtYXhJbmRleCA9IGxpc3QubGVuZ3RoIC0gMTtcbiAgICBsZXQgY3VycmVudEluZGV4ID0gbnVsbDtcbiAgICBsZXQgY3VycmVudEVsZW1lbnQgPSBudWxsO1xuICAgIHdoaWxlIChtaW5JbmRleCA8PSBtYXhJbmRleCkge1xuICAgICAgY3VycmVudEluZGV4ID0gKG1pbkluZGV4ICsgbWF4SW5kZXgpIC8gMiB8IDA7XG4gICAgICBjdXJyZW50RWxlbWVudCA9IGxpc3RbY3VycmVudEluZGV4XTtcbiAgICAgIGNvbnN0IGNvbXBhcmlzb25SZXN1bHQgPSBjb21wYXJpc29uRm4oY3VycmVudEVsZW1lbnQpO1xuICAgICAgaWYgKGNvbXBhcmlzb25SZXN1bHQgPiAwKSB7XG4gICAgICAgIG1pbkluZGV4ID0gY3VycmVudEluZGV4ICsgMTtcbiAgICAgIH0gZWxzZSBpZiAoY29tcGFyaXNvblJlc3VsdCA8IDApIHtcbiAgICAgICAgbWF4SW5kZXggPSBjdXJyZW50SW5kZXggLSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRFbGVtZW50O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGZpcnN0IGZyYWdtZW50IHdob3NlIGVuZFBkdCB2YWx1ZSBleGNlZWRzIHRoZSBnaXZlbiBQRFQsIG9yIG51bGwuXG4gKiBAcGFyYW0gZnJhZ21lbnRzIC0gVGhlIGFycmF5IG9mIGNhbmRpZGF0ZSBmcmFnbWVudHNcbiAqIEBwYXJhbSBQRFRWYWx1ZSAtIFRoZSBQRFQgdmFsdWUgd2hpY2ggbXVzdCBiZSBleGNlZWRlZFxuICogQHBhcmFtIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgLSBUaGUgYW1vdW50IG9mIHRpbWUgdGhhdCBhIGZyYWdtZW50J3Mgc3RhcnQvZW5kIGNhbiBiZSB3aXRoaW4gaW4gb3JkZXIgdG8gYmUgY29uc2lkZXJlZCBjb250aWd1b3VzXG4gKi9cbmZ1bmN0aW9uIGZpbmRGcmFnbWVudEJ5UERUKGZyYWdtZW50cywgUERUVmFsdWUsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UpIHtcbiAgaWYgKFBEVFZhbHVlID09PSBudWxsIHx8ICFBcnJheS5pc0FycmF5KGZyYWdtZW50cykgfHwgIWZyYWdtZW50cy5sZW5ndGggfHwgIWlzRmluaXRlTnVtYmVyKFBEVFZhbHVlKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gaWYgbGVzcyB0aGFuIHN0YXJ0XG4gIGNvbnN0IHN0YXJ0UERUID0gZnJhZ21lbnRzWzBdLnByb2dyYW1EYXRlVGltZTtcbiAgaWYgKFBEVFZhbHVlIDwgKHN0YXJ0UERUIHx8IDApKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgZW5kUERUID0gZnJhZ21lbnRzW2ZyYWdtZW50cy5sZW5ndGggLSAxXS5lbmRQcm9ncmFtRGF0ZVRpbWU7XG4gIGlmIChQRFRWYWx1ZSA+PSAoZW5kUERUIHx8IDApKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IG1heEZyYWdMb29rVXBUb2xlcmFuY2UgfHwgMDtcbiAgZm9yIChsZXQgc2VnID0gMDsgc2VnIDwgZnJhZ21lbnRzLmxlbmd0aDsgKytzZWcpIHtcbiAgICBjb25zdCBmcmFnID0gZnJhZ21lbnRzW3NlZ107XG4gICAgaWYgKHBkdFdpdGhpblRvbGVyYW5jZVRlc3QoUERUVmFsdWUsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGZyYWcpKSB7XG4gICAgICByZXR1cm4gZnJhZztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRmluZHMgYSBmcmFnbWVudCBiYXNlZCBvbiB0aGUgU04gb2YgdGhlIHByZXZpb3VzIGZyYWdtZW50OyBvciBiYXNlZCBvbiB0aGUgbmVlZHMgb2YgdGhlIGN1cnJlbnQgYnVmZmVyLlxuICogVGhpcyBtZXRob2QgY29tcGVuc2F0ZXMgZm9yIHNtYWxsIGJ1ZmZlciBnYXBzIGJ5IGFwcGx5aW5nIGEgdG9sZXJhbmNlIHRvIHRoZSBzdGFydCBvZiBhbnkgY2FuZGlkYXRlIGZyYWdtZW50LCB0aHVzXG4gKiBicmVha2luZyBhbnkgdHJhcHMgd2hpY2ggd291bGQgY2F1c2UgdGhlIHNhbWUgZnJhZ21lbnQgdG8gYmUgY29udGludW91c2x5IHNlbGVjdGVkIHdpdGhpbiBhIHNtYWxsIHJhbmdlLlxuICogQHBhcmFtIGZyYWdQcmV2aW91cyAtIFRoZSBsYXN0IGZyYWcgc3VjY2Vzc2Z1bGx5IGFwcGVuZGVkXG4gKiBAcGFyYW0gZnJhZ21lbnRzIC0gVGhlIGFycmF5IG9mIGNhbmRpZGF0ZSBmcmFnbWVudHNcbiAqIEBwYXJhbSBidWZmZXJFbmQgLSBUaGUgZW5kIG9mIHRoZSBjb250aWd1b3VzIGJ1ZmZlcmVkIHJhbmdlIHRoZSBwbGF5aGVhZCBpcyBjdXJyZW50bHkgd2l0aGluXG4gKiBAcGFyYW0gbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSAtIFRoZSBhbW91bnQgb2YgdGltZSB0aGF0IGEgZnJhZ21lbnQncyBzdGFydC9lbmQgY2FuIGJlIHdpdGhpbiBpbiBvcmRlciB0byBiZSBjb25zaWRlcmVkIGNvbnRpZ3VvdXNcbiAqIEByZXR1cm5zIGEgbWF0Y2hpbmcgZnJhZ21lbnQgb3IgbnVsbFxuICovXG5mdW5jdGlvbiBmaW5kRnJhZ21lbnRCeVBUUyhmcmFnUHJldmlvdXMsIGZyYWdtZW50cywgYnVmZmVyRW5kID0gMCwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IDApIHtcbiAgbGV0IGZyYWdOZXh0ID0gbnVsbDtcbiAgaWYgKGZyYWdQcmV2aW91cykge1xuICAgIGZyYWdOZXh0ID0gZnJhZ21lbnRzW2ZyYWdQcmV2aW91cy5zbiAtIGZyYWdtZW50c1swXS5zbiArIDFdIHx8IG51bGw7XG4gICAgLy8gY2hlY2sgZm9yIGJ1ZmZlci1lbmQgcm91bmRpbmcgZXJyb3JcbiAgICBjb25zdCBidWZmZXJFZGdlRXJyb3IgPSBmcmFnUHJldmlvdXMuZW5kRFRTIC0gYnVmZmVyRW5kO1xuICAgIGlmIChidWZmZXJFZGdlRXJyb3IgPiAwICYmIGJ1ZmZlckVkZ2VFcnJvciA8IDAuMDAwMDAxNSkge1xuICAgICAgYnVmZmVyRW5kICs9IDAuMDAwMDAxNTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYnVmZmVyRW5kID09PSAwICYmIGZyYWdtZW50c1swXS5zdGFydCA9PT0gMCkge1xuICAgIGZyYWdOZXh0ID0gZnJhZ21lbnRzWzBdO1xuICB9XG4gIC8vIFByZWZlciB0aGUgbmV4dCBmcmFnbWVudCBpZiBpdCdzIHdpdGhpbiB0b2xlcmFuY2VcbiAgaWYgKGZyYWdOZXh0ICYmICghZnJhZ1ByZXZpb3VzIHx8IGZyYWdQcmV2aW91cy5sZXZlbCA9PT0gZnJhZ05leHQubGV2ZWwpICYmIGZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdChidWZmZXJFbmQsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGZyYWdOZXh0KSA9PT0gMCkge1xuICAgIHJldHVybiBmcmFnTmV4dDtcbiAgfVxuICAvLyBXZSBtaWdodCBiZSBzZWVraW5nIHBhc3QgdGhlIHRvbGVyYW5jZSBzbyBmaW5kIHRoZSBiZXN0IG1hdGNoXG4gIGNvbnN0IGZvdW5kRnJhZ21lbnQgPSBCaW5hcnlTZWFyY2guc2VhcmNoKGZyYWdtZW50cywgZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0LmJpbmQobnVsbCwgYnVmZmVyRW5kLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlKSk7XG4gIGlmIChmb3VuZEZyYWdtZW50ICYmIChmb3VuZEZyYWdtZW50ICE9PSBmcmFnUHJldmlvdXMgfHwgIWZyYWdOZXh0KSkge1xuICAgIHJldHVybiBmb3VuZEZyYWdtZW50O1xuICB9XG4gIC8vIElmIG5vIG1hdGNoIHdhcyBmb3VuZCByZXR1cm4gdGhlIG5leHQgZnJhZ21lbnQgYWZ0ZXIgZnJhZ1ByZXZpb3VzLCBvciBudWxsXG4gIHJldHVybiBmcmFnTmV4dDtcbn1cblxuLyoqXG4gKiBUaGUgdGVzdCBmdW5jdGlvbiB1c2VkIGJ5IHRoZSBmaW5kRnJhZ21lbnRCeVNuJ3MgQmluYXJ5U2VhcmNoIHRvIGxvb2sgZm9yIHRoZSBiZXN0IG1hdGNoIHRvIHRoZSBjdXJyZW50IGJ1ZmZlciBjb25kaXRpb25zLlxuICogQHBhcmFtIGNhbmRpZGF0ZSAtIFRoZSBmcmFnbWVudCB0byB0ZXN0XG4gKiBAcGFyYW0gYnVmZmVyRW5kIC0gVGhlIGVuZCBvZiB0aGUgY3VycmVudCBidWZmZXJlZCByYW5nZSB0aGUgcGxheWhlYWQgaXMgY3VycmVudGx5IHdpdGhpblxuICogQHBhcmFtIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgLSBUaGUgYW1vdW50IG9mIHRpbWUgdGhhdCBhIGZyYWdtZW50J3Mgc3RhcnQgY2FuIGJlIHdpdGhpbiBpbiBvcmRlciB0byBiZSBjb25zaWRlcmVkIGNvbnRpZ3VvdXNcbiAqIEByZXR1cm5zIDAgaWYgaXQgbWF0Y2hlcywgMSBpZiB0b28gbG93LCAtMSBpZiB0b28gaGlnaFxuICovXG5mdW5jdGlvbiBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QoYnVmZmVyRW5kID0gMCwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IDAsIGNhbmRpZGF0ZSkge1xuICAvLyBlYWdlcmx5IGFjY2VwdCBhbiBhY2N1cmF0ZSBtYXRjaCAobm8gdG9sZXJhbmNlKVxuICBpZiAoY2FuZGlkYXRlLnN0YXJ0IDw9IGJ1ZmZlckVuZCAmJiBjYW5kaWRhdGUuc3RhcnQgKyBjYW5kaWRhdGUuZHVyYXRpb24gPiBidWZmZXJFbmQpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICAvLyBvZmZzZXQgc2hvdWxkIGJlIHdpdGhpbiBmcmFnbWVudCBib3VuZGFyeSAtIGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlXG4gIC8vIHRoaXMgaXMgdG8gY29wZSB3aXRoIHNpdHVhdGlvbnMgbGlrZVxuICAvLyBidWZmZXJFbmQgPSA5Ljk5MVxuICAvLyBmcmFnW8OYXSA6IFswLDEwXVxuICAvLyBmcmFnWzFdIDogWzEwLDIwXVxuICAvLyBidWZmZXJFbmQgaXMgd2l0aGluIGZyYWdbMF0gcmFuZ2UgLi4uIGFsdGhvdWdoIHdoYXQgd2UgYXJlIGV4cGVjdGluZyBpcyB0byByZXR1cm4gZnJhZ1sxXSBoZXJlXG4gIC8vICAgICAgICAgICAgICBmcmFnIHN0YXJ0ICAgICAgICAgICAgICAgZnJhZyBzdGFydCtkdXJhdGlvblxuICAvLyAgICAgICAgICAgICAgICAgIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgLy8gICAgICAgICAgICAgIDwtLS0+ICAgICAgICAgICAgICAgICAgICAgICAgIDwtLS0+XG4gIC8vICAuLi4tLS0tLS0tLT48LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0+PC0tLS0tLS0tLS4uLi5cbiAgLy8gcHJldmlvdXMgZnJhZyAgICAgICAgIG1hdGNoaW5nIGZyYWdtZW50ICAgICAgICAgbmV4dCBmcmFnXG4gIC8vICByZXR1cm4gLTEgICAgICAgICAgICAgcmV0dXJuIDAgICAgICAgICAgICAgICAgIHJldHVybiAxXG4gIC8vIGxvZ2dlci5sb2coYGxldmVsL3NuL3N0YXJ0L2VuZC9idWZFbmQ6JHtsZXZlbH0vJHtjYW5kaWRhdGUuc259LyR7Y2FuZGlkYXRlLnN0YXJ0fS8keyhjYW5kaWRhdGUuc3RhcnQrY2FuZGlkYXRlLmR1cmF0aW9uKX0vJHtidWZmZXJFbmR9YCk7XG4gIC8vIFNldCB0aGUgbG9va3VwIHRvbGVyYW5jZSB0byBiZSBzbWFsbCBlbm91Z2ggdG8gZGV0ZWN0IHRoZSBjdXJyZW50IHNlZ21lbnQgLSBlbnN1cmVzIHdlIGRvbid0IHNraXAgb3ZlciB2ZXJ5IHNtYWxsIHNlZ21lbnRzXG4gIGNvbnN0IGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA9IE1hdGgubWluKG1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGNhbmRpZGF0ZS5kdXJhdGlvbiArIChjYW5kaWRhdGUuZGVsdGFQVFMgPyBjYW5kaWRhdGUuZGVsdGFQVFMgOiAwKSk7XG4gIGlmIChjYW5kaWRhdGUuc3RhcnQgKyBjYW5kaWRhdGUuZHVyYXRpb24gLSBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPD0gYnVmZmVyRW5kKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSBpZiAoY2FuZGlkYXRlLnN0YXJ0IC0gY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID4gYnVmZmVyRW5kICYmIGNhbmRpZGF0ZS5zdGFydCkge1xuICAgIC8vIGlmIG1heEZyYWdMb29rVXBUb2xlcmFuY2Ugd2lsbCBoYXZlIG5lZ2F0aXZlIHZhbHVlIHRoZW4gZG9uJ3QgcmV0dXJuIC0xIGZvciBmaXJzdCBlbGVtZW50XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vKipcbiAqIFRoZSB0ZXN0IGZ1bmN0aW9uIHVzZWQgYnkgdGhlIGZpbmRGcmFnbWVudEJ5UGR0J3MgQmluYXJ5U2VhcmNoIHRvIGxvb2sgZm9yIHRoZSBiZXN0IG1hdGNoIHRvIHRoZSBjdXJyZW50IGJ1ZmZlciBjb25kaXRpb25zLlxuICogVGhpcyBmdW5jdGlvbiB0ZXN0cyB0aGUgY2FuZGlkYXRlJ3MgcHJvZ3JhbSBkYXRlIHRpbWUgdmFsdWVzLCBhcyByZXByZXNlbnRlZCBpbiBVbml4IHRpbWVcbiAqIEBwYXJhbSBjYW5kaWRhdGUgLSBUaGUgZnJhZ21lbnQgdG8gdGVzdFxuICogQHBhcmFtIHBkdEJ1ZmZlckVuZCAtIFRoZSBVbml4IHRpbWUgcmVwcmVzZW50aW5nIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgYnVmZmVyZWQgcmFuZ2VcbiAqIEBwYXJhbSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIC0gVGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgYSBmcmFnbWVudCdzIHN0YXJ0IGNhbiBiZSB3aXRoaW4gaW4gb3JkZXIgdG8gYmUgY29uc2lkZXJlZCBjb250aWd1b3VzXG4gKiBAcmV0dXJucyB0cnVlIGlmIGNvbnRpZ3VvdXMsIGZhbHNlIG90aGVyd2lzZVxuICovXG5mdW5jdGlvbiBwZHRXaXRoaW5Ub2xlcmFuY2VUZXN0KHBkdEJ1ZmZlckVuZCwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgY2FuZGlkYXRlKSB7XG4gIGNvbnN0IGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA9IE1hdGgubWluKG1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGNhbmRpZGF0ZS5kdXJhdGlvbiArIChjYW5kaWRhdGUuZGVsdGFQVFMgPyBjYW5kaWRhdGUuZGVsdGFQVFMgOiAwKSkgKiAxMDAwO1xuXG4gIC8vIGVuZFByb2dyYW1EYXRlVGltZSBjYW4gYmUgbnVsbCwgZGVmYXVsdCB0byB6ZXJvXG4gIGNvbnN0IGVuZFByb2dyYW1EYXRlVGltZSA9IGNhbmRpZGF0ZS5lbmRQcm9ncmFtRGF0ZVRpbWUgfHwgMDtcbiAgcmV0dXJuIGVuZFByb2dyYW1EYXRlVGltZSAtIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA+IHBkdEJ1ZmZlckVuZDtcbn1cbmZ1bmN0aW9uIGZpbmRGcmFnV2l0aENDKGZyYWdtZW50cywgY2MpIHtcbiAgcmV0dXJuIEJpbmFyeVNlYXJjaC5zZWFyY2goZnJhZ21lbnRzLCBjYW5kaWRhdGUgPT4ge1xuICAgIGlmIChjYW5kaWRhdGUuY2MgPCBjYykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChjYW5kaWRhdGUuY2MgPiBjYykge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgTmV0d29ya0Vycm9yQWN0aW9uID0ge1xuICBEb05vdGhpbmc6IDAsXG4gIFNlbmRFbmRDYWxsYmFjazogMSxcbiAgU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveDogMixcbiAgUmVtb3ZlQWx0ZXJuYXRlUGVybWFuZW50bHk6IDMsXG4gIEluc2VydERpc2NvbnRpbnVpdHk6IDQsXG4gIFJldHJ5UmVxdWVzdDogNVxufTtcbnZhciBFcnJvckFjdGlvbkZsYWdzID0ge1xuICBOb25lOiAwLFxuICBNb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSG9zdDogMSxcbiAgTW92ZUFsbEFsdGVybmF0ZXNNYXRjaGluZ0hEQ1A6IDIsXG4gIFN3aXRjaFRvU0RSOiA0XG59OyAvLyBSZXNlcnZlZCBmb3IgZnV0dXJlIHVzZVxuY2xhc3MgRXJyb3JDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5wbGF5bGlzdEVycm9yID0gMDtcbiAgICB0aGlzLnBlbmFsaXplZFJlbmRpdGlvbnMgPSB7fTtcbiAgICB0aGlzLmxvZyA9IHZvaWQgMDtcbiAgICB0aGlzLndhcm4gPSB2b2lkIDA7XG4gICAgdGhpcy5lcnJvciA9IHZvaWQgMDtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmxvZyA9IGxvZ2dlci5sb2cuYmluZChsb2dnZXIsIGBbaW5mb106YCk7XG4gICAgdGhpcy53YXJuID0gbG9nZ2VyLndhcm4uYmluZChsb2dnZXIsIGBbd2FybmluZ106YCk7XG4gICAgdGhpcy5lcnJvciA9IGxvZ2dlci5lcnJvci5iaW5kKGxvZ2dlciwgYFtlcnJvcl06YCk7XG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vbihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX1VQREFURUQsIHRoaXMub25MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICB9XG4gIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgaWYgKCFobHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaGxzLm9mZihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvck91dCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxfVVBEQVRFRCwgdGhpcy5vbkxldmVsVXBkYXRlZCwgdGhpcyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSBudWxsO1xuICAgIHRoaXMucGVuYWxpemVkUmVuZGl0aW9ucyA9IHt9O1xuICB9XG4gIHN0YXJ0TG9hZChzdGFydFBvc2l0aW9uKSB7fVxuICBzdG9wTG9hZCgpIHtcbiAgICB0aGlzLnBsYXlsaXN0RXJyb3IgPSAwO1xuICB9XG4gIGdldFZhcmlhbnRMZXZlbEluZGV4KGZyYWcpIHtcbiAgICByZXR1cm4gKGZyYWcgPT0gbnVsbCA/IHZvaWQgMCA6IGZyYWcudHlwZSkgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4gPyBmcmFnLmxldmVsIDogdGhpcy5obHMubG9hZExldmVsO1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMucGxheWxpc3RFcnJvciA9IDA7XG4gICAgdGhpcy5wZW5hbGl6ZWRSZW5kaXRpb25zID0ge307XG4gIH1cbiAgb25MZXZlbFVwZGF0ZWQoKSB7XG4gICAgdGhpcy5wbGF5bGlzdEVycm9yID0gMDtcbiAgfVxuICBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF9kYXRhJGZyYWcsIF9kYXRhJGxldmVsO1xuICAgIGlmIChkYXRhLmZhdGFsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGNvbnN0IGNvbnRleHQgPSBkYXRhLmNvbnRleHQ7XG4gICAgc3dpdGNoIChkYXRhLmRldGFpbHMpIHtcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfTE9BRF9USU1FT1VUOlxuICAgICAgICBkYXRhLmVycm9yQWN0aW9uID0gdGhpcy5nZXRGcmFnUmV0cnlPclN3aXRjaEFjdGlvbihkYXRhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SOlxuICAgICAgICAvLyBpZ25vcmUgZW1wdHkgc2VnbWVudCBlcnJvcnMgbWFya2VkIGFzIGdhcFxuICAgICAgICBpZiAoKF9kYXRhJGZyYWcgPSBkYXRhLmZyYWcpICE9IG51bGwgJiYgX2RhdGEkZnJhZy5nYXApIHtcbiAgICAgICAgICBkYXRhLmVycm9yQWN0aW9uID0ge1xuICAgICAgICAgICAgYWN0aW9uOiBOZXR3b3JrRXJyb3JBY3Rpb24uRG9Ob3RoaW5nLFxuICAgICAgICAgICAgZmxhZ3M6IEVycm9yQWN0aW9uRmxhZ3MuTm9uZVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0dBUDpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfREVDUllQVF9FUlJPUjpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFN3aXRjaCBsZXZlbCBpZiBwb3NzaWJsZSwgb3RoZXJ3aXNlIGFsbG93IHJldHJ5IGNvdW50IHRvIHJlYWNoIG1heCBlcnJvciByZXRyaWVzXG4gICAgICAgICAgZGF0YS5lcnJvckFjdGlvbiA9IHRoaXMuZ2V0RnJhZ1JldHJ5T3JTd2l0Y2hBY3Rpb24oZGF0YSk7XG4gICAgICAgICAgZGF0YS5lcnJvckFjdGlvbi5hY3Rpb24gPSBOZXR3b3JrRXJyb3JBY3Rpb24uU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0VNUFRZX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuTEVWRUxfUEFSU0lOR19FUlJPUjpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfZGF0YSRjb250ZXh0LCBfZGF0YSRjb250ZXh0JGxldmVsRGU7XG4gICAgICAgICAgLy8gT25seSByZXRyeSB3aGVuIGVtcHR5IGFuZCBsaXZlXG4gICAgICAgICAgY29uc3QgbGV2ZWxJbmRleCA9IGRhdGEucGFyZW50ID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOID8gZGF0YS5sZXZlbCA6IGhscy5sb2FkTGV2ZWw7XG4gICAgICAgICAgaWYgKGRhdGEuZGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkxFVkVMX0VNUFRZX0VSUk9SICYmICEhKChfZGF0YSRjb250ZXh0ID0gZGF0YS5jb250ZXh0KSAhPSBudWxsICYmIChfZGF0YSRjb250ZXh0JGxldmVsRGUgPSBfZGF0YSRjb250ZXh0LmxldmVsRGV0YWlscykgIT0gbnVsbCAmJiBfZGF0YSRjb250ZXh0JGxldmVsRGUubGl2ZSkpIHtcbiAgICAgICAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSB0aGlzLmdldFBsYXlsaXN0UmV0cnlPclN3aXRjaEFjdGlvbihkYXRhLCBsZXZlbEluZGV4KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRXNjYWxhdGUgdG8gZmF0YWwgaWYgbm90IHJldHJ5aW5nIG9yIHN3aXRjaGluZ1xuICAgICAgICAgICAgZGF0YS5sZXZlbFJldHJ5ID0gZmFsc2U7XG4gICAgICAgICAgICBkYXRhLmVycm9yQWN0aW9uID0gdGhpcy5nZXRMZXZlbFN3aXRjaEFjdGlvbihkYXRhLCBsZXZlbEluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfVElNRU9VVDpcbiAgICAgICAgaWYgKHR5cGVvZiAoY29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogY29udGV4dC5sZXZlbCkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgZGF0YS5lcnJvckFjdGlvbiA9IHRoaXMuZ2V0UGxheWxpc3RSZXRyeU9yU3dpdGNoQWN0aW9uKGRhdGEsIGNvbnRleHQubGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX1RJTUVPVVQ6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5TVUJUSVRMRV9MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuU1VCVElUTEVfVFJBQ0tfTE9BRF9USU1FT1VUOlxuICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgIGNvbnN0IGxldmVsID0gaGxzLmxldmVsc1tobHMubG9hZExldmVsXTtcbiAgICAgICAgICBpZiAobGV2ZWwgJiYgKGNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSyAmJiBsZXZlbC5oYXNBdWRpb0dyb3VwKGNvbnRleHQuZ3JvdXBJZCkgfHwgY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLICYmIGxldmVsLmhhc1N1YnRpdGxlR3JvdXAoY29udGV4dC5ncm91cElkKSkpIHtcbiAgICAgICAgICAgIC8vIFBlcmZvcm0gUGF0aHdheSBzd2l0Y2ggb3IgUmVkdW5kYW50IGZhaWxvdmVyIGlmIHBvc3NpYmxlIGZvciBmYXN0ZXN0IHJlY292ZXJ5XG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgYWxsb3cgcGxheWxpc3QgcmV0cnkgY291bnQgdG8gcmVhY2ggbWF4IGVycm9yIHJldHJpZXNcbiAgICAgICAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSB0aGlzLmdldFBsYXlsaXN0UmV0cnlPclN3aXRjaEFjdGlvbihkYXRhLCBobHMubG9hZExldmVsKTtcbiAgICAgICAgICAgIGRhdGEuZXJyb3JBY3Rpb24uYWN0aW9uID0gTmV0d29ya0Vycm9yQWN0aW9uLlNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3g7XG4gICAgICAgICAgICBkYXRhLmVycm9yQWN0aW9uLmZsYWdzID0gRXJyb3JBY3Rpb25GbGFncy5Nb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSG9zdDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9TVEFUVVNfT1VUUFVUX1JFU1RSSUNURUQ6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBsZXZlbCA9IGhscy5sZXZlbHNbaGxzLmxvYWRMZXZlbF07XG4gICAgICAgICAgY29uc3QgcmVzdHJpY3RlZEhkY3BMZXZlbCA9IGxldmVsID09IG51bGwgPyB2b2lkIDAgOiBsZXZlbC5hdHRyc1snSERDUC1MRVZFTCddO1xuICAgICAgICAgIGlmIChyZXN0cmljdGVkSGRjcExldmVsKSB7XG4gICAgICAgICAgICBkYXRhLmVycm9yQWN0aW9uID0ge1xuICAgICAgICAgICAgICBhY3Rpb246IE5ldHdvcmtFcnJvckFjdGlvbi5TZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94LFxuICAgICAgICAgICAgICBmbGFnczogRXJyb3JBY3Rpb25GbGFncy5Nb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSERDUCxcbiAgICAgICAgICAgICAgaGRjcExldmVsOiByZXN0cmljdGVkSGRjcExldmVsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmtleVN5c3RlbUVycm9yKGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfQUREX0NPREVDX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuUkVNVVhfQUxMT0NfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5EX0VSUk9SOlxuICAgICAgICBkYXRhLmVycm9yQWN0aW9uID0gdGhpcy5nZXRMZXZlbFN3aXRjaEFjdGlvbihkYXRhLCAoX2RhdGEkbGV2ZWwgPSBkYXRhLmxldmVsKSAhPSBudWxsID8gX2RhdGEkbGV2ZWwgOiBobHMubG9hZExldmVsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuSU5URVJOQUxfRVhDRVBUSU9OOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORElOR19FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9GVUxMX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuTEVWRUxfU1dJVENIX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX1NUQUxMRURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfU0VFS19PVkVSX0hPTEU6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfTlVER0VfT05fU1RBTEw6XG4gICAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSB7XG4gICAgICAgICAgYWN0aW9uOiBOZXR3b3JrRXJyb3JBY3Rpb24uRG9Ob3RoaW5nLFxuICAgICAgICAgIGZsYWdzOiBFcnJvckFjdGlvbkZsYWdzLk5vbmVcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGF0YS50eXBlID09PSBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IpIHtcbiAgICAgIHRoaXMua2V5U3lzdGVtRXJyb3IoZGF0YSk7XG4gICAgfVxuICB9XG4gIGtleVN5c3RlbUVycm9yKGRhdGEpIHtcbiAgICBjb25zdCBsZXZlbEluZGV4ID0gdGhpcy5nZXRWYXJpYW50TGV2ZWxJbmRleChkYXRhLmZyYWcpO1xuICAgIC8vIERvIG5vdCByZXRyeSBsZXZlbC4gRXNjYWxhdGUgdG8gZmF0YWwgaWYgc3dpdGNoaW5nIGxldmVscyBmYWlscy5cbiAgICBkYXRhLmxldmVsUmV0cnkgPSBmYWxzZTtcbiAgICBkYXRhLmVycm9yQWN0aW9uID0gdGhpcy5nZXRMZXZlbFN3aXRjaEFjdGlvbihkYXRhLCBsZXZlbEluZGV4KTtcbiAgfVxuICBnZXRQbGF5bGlzdFJldHJ5T3JTd2l0Y2hBY3Rpb24oZGF0YSwgbGV2ZWxJbmRleCkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGNvbnN0IHJldHJ5Q29uZmlnID0gZ2V0UmV0cnlDb25maWcoaGxzLmNvbmZpZy5wbGF5bGlzdExvYWRQb2xpY3ksIGRhdGEpO1xuICAgIGNvbnN0IHJldHJ5Q291bnQgPSB0aGlzLnBsYXlsaXN0RXJyb3IrKztcbiAgICBjb25zdCByZXRyeSA9IHNob3VsZFJldHJ5KHJldHJ5Q29uZmlnLCByZXRyeUNvdW50LCBpc1RpbWVvdXRFcnJvcihkYXRhKSwgZGF0YS5yZXNwb25zZSk7XG4gICAgaWYgKHJldHJ5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhY3Rpb246IE5ldHdvcmtFcnJvckFjdGlvbi5SZXRyeVJlcXVlc3QsXG4gICAgICAgIGZsYWdzOiBFcnJvckFjdGlvbkZsYWdzLk5vbmUsXG4gICAgICAgIHJldHJ5Q29uZmlnLFxuICAgICAgICByZXRyeUNvdW50XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBlcnJvckFjdGlvbiA9IHRoaXMuZ2V0TGV2ZWxTd2l0Y2hBY3Rpb24oZGF0YSwgbGV2ZWxJbmRleCk7XG4gICAgaWYgKHJldHJ5Q29uZmlnKSB7XG4gICAgICBlcnJvckFjdGlvbi5yZXRyeUNvbmZpZyA9IHJldHJ5Q29uZmlnO1xuICAgICAgZXJyb3JBY3Rpb24ucmV0cnlDb3VudCA9IHJldHJ5Q291bnQ7XG4gICAgfVxuICAgIHJldHVybiBlcnJvckFjdGlvbjtcbiAgfVxuICBnZXRGcmFnUmV0cnlPclN3aXRjaEFjdGlvbihkYXRhKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgLy8gU2hhcmUgZnJhZ21lbnQgZXJyb3IgY291bnQgYWNjcm9zcyBtZWRpYSBvcHRpb25zIChtYWluLCBhdWRpbywgc3VicylcbiAgICAvLyBUaGlzIGFsbG93cyBmb3IgbGV2ZWwgYmFzZWQgcmVuZGl0aW9uIHN3aXRjaGluZyB3aGVuIG1lZGlhIG9wdGlvbiBhc3NldHMgZmFpbFxuICAgIGNvbnN0IHZhcmlhbnRMZXZlbEluZGV4ID0gdGhpcy5nZXRWYXJpYW50TGV2ZWxJbmRleChkYXRhLmZyYWcpO1xuICAgIGNvbnN0IGxldmVsID0gaGxzLmxldmVsc1t2YXJpYW50TGV2ZWxJbmRleF07XG4gICAgY29uc3Qge1xuICAgICAgZnJhZ0xvYWRQb2xpY3ksXG4gICAgICBrZXlMb2FkUG9saWN5XG4gICAgfSA9IGhscy5jb25maWc7XG4gICAgY29uc3QgcmV0cnlDb25maWcgPSBnZXRSZXRyeUNvbmZpZyhkYXRhLmRldGFpbHMuc3RhcnRzV2l0aCgna2V5JykgPyBrZXlMb2FkUG9saWN5IDogZnJhZ0xvYWRQb2xpY3ksIGRhdGEpO1xuICAgIGNvbnN0IGZyYWdtZW50RXJyb3JzID0gaGxzLmxldmVscy5yZWR1Y2UoKGFjYywgbGV2ZWwpID0+IGFjYyArIGxldmVsLmZyYWdtZW50RXJyb3IsIDApO1xuICAgIC8vIFN3aXRjaCBsZXZlbHMgd2hlbiBvdXQgb2YgcmV0cmllZCBvciBsZXZlbCBpbmRleCBvdXQgb2YgYm91bmRzXG4gICAgaWYgKGxldmVsKSB7XG4gICAgICBpZiAoZGF0YS5kZXRhaWxzICE9PSBFcnJvckRldGFpbHMuRlJBR19HQVApIHtcbiAgICAgICAgbGV2ZWwuZnJhZ21lbnRFcnJvcisrO1xuICAgICAgfVxuICAgICAgY29uc3QgcmV0cnkgPSBzaG91bGRSZXRyeShyZXRyeUNvbmZpZywgZnJhZ21lbnRFcnJvcnMsIGlzVGltZW91dEVycm9yKGRhdGEpLCBkYXRhLnJlc3BvbnNlKTtcbiAgICAgIGlmIChyZXRyeSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFjdGlvbjogTmV0d29ya0Vycm9yQWN0aW9uLlJldHJ5UmVxdWVzdCxcbiAgICAgICAgICBmbGFnczogRXJyb3JBY3Rpb25GbGFncy5Ob25lLFxuICAgICAgICAgIHJldHJ5Q29uZmlnLFxuICAgICAgICAgIHJldHJ5Q291bnQ6IGZyYWdtZW50RXJyb3JzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJlYWNoIG1heCByZXRyeSBjb3VudCwgb3IgTWlzc2luZyBsZXZlbCByZWZlcmVuY2VcbiAgICAvLyBTd2l0Y2ggdG8gdmFsaWQgaW5kZXhcbiAgICBjb25zdCBlcnJvckFjdGlvbiA9IHRoaXMuZ2V0TGV2ZWxTd2l0Y2hBY3Rpb24oZGF0YSwgdmFyaWFudExldmVsSW5kZXgpO1xuICAgIC8vIEFkZCByZXRyeSBkZXRhaWxzIHRvIGFsbG93IHNraXBwaW5nIG9mIEZSQUdfUEFSU0lOR19FUlJPUlxuICAgIGlmIChyZXRyeUNvbmZpZykge1xuICAgICAgZXJyb3JBY3Rpb24ucmV0cnlDb25maWcgPSByZXRyeUNvbmZpZztcbiAgICAgIGVycm9yQWN0aW9uLnJldHJ5Q291bnQgPSBmcmFnbWVudEVycm9ycztcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yQWN0aW9uO1xuICB9XG4gIGdldExldmVsU3dpdGNoQWN0aW9uKGRhdGEsIGxldmVsSW5kZXgpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBpZiAobGV2ZWxJbmRleCA9PT0gbnVsbCB8fCBsZXZlbEluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldmVsSW5kZXggPSBobHMubG9hZExldmVsO1xuICAgIH1cbiAgICBjb25zdCBsZXZlbCA9IHRoaXMuaGxzLmxldmVsc1tsZXZlbEluZGV4XTtcbiAgICBpZiAobGV2ZWwpIHtcbiAgICAgIHZhciBfZGF0YSRmcmFnMiwgX2RhdGEkY29udGV4dDI7XG4gICAgICBjb25zdCBlcnJvckRldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgICBsZXZlbC5sb2FkRXJyb3IrKztcbiAgICAgIGlmIChlcnJvckRldGFpbHMgPT09IEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5EX0VSUk9SKSB7XG4gICAgICAgIGxldmVsLmZyYWdtZW50RXJyb3IrKztcbiAgICAgIH1cbiAgICAgIC8vIFNlYXJjaCBmb3IgbmV4dCBsZXZlbCB0byByZXRyeVxuICAgICAgbGV0IG5leHRMZXZlbCA9IC0xO1xuICAgICAgY29uc3Qge1xuICAgICAgICBsZXZlbHMsXG4gICAgICAgIGxvYWRMZXZlbCxcbiAgICAgICAgbWluQXV0b0xldmVsLFxuICAgICAgICBtYXhBdXRvTGV2ZWxcbiAgICAgIH0gPSBobHM7XG4gICAgICBpZiAoIWhscy5hdXRvTGV2ZWxFbmFibGVkKSB7XG4gICAgICAgIGhscy5sb2FkTGV2ZWwgPSAtMTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZyYWdFcnJvclR5cGUgPSAoX2RhdGEkZnJhZzIgPSBkYXRhLmZyYWcpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YSRmcmFnMi50eXBlO1xuICAgICAgLy8gRmluZCBhbHRlcm5hdGUgYXVkaW8gY29kZWMgaWYgYXZhaWxhYmxlIG9uIGF1ZGlvIGNvZGVjIGVycm9yXG4gICAgICBjb25zdCBpc0F1ZGlvQ29kZWNFcnJvciA9IGZyYWdFcnJvclR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLkFVRElPICYmIGVycm9yRGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUiB8fCBkYXRhLnNvdXJjZUJ1ZmZlck5hbWUgPT09ICdhdWRpbycgJiYgKGVycm9yRGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkJVRkZFUl9BRERfQ09ERUNfRVJST1IgfHwgZXJyb3JEZXRhaWxzID09PSBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORF9FUlJPUik7XG4gICAgICBjb25zdCBmaW5kQXVkaW9Db2RlY0FsdGVybmF0ZSA9IGlzQXVkaW9Db2RlY0Vycm9yICYmIGxldmVscy5zb21lKCh7XG4gICAgICAgIGF1ZGlvQ29kZWNcbiAgICAgIH0pID0+IGxldmVsLmF1ZGlvQ29kZWMgIT09IGF1ZGlvQ29kZWMpO1xuICAgICAgLy8gRmluZCBhbHRlcm5hdGUgdmlkZW8gY29kZWMgaWYgYXZhaWxhYmxlIG9uIHZpZGVvIGNvZGVjIGVycm9yXG4gICAgICBjb25zdCBpc1ZpZGVvQ29kZWNFcnJvciA9IGRhdGEuc291cmNlQnVmZmVyTmFtZSA9PT0gJ3ZpZGVvJyAmJiAoZXJyb3JEZXRhaWxzID09PSBFcnJvckRldGFpbHMuQlVGRkVSX0FERF9DT0RFQ19FUlJPUiB8fCBlcnJvckRldGFpbHMgPT09IEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5EX0VSUk9SKTtcbiAgICAgIGNvbnN0IGZpbmRWaWRlb0NvZGVjQWx0ZXJuYXRlID0gaXNWaWRlb0NvZGVjRXJyb3IgJiYgbGV2ZWxzLnNvbWUoKHtcbiAgICAgICAgY29kZWNTZXQsXG4gICAgICAgIGF1ZGlvQ29kZWNcbiAgICAgIH0pID0+IGxldmVsLmNvZGVjU2V0ICE9PSBjb2RlY1NldCAmJiBsZXZlbC5hdWRpb0NvZGVjID09PSBhdWRpb0NvZGVjKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdHlwZTogcGxheWxpc3RFcnJvclR5cGUsXG4gICAgICAgIGdyb3VwSWQ6IHBsYXlsaXN0RXJyb3JHcm91cElkXG4gICAgICB9ID0gKF9kYXRhJGNvbnRleHQyID0gZGF0YS5jb250ZXh0KSAhPSBudWxsID8gX2RhdGEkY29udGV4dDIgOiB7fTtcbiAgICAgIGZvciAobGV0IGkgPSBsZXZlbHMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IChpICsgbG9hZExldmVsKSAlIGxldmVscy5sZW5ndGg7XG4gICAgICAgIGlmIChjYW5kaWRhdGUgIT09IGxvYWRMZXZlbCAmJiBjYW5kaWRhdGUgPj0gbWluQXV0b0xldmVsICYmIGNhbmRpZGF0ZSA8PSBtYXhBdXRvTGV2ZWwgJiYgbGV2ZWxzW2NhbmRpZGF0ZV0ubG9hZEVycm9yID09PSAwKSB7XG4gICAgICAgICAgdmFyIF9sZXZlbCRhdWRpb0dyb3VwcywgX2xldmVsJHN1YnRpdGxlR3JvdXBzO1xuICAgICAgICAgIGNvbnN0IGxldmVsQ2FuZGlkYXRlID0gbGV2ZWxzW2NhbmRpZGF0ZV07XG4gICAgICAgICAgLy8gU2tpcCBsZXZlbCBzd2l0Y2ggaWYgR0FQIHRhZyBpcyBmb3VuZCBpbiBuZXh0IGxldmVsIGF0IHNhbWUgcG9zaXRpb25cbiAgICAgICAgICBpZiAoZXJyb3JEZXRhaWxzID09PSBFcnJvckRldGFpbHMuRlJBR19HQVAgJiYgZGF0YS5mcmFnKSB7XG4gICAgICAgICAgICBjb25zdCBsZXZlbERldGFpbHMgPSBsZXZlbHNbY2FuZGlkYXRlXS5kZXRhaWxzO1xuICAgICAgICAgICAgaWYgKGxldmVsRGV0YWlscykge1xuICAgICAgICAgICAgICBjb25zdCBmcmFnQ2FuZGlkYXRlID0gZmluZEZyYWdtZW50QnlQVFMoZGF0YS5mcmFnLCBsZXZlbERldGFpbHMuZnJhZ21lbnRzLCBkYXRhLmZyYWcuc3RhcnQpO1xuICAgICAgICAgICAgICBpZiAoZnJhZ0NhbmRpZGF0ZSAhPSBudWxsICYmIGZyYWdDYW5kaWRhdGUuZ2FwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHBsYXlsaXN0RXJyb3JUeXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLkFVRElPX1RSQUNLICYmIGxldmVsQ2FuZGlkYXRlLmhhc0F1ZGlvR3JvdXAocGxheWxpc3RFcnJvckdyb3VwSWQpIHx8IHBsYXlsaXN0RXJyb3JUeXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLICYmIGxldmVsQ2FuZGlkYXRlLmhhc1N1YnRpdGxlR3JvdXAocGxheWxpc3RFcnJvckdyb3VwSWQpKSB7XG4gICAgICAgICAgICAvLyBGb3IgYXVkaW8vc3VicyBwbGF5bGlzdCBlcnJvcnMgZmluZCBhbm90aGVyIGdyb3VwIElEIG9yIGZhbGx0aHJvdWdoIHRvIHJlZHVuZGFudCBmYWlsLW92ZXJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZnJhZ0Vycm9yVHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuQVVESU8gJiYgKF9sZXZlbCRhdWRpb0dyb3VwcyA9IGxldmVsLmF1ZGlvR3JvdXBzKSAhPSBudWxsICYmIF9sZXZlbCRhdWRpb0dyb3Vwcy5zb21lKGdyb3VwSWQgPT4gbGV2ZWxDYW5kaWRhdGUuaGFzQXVkaW9Hcm91cChncm91cElkKSkgfHwgZnJhZ0Vycm9yVHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuU1VCVElUTEUgJiYgKF9sZXZlbCRzdWJ0aXRsZUdyb3VwcyA9IGxldmVsLnN1YnRpdGxlR3JvdXBzKSAhPSBudWxsICYmIF9sZXZlbCRzdWJ0aXRsZUdyb3Vwcy5zb21lKGdyb3VwSWQgPT4gbGV2ZWxDYW5kaWRhdGUuaGFzU3VidGl0bGVHcm91cChncm91cElkKSkgfHwgZmluZEF1ZGlvQ29kZWNBbHRlcm5hdGUgJiYgbGV2ZWwuYXVkaW9Db2RlYyA9PT0gbGV2ZWxDYW5kaWRhdGUuYXVkaW9Db2RlYyB8fCAhZmluZEF1ZGlvQ29kZWNBbHRlcm5hdGUgJiYgbGV2ZWwuYXVkaW9Db2RlYyAhPT0gbGV2ZWxDYW5kaWRhdGUuYXVkaW9Db2RlYyB8fCBmaW5kVmlkZW9Db2RlY0FsdGVybmF0ZSAmJiBsZXZlbC5jb2RlY1NldCA9PT0gbGV2ZWxDYW5kaWRhdGUuY29kZWNTZXQpIHtcbiAgICAgICAgICAgIC8vIEZvciB2aWRlby9hdWRpby9zdWJzIGZyYWcgZXJyb3JzIGZpbmQgYW5vdGhlciBncm91cCBJRCBvciBmYWxsdGhyb3VnaCB0byByZWR1bmRhbnQgZmFpbC1vdmVyXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dExldmVsID0gY2FuZGlkYXRlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobmV4dExldmVsID4gLTEgJiYgaGxzLmxvYWRMZXZlbCAhPT0gbmV4dExldmVsKSB7XG4gICAgICAgIGRhdGEubGV2ZWxSZXRyeSA9IHRydWU7XG4gICAgICAgIHRoaXMucGxheWxpc3RFcnJvciA9IDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYWN0aW9uOiBOZXR3b3JrRXJyb3JBY3Rpb24uU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveCxcbiAgICAgICAgICBmbGFnczogRXJyb3JBY3Rpb25GbGFncy5Ob25lLFxuICAgICAgICAgIG5leHRBdXRvTGV2ZWw6IG5leHRMZXZlbFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBObyBsZXZlbHMgdG8gc3dpdGNoIC8gTWFudWFsIGxldmVsIHNlbGVjdGlvbiAvIExldmVsIG5vdCBmb3VuZFxuICAgIC8vIFJlc29sdmUgd2l0aCBQYXRod2F5IHN3aXRjaCwgUmVkdW5kYW50IGZhaWwtb3Zlciwgb3Igc3RheSBvbiBsb3dlc3QgTGV2ZWxcbiAgICByZXR1cm4ge1xuICAgICAgYWN0aW9uOiBOZXR3b3JrRXJyb3JBY3Rpb24uU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveCxcbiAgICAgIGZsYWdzOiBFcnJvckFjdGlvbkZsYWdzLk1vdmVBbGxBbHRlcm5hdGVzTWF0Y2hpbmdIb3N0XG4gICAgfTtcbiAgfVxuICBvbkVycm9yT3V0KGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF9kYXRhJGVycm9yQWN0aW9uO1xuICAgIHN3aXRjaCAoKF9kYXRhJGVycm9yQWN0aW9uID0gZGF0YS5lcnJvckFjdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhJGVycm9yQWN0aW9uLmFjdGlvbikge1xuICAgICAgY2FzZSBOZXR3b3JrRXJyb3JBY3Rpb24uRG9Ob3RoaW5nOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTmV0d29ya0Vycm9yQWN0aW9uLlNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3g6XG4gICAgICAgIHRoaXMuc2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveChkYXRhKTtcbiAgICAgICAgaWYgKCFkYXRhLmVycm9yQWN0aW9uLnJlc29sdmVkICYmIGRhdGEuZGV0YWlscyAhPT0gRXJyb3JEZXRhaWxzLkZSQUdfR0FQKSB7XG4gICAgICAgICAgZGF0YS5mYXRhbCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoL01lZGlhU291cmNlIHJlYWR5U3RhdGU6IGVuZGVkLy50ZXN0KGRhdGEuZXJyb3IubWVzc2FnZSkpIHtcbiAgICAgICAgICB0aGlzLndhcm4oYE1lZGlhU291cmNlIGVuZGVkIGFmdGVyIFwiJHtkYXRhLnNvdXJjZUJ1ZmZlck5hbWV9XCIgc291cmNlQnVmZmVyIGFwcGVuZCBlcnJvci4gQXR0ZW1wdGluZyB0byByZWNvdmVyIGZyb20gbWVkaWEgZXJyb3IuYCk7XG4gICAgICAgICAgdGhpcy5obHMucmVjb3Zlck1lZGlhRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTmV0d29ya0Vycm9yQWN0aW9uLlJldHJ5UmVxdWVzdDpcbiAgICAgICAgLy8gaGFuZGxlZCBieSBzdHJlYW0gYW5kIHBsYXlsaXN0L2xldmVsIGNvbnRyb2xsZXJzXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoZGF0YS5mYXRhbCkge1xuICAgICAgdGhpcy5obHMuc3RvcExvYWQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgc2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveChkYXRhKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgY29uc3QgZXJyb3JBY3Rpb24gPSBkYXRhLmVycm9yQWN0aW9uO1xuICAgIGlmICghZXJyb3JBY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZmxhZ3MsXG4gICAgICBoZGNwTGV2ZWwsXG4gICAgICBuZXh0QXV0b0xldmVsXG4gICAgfSA9IGVycm9yQWN0aW9uO1xuICAgIHN3aXRjaCAoZmxhZ3MpIHtcbiAgICAgIGNhc2UgRXJyb3JBY3Rpb25GbGFncy5Ob25lOlxuICAgICAgICB0aGlzLnN3aXRjaExldmVsKGRhdGEsIG5leHRBdXRvTGV2ZWwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXJyb3JBY3Rpb25GbGFncy5Nb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSERDUDpcbiAgICAgICAgaWYgKGhkY3BMZXZlbCkge1xuICAgICAgICAgIGhscy5tYXhIZGNwTGV2ZWwgPSBIZGNwTGV2ZWxzW0hkY3BMZXZlbHMuaW5kZXhPZihoZGNwTGV2ZWwpIC0gMV07XG4gICAgICAgICAgZXJyb3JBY3Rpb24ucmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2FybihgUmVzdHJpY3RpbmcgcGxheWJhY2sgdG8gSERDUC1MRVZFTCBvZiBcIiR7aGxzLm1heEhkY3BMZXZlbH1cIiBvciBsb3dlcmApO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gSWYgbm90IHJlc29sdmVkIGJ5IHByZXZpb3VzIGFjdGlvbnMgdHJ5IHRvIHN3aXRjaCB0byBuZXh0IGxldmVsXG4gICAgaWYgKCFlcnJvckFjdGlvbi5yZXNvbHZlZCkge1xuICAgICAgdGhpcy5zd2l0Y2hMZXZlbChkYXRhLCBuZXh0QXV0b0xldmVsKTtcbiAgICB9XG4gIH1cbiAgc3dpdGNoTGV2ZWwoZGF0YSwgbGV2ZWxJbmRleCkge1xuICAgIGlmIChsZXZlbEluZGV4ICE9PSB1bmRlZmluZWQgJiYgZGF0YS5lcnJvckFjdGlvbikge1xuICAgICAgdGhpcy53YXJuKGBzd2l0Y2hpbmcgdG8gbGV2ZWwgJHtsZXZlbEluZGV4fSBhZnRlciAke2RhdGEuZGV0YWlsc31gKTtcbiAgICAgIHRoaXMuaGxzLm5leHRBdXRvTGV2ZWwgPSBsZXZlbEluZGV4O1xuICAgICAgZGF0YS5lcnJvckFjdGlvbi5yZXNvbHZlZCA9IHRydWU7XG4gICAgICAvLyBTdHJlYW0gY29udHJvbGxlciBpcyByZXNwb25zaWJsZSBmb3IgdGhpcyBidXQgd29uJ3Qgc3dpdGNoIG9uIGZhbHNlIHN0YXJ0XG4gICAgICB0aGlzLmhscy5uZXh0TG9hZExldmVsID0gdGhpcy5obHMubmV4dEF1dG9MZXZlbDtcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgQmFzZVBsYXlsaXN0Q29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGhscywgbG9nUHJlZml4KSB7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy50aW1lciA9IC0xO1xuICAgIHRoaXMucmVxdWVzdFNjaGVkdWxlZCA9IC0xO1xuICAgIHRoaXMuY2FuTG9hZCA9IGZhbHNlO1xuICAgIHRoaXMubG9nID0gdm9pZCAwO1xuICAgIHRoaXMud2FybiA9IHZvaWQgMDtcbiAgICB0aGlzLmxvZyA9IGxvZ2dlci5sb2cuYmluZChsb2dnZXIsIGAke2xvZ1ByZWZpeH06YCk7XG4gICAgdGhpcy53YXJuID0gbG9nZ2VyLndhcm4uYmluZChsb2dnZXIsIGAke2xvZ1ByZWZpeH06YCk7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSB0aGlzLmxvZyA9IHRoaXMud2FybiA9IG51bGw7XG4gIH1cbiAgY2xlYXJUaW1lcigpIHtcbiAgICBpZiAodGhpcy50aW1lciAhPT0gLTEpIHtcbiAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgICAgdGhpcy50aW1lciA9IC0xO1xuICAgIH1cbiAgfVxuICBzdGFydExvYWQoKSB7XG4gICAgdGhpcy5jYW5Mb2FkID0gdHJ1ZTtcbiAgICB0aGlzLnJlcXVlc3RTY2hlZHVsZWQgPSAtMTtcbiAgICB0aGlzLmxvYWRQbGF5bGlzdCgpO1xuICB9XG4gIHN0b3BMb2FkKCkge1xuICAgIHRoaXMuY2FuTG9hZCA9IGZhbHNlO1xuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICB9XG4gIHN3aXRjaFBhcmFtcyhwbGF5bGlzdFVyaSwgcHJldmlvdXMpIHtcbiAgICBjb25zdCByZW5kaXRpb25SZXBvcnRzID0gcHJldmlvdXMgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZpb3VzLnJlbmRpdGlvblJlcG9ydHM7XG4gICAgaWYgKHJlbmRpdGlvblJlcG9ydHMpIHtcbiAgICAgIGxldCBmb3VuZEluZGV4ID0gLTE7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbmRpdGlvblJlcG9ydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYXR0ciA9IHJlbmRpdGlvblJlcG9ydHNbaV07XG4gICAgICAgIGxldCB1cmk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdXJpID0gbmV3IHNlbGYuVVJMKGF0dHIuVVJJLCBwcmV2aW91cy51cmwpLmhyZWY7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYENvdWxkIG5vdCBjb25zdHJ1Y3QgbmV3IFVSTCBmb3IgUmVuZGl0aW9uIFJlcG9ydDogJHtlcnJvcn1gKTtcbiAgICAgICAgICB1cmkgPSBhdHRyLlVSSSB8fCAnJztcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2UgZXhhY3QgbWF0Y2guIE90aGVyd2lzZSwgdGhlIGxhc3QgcGFydGlhbCBtYXRjaCwgaWYgYW55LCB3aWxsIGJlIHVzZWRcbiAgICAgICAgLy8gKFBsYXlsaXN0IFVSSSBpbmNsdWRlcyBhIHF1ZXJ5IHN0cmluZyB0aGF0IHRoZSBSZW5kaXRpb24gUmVwb3J0IGRvZXMgbm90KVxuICAgICAgICBpZiAodXJpID09PSBwbGF5bGlzdFVyaSkge1xuICAgICAgICAgIGZvdW5kSW5kZXggPSBpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKHVyaSA9PT0gcGxheWxpc3RVcmkuc3Vic3RyaW5nKDAsIHVyaS5sZW5ndGgpKSB7XG4gICAgICAgICAgZm91bmRJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkge1xuICAgICAgICBjb25zdCBhdHRyID0gcmVuZGl0aW9uUmVwb3J0c1tmb3VuZEluZGV4XTtcbiAgICAgICAgY29uc3QgbXNuID0gcGFyc2VJbnQoYXR0clsnTEFTVC1NU04nXSkgfHwgKHByZXZpb3VzID09IG51bGwgPyB2b2lkIDAgOiBwcmV2aW91cy5sYXN0UGFydFNuKTtcbiAgICAgICAgbGV0IHBhcnQgPSBwYXJzZUludChhdHRyWydMQVNULVBBUlQnXSkgfHwgKHByZXZpb3VzID09IG51bGwgPyB2b2lkIDAgOiBwcmV2aW91cy5sYXN0UGFydEluZGV4KTtcbiAgICAgICAgaWYgKHRoaXMuaGxzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZSkge1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRHb2FsID0gTWF0aC5taW4ocHJldmlvdXMuYWdlIC0gcHJldmlvdXMucGFydFRhcmdldCwgcHJldmlvdXMudGFyZ2V0ZHVyYXRpb24pO1xuICAgICAgICAgIGlmIChwYXJ0ID49IDAgJiYgY3VycmVudEdvYWwgPiBwcmV2aW91cy5wYXJ0VGFyZ2V0KSB7XG4gICAgICAgICAgICBwYXJ0ICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSGxzVXJsUGFyYW1ldGVycyhtc24sIHBhcnQgPj0gMCA/IHBhcnQgOiB1bmRlZmluZWQsIEhsc1NraXAuTm8pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBsb2FkUGxheWxpc3QoaGxzVXJsUGFyYW1ldGVycykge1xuICAgIGlmICh0aGlzLnJlcXVlc3RTY2hlZHVsZWQgPT09IC0xKSB7XG4gICAgICB0aGlzLnJlcXVlc3RTY2hlZHVsZWQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIH1cbiAgICAvLyBMb2FkaW5nIGlzIGhhbmRsZWQgYnkgdGhlIHN1YmNsYXNzZXNcbiAgfVxuICBzaG91bGRMb2FkUGxheWxpc3QocGxheWxpc3QpIHtcbiAgICByZXR1cm4gdGhpcy5jYW5Mb2FkICYmICEhcGxheWxpc3QgJiYgISFwbGF5bGlzdC51cmwgJiYgKCFwbGF5bGlzdC5kZXRhaWxzIHx8IHBsYXlsaXN0LmRldGFpbHMubGl2ZSk7XG4gIH1cbiAgc2hvdWxkUmVsb2FkUGxheWxpc3QocGxheWxpc3QpIHtcbiAgICByZXR1cm4gdGhpcy50aW1lciA9PT0gLTEgJiYgdGhpcy5yZXF1ZXN0U2NoZWR1bGVkID09PSAtMSAmJiB0aGlzLnNob3VsZExvYWRQbGF5bGlzdChwbGF5bGlzdCk7XG4gIH1cbiAgcGxheWxpc3RMb2FkZWQoaW5kZXgsIGRhdGEsIHByZXZpb3VzRGV0YWlscykge1xuICAgIGNvbnN0IHtcbiAgICAgIGRldGFpbHMsXG4gICAgICBzdGF0c1xuICAgIH0gPSBkYXRhO1xuXG4gICAgLy8gU2V0IGxhc3QgdXBkYXRlZCBkYXRlLXRpbWVcbiAgICBjb25zdCBub3cgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnN0IGVsYXBzZWQgPSBzdGF0cy5sb2FkaW5nLmZpcnN0ID8gTWF0aC5tYXgoMCwgbm93IC0gc3RhdHMubG9hZGluZy5maXJzdCkgOiAwO1xuICAgIGRldGFpbHMuYWR2YW5jZWREYXRlVGltZSA9IERhdGUubm93KCkgLSBlbGFwc2VkO1xuXG4gICAgLy8gaWYgY3VycmVudCBwbGF5bGlzdCBpcyBhIGxpdmUgcGxheWxpc3QsIGFybSBhIHRpbWVyIHRvIHJlbG9hZCBpdFxuICAgIGlmIChkZXRhaWxzLmxpdmUgfHwgcHJldmlvdXNEZXRhaWxzICE9IG51bGwgJiYgcHJldmlvdXNEZXRhaWxzLmxpdmUpIHtcbiAgICAgIGRldGFpbHMucmVsb2FkZWQocHJldmlvdXNEZXRhaWxzKTtcbiAgICAgIGlmIChwcmV2aW91c0RldGFpbHMpIHtcbiAgICAgICAgdGhpcy5sb2coYGxpdmUgcGxheWxpc3QgJHtpbmRleH0gJHtkZXRhaWxzLmFkdmFuY2VkID8gJ1JFRlJFU0hFRCAnICsgZGV0YWlscy5sYXN0UGFydFNuICsgJy0nICsgZGV0YWlscy5sYXN0UGFydEluZGV4IDogZGV0YWlscy51cGRhdGVkID8gJ1VQREFURUQnIDogJ01JU1NFRCd9YCk7XG4gICAgICB9XG4gICAgICAvLyBNZXJnZSBsaXZlIHBsYXlsaXN0cyB0byBhZGp1c3QgZnJhZ21lbnQgc3RhcnRzIGFuZCBmaWxsIGluIGRlbHRhIHBsYXlsaXN0IHNraXBwZWQgc2VnbWVudHNcbiAgICAgIGlmIChwcmV2aW91c0RldGFpbHMgJiYgZGV0YWlscy5mcmFnbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICBtZXJnZURldGFpbHMocHJldmlvdXNEZXRhaWxzLCBkZXRhaWxzKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5jYW5Mb2FkIHx8ICFkZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IGRlbGl2ZXJ5RGlyZWN0aXZlcztcbiAgICAgIGxldCBtc24gPSB1bmRlZmluZWQ7XG4gICAgICBsZXQgcGFydCA9IHVuZGVmaW5lZDtcbiAgICAgIGlmIChkZXRhaWxzLmNhbkJsb2NrUmVsb2FkICYmIGRldGFpbHMuZW5kU04gJiYgZGV0YWlscy5hZHZhbmNlZCkge1xuICAgICAgICAvLyBMb2FkIGxldmVsIHdpdGggTEwtSExTIGRlbGl2ZXJ5IGRpcmVjdGl2ZXNcbiAgICAgICAgY29uc3QgbG93TGF0ZW5jeU1vZGUgPSB0aGlzLmhscy5jb25maWcubG93TGF0ZW5jeU1vZGU7XG4gICAgICAgIGNvbnN0IGxhc3RQYXJ0U24gPSBkZXRhaWxzLmxhc3RQYXJ0U247XG4gICAgICAgIGNvbnN0IGVuZFNuID0gZGV0YWlscy5lbmRTTjtcbiAgICAgICAgY29uc3QgbGFzdFBhcnRJbmRleCA9IGRldGFpbHMubGFzdFBhcnRJbmRleDtcbiAgICAgICAgY29uc3QgaGFzUGFydHMgPSBsYXN0UGFydEluZGV4ICE9PSAtMTtcbiAgICAgICAgY29uc3QgbGFzdFBhcnQgPSBsYXN0UGFydFNuID09PSBlbmRTbjtcbiAgICAgICAgLy8gV2hlbiBsb3cgbGF0ZW5jeSBtb2RlIGlzIGRpc2FibGVkLCB3ZSdsbCBza2lwIHBhcnQgcmVxdWVzdHMgb25jZSB0aGUgbGFzdCBwYXJ0IGluZGV4IGlzIGZvdW5kXG4gICAgICAgIGNvbnN0IG5leHRTblN0YXJ0SW5kZXggPSBsb3dMYXRlbmN5TW9kZSA/IDAgOiBsYXN0UGFydEluZGV4O1xuICAgICAgICBpZiAoaGFzUGFydHMpIHtcbiAgICAgICAgICBtc24gPSBsYXN0UGFydCA/IGVuZFNuICsgMSA6IGxhc3RQYXJ0U247XG4gICAgICAgICAgcGFydCA9IGxhc3RQYXJ0ID8gbmV4dFNuU3RhcnRJbmRleCA6IGxhc3RQYXJ0SW5kZXggKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1zbiA9IGVuZFNuICsgMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBMb3ctTGF0ZW5jeSBDRE4gVHVuZS1pbjogXCJhZ2VcIiBoZWFkZXIgYW5kIHRpbWUgc2luY2UgbG9hZCBpbmRpY2F0ZXMgd2UncmUgYmVoaW5kIGJ5IG1vcmUgdGhhbiBvbmUgcGFydFxuICAgICAgICAvLyBVcGRhdGUgZGlyZWN0aXZlcyB0byBvYnRhaW4gdGhlIFBsYXlsaXN0IHRoYXQgaGFzIHRoZSBlc3RpbWF0ZWQgYWRkaXRpb25hbCBkdXJhdGlvbiBvZiBtZWRpYVxuICAgICAgICBjb25zdCBsYXN0QWR2YW5jZWQgPSBkZXRhaWxzLmFnZTtcbiAgICAgICAgY29uc3QgY2RuQWdlID0gbGFzdEFkdmFuY2VkICsgZGV0YWlscy5hZ2VIZWFkZXI7XG4gICAgICAgIGxldCBjdXJyZW50R29hbCA9IE1hdGgubWluKGNkbkFnZSAtIGRldGFpbHMucGFydFRhcmdldCwgZGV0YWlscy50YXJnZXRkdXJhdGlvbiAqIDEuNSk7XG4gICAgICAgIGlmIChjdXJyZW50R29hbCA+IDApIHtcbiAgICAgICAgICBpZiAocHJldmlvdXNEZXRhaWxzICYmIGN1cnJlbnRHb2FsID4gcHJldmlvdXNEZXRhaWxzLnR1bmVJbkdvYWwpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGF0dGVtcHRlZCB0byBnZXQgdGhlIG5leHQgb3IgbGF0ZXN0IHBsYXlsaXN0IHVwZGF0ZSwgYnV0IGN1cnJlbnRHb2FsIGluY3JlYXNlZCxcbiAgICAgICAgICAgIC8vIHRoZW4gd2UgZWl0aGVyIGNhbid0IGNhdGNodXAsIG9yIHRoZSBcImFnZVwiIGhlYWRlciBjYW5ub3QgYmUgdHJ1c3RlZC5cbiAgICAgICAgICAgIHRoaXMud2FybihgQ0ROIFR1bmUtaW4gZ29hbCBpbmNyZWFzZWQgZnJvbTogJHtwcmV2aW91c0RldGFpbHMudHVuZUluR29hbH0gdG86ICR7Y3VycmVudEdvYWx9IHdpdGggcGxheWxpc3QgYWdlOiAke2RldGFpbHMuYWdlfWApO1xuICAgICAgICAgICAgY3VycmVudEdvYWwgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzZWdtZW50cyA9IE1hdGguZmxvb3IoY3VycmVudEdvYWwgLyBkZXRhaWxzLnRhcmdldGR1cmF0aW9uKTtcbiAgICAgICAgICAgIG1zbiArPSBzZWdtZW50cztcbiAgICAgICAgICAgIGlmIChwYXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBNYXRoLnJvdW5kKGN1cnJlbnRHb2FsICUgZGV0YWlscy50YXJnZXRkdXJhdGlvbiAvIGRldGFpbHMucGFydFRhcmdldCk7XG4gICAgICAgICAgICAgIHBhcnQgKz0gcGFydHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxvZyhgQ0ROIFR1bmUtaW4gYWdlOiAke2RldGFpbHMuYWdlSGVhZGVyfXMgbGFzdCBhZHZhbmNlZCAke2xhc3RBZHZhbmNlZC50b0ZpeGVkKDIpfXMgZ29hbDogJHtjdXJyZW50R29hbH0gc2tpcCBzbiAke3NlZ21lbnRzfSB0byBwYXJ0ICR7cGFydH1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGV0YWlscy50dW5lSW5Hb2FsID0gY3VycmVudEdvYWw7XG4gICAgICAgIH1cbiAgICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzID0gdGhpcy5nZXREZWxpdmVyeURpcmVjdGl2ZXMoZGV0YWlscywgZGF0YS5kZWxpdmVyeURpcmVjdGl2ZXMsIG1zbiwgcGFydCk7XG4gICAgICAgIGlmIChsb3dMYXRlbmN5TW9kZSB8fCAhbGFzdFBhcnQpIHtcbiAgICAgICAgICB0aGlzLmxvYWRQbGF5bGlzdChkZWxpdmVyeURpcmVjdGl2ZXMpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkZXRhaWxzLmNhbkJsb2NrUmVsb2FkIHx8IGRldGFpbHMuY2FuU2tpcFVudGlsKSB7XG4gICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlcyA9IHRoaXMuZ2V0RGVsaXZlcnlEaXJlY3RpdmVzKGRldGFpbHMsIGRhdGEuZGVsaXZlcnlEaXJlY3RpdmVzLCBtc24sIHBhcnQpO1xuICAgICAgfVxuICAgICAgY29uc3QgYnVmZmVySW5mbyA9IHRoaXMuaGxzLm1haW5Gb3J3YXJkQnVmZmVySW5mbztcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gYnVmZmVySW5mbyA/IGJ1ZmZlckluZm8uZW5kIC0gYnVmZmVySW5mby5sZW4gOiAwO1xuICAgICAgY29uc3QgZGlzdGFuY2VUb0xpdmVFZGdlTXMgPSAoZGV0YWlscy5lZGdlIC0gcG9zaXRpb24pICogMTAwMDtcbiAgICAgIGNvbnN0IHJlbG9hZEludGVydmFsID0gY29tcHV0ZVJlbG9hZEludGVydmFsKGRldGFpbHMsIGRpc3RhbmNlVG9MaXZlRWRnZU1zKTtcbiAgICAgIGlmIChkZXRhaWxzLnVwZGF0ZWQgJiYgbm93ID4gdGhpcy5yZXF1ZXN0U2NoZWR1bGVkICsgcmVsb2FkSW50ZXJ2YWwpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0U2NoZWR1bGVkID0gc3RhdHMubG9hZGluZy5zdGFydDtcbiAgICAgIH1cbiAgICAgIGlmIChtc24gIT09IHVuZGVmaW5lZCAmJiBkZXRhaWxzLmNhbkJsb2NrUmVsb2FkKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdFNjaGVkdWxlZCA9IHN0YXRzLmxvYWRpbmcuZmlyc3QgKyByZWxvYWRJbnRlcnZhbCAtIChkZXRhaWxzLnBhcnRUYXJnZXQgKiAxMDAwIHx8IDEwMDApO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnJlcXVlc3RTY2hlZHVsZWQgPT09IC0xIHx8IHRoaXMucmVxdWVzdFNjaGVkdWxlZCArIHJlbG9hZEludGVydmFsIDwgbm93KSB7XG4gICAgICAgIHRoaXMucmVxdWVzdFNjaGVkdWxlZCA9IG5vdztcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5yZXF1ZXN0U2NoZWR1bGVkIC0gbm93IDw9IDApIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0U2NoZWR1bGVkICs9IHJlbG9hZEludGVydmFsO1xuICAgICAgfVxuICAgICAgbGV0IGVzdGltYXRlZFRpbWVVbnRpbFVwZGF0ZSA9IHRoaXMucmVxdWVzdFNjaGVkdWxlZCAtIG5vdztcbiAgICAgIGVzdGltYXRlZFRpbWVVbnRpbFVwZGF0ZSA9IE1hdGgubWF4KDAsIGVzdGltYXRlZFRpbWVVbnRpbFVwZGF0ZSk7XG4gICAgICB0aGlzLmxvZyhgcmVsb2FkIGxpdmUgcGxheWxpc3QgJHtpbmRleH0gaW4gJHtNYXRoLnJvdW5kKGVzdGltYXRlZFRpbWVVbnRpbFVwZGF0ZSl9IG1zYCk7XG4gICAgICAvLyB0aGlzLmxvZyhcbiAgICAgIC8vICAgYGxpdmUgcmVsb2FkICR7ZGV0YWlscy51cGRhdGVkID8gJ1JFRlJFU0hFRCcgOiAnTUlTU0VEJ31cbiAgICAgIC8vIHJlbG9hZCBpbiAke2VzdGltYXRlZFRpbWVVbnRpbFVwZGF0ZSAvIDEwMDB9XG4gICAgICAvLyByb3VuZCB0cmlwICR7KHN0YXRzLmxvYWRpbmcuZW5kIC0gc3RhdHMubG9hZGluZy5zdGFydCkgLyAxMDAwfVxuICAgICAgLy8gZGlmZiAke1xuICAgICAgLy8gICAocmVsb2FkSW50ZXJ2YWwgLVxuICAgICAgLy8gICAgIChlc3RpbWF0ZWRUaW1lVW50aWxVcGRhdGUgK1xuICAgICAgLy8gICAgICAgc3RhdHMubG9hZGluZy5lbmQgLVxuICAgICAgLy8gICAgICAgc3RhdHMubG9hZGluZy5zdGFydCkpIC9cbiAgICAgIC8vICAgMTAwMFxuICAgICAgLy8gfVxuICAgICAgLy8gcmVsb2FkIGludGVydmFsICR7cmVsb2FkSW50ZXJ2YWwgLyAxMDAwfVxuICAgICAgLy8gdGFyZ2V0IGR1cmF0aW9uICR7ZGV0YWlscy50YXJnZXRkdXJhdGlvbn1cbiAgICAgIC8vIGRpc3RhbmNlIHRvIGVkZ2UgJHtkaXN0YW5jZVRvTGl2ZUVkZ2VNcyAvIDEwMDB9YFxuICAgICAgLy8gKTtcblxuICAgICAgdGhpcy50aW1lciA9IHNlbGYuc2V0VGltZW91dCgoKSA9PiB0aGlzLmxvYWRQbGF5bGlzdChkZWxpdmVyeURpcmVjdGl2ZXMpLCBlc3RpbWF0ZWRUaW1lVW50aWxVcGRhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICB9XG4gIH1cbiAgZ2V0RGVsaXZlcnlEaXJlY3RpdmVzKGRldGFpbHMsIHByZXZpb3VzRGVsaXZlcnlEaXJlY3RpdmVzLCBtc24sIHBhcnQpIHtcbiAgICBsZXQgc2tpcCA9IGdldFNraXBWYWx1ZShkZXRhaWxzLCBtc24pO1xuICAgIGlmIChwcmV2aW91c0RlbGl2ZXJ5RGlyZWN0aXZlcyAhPSBudWxsICYmIHByZXZpb3VzRGVsaXZlcnlEaXJlY3RpdmVzLnNraXAgJiYgZGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCkge1xuICAgICAgbXNuID0gcHJldmlvdXNEZWxpdmVyeURpcmVjdGl2ZXMubXNuO1xuICAgICAgcGFydCA9IHByZXZpb3VzRGVsaXZlcnlEaXJlY3RpdmVzLnBhcnQ7XG4gICAgICBza2lwID0gSGxzU2tpcC5ObztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBIbHNVcmxQYXJhbWV0ZXJzKG1zbiwgcGFydCwgc2tpcCk7XG4gIH1cbiAgY2hlY2tSZXRyeShlcnJvckV2ZW50KSB7XG4gICAgY29uc3QgZXJyb3JEZXRhaWxzID0gZXJyb3JFdmVudC5kZXRhaWxzO1xuICAgIGNvbnN0IGlzVGltZW91dCA9IGlzVGltZW91dEVycm9yKGVycm9yRXZlbnQpO1xuICAgIGNvbnN0IGVycm9yQWN0aW9uID0gZXJyb3JFdmVudC5lcnJvckFjdGlvbjtcbiAgICBjb25zdCB7XG4gICAgICBhY3Rpb24sXG4gICAgICByZXRyeUNvdW50ID0gMCxcbiAgICAgIHJldHJ5Q29uZmlnXG4gICAgfSA9IGVycm9yQWN0aW9uIHx8IHt9O1xuICAgIGNvbnN0IHJldHJ5ID0gISFlcnJvckFjdGlvbiAmJiAhIXJldHJ5Q29uZmlnICYmIChhY3Rpb24gPT09IE5ldHdvcmtFcnJvckFjdGlvbi5SZXRyeVJlcXVlc3QgfHwgIWVycm9yQWN0aW9uLnJlc29sdmVkICYmIGFjdGlvbiA9PT0gTmV0d29ya0Vycm9yQWN0aW9uLlNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3gpO1xuICAgIGlmIChyZXRyeSkge1xuICAgICAgdmFyIF9lcnJvckV2ZW50JGNvbnRleHQ7XG4gICAgICB0aGlzLnJlcXVlc3RTY2hlZHVsZWQgPSAtMTtcbiAgICAgIGlmIChyZXRyeUNvdW50ID49IHJldHJ5Q29uZmlnLm1heE51bVJldHJ5KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1RpbWVvdXQgJiYgKF9lcnJvckV2ZW50JGNvbnRleHQgPSBlcnJvckV2ZW50LmNvbnRleHQpICE9IG51bGwgJiYgX2Vycm9yRXZlbnQkY29udGV4dC5kZWxpdmVyeURpcmVjdGl2ZXMpIHtcbiAgICAgICAgLy8gVGhlIExMLUhMUyByZXF1ZXN0IGFscmVhZHkgdGltZWQgb3V0IHNvIHJldHJ5IGltbWVkaWF0ZWx5XG4gICAgICAgIHRoaXMud2FybihgUmV0cnlpbmcgcGxheWxpc3QgbG9hZGluZyAke3JldHJ5Q291bnQgKyAxfS8ke3JldHJ5Q29uZmlnLm1heE51bVJldHJ5fSBhZnRlciBcIiR7ZXJyb3JEZXRhaWxzfVwiIHdpdGhvdXQgZGVsaXZlcnktZGlyZWN0aXZlc2ApO1xuICAgICAgICB0aGlzLmxvYWRQbGF5bGlzdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZGVsYXkgPSBnZXRSZXRyeURlbGF5KHJldHJ5Q29uZmlnLCByZXRyeUNvdW50KTtcbiAgICAgICAgLy8gU2NoZWR1bGUgbGV2ZWwvdHJhY2sgcmVsb2FkXG4gICAgICAgIHRoaXMudGltZXIgPSBzZWxmLnNldFRpbWVvdXQoKCkgPT4gdGhpcy5sb2FkUGxheWxpc3QoKSwgZGVsYXkpO1xuICAgICAgICB0aGlzLndhcm4oYFJldHJ5aW5nIHBsYXlsaXN0IGxvYWRpbmcgJHtyZXRyeUNvdW50ICsgMX0vJHtyZXRyeUNvbmZpZy5tYXhOdW1SZXRyeX0gYWZ0ZXIgXCIke2Vycm9yRGV0YWlsc31cIiBpbiAke2RlbGF5fW1zYCk7XG4gICAgICB9XG4gICAgICAvLyBgbGV2ZWxSZXRyeSA9IHRydWVgIHVzZWQgdG8gaW5mb3JtIG90aGVyIGNvbnRyb2xsZXJzIHRoYXQgYSByZXRyeSBpcyBoYXBwZW5pbmdcbiAgICAgIGVycm9yRXZlbnQubGV2ZWxSZXRyeSA9IHRydWU7XG4gICAgICBlcnJvckFjdGlvbi5yZXNvbHZlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiByZXRyeTtcbiAgfVxufVxuXG4vKlxuICogY29tcHV0ZSBhbiBFeHBvbmVudGlhbCBXZWlnaHRlZCBtb3ZpbmcgYXZlcmFnZVxuICogLSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nb3ZpbmdfYXZlcmFnZSNFeHBvbmVudGlhbF9tb3ZpbmdfYXZlcmFnZVxuICogIC0gaGVhdmlseSBpbnNwaXJlZCBmcm9tIHNoYWthLXBsYXllclxuICovXG5cbmNsYXNzIEVXTUEge1xuICAvLyAgQWJvdXQgaGFsZiBvZiB0aGUgZXN0aW1hdGVkIHZhbHVlIHdpbGwgYmUgZnJvbSB0aGUgbGFzdCB8aGFsZkxpZmV8IHNhbXBsZXMgYnkgd2VpZ2h0LlxuICBjb25zdHJ1Y3RvcihoYWxmTGlmZSwgZXN0aW1hdGUgPSAwLCB3ZWlnaHQgPSAwKSB7XG4gICAgdGhpcy5oYWxmTGlmZSA9IHZvaWQgMDtcbiAgICB0aGlzLmFscGhhXyA9IHZvaWQgMDtcbiAgICB0aGlzLmVzdGltYXRlXyA9IHZvaWQgMDtcbiAgICB0aGlzLnRvdGFsV2VpZ2h0XyA9IHZvaWQgMDtcbiAgICB0aGlzLmhhbGZMaWZlID0gaGFsZkxpZmU7XG4gICAgLy8gTGFyZ2VyIHZhbHVlcyBvZiBhbHBoYSBleHBpcmUgaGlzdG9yaWNhbCBkYXRhIG1vcmUgc2xvd2x5LlxuICAgIHRoaXMuYWxwaGFfID0gaGFsZkxpZmUgPyBNYXRoLmV4cChNYXRoLmxvZygwLjUpIC8gaGFsZkxpZmUpIDogMDtcbiAgICB0aGlzLmVzdGltYXRlXyA9IGVzdGltYXRlO1xuICAgIHRoaXMudG90YWxXZWlnaHRfID0gd2VpZ2h0O1xuICB9XG4gIHNhbXBsZSh3ZWlnaHQsIHZhbHVlKSB7XG4gICAgY29uc3QgYWRqQWxwaGEgPSBNYXRoLnBvdyh0aGlzLmFscGhhXywgd2VpZ2h0KTtcbiAgICB0aGlzLmVzdGltYXRlXyA9IHZhbHVlICogKDEgLSBhZGpBbHBoYSkgKyBhZGpBbHBoYSAqIHRoaXMuZXN0aW1hdGVfO1xuICAgIHRoaXMudG90YWxXZWlnaHRfICs9IHdlaWdodDtcbiAgfVxuICBnZXRUb3RhbFdlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy50b3RhbFdlaWdodF87XG4gIH1cbiAgZ2V0RXN0aW1hdGUoKSB7XG4gICAgaWYgKHRoaXMuYWxwaGFfKSB7XG4gICAgICBjb25zdCB6ZXJvRmFjdG9yID0gMSAtIE1hdGgucG93KHRoaXMuYWxwaGFfLCB0aGlzLnRvdGFsV2VpZ2h0Xyk7XG4gICAgICBpZiAoemVyb0ZhY3Rvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZV8gLyB6ZXJvRmFjdG9yO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZV87XG4gIH1cbn1cblxuLypcbiAqIEVXTUEgQmFuZHdpZHRoIEVzdGltYXRvclxuICogIC0gaGVhdmlseSBpbnNwaXJlZCBmcm9tIHNoYWthLXBsYXllclxuICogVHJhY2tzIGJhbmR3aWR0aCBzYW1wbGVzIGFuZCBlc3RpbWF0ZXMgYXZhaWxhYmxlIGJhbmR3aWR0aC5cbiAqIEJhc2VkIG9uIHRoZSBtaW5pbXVtIG9mIHR3byBleHBvbmVudGlhbGx5LXdlaWdodGVkIG1vdmluZyBhdmVyYWdlcyB3aXRoXG4gKiBkaWZmZXJlbnQgaGFsZi1saXZlcy5cbiAqL1xuXG5jbGFzcyBFd21hQmFuZFdpZHRoRXN0aW1hdG9yIHtcbiAgY29uc3RydWN0b3Ioc2xvdywgZmFzdCwgZGVmYXVsdEVzdGltYXRlLCBkZWZhdWx0VFRGQiA9IDEwMCkge1xuICAgIHRoaXMuZGVmYXVsdEVzdGltYXRlXyA9IHZvaWQgMDtcbiAgICB0aGlzLm1pbldlaWdodF8gPSB2b2lkIDA7XG4gICAgdGhpcy5taW5EZWxheU1zXyA9IHZvaWQgMDtcbiAgICB0aGlzLnNsb3dfID0gdm9pZCAwO1xuICAgIHRoaXMuZmFzdF8gPSB2b2lkIDA7XG4gICAgdGhpcy5kZWZhdWx0VFRGQl8gPSB2b2lkIDA7XG4gICAgdGhpcy50dGZiXyA9IHZvaWQgMDtcbiAgICB0aGlzLmRlZmF1bHRFc3RpbWF0ZV8gPSBkZWZhdWx0RXN0aW1hdGU7XG4gICAgdGhpcy5taW5XZWlnaHRfID0gMC4wMDE7XG4gICAgdGhpcy5taW5EZWxheU1zXyA9IDUwO1xuICAgIHRoaXMuc2xvd18gPSBuZXcgRVdNQShzbG93KTtcbiAgICB0aGlzLmZhc3RfID0gbmV3IEVXTUEoZmFzdCk7XG4gICAgdGhpcy5kZWZhdWx0VFRGQl8gPSBkZWZhdWx0VFRGQjtcbiAgICB0aGlzLnR0ZmJfID0gbmV3IEVXTUEoc2xvdyk7XG4gIH1cbiAgdXBkYXRlKHNsb3csIGZhc3QpIHtcbiAgICBjb25zdCB7XG4gICAgICBzbG93XyxcbiAgICAgIGZhc3RfLFxuICAgICAgdHRmYl9cbiAgICB9ID0gdGhpcztcbiAgICBpZiAoc2xvd18uaGFsZkxpZmUgIT09IHNsb3cpIHtcbiAgICAgIHRoaXMuc2xvd18gPSBuZXcgRVdNQShzbG93LCBzbG93Xy5nZXRFc3RpbWF0ZSgpLCBzbG93Xy5nZXRUb3RhbFdlaWdodCgpKTtcbiAgICB9XG4gICAgaWYgKGZhc3RfLmhhbGZMaWZlICE9PSBmYXN0KSB7XG4gICAgICB0aGlzLmZhc3RfID0gbmV3IEVXTUEoZmFzdCwgZmFzdF8uZ2V0RXN0aW1hdGUoKSwgZmFzdF8uZ2V0VG90YWxXZWlnaHQoKSk7XG4gICAgfVxuICAgIGlmICh0dGZiXy5oYWxmTGlmZSAhPT0gc2xvdykge1xuICAgICAgdGhpcy50dGZiXyA9IG5ldyBFV01BKHNsb3csIHR0ZmJfLmdldEVzdGltYXRlKCksIHR0ZmJfLmdldFRvdGFsV2VpZ2h0KCkpO1xuICAgIH1cbiAgfVxuICBzYW1wbGUoZHVyYXRpb25NcywgbnVtQnl0ZXMpIHtcbiAgICBkdXJhdGlvbk1zID0gTWF0aC5tYXgoZHVyYXRpb25NcywgdGhpcy5taW5EZWxheU1zXyk7XG4gICAgY29uc3QgbnVtQml0cyA9IDggKiBudW1CeXRlcztcbiAgICAvLyB3ZWlnaHQgaXMgZHVyYXRpb24gaW4gc2Vjb25kc1xuICAgIGNvbnN0IGR1cmF0aW9uUyA9IGR1cmF0aW9uTXMgLyAxMDAwO1xuICAgIC8vIHZhbHVlIGlzIGJhbmR3aWR0aCBpbiBiaXRzL3NcbiAgICBjb25zdCBiYW5kd2lkdGhJbkJwcyA9IG51bUJpdHMgLyBkdXJhdGlvblM7XG4gICAgdGhpcy5mYXN0Xy5zYW1wbGUoZHVyYXRpb25TLCBiYW5kd2lkdGhJbkJwcyk7XG4gICAgdGhpcy5zbG93Xy5zYW1wbGUoZHVyYXRpb25TLCBiYW5kd2lkdGhJbkJwcyk7XG4gIH1cbiAgc2FtcGxlVFRGQih0dGZiKSB7XG4gICAgLy8gd2VpZ2h0IGlzIGZyZXF1ZW5jeSBjdXJ2ZSBhcHBsaWVkIHRvIFRURkIgaW4gc2Vjb25kc1xuICAgIC8vIChsb25nZXIgdGltZXMgaGF2ZSBsZXNzIHdlaWdodCB3aXRoIGV4cGVjdGVkIGlucHV0IHVuZGVyIDEgc2Vjb25kKVxuICAgIGNvbnN0IHNlY29uZHMgPSB0dGZiIC8gMTAwMDtcbiAgICBjb25zdCB3ZWlnaHQgPSBNYXRoLnNxcnQoMikgKiBNYXRoLmV4cCgtTWF0aC5wb3coc2Vjb25kcywgMikgLyAyKTtcbiAgICB0aGlzLnR0ZmJfLnNhbXBsZSh3ZWlnaHQsIE1hdGgubWF4KHR0ZmIsIDUpKTtcbiAgfVxuICBjYW5Fc3RpbWF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5mYXN0Xy5nZXRUb3RhbFdlaWdodCgpID49IHRoaXMubWluV2VpZ2h0XztcbiAgfVxuICBnZXRFc3RpbWF0ZSgpIHtcbiAgICBpZiAodGhpcy5jYW5Fc3RpbWF0ZSgpKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnc2xvdyBlc3RpbWF0ZTonKyBNYXRoLnJvdW5kKHRoaXMuc2xvd18uZ2V0RXN0aW1hdGUoKSkpO1xuICAgICAgLy8gY29uc29sZS5sb2coJ2Zhc3QgZXN0aW1hdGU6JysgTWF0aC5yb3VuZCh0aGlzLmZhc3RfLmdldEVzdGltYXRlKCkpKTtcbiAgICAgIC8vIFRha2UgdGhlIG1pbmltdW0gb2YgdGhlc2UgdHdvIGVzdGltYXRlcy4gIFRoaXMgc2hvdWxkIGhhdmUgdGhlIGVmZmVjdCBvZlxuICAgICAgLy8gYWRhcHRpbmcgZG93biBxdWlja2x5LCBidXQgdXAgbW9yZSBzbG93bHkuXG4gICAgICByZXR1cm4gTWF0aC5taW4odGhpcy5mYXN0Xy5nZXRFc3RpbWF0ZSgpLCB0aGlzLnNsb3dfLmdldEVzdGltYXRlKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWZhdWx0RXN0aW1hdGVfO1xuICAgIH1cbiAgfVxuICBnZXRFc3RpbWF0ZVRURkIoKSB7XG4gICAgaWYgKHRoaXMudHRmYl8uZ2V0VG90YWxXZWlnaHQoKSA+PSB0aGlzLm1pbldlaWdodF8pIHtcbiAgICAgIHJldHVybiB0aGlzLnR0ZmJfLmdldEVzdGltYXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRUVEZCXztcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHt9XG59XG5cbmNvbnN0IFNVUFBPUlRFRF9JTkZPX0RFRkFVTFQgPSB7XG4gIHN1cHBvcnRlZDogdHJ1ZSxcbiAgY29uZmlndXJhdGlvbnM6IFtdLFxuICBkZWNvZGluZ0luZm9SZXN1bHRzOiBbe1xuICAgIHN1cHBvcnRlZDogdHJ1ZSxcbiAgICBwb3dlckVmZmljaWVudDogdHJ1ZSxcbiAgICBzbW9vdGg6IHRydWVcbiAgfV1cbn07XG5jb25zdCBTVVBQT1JURURfSU5GT19DQUNIRSA9IHt9O1xuZnVuY3Rpb24gcmVxdWlyZXNNZWRpYUNhcGFiaWxpdGllc0RlY29kaW5nSW5mbyhsZXZlbCwgYXVkaW9UcmFja3NCeUdyb3VwLCBjdXJyZW50VmlkZW9SYW5nZSwgY3VycmVudEZyYW1lUmF0ZSwgY3VycmVudEJ3LCBhdWRpb1ByZWZlcmVuY2UpIHtcbiAgLy8gT25seSB0ZXN0IHN1cHBvcnQgd2hlbiBjb25maWd1cmF0aW9uIGlzIGV4Y2VlZHMgbWluaW11bSBvcHRpb25zXG4gIGNvbnN0IGF1ZGlvR3JvdXBzID0gbGV2ZWwuYXVkaW9Db2RlYyA/IGxldmVsLmF1ZGlvR3JvdXBzIDogbnVsbDtcbiAgY29uc3QgYXVkaW9Db2RlY1ByZWZlcmVuY2UgPSBhdWRpb1ByZWZlcmVuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGF1ZGlvUHJlZmVyZW5jZS5hdWRpb0NvZGVjO1xuICBjb25zdCBjaGFubmVsc1ByZWZlcmVuY2UgPSBhdWRpb1ByZWZlcmVuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGF1ZGlvUHJlZmVyZW5jZS5jaGFubmVscztcbiAgY29uc3QgbWF4Q2hhbm5lbHMgPSBjaGFubmVsc1ByZWZlcmVuY2UgPyBwYXJzZUludChjaGFubmVsc1ByZWZlcmVuY2UpIDogYXVkaW9Db2RlY1ByZWZlcmVuY2UgPyBJbmZpbml0eSA6IDI7XG4gIGxldCBhdWRpb0NoYW5uZWxzID0gbnVsbDtcbiAgaWYgKGF1ZGlvR3JvdXBzICE9IG51bGwgJiYgYXVkaW9Hcm91cHMubGVuZ3RoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChhdWRpb0dyb3Vwcy5sZW5ndGggPT09IDEgJiYgYXVkaW9Hcm91cHNbMF0pIHtcbiAgICAgICAgYXVkaW9DaGFubmVscyA9IGF1ZGlvVHJhY2tzQnlHcm91cC5ncm91cHNbYXVkaW9Hcm91cHNbMF1dLmNoYW5uZWxzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXVkaW9DaGFubmVscyA9IGF1ZGlvR3JvdXBzLnJlZHVjZSgoYWNjLCBncm91cElkKSA9PiB7XG4gICAgICAgICAgaWYgKGdyb3VwSWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGF1ZGlvVHJhY2tHcm91cCA9IGF1ZGlvVHJhY2tzQnlHcm91cC5ncm91cHNbZ3JvdXBJZF07XG4gICAgICAgICAgICBpZiAoIWF1ZGlvVHJhY2tHcm91cCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF1ZGlvIHRyYWNrIGdyb3VwICR7Z3JvdXBJZH0gbm90IGZvdW5kYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdW0gYWxsIGNoYW5uZWwga2V5IHZhbHVlc1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXVkaW9UcmFja0dyb3VwLmNoYW5uZWxzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAgIGFjY1trZXldID0gKGFjY1trZXldIHx8IDApICsgYXVkaW9UcmFja0dyb3VwLmNoYW5uZWxzW2tleV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge1xuICAgICAgICAgIDI6IDBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGV2ZWwudmlkZW9Db2RlYyAhPT0gdW5kZWZpbmVkICYmIChsZXZlbC53aWR0aCA+IDE5MjAgJiYgbGV2ZWwuaGVpZ2h0ID4gMTA4OCB8fCBsZXZlbC5oZWlnaHQgPiAxOTIwICYmIGxldmVsLndpZHRoID4gMTA4OCB8fCBsZXZlbC5mcmFtZVJhdGUgPiBNYXRoLm1heChjdXJyZW50RnJhbWVSYXRlLCAzMCkgfHwgbGV2ZWwudmlkZW9SYW5nZSAhPT0gJ1NEUicgJiYgbGV2ZWwudmlkZW9SYW5nZSAhPT0gY3VycmVudFZpZGVvUmFuZ2UgfHwgbGV2ZWwuYml0cmF0ZSA+IE1hdGgubWF4KGN1cnJlbnRCdywgOGU2KSkgfHwgISFhdWRpb0NoYW5uZWxzICYmIGlzRmluaXRlTnVtYmVyKG1heENoYW5uZWxzKSAmJiBPYmplY3Qua2V5cyhhdWRpb0NoYW5uZWxzKS5zb21lKGNoYW5uZWxzID0+IHBhcnNlSW50KGNoYW5uZWxzKSA+IG1heENoYW5uZWxzKTtcbn1cbmZ1bmN0aW9uIGdldE1lZGlhRGVjb2RpbmdJbmZvUHJvbWlzZShsZXZlbCwgYXVkaW9UcmFja3NCeUdyb3VwLCBtZWRpYUNhcGFiaWxpdGllcykge1xuICBjb25zdCB2aWRlb0NvZGVjcyA9IGxldmVsLnZpZGVvQ29kZWM7XG4gIGNvbnN0IGF1ZGlvQ29kZWNzID0gbGV2ZWwuYXVkaW9Db2RlYztcbiAgaWYgKCF2aWRlb0NvZGVjcyB8fCAhYXVkaW9Db2RlY3MgfHwgIW1lZGlhQ2FwYWJpbGl0aWVzKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShTVVBQT1JURURfSU5GT19ERUZBVUxUKTtcbiAgfVxuICBjb25zdCBiYXNlVmlkZW9Db25maWd1cmF0aW9uID0ge1xuICAgIHdpZHRoOiBsZXZlbC53aWR0aCxcbiAgICBoZWlnaHQ6IGxldmVsLmhlaWdodCxcbiAgICBiaXRyYXRlOiBNYXRoLmNlaWwoTWF0aC5tYXgobGV2ZWwuYml0cmF0ZSAqIDAuOSwgbGV2ZWwuYXZlcmFnZUJpdHJhdGUpKSxcbiAgICAvLyBBc3N1bWUgYSBmcmFtZXJhdGUgb2YgMzBmcHMgc2luY2UgTWVkaWFDYXBhYmlsaXRpZXMgd2lsbCBub3QgYWNjZXB0IExldmVsIGRlZmF1bHQgb2YgMC5cbiAgICBmcmFtZXJhdGU6IGxldmVsLmZyYW1lUmF0ZSB8fCAzMFxuICB9O1xuICBjb25zdCB2aWRlb1JhbmdlID0gbGV2ZWwudmlkZW9SYW5nZTtcbiAgaWYgKHZpZGVvUmFuZ2UgIT09ICdTRFInKSB7XG4gICAgYmFzZVZpZGVvQ29uZmlndXJhdGlvbi50cmFuc2ZlckZ1bmN0aW9uID0gdmlkZW9SYW5nZS50b0xvd2VyQ2FzZSgpO1xuICB9XG4gIGNvbnN0IGNvbmZpZ3VyYXRpb25zID0gdmlkZW9Db2RlY3Muc3BsaXQoJywnKS5tYXAodmlkZW9Db2RlYyA9PiAoe1xuICAgIHR5cGU6ICdtZWRpYS1zb3VyY2UnLFxuICAgIHZpZGVvOiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgYmFzZVZpZGVvQ29uZmlndXJhdGlvbiksIHt9LCB7XG4gICAgICBjb250ZW50VHlwZTogbWltZVR5cGVGb3JDb2RlYyh2aWRlb0NvZGVjLCAndmlkZW8nKVxuICAgIH0pXG4gIH0pKTtcbiAgaWYgKGF1ZGlvQ29kZWNzICYmIGxldmVsLmF1ZGlvR3JvdXBzKSB7XG4gICAgbGV2ZWwuYXVkaW9Hcm91cHMuZm9yRWFjaChhdWRpb0dyb3VwSWQgPT4ge1xuICAgICAgdmFyIF9hdWRpb1RyYWNrc0J5R3JvdXAkZztcbiAgICAgIGlmICghYXVkaW9Hcm91cElkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIChfYXVkaW9UcmFja3NCeUdyb3VwJGcgPSBhdWRpb1RyYWNrc0J5R3JvdXAuZ3JvdXBzW2F1ZGlvR3JvdXBJZF0pID09IG51bGwgPyB2b2lkIDAgOiBfYXVkaW9UcmFja3NCeUdyb3VwJGcudHJhY2tzLmZvckVhY2goYXVkaW9UcmFjayA9PiB7XG4gICAgICAgIGlmIChhdWRpb1RyYWNrLmdyb3VwSWQgPT09IGF1ZGlvR3JvdXBJZCkge1xuICAgICAgICAgIGNvbnN0IGNoYW5uZWxzID0gYXVkaW9UcmFjay5jaGFubmVscyB8fCAnJztcbiAgICAgICAgICBjb25zdCBjaGFubmVsc051bWJlciA9IHBhcnNlRmxvYXQoY2hhbm5lbHMpO1xuICAgICAgICAgIGlmIChpc0Zpbml0ZU51bWJlcihjaGFubmVsc051bWJlcikgJiYgY2hhbm5lbHNOdW1iZXIgPiAyKSB7XG4gICAgICAgICAgICBjb25maWd1cmF0aW9ucy5wdXNoLmFwcGx5KGNvbmZpZ3VyYXRpb25zLCBhdWRpb0NvZGVjcy5zcGxpdCgnLCcpLm1hcChhdWRpb0NvZGVjID0+ICh7XG4gICAgICAgICAgICAgIHR5cGU6ICdtZWRpYS1zb3VyY2UnLFxuICAgICAgICAgICAgICBhdWRpbzoge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBtaW1lVHlwZUZvckNvZGVjKGF1ZGlvQ29kZWMsICdhdWRpbycpLFxuICAgICAgICAgICAgICAgIGNoYW5uZWxzOiAnJyArIGNoYW5uZWxzTnVtYmVyXG4gICAgICAgICAgICAgICAgLy8gc3BhdGlhbFJlbmRlcmluZzpcbiAgICAgICAgICAgICAgICAvLyAgIGF1ZGlvQ29kZWMgPT09ICdlYy0zJyAmJiBjaGFubmVscy5pbmRleE9mKCdKT0MnKSxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBQcm9taXNlLmFsbChjb25maWd1cmF0aW9ucy5tYXAoY29uZmlndXJhdGlvbiA9PiB7XG4gICAgLy8gQ2FjaGUgTWVkaWFDYXBhYmlsaXRpZXMgcHJvbWlzZXNcbiAgICBjb25zdCBkZWNvZGluZ0luZm9LZXkgPSBnZXRNZWRpYURlY29kaW5nSW5mb0tleShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4gU1VQUE9SVEVEX0lORk9fQ0FDSEVbZGVjb2RpbmdJbmZvS2V5XSB8fCAoU1VQUE9SVEVEX0lORk9fQ0FDSEVbZGVjb2RpbmdJbmZvS2V5XSA9IG1lZGlhQ2FwYWJpbGl0aWVzLmRlY29kaW5nSW5mbyhjb25maWd1cmF0aW9uKSk7XG4gIH0pKS50aGVuKGRlY29kaW5nSW5mb1Jlc3VsdHMgPT4gKHtcbiAgICBzdXBwb3J0ZWQ6ICFkZWNvZGluZ0luZm9SZXN1bHRzLnNvbWUoaW5mbyA9PiAhaW5mby5zdXBwb3J0ZWQpLFxuICAgIGNvbmZpZ3VyYXRpb25zLFxuICAgIGRlY29kaW5nSW5mb1Jlc3VsdHNcbiAgfSkpLmNhdGNoKGVycm9yID0+ICh7XG4gICAgc3VwcG9ydGVkOiBmYWxzZSxcbiAgICBjb25maWd1cmF0aW9ucyxcbiAgICBkZWNvZGluZ0luZm9SZXN1bHRzOiBbXSxcbiAgICBlcnJvclxuICB9KSk7XG59XG5mdW5jdGlvbiBnZXRNZWRpYURlY29kaW5nSW5mb0tleShjb25maWcpIHtcbiAgY29uc3Qge1xuICAgIGF1ZGlvLFxuICAgIHZpZGVvXG4gIH0gPSBjb25maWc7XG4gIGNvbnN0IG1lZGlhQ29uZmlnID0gdmlkZW8gfHwgYXVkaW87XG4gIGlmIChtZWRpYUNvbmZpZykge1xuICAgIGNvbnN0IGNvZGVjID0gbWVkaWFDb25maWcuY29udGVudFR5cGUuc3BsaXQoJ1wiJylbMV07XG4gICAgaWYgKHZpZGVvKSB7XG4gICAgICByZXR1cm4gYHIke3ZpZGVvLmhlaWdodH14JHt2aWRlby53aWR0aH1mJHtNYXRoLmNlaWwodmlkZW8uZnJhbWVyYXRlKX0ke3ZpZGVvLnRyYW5zZmVyRnVuY3Rpb24gfHwgJ3NkJ31fJHtjb2RlY31fJHtNYXRoLmNlaWwodmlkZW8uYml0cmF0ZSAvIDFlNSl9YDtcbiAgICB9XG4gICAgaWYgKGF1ZGlvKSB7XG4gICAgICByZXR1cm4gYGMke2F1ZGlvLmNoYW5uZWxzfSR7YXVkaW8uc3BhdGlhbFJlbmRlcmluZyA/ICdzJyA6ICduJ31fJHtjb2RlY31gO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogQHJldHVybnMgV2hldGhlciB3ZSBjYW4gZGV0ZWN0IGFuZCB2YWxpZGF0ZSBIRFIgY2FwYWJpbGl0eSB3aXRoaW4gdGhlIHdpbmRvdyBjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIGlzSGRyU3VwcG9ydGVkKCkge1xuICBpZiAodHlwZW9mIG1hdGNoTWVkaWEgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCBtZWRpYVF1ZXJ5TGlzdCA9IG1hdGNoTWVkaWEoJyhkeW5hbWljLXJhbmdlOiBoaWdoKScpO1xuICAgIGNvbnN0IGJhZFF1ZXJ5ID0gbWF0Y2hNZWRpYSgnYmFkIHF1ZXJ5Jyk7XG4gICAgaWYgKG1lZGlhUXVlcnlMaXN0Lm1lZGlhICE9PSBiYWRRdWVyeS5tZWRpYSkge1xuICAgICAgcmV0dXJuIG1lZGlhUXVlcnlMaXN0Lm1hdGNoZXMgPT09IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBTYW5pdGl6ZXMgaW5wdXRzIHRvIHJldHVybiB0aGUgYWN0aXZlIHZpZGVvIHNlbGVjdGlvbiBvcHRpb25zIGZvciBIRFIvU0RSLlxuICogV2hlbiBib3RoIGlucHV0cyBhcmUgbnVsbDpcbiAqXG4gKiAgICBgeyBwcmVmZXJIRFI6IGZhbHNlLCBhbGxvd2VkVmlkZW9SYW5nZXM6IFtdIH1gXG4gKlxuICogV2hlbiBgY3VycmVudFZpZGVvUmFuZ2VgIG5vbi1udWxsLCBtYWludGFpbiB0aGUgYWN0aXZlIHJhbmdlOlxuICpcbiAqICAgIGB7IHByZWZlckhEUjogY3VycmVudFZpZGVvUmFuZ2UgIT09ICdTRFInLCBhbGxvd2VkVmlkZW9SYW5nZXM6IFtjdXJyZW50VmlkZW9SYW5nZV0gfWBcbiAqXG4gKiBXaGVuIFZpZGVvU2VsZWN0aW9uT3B0aW9uIG5vbi1udWxsOlxuICpcbiAqICAtIEFsbG93IGFsbCB2aWRlbyByYW5nZXMgaWYgYGFsbG93ZWRWaWRlb1Jhbmdlc2AgdW5zcGVjaWZpZWQuXG4gKiAgLSBJZiBgcHJlZmVySERSYCBpcyBub24tbnVsbCB1c2UgdGhlIHZhbHVlIHRvIGZpbHRlciBgYWxsb3dlZFZpZGVvUmFuZ2VzYC5cbiAqICAtIEVsc2UgY2hlY2sgd2luZG93IGZvciBIRFIgc3VwcG9ydCBhbmQgc2V0IGBwcmVmZXJIRFJgIHRvIHRoZSByZXN1bHQuXG4gKlxuICogQHBhcmFtIGN1cnJlbnRWaWRlb1JhbmdlXG4gKiBAcGFyYW0gdmlkZW9QcmVmZXJlbmNlXG4gKi9cbmZ1bmN0aW9uIGdldFZpZGVvU2VsZWN0aW9uT3B0aW9ucyhjdXJyZW50VmlkZW9SYW5nZSwgdmlkZW9QcmVmZXJlbmNlKSB7XG4gIGxldCBwcmVmZXJIRFIgPSBmYWxzZTtcbiAgbGV0IGFsbG93ZWRWaWRlb1JhbmdlcyA9IFtdO1xuICBpZiAoY3VycmVudFZpZGVvUmFuZ2UpIHtcbiAgICBwcmVmZXJIRFIgPSBjdXJyZW50VmlkZW9SYW5nZSAhPT0gJ1NEUic7XG4gICAgYWxsb3dlZFZpZGVvUmFuZ2VzID0gW2N1cnJlbnRWaWRlb1JhbmdlXTtcbiAgfVxuICBpZiAodmlkZW9QcmVmZXJlbmNlKSB7XG4gICAgYWxsb3dlZFZpZGVvUmFuZ2VzID0gdmlkZW9QcmVmZXJlbmNlLmFsbG93ZWRWaWRlb1JhbmdlcyB8fCBWaWRlb1JhbmdlVmFsdWVzLnNsaWNlKDApO1xuICAgIHByZWZlckhEUiA9IHZpZGVvUHJlZmVyZW5jZS5wcmVmZXJIRFIgIT09IHVuZGVmaW5lZCA/IHZpZGVvUHJlZmVyZW5jZS5wcmVmZXJIRFIgOiBpc0hkclN1cHBvcnRlZCgpO1xuICAgIGlmIChwcmVmZXJIRFIpIHtcbiAgICAgIGFsbG93ZWRWaWRlb1JhbmdlcyA9IGFsbG93ZWRWaWRlb1Jhbmdlcy5maWx0ZXIocmFuZ2UgPT4gcmFuZ2UgIT09ICdTRFInKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWxsb3dlZFZpZGVvUmFuZ2VzID0gWydTRFInXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwcmVmZXJIRFIsXG4gICAgYWxsb3dlZFZpZGVvUmFuZ2VzXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFN0YXJ0Q29kZWNUaWVyKGNvZGVjVGllcnMsIGN1cnJlbnRWaWRlb1JhbmdlLCBjdXJyZW50QncsIGF1ZGlvUHJlZmVyZW5jZSwgdmlkZW9QcmVmZXJlbmNlKSB7XG4gIGNvbnN0IGNvZGVjU2V0cyA9IE9iamVjdC5rZXlzKGNvZGVjVGllcnMpO1xuICBjb25zdCBjaGFubmVsc1ByZWZlcmVuY2UgPSBhdWRpb1ByZWZlcmVuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGF1ZGlvUHJlZmVyZW5jZS5jaGFubmVscztcbiAgY29uc3QgYXVkaW9Db2RlY1ByZWZlcmVuY2UgPSBhdWRpb1ByZWZlcmVuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGF1ZGlvUHJlZmVyZW5jZS5hdWRpb0NvZGVjO1xuICBjb25zdCBwcmVmZXJTdGVyZW8gPSBjaGFubmVsc1ByZWZlcmVuY2UgJiYgcGFyc2VJbnQoY2hhbm5lbHNQcmVmZXJlbmNlKSA9PT0gMjtcbiAgLy8gVXNlIGZpcnN0IGxldmVsIHNldCB0byBkZXRlcm1pbmUgc3RlcmVvLCBhbmQgbWluaW11bSByZXNvbHV0aW9uIGFuZCBmcmFtZXJhdGVcbiAgbGV0IGhhc1N0ZXJlbyA9IHRydWU7XG4gIGxldCBoYXNDdXJyZW50VmlkZW9SYW5nZSA9IGZhbHNlO1xuICBsZXQgbWluSGVpZ2h0ID0gSW5maW5pdHk7XG4gIGxldCBtaW5GcmFtZXJhdGUgPSBJbmZpbml0eTtcbiAgbGV0IG1pbkJpdHJhdGUgPSBJbmZpbml0eTtcbiAgbGV0IHNlbGVjdGVkU2NvcmUgPSAwO1xuICBsZXQgdmlkZW9SYW5nZXMgPSBbXTtcbiAgY29uc3Qge1xuICAgIHByZWZlckhEUixcbiAgICBhbGxvd2VkVmlkZW9SYW5nZXNcbiAgfSA9IGdldFZpZGVvU2VsZWN0aW9uT3B0aW9ucyhjdXJyZW50VmlkZW9SYW5nZSwgdmlkZW9QcmVmZXJlbmNlKTtcbiAgZm9yIChsZXQgaSA9IGNvZGVjU2V0cy5sZW5ndGg7IGktLTspIHtcbiAgICBjb25zdCB0aWVyID0gY29kZWNUaWVyc1tjb2RlY1NldHNbaV1dO1xuICAgIGhhc1N0ZXJlbyA9IHRpZXIuY2hhbm5lbHNbMl0gPiAwO1xuICAgIG1pbkhlaWdodCA9IE1hdGgubWluKG1pbkhlaWdodCwgdGllci5taW5IZWlnaHQpO1xuICAgIG1pbkZyYW1lcmF0ZSA9IE1hdGgubWluKG1pbkZyYW1lcmF0ZSwgdGllci5taW5GcmFtZXJhdGUpO1xuICAgIG1pbkJpdHJhdGUgPSBNYXRoLm1pbihtaW5CaXRyYXRlLCB0aWVyLm1pbkJpdHJhdGUpO1xuICAgIGNvbnN0IG1hdGNoaW5nVmlkZW9SYW5nZXMgPSBhbGxvd2VkVmlkZW9SYW5nZXMuZmlsdGVyKHJhbmdlID0+IHRpZXIudmlkZW9SYW5nZXNbcmFuZ2VdID4gMCk7XG4gICAgaWYgKG1hdGNoaW5nVmlkZW9SYW5nZXMubGVuZ3RoID4gMCkge1xuICAgICAgaGFzQ3VycmVudFZpZGVvUmFuZ2UgPSB0cnVlO1xuICAgICAgdmlkZW9SYW5nZXMgPSBtYXRjaGluZ1ZpZGVvUmFuZ2VzO1xuICAgIH1cbiAgfVxuICBtaW5IZWlnaHQgPSBpc0Zpbml0ZU51bWJlcihtaW5IZWlnaHQpID8gbWluSGVpZ2h0IDogMDtcbiAgbWluRnJhbWVyYXRlID0gaXNGaW5pdGVOdW1iZXIobWluRnJhbWVyYXRlKSA/IG1pbkZyYW1lcmF0ZSA6IDA7XG4gIGNvbnN0IG1heEhlaWdodCA9IE1hdGgubWF4KDEwODAsIG1pbkhlaWdodCk7XG4gIGNvbnN0IG1heEZyYW1lcmF0ZSA9IE1hdGgubWF4KDMwLCBtaW5GcmFtZXJhdGUpO1xuICBtaW5CaXRyYXRlID0gaXNGaW5pdGVOdW1iZXIobWluQml0cmF0ZSkgPyBtaW5CaXRyYXRlIDogY3VycmVudEJ3O1xuICBjdXJyZW50QncgPSBNYXRoLm1heChtaW5CaXRyYXRlLCBjdXJyZW50QncpO1xuICAvLyBJZiB0aGVyZSBhcmUgbm8gdmFyaWFudHMgd2l0aCBtYXRjaGluZyBwcmVmZXJlbmNlLCBzZXQgY3VycmVudFZpZGVvUmFuZ2UgdG8gdW5kZWZpbmVkXG4gIGlmICghaGFzQ3VycmVudFZpZGVvUmFuZ2UpIHtcbiAgICBjdXJyZW50VmlkZW9SYW5nZSA9IHVuZGVmaW5lZDtcbiAgICB2aWRlb1JhbmdlcyA9IFtdO1xuICB9XG4gIGNvbnN0IGNvZGVjU2V0ID0gY29kZWNTZXRzLnJlZHVjZSgoc2VsZWN0ZWQsIGNhbmRpZGF0ZSkgPT4ge1xuICAgIC8vIFJlbW92ZSBjYW5kaWF0ZXMgd2hpY2ggZG8gbm90IG1lZXQgYml0cmF0ZSwgZGVmYXVsdCBhdWRpbywgc3RlcmVvIG9yIGNoYW5uZWxzIHByZWZlcmVuY2UsIDEwODBwIG9yIGxvd2VyLCAzMGZwcyBvciBsb3dlciwgb3IgU0RSL0hEUiBzZWxlY3Rpb24gaWYgcHJlc2VudFxuICAgIGNvbnN0IGNhbmRpZGF0ZVRpZXIgPSBjb2RlY1RpZXJzW2NhbmRpZGF0ZV07XG4gICAgaWYgKGNhbmRpZGF0ZSA9PT0gc2VsZWN0ZWQpIHtcbiAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICB9XG4gICAgaWYgKGNhbmRpZGF0ZVRpZXIubWluQml0cmF0ZSA+IGN1cnJlbnRCdykge1xuICAgICAgbG9nU3RhcnRDb2RlY0NhbmRpZGF0ZUlnbm9yZWQoY2FuZGlkYXRlLCBgbWluIGJpdHJhdGUgb2YgJHtjYW5kaWRhdGVUaWVyLm1pbkJpdHJhdGV9ID4gY3VycmVudCBlc3RpbWF0ZSBvZiAke2N1cnJlbnRCd31gKTtcbiAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICB9XG4gICAgaWYgKCFjYW5kaWRhdGVUaWVyLmhhc0RlZmF1bHRBdWRpbykge1xuICAgICAgbG9nU3RhcnRDb2RlY0NhbmRpZGF0ZUlnbm9yZWQoY2FuZGlkYXRlLCBgbm8gcmVuZGl0aW9ucyB3aXRoIGRlZmF1bHQgb3IgYXV0by1zZWxlY3Qgc291bmQgZm91bmRgKTtcbiAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICB9XG4gICAgaWYgKGF1ZGlvQ29kZWNQcmVmZXJlbmNlICYmIGNhbmRpZGF0ZS5pbmRleE9mKGF1ZGlvQ29kZWNQcmVmZXJlbmNlLnN1YnN0cmluZygwLCA0KSkgJSA1ICE9PSAwKSB7XG4gICAgICBsb2dTdGFydENvZGVjQ2FuZGlkYXRlSWdub3JlZChjYW5kaWRhdGUsIGBhdWRpbyBjb2RlYyBwcmVmZXJlbmNlIFwiJHthdWRpb0NvZGVjUHJlZmVyZW5jZX1cIiBub3QgZm91bmRgKTtcbiAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICB9XG4gICAgaWYgKGNoYW5uZWxzUHJlZmVyZW5jZSAmJiAhcHJlZmVyU3RlcmVvKSB7XG4gICAgICBpZiAoIWNhbmRpZGF0ZVRpZXIuY2hhbm5lbHNbY2hhbm5lbHNQcmVmZXJlbmNlXSkge1xuICAgICAgICBsb2dTdGFydENvZGVjQ2FuZGlkYXRlSWdub3JlZChjYW5kaWRhdGUsIGBubyByZW5kaXRpb25zIHdpdGggJHtjaGFubmVsc1ByZWZlcmVuY2V9IGNoYW5uZWwgc291bmQgZm91bmQgKGNoYW5uZWxzIG9wdGlvbnM6ICR7T2JqZWN0LmtleXMoY2FuZGlkYXRlVGllci5jaGFubmVscyl9KWApO1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgoIWF1ZGlvQ29kZWNQcmVmZXJlbmNlIHx8IHByZWZlclN0ZXJlbykgJiYgaGFzU3RlcmVvICYmIGNhbmRpZGF0ZVRpZXIuY2hhbm5lbHNbJzInXSA9PT0gMCkge1xuICAgICAgbG9nU3RhcnRDb2RlY0NhbmRpZGF0ZUlnbm9yZWQoY2FuZGlkYXRlLCBgbm8gcmVuZGl0aW9ucyB3aXRoIHN0ZXJlbyBzb3VuZCBmb3VuZGApO1xuICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgIH1cbiAgICBpZiAoY2FuZGlkYXRlVGllci5taW5IZWlnaHQgPiBtYXhIZWlnaHQpIHtcbiAgICAgIGxvZ1N0YXJ0Q29kZWNDYW5kaWRhdGVJZ25vcmVkKGNhbmRpZGF0ZSwgYG1pbiByZXNvbHV0aW9uIG9mICR7Y2FuZGlkYXRlVGllci5taW5IZWlnaHR9ID4gbWF4aW11bSBvZiAke21heEhlaWdodH1gKTtcbiAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICB9XG4gICAgaWYgKGNhbmRpZGF0ZVRpZXIubWluRnJhbWVyYXRlID4gbWF4RnJhbWVyYXRlKSB7XG4gICAgICBsb2dTdGFydENvZGVjQ2FuZGlkYXRlSWdub3JlZChjYW5kaWRhdGUsIGBtaW4gZnJhbWVyYXRlIG9mICR7Y2FuZGlkYXRlVGllci5taW5GcmFtZXJhdGV9ID4gbWF4aW11bSBvZiAke21heEZyYW1lcmF0ZX1gKTtcbiAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICB9XG4gICAgaWYgKCF2aWRlb1Jhbmdlcy5zb21lKHJhbmdlID0+IGNhbmRpZGF0ZVRpZXIudmlkZW9SYW5nZXNbcmFuZ2VdID4gMCkpIHtcbiAgICAgIGxvZ1N0YXJ0Q29kZWNDYW5kaWRhdGVJZ25vcmVkKGNhbmRpZGF0ZSwgYG5vIHZhcmlhbnRzIHdpdGggVklERU8tUkFOR0Ugb2YgJHtKU09OLnN0cmluZ2lmeSh2aWRlb1Jhbmdlcyl9IGZvdW5kYCk7XG4gICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgfVxuICAgIGlmIChjYW5kaWRhdGVUaWVyLm1heFNjb3JlIDwgc2VsZWN0ZWRTY29yZSkge1xuICAgICAgbG9nU3RhcnRDb2RlY0NhbmRpZGF0ZUlnbm9yZWQoY2FuZGlkYXRlLCBgbWF4IHNjb3JlIG9mICR7Y2FuZGlkYXRlVGllci5tYXhTY29yZX0gPCBzZWxlY3RlZCBtYXggb2YgJHtzZWxlY3RlZFNjb3JlfWApO1xuICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgY2FuZGlhdGVzIHdpdGggbGVzcyBwcmVmZXJyZWQgY29kZWNzIG9yIG1vcmUgZXJyb3JzXG4gICAgaWYgKHNlbGVjdGVkICYmIChjb2RlY3NTZXRTZWxlY3Rpb25QcmVmZXJlbmNlVmFsdWUoY2FuZGlkYXRlKSA+PSBjb2RlY3NTZXRTZWxlY3Rpb25QcmVmZXJlbmNlVmFsdWUoc2VsZWN0ZWQpIHx8IGNhbmRpZGF0ZVRpZXIuZnJhZ21lbnRFcnJvciA+IGNvZGVjVGllcnNbc2VsZWN0ZWRdLmZyYWdtZW50RXJyb3IpKSB7XG4gICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgfVxuICAgIHNlbGVjdGVkU2NvcmUgPSBjYW5kaWRhdGVUaWVyLm1heFNjb3JlO1xuICAgIHJldHVybiBjYW5kaWRhdGU7XG4gIH0sIHVuZGVmaW5lZCk7XG4gIHJldHVybiB7XG4gICAgY29kZWNTZXQsXG4gICAgdmlkZW9SYW5nZXMsXG4gICAgcHJlZmVySERSLFxuICAgIG1pbkZyYW1lcmF0ZSxcbiAgICBtaW5CaXRyYXRlXG4gIH07XG59XG5mdW5jdGlvbiBsb2dTdGFydENvZGVjQ2FuZGlkYXRlSWdub3JlZChjb2RlU2V0LCByZWFzb24pIHtcbiAgbG9nZ2VyLmxvZyhgW2Ficl0gc3RhcnQgY2FuZGlkYXRlcyB3aXRoIFwiJHtjb2RlU2V0fVwiIGlnbm9yZWQgYmVjYXVzZSAke3JlYXNvbn1gKTtcbn1cbmZ1bmN0aW9uIGdldEF1ZGlvVHJhY2tzQnlHcm91cChhbGxBdWRpb1RyYWNrcykge1xuICByZXR1cm4gYWxsQXVkaW9UcmFja3MucmVkdWNlKChhdWRpb1RyYWNrc0J5R3JvdXAsIHRyYWNrKSA9PiB7XG4gICAgbGV0IHRyYWNrR3JvdXAgPSBhdWRpb1RyYWNrc0J5R3JvdXAuZ3JvdXBzW3RyYWNrLmdyb3VwSWRdO1xuICAgIGlmICghdHJhY2tHcm91cCkge1xuICAgICAgdHJhY2tHcm91cCA9IGF1ZGlvVHJhY2tzQnlHcm91cC5ncm91cHNbdHJhY2suZ3JvdXBJZF0gPSB7XG4gICAgICAgIHRyYWNrczogW10sXG4gICAgICAgIGNoYW5uZWxzOiB7XG4gICAgICAgICAgMjogMFxuICAgICAgICB9LFxuICAgICAgICBoYXNEZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgaGFzQXV0b1NlbGVjdDogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIHRyYWNrR3JvdXAudHJhY2tzLnB1c2godHJhY2spO1xuICAgIGNvbnN0IGNoYW5uZWxzS2V5ID0gdHJhY2suY2hhbm5lbHMgfHwgJzInO1xuICAgIHRyYWNrR3JvdXAuY2hhbm5lbHNbY2hhbm5lbHNLZXldID0gKHRyYWNrR3JvdXAuY2hhbm5lbHNbY2hhbm5lbHNLZXldIHx8IDApICsgMTtcbiAgICB0cmFja0dyb3VwLmhhc0RlZmF1bHQgPSB0cmFja0dyb3VwLmhhc0RlZmF1bHQgfHwgdHJhY2suZGVmYXVsdDtcbiAgICB0cmFja0dyb3VwLmhhc0F1dG9TZWxlY3QgPSB0cmFja0dyb3VwLmhhc0F1dG9TZWxlY3QgfHwgdHJhY2suYXV0b3NlbGVjdDtcbiAgICBpZiAodHJhY2tHcm91cC5oYXNEZWZhdWx0KSB7XG4gICAgICBhdWRpb1RyYWNrc0J5R3JvdXAuaGFzRGVmYXVsdEF1ZGlvID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRyYWNrR3JvdXAuaGFzQXV0b1NlbGVjdCkge1xuICAgICAgYXVkaW9UcmFja3NCeUdyb3VwLmhhc0F1dG9TZWxlY3RBdWRpbyA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBhdWRpb1RyYWNrc0J5R3JvdXA7XG4gIH0sIHtcbiAgICBoYXNEZWZhdWx0QXVkaW86IGZhbHNlLFxuICAgIGhhc0F1dG9TZWxlY3RBdWRpbzogZmFsc2UsXG4gICAgZ3JvdXBzOiB7fVxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldENvZGVjVGllcnMobGV2ZWxzLCBhdWRpb1RyYWNrc0J5R3JvdXAsIG1pbkF1dG9MZXZlbCwgbWF4QXV0b0xldmVsKSB7XG4gIHJldHVybiBsZXZlbHMuc2xpY2UobWluQXV0b0xldmVsLCBtYXhBdXRvTGV2ZWwgKyAxKS5yZWR1Y2UoKHRpZXJzLCBsZXZlbCkgPT4ge1xuICAgIGlmICghbGV2ZWwuY29kZWNTZXQpIHtcbiAgICAgIHJldHVybiB0aWVycztcbiAgICB9XG4gICAgY29uc3QgYXVkaW9Hcm91cHMgPSBsZXZlbC5hdWRpb0dyb3VwcztcbiAgICBsZXQgdGllciA9IHRpZXJzW2xldmVsLmNvZGVjU2V0XTtcbiAgICBpZiAoIXRpZXIpIHtcbiAgICAgIHRpZXJzW2xldmVsLmNvZGVjU2V0XSA9IHRpZXIgPSB7XG4gICAgICAgIG1pbkJpdHJhdGU6IEluZmluaXR5LFxuICAgICAgICBtaW5IZWlnaHQ6IEluZmluaXR5LFxuICAgICAgICBtaW5GcmFtZXJhdGU6IEluZmluaXR5LFxuICAgICAgICBtYXhTY29yZTogMCxcbiAgICAgICAgdmlkZW9SYW5nZXM6IHtcbiAgICAgICAgICBTRFI6IDBcbiAgICAgICAgfSxcbiAgICAgICAgY2hhbm5lbHM6IHtcbiAgICAgICAgICAnMic6IDBcbiAgICAgICAgfSxcbiAgICAgICAgaGFzRGVmYXVsdEF1ZGlvOiAhYXVkaW9Hcm91cHMsXG4gICAgICAgIGZyYWdtZW50RXJyb3I6IDBcbiAgICAgIH07XG4gICAgfVxuICAgIHRpZXIubWluQml0cmF0ZSA9IE1hdGgubWluKHRpZXIubWluQml0cmF0ZSwgbGV2ZWwuYml0cmF0ZSk7XG4gICAgY29uc3QgbGVzc2VyV2lkdGhPckhlaWdodCA9IE1hdGgubWluKGxldmVsLmhlaWdodCwgbGV2ZWwud2lkdGgpO1xuICAgIHRpZXIubWluSGVpZ2h0ID0gTWF0aC5taW4odGllci5taW5IZWlnaHQsIGxlc3NlcldpZHRoT3JIZWlnaHQpO1xuICAgIHRpZXIubWluRnJhbWVyYXRlID0gTWF0aC5taW4odGllci5taW5GcmFtZXJhdGUsIGxldmVsLmZyYW1lUmF0ZSk7XG4gICAgdGllci5tYXhTY29yZSA9IE1hdGgubWF4KHRpZXIubWF4U2NvcmUsIGxldmVsLnNjb3JlKTtcbiAgICB0aWVyLmZyYWdtZW50RXJyb3IgKz0gbGV2ZWwuZnJhZ21lbnRFcnJvcjtcbiAgICB0aWVyLnZpZGVvUmFuZ2VzW2xldmVsLnZpZGVvUmFuZ2VdID0gKHRpZXIudmlkZW9SYW5nZXNbbGV2ZWwudmlkZW9SYW5nZV0gfHwgMCkgKyAxO1xuICAgIGlmIChhdWRpb0dyb3Vwcykge1xuICAgICAgYXVkaW9Hcm91cHMuZm9yRWFjaChhdWRpb0dyb3VwSWQgPT4ge1xuICAgICAgICBpZiAoIWF1ZGlvR3JvdXBJZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhdWRpb0dyb3VwID0gYXVkaW9UcmFja3NCeUdyb3VwLmdyb3Vwc1thdWRpb0dyb3VwSWRdO1xuICAgICAgICAvLyBEZWZhdWx0IGF1ZGlvIGlzIGFueSBncm91cCB3aXRoIERFRkFVTFQ9WUVTLCBvciBpZiBtaXNzaW5nIHRoZW4gYW55IGdyb3VwIHdpdGggQVVUT1NFTEVDVD1ZRVMsIG9yIGFsbCB2YXJpYW50c1xuICAgICAgICB0aWVyLmhhc0RlZmF1bHRBdWRpbyA9IHRpZXIuaGFzRGVmYXVsdEF1ZGlvIHx8IGF1ZGlvVHJhY2tzQnlHcm91cC5oYXNEZWZhdWx0QXVkaW8gPyBhdWRpb0dyb3VwLmhhc0RlZmF1bHQgOiBhdWRpb0dyb3VwLmhhc0F1dG9TZWxlY3QgfHwgIWF1ZGlvVHJhY2tzQnlHcm91cC5oYXNEZWZhdWx0QXVkaW8gJiYgIWF1ZGlvVHJhY2tzQnlHcm91cC5oYXNBdXRvU2VsZWN0QXVkaW87XG4gICAgICAgIE9iamVjdC5rZXlzKGF1ZGlvR3JvdXAuY2hhbm5lbHMpLmZvckVhY2goY2hhbm5lbHMgPT4ge1xuICAgICAgICAgIHRpZXIuY2hhbm5lbHNbY2hhbm5lbHNdID0gKHRpZXIuY2hhbm5lbHNbY2hhbm5lbHNdIHx8IDApICsgYXVkaW9Hcm91cC5jaGFubmVsc1tjaGFubmVsc107XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aWVycztcbiAgfSwge30pO1xufVxuZnVuY3Rpb24gZmluZE1hdGNoaW5nT3B0aW9uKG9wdGlvbiwgdHJhY2tzLCBtYXRjaFByZWRpY2F0ZSkge1xuICBpZiAoJ2F0dHJzJyBpbiBvcHRpb24pIHtcbiAgICBjb25zdCBpbmRleCA9IHRyYWNrcy5pbmRleE9mKG9wdGlvbik7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRyYWNrID0gdHJhY2tzW2ldO1xuICAgIGlmIChtYXRjaGVzT3B0aW9uKG9wdGlvbiwgdHJhY2ssIG1hdGNoUHJlZGljYXRlKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIG1hdGNoZXNPcHRpb24ob3B0aW9uLCB0cmFjaywgbWF0Y2hQcmVkaWNhdGUpIHtcbiAgY29uc3Qge1xuICAgIGdyb3VwSWQsXG4gICAgbmFtZSxcbiAgICBsYW5nLFxuICAgIGFzc29jTGFuZyxcbiAgICBjaGFyYWN0ZXJpc3RpY3MsXG4gICAgZGVmYXVsdDogaXNEZWZhdWx0XG4gIH0gPSBvcHRpb247XG4gIGNvbnN0IGZvcmNlZCA9IG9wdGlvbi5mb3JjZWQ7XG4gIHJldHVybiAoZ3JvdXBJZCA9PT0gdW5kZWZpbmVkIHx8IHRyYWNrLmdyb3VwSWQgPT09IGdyb3VwSWQpICYmIChuYW1lID09PSB1bmRlZmluZWQgfHwgdHJhY2submFtZSA9PT0gbmFtZSkgJiYgKGxhbmcgPT09IHVuZGVmaW5lZCB8fCB0cmFjay5sYW5nID09PSBsYW5nKSAmJiAobGFuZyA9PT0gdW5kZWZpbmVkIHx8IHRyYWNrLmFzc29jTGFuZyA9PT0gYXNzb2NMYW5nKSAmJiAoaXNEZWZhdWx0ID09PSB1bmRlZmluZWQgfHwgdHJhY2suZGVmYXVsdCA9PT0gaXNEZWZhdWx0KSAmJiAoZm9yY2VkID09PSB1bmRlZmluZWQgfHwgdHJhY2suZm9yY2VkID09PSBmb3JjZWQpICYmIChjaGFyYWN0ZXJpc3RpY3MgPT09IHVuZGVmaW5lZCB8fCBjaGFyYWN0ZXJpc3RpY3NNYXRjaChjaGFyYWN0ZXJpc3RpY3MsIHRyYWNrLmNoYXJhY3RlcmlzdGljcykpICYmIChtYXRjaFByZWRpY2F0ZSA9PT0gdW5kZWZpbmVkIHx8IG1hdGNoUHJlZGljYXRlKG9wdGlvbiwgdHJhY2spKTtcbn1cbmZ1bmN0aW9uIGNoYXJhY3RlcmlzdGljc01hdGNoKGNoYXJhY3RlcmlzdGljc0EsIGNoYXJhY3RlcmlzdGljc0IgPSAnJykge1xuICBjb25zdCBhcnJBID0gY2hhcmFjdGVyaXN0aWNzQS5zcGxpdCgnLCcpO1xuICBjb25zdCBhcnJCID0gY2hhcmFjdGVyaXN0aWNzQi5zcGxpdCgnLCcpO1xuICAvLyBFeHBlY3RzIGVhY2ggaXRlbSB0byBiZSB1bmlxdWU6XG4gIHJldHVybiBhcnJBLmxlbmd0aCA9PT0gYXJyQi5sZW5ndGggJiYgIWFyckEuc29tZShlbCA9PiBhcnJCLmluZGV4T2YoZWwpID09PSAtMSk7XG59XG5mdW5jdGlvbiBhdWRpb01hdGNoUHJlZGljYXRlKG9wdGlvbiwgdHJhY2spIHtcbiAgY29uc3Qge1xuICAgIGF1ZGlvQ29kZWMsXG4gICAgY2hhbm5lbHNcbiAgfSA9IG9wdGlvbjtcbiAgcmV0dXJuIChhdWRpb0NvZGVjID09PSB1bmRlZmluZWQgfHwgKHRyYWNrLmF1ZGlvQ29kZWMgfHwgJycpLnN1YnN0cmluZygwLCA0KSA9PT0gYXVkaW9Db2RlYy5zdWJzdHJpbmcoMCwgNCkpICYmIChjaGFubmVscyA9PT0gdW5kZWZpbmVkIHx8IGNoYW5uZWxzID09PSAodHJhY2suY2hhbm5lbHMgfHwgJzInKSk7XG59XG5mdW5jdGlvbiBmaW5kQ2xvc2VzdExldmVsV2l0aEF1ZGlvR3JvdXAob3B0aW9uLCBsZXZlbHMsIGFsbEF1ZGlvVHJhY2tzLCBzZWFyY2hJbmRleCwgbWF0Y2hQcmVkaWNhdGUpIHtcbiAgY29uc3QgY3VycmVudExldmVsID0gbGV2ZWxzW3NlYXJjaEluZGV4XTtcbiAgLy8gQXJlIHRoZXJlIHZhcmlhbnRzIHdpdGggc2FtZSBVUkkgYXMgY3VycmVudCBsZXZlbD9cbiAgLy8gSWYgc28sIGZpbmQgYSBtYXRjaCB0aGF0IGRvZXMgbm90IHJlcXVpcmUgYW55IGxldmVsIFVSSSBjaGFuZ2VcbiAgY29uc3QgdmFyaWFudHMgPSBsZXZlbHMucmVkdWNlKCh2YXJpYW50TWFwLCBsZXZlbCwgaW5kZXgpID0+IHtcbiAgICBjb25zdCB1cmkgPSBsZXZlbC51cmk7XG4gICAgY29uc3QgcmVuZGl0aW9ucyA9IHZhcmlhbnRNYXBbdXJpXSB8fCAodmFyaWFudE1hcFt1cmldID0gW10pO1xuICAgIHJlbmRpdGlvbnMucHVzaChpbmRleCk7XG4gICAgcmV0dXJuIHZhcmlhbnRNYXA7XG4gIH0sIHt9KTtcbiAgY29uc3QgcmVuZGl0aW9ucyA9IHZhcmlhbnRzW2N1cnJlbnRMZXZlbC51cmldO1xuICBpZiAocmVuZGl0aW9ucy5sZW5ndGggPiAxKSB7XG4gICAgc2VhcmNoSW5kZXggPSBNYXRoLm1heC5hcHBseShNYXRoLCByZW5kaXRpb25zKTtcbiAgfVxuICAvLyBGaW5kIGJlc3QgbWF0Y2hcbiAgY29uc3QgY3VycmVudFZpZGVvUmFuZ2UgPSBjdXJyZW50TGV2ZWwudmlkZW9SYW5nZTtcbiAgY29uc3QgY3VycmVudEZyYW1lUmF0ZSA9IGN1cnJlbnRMZXZlbC5mcmFtZVJhdGU7XG4gIGNvbnN0IGN1cnJlbnRWaWRlb0NvZGVjID0gY3VycmVudExldmVsLmNvZGVjU2V0LnN1YnN0cmluZygwLCA0KTtcbiAgY29uc3QgbWF0Y2hpbmdWaWRlbyA9IHNlYXJjaERvd25BbmRVcExpc3QobGV2ZWxzLCBzZWFyY2hJbmRleCwgbGV2ZWwgPT4ge1xuICAgIGlmIChsZXZlbC52aWRlb1JhbmdlICE9PSBjdXJyZW50VmlkZW9SYW5nZSB8fCBsZXZlbC5mcmFtZVJhdGUgIT09IGN1cnJlbnRGcmFtZVJhdGUgfHwgbGV2ZWwuY29kZWNTZXQuc3Vic3RyaW5nKDAsIDQpICE9PSBjdXJyZW50VmlkZW9Db2RlYykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhdWRpb0dyb3VwcyA9IGxldmVsLmF1ZGlvR3JvdXBzO1xuICAgIGNvbnN0IHRyYWNrcyA9IGFsbEF1ZGlvVHJhY2tzLmZpbHRlcih0cmFjayA9PiAhYXVkaW9Hcm91cHMgfHwgYXVkaW9Hcm91cHMuaW5kZXhPZih0cmFjay5ncm91cElkKSAhPT0gLTEpO1xuICAgIHJldHVybiBmaW5kTWF0Y2hpbmdPcHRpb24ob3B0aW9uLCB0cmFja3MsIG1hdGNoUHJlZGljYXRlKSA+IC0xO1xuICB9KTtcbiAgaWYgKG1hdGNoaW5nVmlkZW8gPiAtMSkge1xuICAgIHJldHVybiBtYXRjaGluZ1ZpZGVvO1xuICB9XG4gIHJldHVybiBzZWFyY2hEb3duQW5kVXBMaXN0KGxldmVscywgc2VhcmNoSW5kZXgsIGxldmVsID0+IHtcbiAgICBjb25zdCBhdWRpb0dyb3VwcyA9IGxldmVsLmF1ZGlvR3JvdXBzO1xuICAgIGNvbnN0IHRyYWNrcyA9IGFsbEF1ZGlvVHJhY2tzLmZpbHRlcih0cmFjayA9PiAhYXVkaW9Hcm91cHMgfHwgYXVkaW9Hcm91cHMuaW5kZXhPZih0cmFjay5ncm91cElkKSAhPT0gLTEpO1xuICAgIHJldHVybiBmaW5kTWF0Y2hpbmdPcHRpb24ob3B0aW9uLCB0cmFja3MsIG1hdGNoUHJlZGljYXRlKSA+IC0xO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHNlYXJjaERvd25BbmRVcExpc3QoYXJyLCBzZWFyY2hJbmRleCwgcHJlZGljYXRlKSB7XG4gIGZvciAobGV0IGkgPSBzZWFyY2hJbmRleDsgaTsgaS0tKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJbaV0pKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IHNlYXJjaEluZGV4ICsgMTsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyW2ldKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuY2xhc3MgQWJyQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKF9obHMpIHtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmxhc3RMZXZlbExvYWRTZWMgPSAwO1xuICAgIHRoaXMubGFzdExvYWRlZEZyYWdMZXZlbCA9IC0xO1xuICAgIHRoaXMuZmlyc3RTZWxlY3Rpb24gPSAtMTtcbiAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gLTE7XG4gICAgdGhpcy5uZXh0QXV0b0xldmVsS2V5ID0gJyc7XG4gICAgdGhpcy5hdWRpb1RyYWNrc0J5R3JvdXAgPSBudWxsO1xuICAgIHRoaXMuY29kZWNUaWVycyA9IG51bGw7XG4gICAgdGhpcy50aW1lciA9IC0xO1xuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMucGFydEN1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMuYml0cmF0ZVRlc3REZWxheSA9IDA7XG4gICAgdGhpcy5id0VzdGltYXRvciA9IHZvaWQgMDtcbiAgICAvKlxuICAgICAgICBUaGlzIG1ldGhvZCBtb25pdG9ycyB0aGUgZG93bmxvYWQgcmF0ZSBvZiB0aGUgY3VycmVudCBmcmFnbWVudCwgYW5kIHdpbGwgZG93bnN3aXRjaCBpZiB0aGF0IGZyYWdtZW50IHdpbGwgbm90IGxvYWRcbiAgICAgICAgcXVpY2tseSBlbm91Z2ggdG8gcHJldmVudCB1bmRlcmJ1ZmZlcmluZ1xuICAgICAgKi9cbiAgICB0aGlzLl9hYmFuZG9uUnVsZXNDaGVjayA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZnJhZ0N1cnJlbnQ6IGZyYWcsXG4gICAgICAgIHBhcnRDdXJyZW50OiBwYXJ0LFxuICAgICAgICBobHNcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBhdXRvTGV2ZWxFbmFibGVkLFxuICAgICAgICBtZWRpYVxuICAgICAgfSA9IGhscztcbiAgICAgIGlmICghZnJhZyB8fCAhbWVkaWEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCBzdGF0cyA9IHBhcnQgPyBwYXJ0LnN0YXRzIDogZnJhZy5zdGF0cztcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gcGFydCA/IHBhcnQuZHVyYXRpb24gOiBmcmFnLmR1cmF0aW9uO1xuICAgICAgY29uc3QgdGltZUxvYWRpbmcgPSBub3cgLSBzdGF0cy5sb2FkaW5nLnN0YXJ0O1xuICAgICAgY29uc3QgbWluQXV0b0xldmVsID0gaGxzLm1pbkF1dG9MZXZlbDtcbiAgICAgIC8vIElmIGZyYWcgbG9hZGluZyBpcyBhYm9ydGVkLCBjb21wbGV0ZSwgb3IgZnJvbSBsb3dlc3QgbGV2ZWwsIHN0b3AgdGltZXIgYW5kIHJldHVyblxuICAgICAgaWYgKHN0YXRzLmFib3J0ZWQgfHwgc3RhdHMubG9hZGVkICYmIHN0YXRzLmxvYWRlZCA9PT0gc3RhdHMudG90YWwgfHwgZnJhZy5sZXZlbCA8PSBtaW5BdXRvTGV2ZWwpIHtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICAgIC8vIHJlc2V0IGZvcmNlZCBhdXRvIGxldmVsIHZhbHVlIHNvIHRoYXQgbmV4dCBsZXZlbCB3aWxsIGJlIHNlbGVjdGVkXG4gICAgICAgIHRoaXMuX25leHRBdXRvTGV2ZWwgPSAtMTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGlzIGNoZWNrIG9ubHkgcnVucyBpZiB3ZSdyZSBpbiBBQlIgbW9kZSBhbmQgYWN0dWFsbHkgcGxheWluZ1xuICAgICAgaWYgKCFhdXRvTGV2ZWxFbmFibGVkIHx8IG1lZGlhLnBhdXNlZCB8fCAhbWVkaWEucGxheWJhY2tSYXRlIHx8ICFtZWRpYS5yZWFkeVN0YXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBobHMubWFpbkZvcndhcmRCdWZmZXJJbmZvO1xuICAgICAgaWYgKGJ1ZmZlckluZm8gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdHRmYkVzdGltYXRlID0gdGhpcy5id0VzdGltYXRvci5nZXRFc3RpbWF0ZVRURkIoKTtcbiAgICAgIGNvbnN0IHBsYXliYWNrUmF0ZSA9IE1hdGguYWJzKG1lZGlhLnBsYXliYWNrUmF0ZSk7XG4gICAgICAvLyBUbyBtYWludGFpbiBzdGFibGUgYWRhcHRpdmUgcGxheWJhY2ssIG9ubHkgYmVnaW4gbW9uaXRvcmluZyBmcmFnIGxvYWRpbmcgYWZ0ZXIgaGFsZiBvciBtb3JlIG9mIGl0cyBwbGF5YmFjayBkdXJhdGlvbiBoYXMgcGFzc2VkXG4gICAgICBpZiAodGltZUxvYWRpbmcgPD0gTWF0aC5tYXgodHRmYkVzdGltYXRlLCAxMDAwICogKGR1cmF0aW9uIC8gKHBsYXliYWNrUmF0ZSAqIDIpKSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBidWZmZXJTdGFydmF0aW9uRGVsYXkgaXMgYW4gZXN0aW1hdGUgb2YgdGhlIGFtb3VudCB0aW1lIChpbiBzZWNvbmRzKSBpdCB3aWxsIHRha2UgdG8gZXhoYXVzdCB0aGUgYnVmZmVyXG4gICAgICBjb25zdCBidWZmZXJTdGFydmF0aW9uRGVsYXkgPSBidWZmZXJJbmZvLmxlbiAvIHBsYXliYWNrUmF0ZTtcbiAgICAgIGNvbnN0IHR0ZmIgPSBzdGF0cy5sb2FkaW5nLmZpcnN0ID8gc3RhdHMubG9hZGluZy5maXJzdCAtIHN0YXRzLmxvYWRpbmcuc3RhcnQgOiAtMTtcbiAgICAgIGNvbnN0IGxvYWRlZEZpcnN0Qnl0ZSA9IHN0YXRzLmxvYWRlZCAmJiB0dGZiID4gLTE7XG4gICAgICBjb25zdCBid0VzdGltYXRlID0gdGhpcy5nZXRCd0VzdGltYXRlKCk7XG4gICAgICBjb25zdCBsZXZlbHMgPSBobHMubGV2ZWxzO1xuICAgICAgY29uc3QgbGV2ZWwgPSBsZXZlbHNbZnJhZy5sZXZlbF07XG4gICAgICBjb25zdCBleHBlY3RlZExlbiA9IHN0YXRzLnRvdGFsIHx8IE1hdGgubWF4KHN0YXRzLmxvYWRlZCwgTWF0aC5yb3VuZChkdXJhdGlvbiAqIGxldmVsLmF2ZXJhZ2VCaXRyYXRlIC8gOCkpO1xuICAgICAgbGV0IHRpbWVTdHJlYW1pbmcgPSBsb2FkZWRGaXJzdEJ5dGUgPyB0aW1lTG9hZGluZyAtIHR0ZmIgOiB0aW1lTG9hZGluZztcbiAgICAgIGlmICh0aW1lU3RyZWFtaW5nIDwgMSAmJiBsb2FkZWRGaXJzdEJ5dGUpIHtcbiAgICAgICAgdGltZVN0cmVhbWluZyA9IE1hdGgubWluKHRpbWVMb2FkaW5nLCBzdGF0cy5sb2FkZWQgKiA4IC8gYndFc3RpbWF0ZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBsb2FkUmF0ZSA9IGxvYWRlZEZpcnN0Qnl0ZSA/IHN0YXRzLmxvYWRlZCAqIDEwMDAgLyB0aW1lU3RyZWFtaW5nIDogMDtcbiAgICAgIC8vIGZyYWdMb2FkRGVsYXkgaXMgYW4gZXN0aW1hdGUgb2YgdGhlIHRpbWUgKGluIHNlY29uZHMpIGl0IHdpbGwgdGFrZSB0byBidWZmZXIgdGhlIHJlbWFpbmRlciBvZiB0aGUgZnJhZ21lbnRcbiAgICAgIGNvbnN0IGZyYWdMb2FkZWREZWxheSA9IGxvYWRSYXRlID8gKGV4cGVjdGVkTGVuIC0gc3RhdHMubG9hZGVkKSAvIGxvYWRSYXRlIDogZXhwZWN0ZWRMZW4gKiA4IC8gYndFc3RpbWF0ZSArIHR0ZmJFc3RpbWF0ZSAvIDEwMDA7XG4gICAgICAvLyBPbmx5IGRvd25zd2l0Y2ggaWYgdGhlIHRpbWUgdG8gZmluaXNoIGxvYWRpbmcgdGhlIGN1cnJlbnQgZnJhZ21lbnQgaXMgZ3JlYXRlciB0aGFuIHRoZSBhbW91bnQgb2YgYnVmZmVyIGxlZnRcbiAgICAgIGlmIChmcmFnTG9hZGVkRGVsYXkgPD0gYnVmZmVyU3RhcnZhdGlvbkRlbGF5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJ3ZSA9IGxvYWRSYXRlID8gbG9hZFJhdGUgKiA4IDogYndFc3RpbWF0ZTtcbiAgICAgIGxldCBmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICBsZXQgbmV4dExvYWRMZXZlbDtcbiAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBsb3dlciBsZXZlbCBhbmQgdHJ5IHRvIGZpbmQgdGhlIGxhcmdlc3Qgb25lIHRoYXQgYXZvaWRzIHJlYnVmZmVyaW5nXG4gICAgICBmb3IgKG5leHRMb2FkTGV2ZWwgPSBmcmFnLmxldmVsIC0gMTsgbmV4dExvYWRMZXZlbCA+IG1pbkF1dG9MZXZlbDsgbmV4dExvYWRMZXZlbC0tKSB7XG4gICAgICAgIC8vIGNvbXB1dGUgdGltZSB0byBsb2FkIG5leHQgZnJhZ21lbnQgYXQgbG93ZXIgbGV2ZWxcbiAgICAgICAgLy8gOCA9IGJpdHMgcGVyIGJ5dGUgKGJwcy9CcHMpXG4gICAgICAgIGNvbnN0IGxldmVsTmV4dEJpdHJhdGUgPSBsZXZlbHNbbmV4dExvYWRMZXZlbF0ubWF4Qml0cmF0ZTtcbiAgICAgICAgZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5ID0gdGhpcy5nZXRUaW1lVG9Mb2FkRnJhZyh0dGZiRXN0aW1hdGUgLyAxMDAwLCBid2UsIGR1cmF0aW9uICogbGV2ZWxOZXh0Qml0cmF0ZSwgIWxldmVsc1tuZXh0TG9hZExldmVsXS5kZXRhaWxzKTtcbiAgICAgICAgaWYgKGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA8IGJ1ZmZlclN0YXJ2YXRpb25EZWxheSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBPbmx5IGVtZXJnZW5jeSBzd2l0Y2ggZG93biBpZiBpdCB0YWtlcyBsZXNzIHRpbWUgdG8gbG9hZCBhIG5ldyBmcmFnbWVudCBhdCBsb3dlc3QgbGV2ZWwgaW5zdGVhZCBvZiBjb250aW51aW5nXG4gICAgICAvLyB0byBsb2FkIHRoZSBjdXJyZW50IG9uZVxuICAgICAgaWYgKGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA+PSBmcmFnTG9hZGVkRGVsYXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBlc3RpbWF0ZWQgbG9hZCB0aW1lIG9mIG5ldyBzZWdtZW50IGlzIGNvbXBsZXRlbHkgdW5yZWFzb25hYmxlLCBpZ25vcmUgYW5kIGRvIG5vdCBlbWVyZ2VuY3kgc3dpdGNoIGRvd25cbiAgICAgIGlmIChmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkgPiBkdXJhdGlvbiAqIDEwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGhscy5uZXh0TG9hZExldmVsID0gaGxzLm5leHRBdXRvTGV2ZWwgPSBuZXh0TG9hZExldmVsO1xuICAgICAgaWYgKGxvYWRlZEZpcnN0Qnl0ZSkge1xuICAgICAgICAvLyBJZiB0aGVyZSBoYXMgYmVlbiBsb2FkaW5nIHByb2dyZXNzLCBzYW1wbGUgYmFuZHdpZHRoIHVzaW5nIGxvYWRpbmcgdGltZSBvZmZzZXQgYnkgbWluaW11bSBUVEZCIHRpbWVcbiAgICAgICAgdGhpcy5id0VzdGltYXRvci5zYW1wbGUodGltZUxvYWRpbmcgLSBNYXRoLm1pbih0dGZiRXN0aW1hdGUsIHR0ZmIpLCBzdGF0cy5sb2FkZWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgaGFzIGJlZW4gbm8gbG9hZGluZyBwcm9ncmVzcywgc2FtcGxlIFRURkJcbiAgICAgICAgdGhpcy5id0VzdGltYXRvci5zYW1wbGVUVEZCKHRpbWVMb2FkaW5nKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5leHRMb2FkTGV2ZWxCaXRyYXRlID0gbGV2ZWxzW25leHRMb2FkTGV2ZWxdLm1heEJpdHJhdGU7XG4gICAgICBpZiAodGhpcy5nZXRCd0VzdGltYXRlKCkgKiB0aGlzLmhscy5jb25maWcuYWJyQmFuZFdpZHRoVXBGYWN0b3IgPiBuZXh0TG9hZExldmVsQml0cmF0ZSkge1xuICAgICAgICB0aGlzLnJlc2V0RXN0aW1hdG9yKG5leHRMb2FkTGV2ZWxCaXRyYXRlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgbG9nZ2VyLndhcm4oYFthYnJdIEZyYWdtZW50ICR7ZnJhZy5zbn0ke3BhcnQgPyAnIHBhcnQgJyArIHBhcnQuaW5kZXggOiAnJ30gb2YgbGV2ZWwgJHtmcmFnLmxldmVsfSBpcyBsb2FkaW5nIHRvbyBzbG93bHk7XG4gICAgICBUaW1lIHRvIHVuZGVyYnVmZmVyOiAke2J1ZmZlclN0YXJ2YXRpb25EZWxheS50b0ZpeGVkKDMpfSBzXG4gICAgICBFc3RpbWF0ZWQgbG9hZCB0aW1lIGZvciBjdXJyZW50IGZyYWdtZW50OiAke2ZyYWdMb2FkZWREZWxheS50b0ZpeGVkKDMpfSBzXG4gICAgICBFc3RpbWF0ZWQgbG9hZCB0aW1lIGZvciBkb3duIHN3aXRjaCBmcmFnbWVudDogJHtmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkudG9GaXhlZCgzKX0gc1xuICAgICAgVFRGQiBlc3RpbWF0ZTogJHt0dGZiIHwgMH0gbXNcbiAgICAgIEN1cnJlbnQgQlcgZXN0aW1hdGU6ICR7aXNGaW5pdGVOdW1iZXIoYndFc3RpbWF0ZSkgPyBid0VzdGltYXRlIHwgMCA6ICdVbmtub3duJ30gYnBzXG4gICAgICBOZXcgQlcgZXN0aW1hdGU6ICR7dGhpcy5nZXRCd0VzdGltYXRlKCkgfCAwfSBicHNcbiAgICAgIFN3aXRjaGluZyB0byBsZXZlbCAke25leHRMb2FkTGV2ZWx9IEAgJHtuZXh0TG9hZExldmVsQml0cmF0ZSB8IDB9IGJwc2ApO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRCwge1xuICAgICAgICBmcmFnLFxuICAgICAgICBwYXJ0LFxuICAgICAgICBzdGF0c1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLmhscyA9IF9obHM7XG4gICAgdGhpcy5id0VzdGltYXRvciA9IHRoaXMuaW5pdEVzdGltYXRvcigpO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICByZXNldEVzdGltYXRvcihhYnJFd21hRGVmYXVsdEVzdGltYXRlKSB7XG4gICAgaWYgKGFickV3bWFEZWZhdWx0RXN0aW1hdGUpIHtcbiAgICAgIGxvZ2dlci5sb2coYHNldHRpbmcgaW5pdGlhbCBid2UgdG8gJHthYnJFd21hRGVmYXVsdEVzdGltYXRlfWApO1xuICAgICAgdGhpcy5obHMuY29uZmlnLmFickV3bWFEZWZhdWx0RXN0aW1hdGUgPSBhYnJFd21hRGVmYXVsdEVzdGltYXRlO1xuICAgIH1cbiAgICB0aGlzLmZpcnN0U2VsZWN0aW9uID0gLTE7XG4gICAgdGhpcy5id0VzdGltYXRvciA9IHRoaXMuaW5pdEVzdGltYXRvcigpO1xuICB9XG4gIGluaXRFc3RpbWF0b3IoKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuICAgIHJldHVybiBuZXcgRXdtYUJhbmRXaWR0aEVzdGltYXRvcihjb25maWcuYWJyRXdtYVNsb3dWb0QsIGNvbmZpZy5hYnJFd21hRmFzdFZvRCwgY29uZmlnLmFickV3bWFEZWZhdWx0RXN0aW1hdGUpO1xuICB9XG4gIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX0xPQURJTkcsIHRoaXMub25GcmFnTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX0xPQURFRCwgdGhpcy5vbkZyYWdMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9TV0lUQ0hJTkcsIHRoaXMub25MZXZlbFN3aXRjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTFNfVVBEQVRFRCwgdGhpcy5vbkxldmVsc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFYX0FVVE9fTEVWRUxfVVBEQVRFRCwgdGhpcy5vbk1heEF1dG9MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH1cbiAgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWhscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0xPQURJTkcsIHRoaXMub25GcmFnTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19MT0FERUQsIHRoaXMub25GcmFnTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9TV0lUQ0hJTkcsIHRoaXMub25MZXZlbFN3aXRjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMU19VUERBVEVELCB0aGlzLm9uTGV2ZWxzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFYX0FVVE9fTEVWRUxfVVBEQVRFRCwgdGhpcy5vbk1heEF1dG9MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuaGxzID0gdGhpcy5fYWJhbmRvblJ1bGVzQ2hlY2sgPSBudWxsO1xuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSB0aGlzLnBhcnRDdXJyZW50ID0gbnVsbDtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgIHRoaXMubGFzdExvYWRlZEZyYWdMZXZlbCA9IC0xO1xuICAgIHRoaXMuZmlyc3RTZWxlY3Rpb24gPSAtMTtcbiAgICB0aGlzLmxhc3RMZXZlbExvYWRTZWMgPSAwO1xuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSB0aGlzLnBhcnRDdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLm9uTGV2ZWxzVXBkYXRlZCgpO1xuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICB9XG4gIG9uTGV2ZWxzVXBkYXRlZCgpIHtcbiAgICBpZiAodGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsID4gLTEgJiYgdGhpcy5mcmFnQ3VycmVudCkge1xuICAgICAgdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsID0gdGhpcy5mcmFnQ3VycmVudC5sZXZlbDtcbiAgICB9XG4gICAgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IC0xO1xuICAgIHRoaXMub25NYXhBdXRvTGV2ZWxVcGRhdGVkKCk7XG4gICAgdGhpcy5jb2RlY1RpZXJzID0gbnVsbDtcbiAgICB0aGlzLmF1ZGlvVHJhY2tzQnlHcm91cCA9IG51bGw7XG4gIH1cbiAgb25NYXhBdXRvTGV2ZWxVcGRhdGVkKCkge1xuICAgIHRoaXMuZmlyc3RTZWxlY3Rpb24gPSAtMTtcbiAgICB0aGlzLm5leHRBdXRvTGV2ZWxLZXkgPSAnJztcbiAgfVxuICBvbkZyYWdMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3QgZnJhZyA9IGRhdGEuZnJhZztcbiAgICBpZiAodGhpcy5pZ25vcmVGcmFnbWVudChmcmFnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWZyYWcuYml0cmF0ZVRlc3QpIHtcbiAgICAgIHZhciBfZGF0YSRwYXJ0O1xuICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7XG4gICAgICB0aGlzLnBhcnRDdXJyZW50ID0gKF9kYXRhJHBhcnQgPSBkYXRhLnBhcnQpICE9IG51bGwgPyBfZGF0YSRwYXJ0IDogbnVsbDtcbiAgICB9XG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgdGhpcy50aW1lciA9IHNlbGYuc2V0SW50ZXJ2YWwodGhpcy5fYWJhbmRvblJ1bGVzQ2hlY2ssIDEwMCk7XG4gIH1cbiAgb25MZXZlbFN3aXRjaGluZyhldmVudCwgZGF0YSkge1xuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICB9XG4gIG9uRXJyb3IoZXZlbnQsIGRhdGEpIHtcbiAgICBpZiAoZGF0YS5mYXRhbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKGRhdGEuZGV0YWlscykge1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0FERF9DT0RFQ19FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRfRVJST1I6XG4gICAgICAgIC8vIFJlc2V0IGxhc3QgbG9hZGVkIGxldmVsIHNvIHRoYXQgYSBuZXcgc2VsZWN0aW9uIGNhbiBiZSBtYWRlIGFmdGVyIGNhbGxpbmcgcmVjb3Zlck1lZGlhRXJyb3JcbiAgICAgICAgdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsID0gLTE7XG4gICAgICAgIHRoaXMuZmlyc3RTZWxlY3Rpb24gPSAtMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgZnJhZ0N1cnJlbnQsXG4gICAgICAgICAgICBwYXJ0Q3VycmVudDogcGFydFxuICAgICAgICAgIH0gPSB0aGlzO1xuICAgICAgICAgIGlmIChmcmFnICYmIGZyYWdDdXJyZW50ICYmIGZyYWcuc24gPT09IGZyYWdDdXJyZW50LnNuICYmIGZyYWcubGV2ZWwgPT09IGZyYWdDdXJyZW50LmxldmVsKSB7XG4gICAgICAgICAgICBjb25zdCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRzID0gcGFydCA/IHBhcnQuc3RhdHMgOiBmcmFnLnN0YXRzO1xuICAgICAgICAgICAgY29uc3QgdGltZUxvYWRpbmcgPSBub3cgLSBzdGF0cy5sb2FkaW5nLnN0YXJ0O1xuICAgICAgICAgICAgY29uc3QgdHRmYiA9IHN0YXRzLmxvYWRpbmcuZmlyc3QgPyBzdGF0cy5sb2FkaW5nLmZpcnN0IC0gc3RhdHMubG9hZGluZy5zdGFydCA6IC0xO1xuICAgICAgICAgICAgY29uc3QgbG9hZGVkRmlyc3RCeXRlID0gc3RhdHMubG9hZGVkICYmIHR0ZmIgPiAtMTtcbiAgICAgICAgICAgIGlmIChsb2FkZWRGaXJzdEJ5dGUpIHtcbiAgICAgICAgICAgICAgY29uc3QgdHRmYkVzdGltYXRlID0gdGhpcy5id0VzdGltYXRvci5nZXRFc3RpbWF0ZVRURkIoKTtcbiAgICAgICAgICAgICAgdGhpcy5id0VzdGltYXRvci5zYW1wbGUodGltZUxvYWRpbmcgLSBNYXRoLm1pbih0dGZiRXN0aW1hdGUsIHR0ZmIpLCBzdGF0cy5sb2FkZWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5id0VzdGltYXRvci5zYW1wbGVUVEZCKHRpbWVMb2FkaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0VGltZVRvTG9hZEZyYWcodGltZVRvRmlyc3RCeXRlU2VjLCBiYW5kd2lkdGgsIGZyYWdTaXplQml0cywgaXNTd2l0Y2gpIHtcbiAgICBjb25zdCBmcmFnTG9hZFNlYyA9IHRpbWVUb0ZpcnN0Qnl0ZVNlYyArIGZyYWdTaXplQml0cyAvIGJhbmR3aWR0aDtcbiAgICBjb25zdCBwbGF5bGlzdExvYWRTZWMgPSBpc1N3aXRjaCA/IHRoaXMubGFzdExldmVsTG9hZFNlYyA6IDA7XG4gICAgcmV0dXJuIGZyYWdMb2FkU2VjICsgcGxheWxpc3RMb2FkU2VjO1xuICB9XG4gIG9uTGV2ZWxMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG4gICAgY29uc3Qge1xuICAgICAgbG9hZGluZ1xuICAgIH0gPSBkYXRhLnN0YXRzO1xuICAgIGNvbnN0IHRpbWVMb2FkaW5nTXMgPSBsb2FkaW5nLmVuZCAtIGxvYWRpbmcuc3RhcnQ7XG4gICAgaWYgKGlzRmluaXRlTnVtYmVyKHRpbWVMb2FkaW5nTXMpKSB7XG4gICAgICB0aGlzLmxhc3RMZXZlbExvYWRTZWMgPSB0aW1lTG9hZGluZ01zIC8gMTAwMDtcbiAgICB9XG4gICAgaWYgKGRhdGEuZGV0YWlscy5saXZlKSB7XG4gICAgICB0aGlzLmJ3RXN0aW1hdG9yLnVwZGF0ZShjb25maWcuYWJyRXdtYVNsb3dMaXZlLCBjb25maWcuYWJyRXdtYUZhc3RMaXZlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5id0VzdGltYXRvci51cGRhdGUoY29uZmlnLmFickV3bWFTbG93Vm9ELCBjb25maWcuYWJyRXdtYUZhc3RWb0QpO1xuICAgIH1cbiAgfVxuICBvbkZyYWdMb2FkZWQoZXZlbnQsIHtcbiAgICBmcmFnLFxuICAgIHBhcnRcbiAgfSkge1xuICAgIGNvbnN0IHN0YXRzID0gcGFydCA/IHBhcnQuc3RhdHMgOiBmcmFnLnN0YXRzO1xuICAgIGlmIChmcmFnLnR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pIHtcbiAgICAgIHRoaXMuYndFc3RpbWF0b3Iuc2FtcGxlVFRGQihzdGF0cy5sb2FkaW5nLmZpcnN0IC0gc3RhdHMubG9hZGluZy5zdGFydCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlnbm9yZUZyYWdtZW50KGZyYWcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHN0b3AgbW9uaXRvcmluZyBidyBvbmNlIGZyYWcgbG9hZGVkXG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgLy8gcmVzZXQgZm9yY2VkIGF1dG8gbGV2ZWwgdmFsdWUgc28gdGhhdCBuZXh0IGxldmVsIHdpbGwgYmUgc2VsZWN0ZWRcbiAgICBpZiAoZnJhZy5sZXZlbCA9PT0gdGhpcy5fbmV4dEF1dG9MZXZlbCkge1xuICAgICAgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IC0xO1xuICAgIH1cbiAgICB0aGlzLmZpcnN0U2VsZWN0aW9uID0gLTE7XG5cbiAgICAvLyBjb21wdXRlIGxldmVsIGF2ZXJhZ2UgYml0cmF0ZVxuICAgIGlmICh0aGlzLmhscy5jb25maWcuYWJyTWF4V2l0aFJlYWxCaXRyYXRlKSB7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IHBhcnQgPyBwYXJ0LmR1cmF0aW9uIDogZnJhZy5kdXJhdGlvbjtcbiAgICAgIGNvbnN0IGxldmVsID0gdGhpcy5obHMubGV2ZWxzW2ZyYWcubGV2ZWxdO1xuICAgICAgY29uc3QgbG9hZGVkQnl0ZXMgPSAobGV2ZWwubG9hZGVkID8gbGV2ZWwubG9hZGVkLmJ5dGVzIDogMCkgKyBzdGF0cy5sb2FkZWQ7XG4gICAgICBjb25zdCBsb2FkZWREdXJhdGlvbiA9IChsZXZlbC5sb2FkZWQgPyBsZXZlbC5sb2FkZWQuZHVyYXRpb24gOiAwKSArIGR1cmF0aW9uO1xuICAgICAgbGV2ZWwubG9hZGVkID0ge1xuICAgICAgICBieXRlczogbG9hZGVkQnl0ZXMsXG4gICAgICAgIGR1cmF0aW9uOiBsb2FkZWREdXJhdGlvblxuICAgICAgfTtcbiAgICAgIGxldmVsLnJlYWxCaXRyYXRlID0gTWF0aC5yb3VuZCg4ICogbG9hZGVkQnl0ZXMgLyBsb2FkZWREdXJhdGlvbik7XG4gICAgfVxuICAgIGlmIChmcmFnLmJpdHJhdGVUZXN0KSB7XG4gICAgICBjb25zdCBmcmFnQnVmZmVyZWREYXRhID0ge1xuICAgICAgICBzdGF0cyxcbiAgICAgICAgZnJhZyxcbiAgICAgICAgcGFydCxcbiAgICAgICAgaWQ6IGZyYWcudHlwZVxuICAgICAgfTtcbiAgICAgIHRoaXMub25GcmFnQnVmZmVyZWQoRXZlbnRzLkZSQUdfQlVGRkVSRUQsIGZyYWdCdWZmZXJlZERhdGEpO1xuICAgICAgZnJhZy5iaXRyYXRlVGVzdCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzdG9yZSBsZXZlbCBpZCBhZnRlciBzdWNjZXNzZnVsIGZyYWdtZW50IGxvYWQgZm9yIHBsYXliYWNrXG4gICAgICB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwgPSBmcmFnLmxldmVsO1xuICAgIH1cbiAgfVxuICBvbkZyYWdCdWZmZXJlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWcsXG4gICAgICBwYXJ0XG4gICAgfSA9IGRhdGE7XG4gICAgY29uc3Qgc3RhdHMgPSBwYXJ0ICE9IG51bGwgJiYgcGFydC5zdGF0cy5sb2FkZWQgPyBwYXJ0LnN0YXRzIDogZnJhZy5zdGF0cztcbiAgICBpZiAoc3RhdHMuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5pZ25vcmVGcmFnbWVudChmcmFnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBVc2UgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBwYXJzaW5nIGFuZCByZXF1ZXN0IGluc3RlYWQgb2YgYnVmZmVyaW5nIGFuZCByZXF1ZXN0IHRvIGNvbXB1dGUgZnJhZ0xvYWRpbmdQcm9jZXNzaW5nO1xuICAgIC8vIHJhdGlvbmFsZSBpcyB0aGF0IGJ1ZmZlciBhcHBlbmRpbmcgb25seSBoYXBwZW5zIG9uY2UgbWVkaWEgaXMgYXR0YWNoZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGNvbmZpZy5zdGFydEZyYWdQcmVmZXRjaFxuICAgIC8vIGlzIHVzZWQuIElmIHdlIHVzZWQgYnVmZmVyaW5nIGluIHRoYXQgY2FzZSwgb3VyIEJXIGVzdGltYXRlIHNhbXBsZSB3aWxsIGJlIHZlcnkgbGFyZ2UuXG4gICAgY29uc3QgcHJvY2Vzc2luZ01zID0gc3RhdHMucGFyc2luZy5lbmQgLSBzdGF0cy5sb2FkaW5nLnN0YXJ0IC0gTWF0aC5taW4oc3RhdHMubG9hZGluZy5maXJzdCAtIHN0YXRzLmxvYWRpbmcuc3RhcnQsIHRoaXMuYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGVUVEZCKCkpO1xuICAgIHRoaXMuYndFc3RpbWF0b3Iuc2FtcGxlKHByb2Nlc3NpbmdNcywgc3RhdHMubG9hZGVkKTtcbiAgICBzdGF0cy5id0VzdGltYXRlID0gdGhpcy5nZXRCd0VzdGltYXRlKCk7XG4gICAgaWYgKGZyYWcuYml0cmF0ZVRlc3QpIHtcbiAgICAgIHRoaXMuYml0cmF0ZVRlc3REZWxheSA9IHByb2Nlc3NpbmdNcyAvIDEwMDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYml0cmF0ZVRlc3REZWxheSA9IDA7XG4gICAgfVxuICB9XG4gIGlnbm9yZUZyYWdtZW50KGZyYWcpIHtcbiAgICAvLyBPbmx5IGNvdW50IG5vbi1hbHQtYXVkaW8gZnJhZ3Mgd2hpY2ggd2VyZSBhY3R1YWxseSBidWZmZXJlZCBpbiBvdXIgQlcgY2FsY3VsYXRpb25zXG4gICAgcmV0dXJuIGZyYWcudHlwZSAhPT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTiB8fCBmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnO1xuICB9XG4gIGNsZWFyVGltZXIoKSB7XG4gICAgaWYgKHRoaXMudGltZXIgPiAtMSkge1xuICAgICAgc2VsZi5jbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgdGhpcy50aW1lciA9IC0xO1xuICAgIH1cbiAgfVxuICBnZXQgZmlyc3RBdXRvTGV2ZWwoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbWF4QXV0b0xldmVsLFxuICAgICAgbWluQXV0b0xldmVsXG4gICAgfSA9IHRoaXMuaGxzO1xuICAgIGNvbnN0IGJ3RXN0aW1hdGUgPSB0aGlzLmdldEJ3RXN0aW1hdGUoKTtcbiAgICBjb25zdCBtYXhTdGFydERlbGF5ID0gdGhpcy5obHMuY29uZmlnLm1heFN0YXJ2YXRpb25EZWxheTtcbiAgICBjb25zdCBhYnJBdXRvTGV2ZWwgPSB0aGlzLmZpbmRCZXN0TGV2ZWwoYndFc3RpbWF0ZSwgbWluQXV0b0xldmVsLCBtYXhBdXRvTGV2ZWwsIDAsIG1heFN0YXJ0RGVsYXksIDEsIDEpO1xuICAgIGlmIChhYnJBdXRvTGV2ZWwgPiAtMSkge1xuICAgICAgcmV0dXJuIGFickF1dG9MZXZlbDtcbiAgICB9XG4gICAgY29uc3QgZmlyc3RMZXZlbCA9IHRoaXMuaGxzLmZpcnN0TGV2ZWw7XG4gICAgY29uc3QgY2xhbXBlZCA9IE1hdGgubWluKE1hdGgubWF4KGZpcnN0TGV2ZWwsIG1pbkF1dG9MZXZlbCksIG1heEF1dG9MZXZlbCk7XG4gICAgbG9nZ2VyLndhcm4oYFthYnJdIENvdWxkIG5vdCBmaW5kIGJlc3Qgc3RhcnRpbmcgYXV0byBsZXZlbC4gRGVmYXVsdGluZyB0byBmaXJzdCBpbiBwbGF5bGlzdCAke2ZpcnN0TGV2ZWx9IGNsYW1wZWQgdG8gJHtjbGFtcGVkfWApO1xuICAgIHJldHVybiBjbGFtcGVkO1xuICB9XG4gIGdldCBmb3JjZWRBdXRvTGV2ZWwoKSB7XG4gICAgaWYgKHRoaXMubmV4dEF1dG9MZXZlbEtleSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbmV4dEF1dG9MZXZlbDtcbiAgfVxuXG4gIC8vIHJldHVybiBuZXh0IGF1dG8gbGV2ZWxcbiAgZ2V0IG5leHRBdXRvTGV2ZWwoKSB7XG4gICAgY29uc3QgZm9yY2VkQXV0b0xldmVsID0gdGhpcy5mb3JjZWRBdXRvTGV2ZWw7XG4gICAgY29uc3QgYndFc3RpbWF0b3IgPSB0aGlzLmJ3RXN0aW1hdG9yO1xuICAgIGNvbnN0IHVzZUVzdGltYXRlID0gYndFc3RpbWF0b3IuY2FuRXN0aW1hdGUoKTtcbiAgICBjb25zdCBsb2FkZWRGaXJzdEZyYWcgPSB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwgPiAtMTtcbiAgICAvLyBpbiBjYXNlIG5leHQgYXV0byBsZXZlbCBoYXMgYmVlbiBmb3JjZWQsIGFuZCBidyBub3QgYXZhaWxhYmxlIG9yIG5vdCByZWxpYWJsZSwgcmV0dXJuIGZvcmNlZCB2YWx1ZVxuICAgIGlmIChmb3JjZWRBdXRvTGV2ZWwgIT09IC0xICYmICghdXNlRXN0aW1hdGUgfHwgIWxvYWRlZEZpcnN0RnJhZyB8fCB0aGlzLm5leHRBdXRvTGV2ZWxLZXkgPT09IHRoaXMuZ2V0QXV0b0xldmVsS2V5KCkpKSB7XG4gICAgICByZXR1cm4gZm9yY2VkQXV0b0xldmVsO1xuICAgIH1cblxuICAgIC8vIGNvbXB1dGUgbmV4dCBsZXZlbCB1c2luZyBBQlIgbG9naWNcbiAgICBjb25zdCBuZXh0QUJSQXV0b0xldmVsID0gdXNlRXN0aW1hdGUgJiYgbG9hZGVkRmlyc3RGcmFnID8gdGhpcy5nZXROZXh0QUJSQXV0b0xldmVsKCkgOiB0aGlzLmZpcnN0QXV0b0xldmVsO1xuXG4gICAgLy8gdXNlIGZvcmNlZCBhdXRvIGxldmVsIHdoaWxlIGl0IGhhc24ndCBlcnJvcmVkIG1vcmUgdGhhbiBBQlIgc2VsZWN0aW9uXG4gICAgaWYgKGZvcmNlZEF1dG9MZXZlbCAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IGxldmVscyA9IHRoaXMuaGxzLmxldmVscztcbiAgICAgIGlmIChsZXZlbHMubGVuZ3RoID4gTWF0aC5tYXgoZm9yY2VkQXV0b0xldmVsLCBuZXh0QUJSQXV0b0xldmVsKSAmJiBsZXZlbHNbZm9yY2VkQXV0b0xldmVsXS5sb2FkRXJyb3IgPD0gbGV2ZWxzW25leHRBQlJBdXRvTGV2ZWxdLmxvYWRFcnJvcikge1xuICAgICAgICByZXR1cm4gZm9yY2VkQXV0b0xldmVsO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNhdmUgcmVzdWx0IHVudGlsIHN0YXRlIGhhcyBjaGFuZ2VkXG4gICAgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IG5leHRBQlJBdXRvTGV2ZWw7XG4gICAgdGhpcy5uZXh0QXV0b0xldmVsS2V5ID0gdGhpcy5nZXRBdXRvTGV2ZWxLZXkoKTtcbiAgICByZXR1cm4gbmV4dEFCUkF1dG9MZXZlbDtcbiAgfVxuICBnZXRBdXRvTGV2ZWxLZXkoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuZ2V0QndFc3RpbWF0ZSgpfV8ke3RoaXMuZ2V0U3RhcnZhdGlvbkRlbGF5KCkudG9GaXhlZCgyKX1gO1xuICB9XG4gIGdldE5leHRBQlJBdXRvTGV2ZWwoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZ0N1cnJlbnQsXG4gICAgICBwYXJ0Q3VycmVudCxcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIG1heEF1dG9MZXZlbCxcbiAgICAgIGNvbmZpZyxcbiAgICAgIG1pbkF1dG9MZXZlbFxuICAgIH0gPSBobHM7XG4gICAgY29uc3QgY3VycmVudEZyYWdEdXJhdGlvbiA9IHBhcnRDdXJyZW50ID8gcGFydEN1cnJlbnQuZHVyYXRpb24gOiBmcmFnQ3VycmVudCA/IGZyYWdDdXJyZW50LmR1cmF0aW9uIDogMDtcbiAgICBjb25zdCBhdmdidyA9IHRoaXMuZ2V0QndFc3RpbWF0ZSgpO1xuICAgIC8vIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSBpcyB0aGUgd2FsbC1jbG9jayB0aW1lIGxlZnQgdW50aWwgdGhlIHBsYXliYWNrIGJ1ZmZlciBpcyBleGhhdXN0ZWQuXG4gICAgY29uc3QgYnVmZmVyU3RhcnZhdGlvbkRlbGF5ID0gdGhpcy5nZXRTdGFydmF0aW9uRGVsYXkoKTtcbiAgICBsZXQgYndGYWN0b3IgPSBjb25maWcuYWJyQmFuZFdpZHRoRmFjdG9yO1xuICAgIGxldCBid1VwRmFjdG9yID0gY29uZmlnLmFickJhbmRXaWR0aFVwRmFjdG9yO1xuXG4gICAgLy8gRmlyc3QsIGxvb2sgdG8gc2VlIGlmIHdlIGNhbiBmaW5kIGEgbGV2ZWwgbWF0Y2hpbmcgd2l0aCBvdXIgYXZnIGJhbmR3aWR0aCBBTkQgdGhhdCBjb3VsZCBhbHNvIGd1YXJhbnRlZSBubyByZWJ1ZmZlcmluZyBhdCBhbGxcbiAgICBpZiAoYnVmZmVyU3RhcnZhdGlvbkRlbGF5KSB7XG4gICAgICBjb25zdCBfYmVzdExldmVsID0gdGhpcy5maW5kQmVzdExldmVsKGF2Z2J3LCBtaW5BdXRvTGV2ZWwsIG1heEF1dG9MZXZlbCwgYnVmZmVyU3RhcnZhdGlvbkRlbGF5LCAwLCBid0ZhY3RvciwgYndVcEZhY3Rvcik7XG4gICAgICBpZiAoX2Jlc3RMZXZlbCA+PSAwKSB7XG4gICAgICAgIHJldHVybiBfYmVzdExldmVsO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBub3QgcG9zc2libGUgdG8gZ2V0IHJpZCBvZiByZWJ1ZmZlcmluZy4uLiB0cnkgdG8gZmluZCBsZXZlbCB0aGF0IHdpbGwgZ3VhcmFudGVlIGxlc3MgdGhhbiBtYXhTdGFydmF0aW9uRGVsYXkgb2YgcmVidWZmZXJpbmdcbiAgICBsZXQgbWF4U3RhcnZhdGlvbkRlbGF5ID0gY3VycmVudEZyYWdEdXJhdGlvbiA/IE1hdGgubWluKGN1cnJlbnRGcmFnRHVyYXRpb24sIGNvbmZpZy5tYXhTdGFydmF0aW9uRGVsYXkpIDogY29uZmlnLm1heFN0YXJ2YXRpb25EZWxheTtcbiAgICBpZiAoIWJ1ZmZlclN0YXJ2YXRpb25EZWxheSkge1xuICAgICAgLy8gaW4gY2FzZSBidWZmZXIgaXMgZW1wdHksIGxldCdzIGNoZWNrIGlmIHByZXZpb3VzIGZyYWdtZW50IHdhcyBsb2FkZWQgdG8gcGVyZm9ybSBhIGJpdHJhdGUgdGVzdFxuICAgICAgY29uc3QgYml0cmF0ZVRlc3REZWxheSA9IHRoaXMuYml0cmF0ZVRlc3REZWxheTtcbiAgICAgIGlmIChiaXRyYXRlVGVzdERlbGF5KSB7XG4gICAgICAgIC8vIGlmIGl0IGlzIHRoZSBjYXNlLCB0aGVuIHdlIG5lZWQgdG8gYWRqdXN0IG91ciBtYXggc3RhcnZhdGlvbiBkZWxheSB1c2luZyBtYXhMb2FkaW5nRGVsYXkgY29uZmlnIHZhbHVlXG4gICAgICAgIC8vIG1heCB2aWRlbyBsb2FkaW5nIGRlbGF5IHVzZWQgaW4gIGF1dG9tYXRpYyBzdGFydCBsZXZlbCBzZWxlY3Rpb24gOlxuICAgICAgICAvLyBpbiB0aGF0IG1vZGUgQUJSIGNvbnRyb2xsZXIgd2lsbCBlbnN1cmUgdGhhdCB2aWRlbyBsb2FkaW5nIHRpbWUgKGllIHRoZSB0aW1lIHRvIGZldGNoIHRoZSBmaXJzdCBmcmFnbWVudCBhdCBsb3dlc3QgcXVhbGl0eSBsZXZlbCArXG4gICAgICAgIC8vIHRoZSB0aW1lIHRvIGZldGNoIHRoZSBmcmFnbWVudCBhdCB0aGUgYXBwcm9wcmlhdGUgcXVhbGl0eSBsZXZlbCBpcyBsZXNzIHRoYW4gYGBgbWF4TG9hZGluZ0RlbGF5YGBgIClcbiAgICAgICAgLy8gY2FwIG1heExvYWRpbmdEZWxheSBhbmQgZW5zdXJlIGl0IGlzIG5vdCBiaWdnZXIgJ3RoYW4gYml0cmF0ZSB0ZXN0JyBmcmFnIGR1cmF0aW9uXG4gICAgICAgIGNvbnN0IG1heExvYWRpbmdEZWxheSA9IGN1cnJlbnRGcmFnRHVyYXRpb24gPyBNYXRoLm1pbihjdXJyZW50RnJhZ0R1cmF0aW9uLCBjb25maWcubWF4TG9hZGluZ0RlbGF5KSA6IGNvbmZpZy5tYXhMb2FkaW5nRGVsYXk7XG4gICAgICAgIG1heFN0YXJ2YXRpb25EZWxheSA9IG1heExvYWRpbmdEZWxheSAtIGJpdHJhdGVUZXN0RGVsYXk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGBbYWJyXSBiaXRyYXRlIHRlc3QgdG9vayAke01hdGgucm91bmQoMTAwMCAqIGJpdHJhdGVUZXN0RGVsYXkpfW1zLCBzZXQgZmlyc3QgZnJhZ21lbnQgbWF4IGZldGNoRHVyYXRpb24gdG8gJHtNYXRoLnJvdW5kKDEwMDAgKiBtYXhTdGFydmF0aW9uRGVsYXkpfSBtc2ApO1xuICAgICAgICAvLyBkb24ndCB1c2UgY29uc2VydmF0aXZlIGZhY3RvciBvbiBiaXRyYXRlIHRlc3RcbiAgICAgICAgYndGYWN0b3IgPSBid1VwRmFjdG9yID0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYmVzdExldmVsID0gdGhpcy5maW5kQmVzdExldmVsKGF2Z2J3LCBtaW5BdXRvTGV2ZWwsIG1heEF1dG9MZXZlbCwgYnVmZmVyU3RhcnZhdGlvbkRlbGF5LCBtYXhTdGFydmF0aW9uRGVsYXksIGJ3RmFjdG9yLCBid1VwRmFjdG9yKTtcbiAgICBsb2dnZXIuaW5mbyhgW2Ficl0gJHtidWZmZXJTdGFydmF0aW9uRGVsYXkgPyAncmVidWZmZXJpbmcgZXhwZWN0ZWQnIDogJ2J1ZmZlciBpcyBlbXB0eSd9LCBvcHRpbWFsIHF1YWxpdHkgbGV2ZWwgJHtiZXN0TGV2ZWx9YCk7XG4gICAgaWYgKGJlc3RMZXZlbCA+IC0xKSB7XG4gICAgICByZXR1cm4gYmVzdExldmVsO1xuICAgIH1cbiAgICAvLyBJZiBubyBtYXRjaGluZyBsZXZlbCBmb3VuZCwgc2VlIGlmIG1pbiBhdXRvIGxldmVsIHdvdWxkIGJlIGEgYmV0dGVyIG9wdGlvblxuICAgIGNvbnN0IG1pbkxldmVsID0gaGxzLmxldmVsc1ttaW5BdXRvTGV2ZWxdO1xuICAgIGNvbnN0IGF1dG9MZXZlbCA9IGhscy5sZXZlbHNbaGxzLmxvYWRMZXZlbF07XG4gICAgaWYgKChtaW5MZXZlbCA9PSBudWxsID8gdm9pZCAwIDogbWluTGV2ZWwuYml0cmF0ZSkgPCAoYXV0b0xldmVsID09IG51bGwgPyB2b2lkIDAgOiBhdXRvTGV2ZWwuYml0cmF0ZSkpIHtcbiAgICAgIHJldHVybiBtaW5BdXRvTGV2ZWw7XG4gICAgfVxuICAgIC8vIG9yIGlmIGJpdHJhdGUgaXMgbm90IGxvd2VyLCBjb250aW51ZSB0byB1c2UgbG9hZExldmVsXG4gICAgcmV0dXJuIGhscy5sb2FkTGV2ZWw7XG4gIH1cbiAgZ2V0U3RhcnZhdGlvbkRlbGF5KCkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGNvbnN0IG1lZGlhID0gaGxzLm1lZGlhO1xuICAgIGlmICghbWVkaWEpIHtcbiAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgLy8gcGxheWJhY2tSYXRlIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGUgcGxheWJhY2sgcmF0ZTsgaWYgbWVkaWEucGxheWJhY2tSYXRlIGlzIDAsIHdlIHVzZSAxIHRvIGxvYWQgYXNcbiAgICAvLyBpZiB3ZSdyZSBwbGF5aW5nIGJhY2sgYXQgdGhlIG5vcm1hbCByYXRlLlxuICAgIGNvbnN0IHBsYXliYWNrUmF0ZSA9IG1lZGlhICYmIG1lZGlhLnBsYXliYWNrUmF0ZSAhPT0gMCA/IE1hdGguYWJzKG1lZGlhLnBsYXliYWNrUmF0ZSkgOiAxLjA7XG4gICAgY29uc3QgYnVmZmVySW5mbyA9IGhscy5tYWluRm9yd2FyZEJ1ZmZlckluZm87XG4gICAgcmV0dXJuIChidWZmZXJJbmZvID8gYnVmZmVySW5mby5sZW4gOiAwKSAvIHBsYXliYWNrUmF0ZTtcbiAgfVxuICBnZXRCd0VzdGltYXRlKCkge1xuICAgIHJldHVybiB0aGlzLmJ3RXN0aW1hdG9yLmNhbkVzdGltYXRlKCkgPyB0aGlzLmJ3RXN0aW1hdG9yLmdldEVzdGltYXRlKCkgOiB0aGlzLmhscy5jb25maWcuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZTtcbiAgfVxuICBmaW5kQmVzdExldmVsKGN1cnJlbnRCdywgbWluQXV0b0xldmVsLCBtYXhBdXRvTGV2ZWwsIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSwgbWF4U3RhcnZhdGlvbkRlbGF5LCBid0ZhY3RvciwgYndVcEZhY3Rvcikge1xuICAgIHZhciBfbGV2ZWwkZGV0YWlscztcbiAgICBjb25zdCBtYXhGZXRjaER1cmF0aW9uID0gYnVmZmVyU3RhcnZhdGlvbkRlbGF5ICsgbWF4U3RhcnZhdGlvbkRlbGF5O1xuICAgIGNvbnN0IGxhc3RMb2FkZWRGcmFnTGV2ZWwgPSB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWw7XG4gICAgY29uc3Qgc2VsZWN0aW9uQmFzZUxldmVsID0gbGFzdExvYWRlZEZyYWdMZXZlbCA9PT0gLTEgPyB0aGlzLmhscy5maXJzdExldmVsIDogbGFzdExvYWRlZEZyYWdMZXZlbDtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnQ3VycmVudCxcbiAgICAgIHBhcnRDdXJyZW50XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWxzLFxuICAgICAgYWxsQXVkaW9UcmFja3MsXG4gICAgICBsb2FkTGV2ZWwsXG4gICAgICBjb25maWdcbiAgICB9ID0gdGhpcy5obHM7XG4gICAgaWYgKGxldmVscy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdCBsZXZlbCA9IGxldmVsc1tzZWxlY3Rpb25CYXNlTGV2ZWxdO1xuICAgIGNvbnN0IGxpdmUgPSAhIShsZXZlbCAhPSBudWxsICYmIChfbGV2ZWwkZGV0YWlscyA9IGxldmVsLmRldGFpbHMpICE9IG51bGwgJiYgX2xldmVsJGRldGFpbHMubGl2ZSk7XG4gICAgY29uc3QgZmlyc3RTZWxlY3Rpb24gPSBsb2FkTGV2ZWwgPT09IC0xIHx8IGxhc3RMb2FkZWRGcmFnTGV2ZWwgPT09IC0xO1xuICAgIGxldCBjdXJyZW50Q29kZWNTZXQ7XG4gICAgbGV0IGN1cnJlbnRWaWRlb1JhbmdlID0gJ1NEUic7XG4gICAgbGV0IGN1cnJlbnRGcmFtZVJhdGUgPSAobGV2ZWwgPT0gbnVsbCA/IHZvaWQgMCA6IGxldmVsLmZyYW1lUmF0ZSkgfHwgMDtcbiAgICBjb25zdCB7XG4gICAgICBhdWRpb1ByZWZlcmVuY2UsXG4gICAgICB2aWRlb1ByZWZlcmVuY2VcbiAgICB9ID0gY29uZmlnO1xuICAgIGNvbnN0IGF1ZGlvVHJhY2tzQnlHcm91cCA9IHRoaXMuYXVkaW9UcmFja3NCeUdyb3VwIHx8ICh0aGlzLmF1ZGlvVHJhY2tzQnlHcm91cCA9IGdldEF1ZGlvVHJhY2tzQnlHcm91cChhbGxBdWRpb1RyYWNrcykpO1xuICAgIGlmIChmaXJzdFNlbGVjdGlvbikge1xuICAgICAgaWYgKHRoaXMuZmlyc3RTZWxlY3Rpb24gIT09IC0xKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpcnN0U2VsZWN0aW9uO1xuICAgICAgfVxuICAgICAgY29uc3QgY29kZWNUaWVycyA9IHRoaXMuY29kZWNUaWVycyB8fCAodGhpcy5jb2RlY1RpZXJzID0gZ2V0Q29kZWNUaWVycyhsZXZlbHMsIGF1ZGlvVHJhY2tzQnlHcm91cCwgbWluQXV0b0xldmVsLCBtYXhBdXRvTGV2ZWwpKTtcbiAgICAgIGNvbnN0IHN0YXJ0VGllciA9IGdldFN0YXJ0Q29kZWNUaWVyKGNvZGVjVGllcnMsIGN1cnJlbnRWaWRlb1JhbmdlLCBjdXJyZW50QncsIGF1ZGlvUHJlZmVyZW5jZSwgdmlkZW9QcmVmZXJlbmNlKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29kZWNTZXQsXG4gICAgICAgIHZpZGVvUmFuZ2VzLFxuICAgICAgICBtaW5GcmFtZXJhdGUsXG4gICAgICAgIG1pbkJpdHJhdGUsXG4gICAgICAgIHByZWZlckhEUlxuICAgICAgfSA9IHN0YXJ0VGllcjtcbiAgICAgIGN1cnJlbnRDb2RlY1NldCA9IGNvZGVjU2V0O1xuICAgICAgY3VycmVudFZpZGVvUmFuZ2UgPSBwcmVmZXJIRFIgPyB2aWRlb1Jhbmdlc1t2aWRlb1Jhbmdlcy5sZW5ndGggLSAxXSA6IHZpZGVvUmFuZ2VzWzBdO1xuICAgICAgY3VycmVudEZyYW1lUmF0ZSA9IG1pbkZyYW1lcmF0ZTtcbiAgICAgIGN1cnJlbnRCdyA9IE1hdGgubWF4KGN1cnJlbnRCdywgbWluQml0cmF0ZSk7XG4gICAgICBsb2dnZXIubG9nKGBbYWJyXSBwaWNrZWQgc3RhcnQgdGllciAke0pTT04uc3RyaW5naWZ5KHN0YXJ0VGllcil9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRDb2RlY1NldCA9IGxldmVsID09IG51bGwgPyB2b2lkIDAgOiBsZXZlbC5jb2RlY1NldDtcbiAgICAgIGN1cnJlbnRWaWRlb1JhbmdlID0gbGV2ZWwgPT0gbnVsbCA/IHZvaWQgMCA6IGxldmVsLnZpZGVvUmFuZ2U7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRGcmFnRHVyYXRpb24gPSBwYXJ0Q3VycmVudCA/IHBhcnRDdXJyZW50LmR1cmF0aW9uIDogZnJhZ0N1cnJlbnQgPyBmcmFnQ3VycmVudC5kdXJhdGlvbiA6IDA7XG4gICAgY29uc3QgdHRmYkVzdGltYXRlU2VjID0gdGhpcy5id0VzdGltYXRvci5nZXRFc3RpbWF0ZVRURkIoKSAvIDEwMDA7XG4gICAgY29uc3QgbGV2ZWxzU2tpcHBlZCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSBtYXhBdXRvTGV2ZWw7IGkgPj0gbWluQXV0b0xldmVsOyBpLS0pIHtcbiAgICAgIHZhciBfbGV2ZWxJbmZvJHN1cHBvcnRlZFI7XG4gICAgICBjb25zdCBsZXZlbEluZm8gPSBsZXZlbHNbaV07XG4gICAgICBjb25zdCB1cFN3aXRjaCA9IGkgPiBzZWxlY3Rpb25CYXNlTGV2ZWw7XG4gICAgICBpZiAoIWxldmVsSW5mbykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjb25maWcudXNlTWVkaWFDYXBhYmlsaXRpZXMgJiYgIWxldmVsSW5mby5zdXBwb3J0ZWRSZXN1bHQgJiYgIWxldmVsSW5mby5zdXBwb3J0ZWRQcm9taXNlKSB7XG4gICAgICAgIGNvbnN0IG1lZGlhQ2FwYWJpbGl0aWVzID0gbmF2aWdhdG9yLm1lZGlhQ2FwYWJpbGl0aWVzO1xuICAgICAgICBpZiAodHlwZW9mIChtZWRpYUNhcGFiaWxpdGllcyA9PSBudWxsID8gdm9pZCAwIDogbWVkaWFDYXBhYmlsaXRpZXMuZGVjb2RpbmdJbmZvKSA9PT0gJ2Z1bmN0aW9uJyAmJiByZXF1aXJlc01lZGlhQ2FwYWJpbGl0aWVzRGVjb2RpbmdJbmZvKGxldmVsSW5mbywgYXVkaW9UcmFja3NCeUdyb3VwLCBjdXJyZW50VmlkZW9SYW5nZSwgY3VycmVudEZyYW1lUmF0ZSwgY3VycmVudEJ3LCBhdWRpb1ByZWZlcmVuY2UpKSB7XG4gICAgICAgICAgbGV2ZWxJbmZvLnN1cHBvcnRlZFByb21pc2UgPSBnZXRNZWRpYURlY29kaW5nSW5mb1Byb21pc2UobGV2ZWxJbmZvLCBhdWRpb1RyYWNrc0J5R3JvdXAsIG1lZGlhQ2FwYWJpbGl0aWVzKTtcbiAgICAgICAgICBsZXZlbEluZm8uc3VwcG9ydGVkUHJvbWlzZS50aGVuKGRlY29kaW5nSW5mbyA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGxzKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldmVsSW5mby5zdXBwb3J0ZWRSZXN1bHQgPSBkZWNvZGluZ0luZm87XG4gICAgICAgICAgICBjb25zdCBsZXZlbHMgPSB0aGlzLmhscy5sZXZlbHM7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGxldmVscy5pbmRleE9mKGxldmVsSW5mbyk7XG4gICAgICAgICAgICBpZiAoZGVjb2RpbmdJbmZvLmVycm9yKSB7XG4gICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBbYWJyXSBNZWRpYUNhcGFiaWxpdGllcyBkZWNvZGluZ0luZm8gZXJyb3I6IFwiJHtkZWNvZGluZ0luZm8uZXJyb3J9XCIgZm9yIGxldmVsICR7aW5kZXh9ICR7SlNPTi5zdHJpbmdpZnkoZGVjb2RpbmdJbmZvKX1gKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWRlY29kaW5nSW5mby5zdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYFthYnJdIFVuc3VwcG9ydGVkIE1lZGlhQ2FwYWJpbGl0aWVzIGRlY29kaW5nSW5mbyByZXN1bHQgZm9yIGxldmVsICR7aW5kZXh9ICR7SlNPTi5zdHJpbmdpZnkoZGVjb2RpbmdJbmZvKX1gKTtcbiAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEgJiYgbGV2ZWxzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGBbYWJyXSBSZW1vdmluZyB1bnN1cHBvcnRlZCBsZXZlbCAke2luZGV4fWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaGxzLnJlbW92ZUxldmVsKGluZGV4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldmVsSW5mby5zdXBwb3J0ZWRSZXN1bHQgPSBTVVBQT1JURURfSU5GT19ERUZBVUxUO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHNraXAgY2FuZGlkYXRlcyB3aGljaCBjaGFuZ2UgY29kZWMtZmFtaWx5IG9yIHZpZGVvLXJhbmdlLFxuICAgICAgLy8gYW5kIHdoaWNoIGRlY3JlYXNlIG9yIGluY3JlYXNlIGZyYW1lLXJhdGUgZm9yIHVwIGFuZCBkb3duLXN3aXRjaCByZXNwZWN0ZnVsbHlcbiAgICAgIGlmIChjdXJyZW50Q29kZWNTZXQgJiYgbGV2ZWxJbmZvLmNvZGVjU2V0ICE9PSBjdXJyZW50Q29kZWNTZXQgfHwgY3VycmVudFZpZGVvUmFuZ2UgJiYgbGV2ZWxJbmZvLnZpZGVvUmFuZ2UgIT09IGN1cnJlbnRWaWRlb1JhbmdlIHx8IHVwU3dpdGNoICYmIGN1cnJlbnRGcmFtZVJhdGUgPiBsZXZlbEluZm8uZnJhbWVSYXRlIHx8ICF1cFN3aXRjaCAmJiBjdXJyZW50RnJhbWVSYXRlID4gMCAmJiBjdXJyZW50RnJhbWVSYXRlIDwgbGV2ZWxJbmZvLmZyYW1lUmF0ZSB8fCBsZXZlbEluZm8uc3VwcG9ydGVkUmVzdWx0ICYmICEoKF9sZXZlbEluZm8kc3VwcG9ydGVkUiA9IGxldmVsSW5mby5zdXBwb3J0ZWRSZXN1bHQuZGVjb2RpbmdJbmZvUmVzdWx0cykgIT0gbnVsbCAmJiBfbGV2ZWxJbmZvJHN1cHBvcnRlZFJbMF0uc21vb3RoKSkge1xuICAgICAgICBsZXZlbHNTa2lwcGVkLnB1c2goaSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gbGV2ZWxJbmZvLmRldGFpbHM7XG4gICAgICBjb25zdCBhdmdEdXJhdGlvbiA9IChwYXJ0Q3VycmVudCA/IGxldmVsRGV0YWlscyA9PSBudWxsID8gdm9pZCAwIDogbGV2ZWxEZXRhaWxzLnBhcnRUYXJnZXQgOiBsZXZlbERldGFpbHMgPT0gbnVsbCA/IHZvaWQgMCA6IGxldmVsRGV0YWlscy5hdmVyYWdldGFyZ2V0ZHVyYXRpb24pIHx8IGN1cnJlbnRGcmFnRHVyYXRpb247XG4gICAgICBsZXQgYWRqdXN0ZWRidztcbiAgICAgIC8vIGZvbGxvdyBhbGdvcml0aG0gY2FwdHVyZWQgZnJvbSBzdGFnZWZyaWdodCA6XG4gICAgICAvLyBodHRwczovL2FuZHJvaWQuZ29vZ2xlc291cmNlLmNvbS9wbGF0Zm9ybS9mcmFtZXdvcmtzL2F2LysvbWFzdGVyL21lZGlhL2xpYnN0YWdlZnJpZ2h0L2h0dHBsaXZlL0xpdmVTZXNzaW9uLmNwcFxuICAgICAgLy8gUGljayB0aGUgaGlnaGVzdCBiYW5kd2lkdGggc3RyZWFtIGJlbG93IG9yIGVxdWFsIHRvIGVzdGltYXRlZCBiYW5kd2lkdGguXG4gICAgICAvLyBjb25zaWRlciBvbmx5IDgwJSBvZiB0aGUgYXZhaWxhYmxlIGJhbmR3aWR0aCwgYnV0IGlmIHdlIGFyZSBzd2l0Y2hpbmcgdXAsXG4gICAgICAvLyBiZSBldmVuIG1vcmUgY29uc2VydmF0aXZlICg3MCUpIHRvIGF2b2lkIG92ZXJlc3RpbWF0aW5nIGFuZCBpbW1lZGlhdGVseVxuICAgICAgLy8gc3dpdGNoaW5nIGJhY2suXG4gICAgICBpZiAoIXVwU3dpdGNoKSB7XG4gICAgICAgIGFkanVzdGVkYncgPSBid0ZhY3RvciAqIGN1cnJlbnRCdztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkanVzdGVkYncgPSBid1VwRmFjdG9yICogY3VycmVudEJ3O1xuICAgICAgfVxuXG4gICAgICAvLyBVc2UgYXZlcmFnZSBiaXRyYXRlIHdoZW4gc3RhcnZhdGlvbiBkZWxheSAoYnVmZmVyIGxlbmd0aCkgaXMgZ3Qgb3IgZXEgdHdvIHNlZ21lbnQgZHVyYXRpb25zIGFuZCByZWJ1ZmZlcmluZyBpcyBub3QgZXhwZWN0ZWQgKG1heFN0YXJ2YXRpb25EZWxheSA+IDApXG4gICAgICBjb25zdCBiaXRyYXRlID0gY3VycmVudEZyYWdEdXJhdGlvbiAmJiBidWZmZXJTdGFydmF0aW9uRGVsYXkgPj0gY3VycmVudEZyYWdEdXJhdGlvbiAqIDIgJiYgbWF4U3RhcnZhdGlvbkRlbGF5ID09PSAwID8gbGV2ZWxzW2ldLmF2ZXJhZ2VCaXRyYXRlIDogbGV2ZWxzW2ldLm1heEJpdHJhdGU7XG4gICAgICBjb25zdCBmZXRjaER1cmF0aW9uID0gdGhpcy5nZXRUaW1lVG9Mb2FkRnJhZyh0dGZiRXN0aW1hdGVTZWMsIGFkanVzdGVkYncsIGJpdHJhdGUgKiBhdmdEdXJhdGlvbiwgbGV2ZWxEZXRhaWxzID09PSB1bmRlZmluZWQpO1xuICAgICAgY29uc3QgY2FuU3dpdGNoV2l0aGluVG9sZXJhbmNlID1cbiAgICAgIC8vIGlmIGFkanVzdGVkIGJ3IGlzIGdyZWF0ZXIgdGhhbiBsZXZlbCBiaXRyYXRlIEFORFxuICAgICAgYWRqdXN0ZWRidyA+PSBiaXRyYXRlICYmIChcbiAgICAgIC8vIG5vIGxldmVsIGNoYW5nZSwgb3IgbmV3IGxldmVsIGhhcyBubyBlcnJvciBoaXN0b3J5XG4gICAgICBpID09PSBsYXN0TG9hZGVkRnJhZ0xldmVsIHx8IGxldmVsSW5mby5sb2FkRXJyb3IgPT09IDAgJiYgbGV2ZWxJbmZvLmZyYWdtZW50RXJyb3IgPT09IDApICYmIChcbiAgICAgIC8vIGZyYWdtZW50IGZldGNoRHVyYXRpb24gdW5rbm93biBPUiBsaXZlIHN0cmVhbSBPUiBmcmFnbWVudCBmZXRjaER1cmF0aW9uIGxlc3MgdGhhbiBtYXggYWxsb3dlZCBmZXRjaCBkdXJhdGlvbiwgdGhlbiB0aGlzIGxldmVsIG1hdGNoZXNcbiAgICAgIC8vIHdlIGRvbid0IGFjY291bnQgZm9yIG1heCBGZXRjaCBEdXJhdGlvbiBmb3IgbGl2ZSBzdHJlYW1zLCB0aGlzIGlzIHRvIGF2b2lkIHN3aXRjaGluZyBkb3duIHdoZW4gbmVhciB0aGUgZWRnZSBvZiBsaXZlIHNsaWRpbmcgd2luZG93IC4uLlxuICAgICAgLy8gc3BlY2lhbCBjYXNlIHRvIHN1cHBvcnQgc3RhcnRMZXZlbCA9IC0xIChiaXRyYXRlVGVzdCkgb24gbGl2ZSBzdHJlYW1zIDogaW4gdGhhdCBjYXNlIHdlIHNob3VsZCBub3QgZXhpdCBsb29wIHNvIHRoYXQgZmluZEJlc3RMZXZlbCB3aWxsIHJldHVybiAtMVxuICAgICAgZmV0Y2hEdXJhdGlvbiA8PSB0dGZiRXN0aW1hdGVTZWMgfHwgIWlzRmluaXRlTnVtYmVyKGZldGNoRHVyYXRpb24pIHx8IGxpdmUgJiYgIXRoaXMuYml0cmF0ZVRlc3REZWxheSB8fCBmZXRjaER1cmF0aW9uIDwgbWF4RmV0Y2hEdXJhdGlvbik7XG4gICAgICBpZiAoY2FuU3dpdGNoV2l0aGluVG9sZXJhbmNlKSB7XG4gICAgICAgIGNvbnN0IGZvcmNlZEF1dG9MZXZlbCA9IHRoaXMuZm9yY2VkQXV0b0xldmVsO1xuICAgICAgICBpZiAoaSAhPT0gbG9hZExldmVsICYmIChmb3JjZWRBdXRvTGV2ZWwgPT09IC0xIHx8IGZvcmNlZEF1dG9MZXZlbCAhPT0gbG9hZExldmVsKSkge1xuICAgICAgICAgIGlmIChsZXZlbHNTa2lwcGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRyYWNlKGBbYWJyXSBTa2lwcGVkIGxldmVsKHMpICR7bGV2ZWxzU2tpcHBlZC5qb2luKCcsJyl9IG9mICR7bWF4QXV0b0xldmVsfSBtYXggd2l0aCBDT0RFQ1MgYW5kIFZJREVPLVJBTkdFOlwiJHtsZXZlbHNbbGV2ZWxzU2tpcHBlZFswXV0uY29kZWNzfVwiICR7bGV2ZWxzW2xldmVsc1NraXBwZWRbMF1dLnZpZGVvUmFuZ2V9OyBub3QgY29tcGF0aWJsZSB3aXRoIFwiJHtsZXZlbC5jb2RlY3N9XCIgJHtjdXJyZW50VmlkZW9SYW5nZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbG9nZ2VyLmluZm8oYFthYnJdIHN3aXRjaCBjYW5kaWRhdGU6JHtzZWxlY3Rpb25CYXNlTGV2ZWx9LT4ke2l9IGFkanVzdGVkYncoJHtNYXRoLnJvdW5kKGFkanVzdGVkYncpfSktYml0cmF0ZT0ke01hdGgucm91bmQoYWRqdXN0ZWRidyAtIGJpdHJhdGUpfSB0dGZiOiR7dHRmYkVzdGltYXRlU2VjLnRvRml4ZWQoMSl9IGF2Z0R1cmF0aW9uOiR7YXZnRHVyYXRpb24udG9GaXhlZCgxKX0gbWF4RmV0Y2hEdXJhdGlvbjoke21heEZldGNoRHVyYXRpb24udG9GaXhlZCgxKX0gZmV0Y2hEdXJhdGlvbjoke2ZldGNoRHVyYXRpb24udG9GaXhlZCgxKX0gZmlyc3RTZWxlY3Rpb246JHtmaXJzdFNlbGVjdGlvbn0gY29kZWNTZXQ6JHtjdXJyZW50Q29kZWNTZXR9IHZpZGVvUmFuZ2U6JHtjdXJyZW50VmlkZW9SYW5nZX0gaGxzLmxvYWRMZXZlbDoke2xvYWRMZXZlbH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlyc3RTZWxlY3Rpb24pIHtcbiAgICAgICAgICB0aGlzLmZpcnN0U2VsZWN0aW9uID0gaTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhcyB3ZSBhcmUgbG9vcGluZyBmcm9tIGhpZ2hlc3QgdG8gbG93ZXN0LCB0aGlzIHdpbGwgcmV0dXJuIHRoZSBiZXN0IGFjaGlldmFibGUgcXVhbGl0eSBsZXZlbFxuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gbm90IGVub3VnaCB0aW1lIGJ1ZGdldCBldmVuIHdpdGggcXVhbGl0eSBsZXZlbCAwIC4uLiByZWJ1ZmZlcmluZyBtaWdodCBoYXBwZW5cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgc2V0IG5leHRBdXRvTGV2ZWwobmV4dExldmVsKSB7XG4gICAgY29uc3Qge1xuICAgICAgbWF4QXV0b0xldmVsLFxuICAgICAgbWluQXV0b0xldmVsXG4gICAgfSA9IHRoaXMuaGxzO1xuICAgIGNvbnN0IHZhbHVlID0gTWF0aC5taW4oTWF0aC5tYXgobmV4dExldmVsLCBtaW5BdXRvTGV2ZWwpLCBtYXhBdXRvTGV2ZWwpO1xuICAgIGlmICh0aGlzLl9uZXh0QXV0b0xldmVsICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5uZXh0QXV0b0xldmVsS2V5ID0gJyc7XG4gICAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gdmFsdWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQGlnbm9yZVxuICogU3ViLWNsYXNzIHNwZWNpYWxpemF0aW9uIG9mIEV2ZW50SGFuZGxlciBiYXNlIGNsYXNzLlxuICpcbiAqIFRhc2tMb29wIGFsbG93cyB0byBzY2hlZHVsZSBhIHRhc2sgZnVuY3Rpb24gYmVpbmcgY2FsbGVkIChvcHRpb25uYWx5IHJlcGVhdGVkbHkpIG9uIHRoZSBtYWluIGxvb3AsXG4gKiBzY2hlZHVsZWQgYXN5bmNocm9uZW91c2x5LCBhdm9pZGluZyByZWN1cnNpdmUgY2FsbHMgaW4gdGhlIHNhbWUgdGljay5cbiAqXG4gKiBUaGUgdGFzayBpdHNlbGYgaXMgaW1wbGVtZW50ZWQgaW4gYGRvVGlja2AuIEl0IGNhbiBiZSByZXF1ZXN0ZWQgYW5kIGNhbGxlZCBmb3Igc2luZ2xlIGV4ZWN1dGlvblxuICogdXNpbmcgdGhlIGB0aWNrYCBtZXRob2QuXG4gKlxuICogSXQgd2lsbCBiZSBhc3N1cmVkIHRoYXQgdGhlIHRhc2sgZXhlY3V0aW9uIG1ldGhvZCAoYHRpY2tgKSBvbmx5IGdldHMgY2FsbGVkIG9uY2UgcGVyIG1haW4gbG9vcCBcInRpY2tcIixcbiAqIG5vIG1hdHRlciBob3cgb2Z0ZW4gaXQgZ2V0cyByZXF1ZXN0ZWQgZm9yIGV4ZWN1dGlvbi4gRXhlY3V0aW9uIGluIGZ1cnRoZXIgdGlja3Mgd2lsbCBiZSBzY2hlZHVsZWQgYWNjb3JkaW5nbHkuXG4gKlxuICogSWYgZnVydGhlciBleGVjdXRpb24gcmVxdWVzdHMgaGF2ZSBhbHJlYWR5IGJlZW4gc2NoZWR1bGVkIG9uIHRoZSBuZXh0IHRpY2ssIGl0IGNhbiBiZSBjaGVja2VkIHdpdGggYGhhc05leHRUaWNrYCxcbiAqIGFuZCBjYW5jZWxsZWQgd2l0aCBgY2xlYXJOZXh0VGlja2AuXG4gKlxuICogVGhlIHRhc2sgY2FuIGJlIHNjaGVkdWxlZCBhcyBhbiBpbnRlcnZhbCByZXBlYXRlZGx5IHdpdGggYSBwZXJpb2QgYXMgcGFyYW1ldGVyIChzZWUgYHNldEludGVydmFsYCwgYGNsZWFySW50ZXJ2YWxgKS5cbiAqXG4gKiBTdWItY2xhc3NlcyBuZWVkIHRvIGltcGxlbWVudCB0aGUgYGRvVGlja2AgbWV0aG9kIHdoaWNoIHdpbGwgZWZmZWN0aXZlbHkgaGF2ZSB0aGUgdGFzayBleGVjdXRpb24gcm91dGluZS5cbiAqXG4gKiBGdXJ0aGVyIGV4cGxhbmF0aW9uczpcbiAqXG4gKiBUaGUgYmFzZWNsYXNzIGhhcyBhIGB0aWNrYCBtZXRob2QgdGhhdCB3aWxsIHNjaGVkdWxlIHRoZSBkb1RpY2sgY2FsbC4gSXQgbWF5IGJlIGNhbGxlZCBzeW5jaHJvbmVvdXNseVxuICogb25seSBmb3IgYSBzdGFjay1kZXB0aCBvZiBvbmUuIE9uIHJlLWVudHJhbnQgY2FsbHMsIHN1Yi1zZXF1ZW50IGNhbGxzIGFyZSBzY2hlZHVsZWQgZm9yIG5leHQgbWFpbiBsb29wIHRpY2tzLlxuICpcbiAqIFdoZW4gdGhlIHRhc2sgZXhlY3V0aW9uIChgdGlja2AgbWV0aG9kKSBpcyBjYWxsZWQgaW4gcmUtZW50cmFudCB3YXkgdGhpcyBpcyBkZXRlY3RlZCBhbmRcbiAqIHdlIGFyZSBsaW1pdGluZyB0aGUgdGFzayBleGVjdXRpb24gcGVyIGNhbGwgc3RhY2sgdG8gZXhhY3RseSBvbmUsIGJ1dCBzY2hlZHVsaW5nL3Bvc3QtcG9uaW5nIGZ1cnRoZXJcbiAqIHRhc2sgcHJvY2Vzc2luZyBvbiB0aGUgbmV4dCBtYWluIGxvb3AgaXRlcmF0aW9uIChhbHNvIGtub3duIGFzIFwibmV4dCB0aWNrXCIgaW4gdGhlIE5vZGUvSlMgcnVudGltZSBsaW5nbykuXG4gKi9cbmNsYXNzIFRhc2tMb29wIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fYm91bmRUaWNrID0gdm9pZCAwO1xuICAgIHRoaXMuX3RpY2tUaW1lciA9IG51bGw7XG4gICAgdGhpcy5fdGlja0ludGVydmFsID0gbnVsbDtcbiAgICB0aGlzLl90aWNrQ2FsbENvdW50ID0gMDtcbiAgICB0aGlzLl9ib3VuZFRpY2sgPSB0aGlzLnRpY2suYmluZCh0aGlzKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMub25IYW5kbGVyRGVzdHJveWluZygpO1xuICAgIHRoaXMub25IYW5kbGVyRGVzdHJveWVkKCk7XG4gIH1cbiAgb25IYW5kbGVyRGVzdHJveWluZygpIHtcbiAgICAvLyBjbGVhciBhbGwgdGltZXJzIGJlZm9yZSB1bnJlZ2lzdGVyaW5nIGZyb20gZXZlbnQgYnVzXG4gICAgdGhpcy5jbGVhck5leHRUaWNrKCk7XG4gICAgdGhpcy5jbGVhckludGVydmFsKCk7XG4gIH1cbiAgb25IYW5kbGVyRGVzdHJveWVkKCkge31cbiAgaGFzSW50ZXJ2YWwoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fdGlja0ludGVydmFsO1xuICB9XG4gIGhhc05leHRUaWNrKCkge1xuICAgIHJldHVybiAhIXRoaXMuX3RpY2tUaW1lcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gbWlsbGlzIC0gSW50ZXJ2YWwgdGltZSAobXMpXG4gICAqIEBldHVybnMgVHJ1ZSB3aGVuIGludGVydmFsIGhhcyBiZWVuIHNjaGVkdWxlZCwgZmFsc2Ugd2hlbiBhbHJlYWR5IHNjaGVkdWxlZCAobm8gZWZmZWN0KVxuICAgKi9cbiAgc2V0SW50ZXJ2YWwobWlsbGlzKSB7XG4gICAgaWYgKCF0aGlzLl90aWNrSW50ZXJ2YWwpIHtcbiAgICAgIHRoaXMuX3RpY2tDYWxsQ291bnQgPSAwO1xuICAgICAgdGhpcy5fdGlja0ludGVydmFsID0gc2VsZi5zZXRJbnRlcnZhbCh0aGlzLl9ib3VuZFRpY2ssIG1pbGxpcyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIFRydWUgd2hlbiBpbnRlcnZhbCB3YXMgY2xlYXJlZCwgZmFsc2Ugd2hlbiBub25lIHdhcyBzZXQgKG5vIGVmZmVjdClcbiAgICovXG4gIGNsZWFySW50ZXJ2YWwoKSB7XG4gICAgaWYgKHRoaXMuX3RpY2tJbnRlcnZhbCkge1xuICAgICAgc2VsZi5jbGVhckludGVydmFsKHRoaXMuX3RpY2tJbnRlcnZhbCk7XG4gICAgICB0aGlzLl90aWNrSW50ZXJ2YWwgPSBudWxsO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBUcnVlIHdoZW4gdGltZW91dCB3YXMgY2xlYXJlZCwgZmFsc2Ugd2hlbiBub25lIHdhcyBzZXQgKG5vIGVmZmVjdClcbiAgICovXG4gIGNsZWFyTmV4dFRpY2soKSB7XG4gICAgaWYgKHRoaXMuX3RpY2tUaW1lcikge1xuICAgICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5fdGlja1RpbWVyKTtcbiAgICAgIHRoaXMuX3RpY2tUaW1lciA9IG51bGw7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFdpbGwgY2FsbCB0aGUgc3ViY2xhc3MgZG9UaWNrIGltcGxlbWVudGF0aW9uIGluIHRoaXMgbWFpbiBsb29wIHRpY2tcbiAgICogb3IgaW4gdGhlIG5leHQgb25lICh2aWEgc2V0VGltZW91dCgsMCkpIGluIGNhc2UgaXQgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWRcbiAgICogaW4gdGhpcyB0aWNrIChpbiBjYXNlIHRoaXMgaXMgYSByZS1lbnRyYW50IGNhbGwpLlxuICAgKi9cbiAgdGljaygpIHtcbiAgICB0aGlzLl90aWNrQ2FsbENvdW50Kys7XG4gICAgaWYgKHRoaXMuX3RpY2tDYWxsQ291bnQgPT09IDEpIHtcbiAgICAgIHRoaXMuZG9UaWNrKCk7XG4gICAgICAvLyByZS1lbnRyYW50IGNhbGwgdG8gdGljayBmcm9tIHByZXZpb3VzIGRvVGljayBjYWxsIHN0YWNrXG4gICAgICAvLyAtPiBzY2hlZHVsZSBhIGNhbGwgb24gdGhlIG5leHQgbWFpbiBsb29wIGl0ZXJhdGlvbiB0byBwcm9jZXNzIHRoaXMgdGFzayBwcm9jZXNzaW5nIHJlcXVlc3RcbiAgICAgIGlmICh0aGlzLl90aWNrQ2FsbENvdW50ID4gMSkge1xuICAgICAgICAvLyBtYWtlIHN1cmUgb25seSBvbmUgdGltZXIgZXhpc3RzIGF0IGFueSB0aW1lIGF0IG1heFxuICAgICAgICB0aGlzLnRpY2tJbW1lZGlhdGUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3RpY2tDYWxsQ291bnQgPSAwO1xuICAgIH1cbiAgfVxuICB0aWNrSW1tZWRpYXRlKCkge1xuICAgIHRoaXMuY2xlYXJOZXh0VGljaygpO1xuICAgIHRoaXMuX3RpY2tUaW1lciA9IHNlbGYuc2V0VGltZW91dCh0aGlzLl9ib3VuZFRpY2ssIDApO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvciBzdWJjbGFzcyB0byBpbXBsZW1lbnQgdGFzayBsb2dpY1xuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIGRvVGljaygpIHt9XG59XG5cbnZhciBGcmFnbWVudFN0YXRlID0ge1xuICBOT1RfTE9BREVEOiBcIk5PVF9MT0FERURcIixcbiAgQVBQRU5ESU5HOiBcIkFQUEVORElOR1wiLFxuICBQQVJUSUFMOiBcIlBBUlRJQUxcIixcbiAgT0s6IFwiT0tcIlxufTtcbmNsYXNzIEZyYWdtZW50VHJhY2tlciB7XG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHRoaXMuYWN0aXZlUGFydExpc3RzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmVuZExpc3RGcmFnbWVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuZnJhZ21lbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnRpbWVSYW5nZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuYnVmZmVyUGFkZGluZyA9IDAuMjtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmhhc0dhcHMgPSBmYWxzZTtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLl9yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIF9yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9BUFBFTkRFRCwgdGhpcy5vbkJ1ZmZlckFwcGVuZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19MT0FERUQsIHRoaXMub25GcmFnTG9hZGVkLCB0aGlzKTtcbiAgfVxuICBfdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfQVBQRU5ERUQsIHRoaXMub25CdWZmZXJBcHBlbmRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19MT0FERUQsIHRoaXMub25GcmFnTG9hZGVkLCB0aGlzKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5mcmFnbWVudHMgPVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmFjdGl2ZVBhcnRMaXN0cyA9XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuZW5kTGlzdEZyYWdtZW50cyA9IHRoaXMudGltZVJhbmdlcyA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgRnJhZ21lbnQgb3IgUGFydCB3aXRoIGFuIGFwcGVuZGVkIHJhbmdlIHRoYXQgbWF0Y2hlcyB0aGUgcG9zaXRpb24gYW5kIGxldmVsVHlwZVxuICAgKiBPdGhlcndpc2UsIHJldHVybiBudWxsXG4gICAqL1xuICBnZXRBcHBlbmRlZEZyYWcocG9zaXRpb24sIGxldmVsVHlwZSkge1xuICAgIGNvbnN0IGFjdGl2ZVBhcnRzID0gdGhpcy5hY3RpdmVQYXJ0TGlzdHNbbGV2ZWxUeXBlXTtcbiAgICBpZiAoYWN0aXZlUGFydHMpIHtcbiAgICAgIGZvciAobGV0IGkgPSBhY3RpdmVQYXJ0cy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgY29uc3QgYWN0aXZlUGFydCA9IGFjdGl2ZVBhcnRzW2ldO1xuICAgICAgICBpZiAoIWFjdGl2ZVBhcnQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcHBlbmRlZFBUUyA9IGFjdGl2ZVBhcnQuZW5kO1xuICAgICAgICBpZiAoYWN0aXZlUGFydC5zdGFydCA8PSBwb3NpdGlvbiAmJiBhcHBlbmRlZFBUUyAhPT0gbnVsbCAmJiBwb3NpdGlvbiA8PSBhcHBlbmRlZFBUUykge1xuICAgICAgICAgIHJldHVybiBhY3RpdmVQYXJ0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcmVkRnJhZyhwb3NpdGlvbiwgbGV2ZWxUeXBlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBidWZmZXJlZCBGcmFnbWVudCB0aGF0IG1hdGNoZXMgdGhlIHBvc2l0aW9uIGFuZCBsZXZlbFR5cGUuXG4gICAqIEEgYnVmZmVyZWQgRnJhZ21lbnQgaXMgb25lIHdob3NlIGxvYWRpbmcsIHBhcnNpbmcgYW5kIGFwcGVuZGluZyBpcyBkb25lIChjb21wbGV0ZWQgb3IgXCJwYXJ0aWFsXCIgbWVhbmluZyBhYm9ydGVkKS5cbiAgICogSWYgbm90IGZvdW5kIGFueSBGcmFnbWVudCwgcmV0dXJuIG51bGxcbiAgICovXG4gIGdldEJ1ZmZlcmVkRnJhZyhwb3NpdGlvbiwgbGV2ZWxUeXBlKSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZ21lbnRzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50cyk7XG4gICAgZm9yIChsZXQgaSA9IGtleXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICBjb25zdCBmcmFnbWVudEVudGl0eSA9IGZyYWdtZW50c1trZXlzW2ldXTtcbiAgICAgIGlmICgoZnJhZ21lbnRFbnRpdHkgPT0gbnVsbCA/IHZvaWQgMCA6IGZyYWdtZW50RW50aXR5LmJvZHkudHlwZSkgPT09IGxldmVsVHlwZSAmJiBmcmFnbWVudEVudGl0eS5idWZmZXJlZCkge1xuICAgICAgICBjb25zdCBmcmFnID0gZnJhZ21lbnRFbnRpdHkuYm9keTtcbiAgICAgICAgaWYgKGZyYWcuc3RhcnQgPD0gcG9zaXRpb24gJiYgcG9zaXRpb24gPD0gZnJhZy5lbmQpIHtcbiAgICAgICAgICByZXR1cm4gZnJhZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJ0aWFsIGZyYWdtZW50cyBlZmZlY3RlZCBieSBjb2RlZCBmcmFtZSBldmljdGlvbiB3aWxsIGJlIHJlbW92ZWRcbiAgICogVGhlIGJyb3dzZXIgd2lsbCB1bmxvYWQgcGFydHMgb2YgdGhlIGJ1ZmZlciB0byBmcmVlIHVwIG1lbW9yeSBmb3IgbmV3IGJ1ZmZlciBkYXRhXG4gICAqIEZyYWdtZW50cyB3aWxsIG5lZWQgdG8gYmUgcmVsb2FkZWQgd2hlbiB0aGUgYnVmZmVyIGlzIGZyZWVkIHVwLCByZW1vdmluZyBwYXJ0aWFsIGZyYWdtZW50cyB3aWxsIGFsbG93IHRoZW0gdG8gcmVsb2FkKHNpbmNlIHRoZXJlIG1pZ2h0IGJlIHBhcnRzIHRoYXQgYXJlIHN0aWxsIHBsYXlhYmxlKVxuICAgKi9cbiAgZGV0ZWN0RXZpY3RlZEZyYWdtZW50cyhlbGVtZW50YXJ5U3RyZWFtLCB0aW1lUmFuZ2UsIHBsYXlsaXN0VHlwZSwgYXBwZW5kZWRQYXJ0KSB7XG4gICAgaWYgKHRoaXMudGltZVJhbmdlcykge1xuICAgICAgdGhpcy50aW1lUmFuZ2VzW2VsZW1lbnRhcnlTdHJlYW1dID0gdGltZVJhbmdlO1xuICAgIH1cbiAgICAvLyBDaGVjayBpZiBhbnkgZmxhZ2dlZCBmcmFnbWVudHMgaGF2ZSBiZWVuIHVubG9hZGVkXG4gICAgLy8gZXhjbHVkaW5nIGFueXRoaW5nIG5ld2VyIHRoYW4gYXBwZW5kZWRQYXJ0U25cbiAgICBjb25zdCBhcHBlbmRlZFBhcnRTbiA9IChhcHBlbmRlZFBhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IGFwcGVuZGVkUGFydC5mcmFnbWVudC5zbikgfHwgLTE7XG4gICAgT2JqZWN0LmtleXModGhpcy5mcmFnbWVudHMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGNvbnN0IGZyYWdtZW50RW50aXR5ID0gdGhpcy5mcmFnbWVudHNba2V5XTtcbiAgICAgIGlmICghZnJhZ21lbnRFbnRpdHkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGFwcGVuZGVkUGFydFNuID49IGZyYWdtZW50RW50aXR5LmJvZHkuc24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFmcmFnbWVudEVudGl0eS5idWZmZXJlZCAmJiAhZnJhZ21lbnRFbnRpdHkubG9hZGVkKSB7XG4gICAgICAgIGlmIChmcmFnbWVudEVudGl0eS5ib2R5LnR5cGUgPT09IHBsYXlsaXN0VHlwZSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlRnJhZ21lbnQoZnJhZ21lbnRFbnRpdHkuYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZXNEYXRhID0gZnJhZ21lbnRFbnRpdHkucmFuZ2VbZWxlbWVudGFyeVN0cmVhbV07XG4gICAgICBpZiAoIWVzRGF0YSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlc0RhdGEudGltZS5zb21lKHRpbWUgPT4ge1xuICAgICAgICBjb25zdCBpc05vdEJ1ZmZlcmVkID0gIXRoaXMuaXNUaW1lQnVmZmVyZWQodGltZS5zdGFydFBUUywgdGltZS5lbmRQVFMsIHRpbWVSYW5nZSk7XG4gICAgICAgIGlmIChpc05vdEJ1ZmZlcmVkKSB7XG4gICAgICAgICAgLy8gVW5yZWdpc3RlciBwYXJ0aWFsIGZyYWdtZW50IGFzIGl0IG5lZWRzIHRvIGxvYWQgYWdhaW4gdG8gYmUgcmV1c2VkXG4gICAgICAgICAgdGhpcy5yZW1vdmVGcmFnbWVudChmcmFnbWVudEVudGl0eS5ib2R5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNOb3RCdWZmZXJlZDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZnJhZ21lbnQgcGFzc2VkIGluIGlzIGxvYWRlZCBpbiB0aGUgYnVmZmVyIHByb3Blcmx5XG4gICAqIFBhcnRpYWxseSBsb2FkZWQgZnJhZ21lbnRzIHdpbGwgYmUgcmVnaXN0ZXJlZCBhcyBhIHBhcnRpYWwgZnJhZ21lbnRcbiAgICovXG4gIGRldGVjdFBhcnRpYWxGcmFnbWVudHMoZGF0YSkge1xuICAgIGNvbnN0IHRpbWVSYW5nZXMgPSB0aGlzLnRpbWVSYW5nZXM7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIHBhcnRcbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoIXRpbWVSYW5nZXMgfHwgZnJhZy5zbiA9PT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBmcmFnS2V5ID0gZ2V0RnJhZ21lbnRLZXkoZnJhZyk7XG4gICAgY29uc3QgZnJhZ21lbnRFbnRpdHkgPSB0aGlzLmZyYWdtZW50c1tmcmFnS2V5XTtcbiAgICBpZiAoIWZyYWdtZW50RW50aXR5IHx8IGZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkICYmIGZyYWcuZ2FwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlzRnJhZ0hpbnQgPSAhZnJhZy5yZWx1cmw7XG4gICAgT2JqZWN0LmtleXModGltZVJhbmdlcykuZm9yRWFjaChlbGVtZW50YXJ5U3RyZWFtID0+IHtcbiAgICAgIGNvbnN0IHN0cmVhbUluZm8gPSBmcmFnLmVsZW1lbnRhcnlTdHJlYW1zW2VsZW1lbnRhcnlTdHJlYW1dO1xuICAgICAgaWYgKCFzdHJlYW1JbmZvKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRpbWVSYW5nZSA9IHRpbWVSYW5nZXNbZWxlbWVudGFyeVN0cmVhbV07XG4gICAgICBjb25zdCBwYXJ0aWFsID0gaXNGcmFnSGludCB8fCBzdHJlYW1JbmZvLnBhcnRpYWwgPT09IHRydWU7XG4gICAgICBmcmFnbWVudEVudGl0eS5yYW5nZVtlbGVtZW50YXJ5U3RyZWFtXSA9IHRoaXMuZ2V0QnVmZmVyZWRUaW1lcyhmcmFnLCBwYXJ0LCBwYXJ0aWFsLCB0aW1lUmFuZ2UpO1xuICAgIH0pO1xuICAgIGZyYWdtZW50RW50aXR5LmxvYWRlZCA9IG51bGw7XG4gICAgaWYgKE9iamVjdC5rZXlzKGZyYWdtZW50RW50aXR5LnJhbmdlKS5sZW5ndGgpIHtcbiAgICAgIGZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkID0gdHJ1ZTtcbiAgICAgIGNvbnN0IGVuZExpc3QgPSBmcmFnbWVudEVudGl0eS5ib2R5LmVuZExpc3QgPSBmcmFnLmVuZExpc3QgfHwgZnJhZ21lbnRFbnRpdHkuYm9keS5lbmRMaXN0O1xuICAgICAgaWYgKGVuZExpc3QpIHtcbiAgICAgICAgdGhpcy5lbmRMaXN0RnJhZ21lbnRzW2ZyYWdtZW50RW50aXR5LmJvZHkudHlwZV0gPSBmcmFnbWVudEVudGl0eTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNQYXJ0aWFsKGZyYWdtZW50RW50aXR5KSkge1xuICAgICAgICAvLyBSZW1vdmUgb2xkZXIgZnJhZ21lbnQgcGFydHMgZnJvbSBsb29rdXAgYWZ0ZXIgZnJhZyBpcyB0cmFja2VkIGFzIGJ1ZmZlcmVkXG4gICAgICAgIHRoaXMucmVtb3ZlUGFydHMoZnJhZy5zbiAtIDEsIGZyYWcudHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlbW92ZSBmcmFnbWVudCBpZiBub3RoaW5nIHdhcyBhcHBlbmRlZFxuICAgICAgdGhpcy5yZW1vdmVGcmFnbWVudChmcmFnbWVudEVudGl0eS5ib2R5KTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlUGFydHMoc25Ub0tlZXAsIGxldmVsVHlwZSkge1xuICAgIGNvbnN0IGFjdGl2ZVBhcnRzID0gdGhpcy5hY3RpdmVQYXJ0TGlzdHNbbGV2ZWxUeXBlXTtcbiAgICBpZiAoIWFjdGl2ZVBhcnRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlUGFydExpc3RzW2xldmVsVHlwZV0gPSBhY3RpdmVQYXJ0cy5maWx0ZXIocGFydCA9PiBwYXJ0LmZyYWdtZW50LnNuID49IHNuVG9LZWVwKTtcbiAgfVxuICBmcmFnQnVmZmVyZWQoZnJhZywgZm9yY2UpIHtcbiAgICBjb25zdCBmcmFnS2V5ID0gZ2V0RnJhZ21lbnRLZXkoZnJhZyk7XG4gICAgbGV0IGZyYWdtZW50RW50aXR5ID0gdGhpcy5mcmFnbWVudHNbZnJhZ0tleV07XG4gICAgaWYgKCFmcmFnbWVudEVudGl0eSAmJiBmb3JjZSkge1xuICAgICAgZnJhZ21lbnRFbnRpdHkgPSB0aGlzLmZyYWdtZW50c1tmcmFnS2V5XSA9IHtcbiAgICAgICAgYm9keTogZnJhZyxcbiAgICAgICAgYXBwZW5kZWRQVFM6IG51bGwsXG4gICAgICAgIGxvYWRlZDogbnVsbCxcbiAgICAgICAgYnVmZmVyZWQ6IGZhbHNlLFxuICAgICAgICByYW5nZTogT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgICAgfTtcbiAgICAgIGlmIChmcmFnLmdhcCkge1xuICAgICAgICB0aGlzLmhhc0dhcHMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZnJhZ21lbnRFbnRpdHkpIHtcbiAgICAgIGZyYWdtZW50RW50aXR5LmxvYWRlZCA9IG51bGw7XG4gICAgICBmcmFnbWVudEVudGl0eS5idWZmZXJlZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIGdldEJ1ZmZlcmVkVGltZXMoZnJhZ21lbnQsIHBhcnQsIHBhcnRpYWwsIHRpbWVSYW5nZSkge1xuICAgIGNvbnN0IGJ1ZmZlcmVkID0ge1xuICAgICAgdGltZTogW10sXG4gICAgICBwYXJ0aWFsXG4gICAgfTtcbiAgICBjb25zdCBzdGFydFBUUyA9IGZyYWdtZW50LnN0YXJ0O1xuICAgIGNvbnN0IGVuZFBUUyA9IGZyYWdtZW50LmVuZDtcbiAgICBjb25zdCBtaW5FbmRQVFMgPSBmcmFnbWVudC5taW5FbmRQVFMgfHwgZW5kUFRTO1xuICAgIGNvbnN0IG1heFN0YXJ0UFRTID0gZnJhZ21lbnQubWF4U3RhcnRQVFMgfHwgc3RhcnRQVFM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aW1lUmFuZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHRpbWVSYW5nZS5zdGFydChpKSAtIHRoaXMuYnVmZmVyUGFkZGluZztcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSB0aW1lUmFuZ2UuZW5kKGkpICsgdGhpcy5idWZmZXJQYWRkaW5nO1xuICAgICAgaWYgKG1heFN0YXJ0UFRTID49IHN0YXJ0VGltZSAmJiBtaW5FbmRQVFMgPD0gZW5kVGltZSkge1xuICAgICAgICAvLyBGcmFnbWVudCBpcyBlbnRpcmVseSBjb250YWluZWQgaW4gYnVmZmVyXG4gICAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgdGhlIG90aGVyIHRpbWVSYW5nZSB0aW1lcyBzaW5jZSBpdCdzIGNvbXBsZXRlbHkgcGxheWFibGVcbiAgICAgICAgYnVmZmVyZWQudGltZS5wdXNoKHtcbiAgICAgICAgICBzdGFydFBUUzogTWF0aC5tYXgoc3RhcnRQVFMsIHRpbWVSYW5nZS5zdGFydChpKSksXG4gICAgICAgICAgZW5kUFRTOiBNYXRoLm1pbihlbmRQVFMsIHRpbWVSYW5nZS5lbmQoaSkpXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnRQVFMgPCBlbmRUaW1lICYmIGVuZFBUUyA+IHN0YXJ0VGltZSkge1xuICAgICAgICBjb25zdCBzdGFydCA9IE1hdGgubWF4KHN0YXJ0UFRTLCB0aW1lUmFuZ2Uuc3RhcnQoaSkpO1xuICAgICAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihlbmRQVFMsIHRpbWVSYW5nZS5lbmQoaSkpO1xuICAgICAgICBpZiAoZW5kID4gc3RhcnQpIHtcbiAgICAgICAgICBidWZmZXJlZC5wYXJ0aWFsID0gdHJ1ZTtcbiAgICAgICAgICAvLyBDaGVjayBmb3IgaW50ZXJzZWN0aW9uIHdpdGggYnVmZmVyXG4gICAgICAgICAgLy8gR2V0IHBsYXlhYmxlIHNlY3Rpb25zIG9mIHRoZSBmcmFnbWVudFxuICAgICAgICAgIGJ1ZmZlcmVkLnRpbWUucHVzaCh7XG4gICAgICAgICAgICBzdGFydFBUUzogc3RhcnQsXG4gICAgICAgICAgICBlbmRQVFM6IGVuZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVuZFBUUyA8PSBzdGFydFRpbWUpIHtcbiAgICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayB0aGUgcmVzdCBvZiB0aGUgdGltZVJhbmdlIGFzIGl0IGlzIGluIG9yZGVyXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyZWQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgcGFydGlhbCBmcmFnbWVudCBmb3IgYSBjZXJ0YWluIHRpbWVcbiAgICovXG4gIGdldFBhcnRpYWxGcmFnbWVudCh0aW1lKSB7XG4gICAgbGV0IGJlc3RGcmFnbWVudCA9IG51bGw7XG4gICAgbGV0IHRpbWVQYWRkaW5nO1xuICAgIGxldCBzdGFydFRpbWU7XG4gICAgbGV0IGVuZFRpbWU7XG4gICAgbGV0IGJlc3RPdmVybGFwID0gMDtcbiAgICBjb25zdCB7XG4gICAgICBidWZmZXJQYWRkaW5nLFxuICAgICAgZnJhZ21lbnRzXG4gICAgfSA9IHRoaXM7XG4gICAgT2JqZWN0LmtleXMoZnJhZ21lbnRzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBmcmFnbWVudEVudGl0eSA9IGZyYWdtZW50c1trZXldO1xuICAgICAgaWYgKCFmcmFnbWVudEVudGl0eSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNQYXJ0aWFsKGZyYWdtZW50RW50aXR5KSkge1xuICAgICAgICBzdGFydFRpbWUgPSBmcmFnbWVudEVudGl0eS5ib2R5LnN0YXJ0IC0gYnVmZmVyUGFkZGluZztcbiAgICAgICAgZW5kVGltZSA9IGZyYWdtZW50RW50aXR5LmJvZHkuZW5kICsgYnVmZmVyUGFkZGluZztcbiAgICAgICAgaWYgKHRpbWUgPj0gc3RhcnRUaW1lICYmIHRpbWUgPD0gZW5kVGltZSkge1xuICAgICAgICAgIC8vIFVzZSB0aGUgZnJhZ21lbnQgdGhhdCBoYXMgdGhlIG1vc3QgcGFkZGluZyBmcm9tIHN0YXJ0IGFuZCBlbmQgdGltZVxuICAgICAgICAgIHRpbWVQYWRkaW5nID0gTWF0aC5taW4odGltZSAtIHN0YXJ0VGltZSwgZW5kVGltZSAtIHRpbWUpO1xuICAgICAgICAgIGlmIChiZXN0T3ZlcmxhcCA8PSB0aW1lUGFkZGluZykge1xuICAgICAgICAgICAgYmVzdEZyYWdtZW50ID0gZnJhZ21lbnRFbnRpdHkuYm9keTtcbiAgICAgICAgICAgIGJlc3RPdmVybGFwID0gdGltZVBhZGRpbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGJlc3RGcmFnbWVudDtcbiAgfVxuICBpc0VuZExpc3RBcHBlbmRlZCh0eXBlKSB7XG4gICAgY29uc3QgbGFzdEZyYWdtZW50RW50aXR5ID0gdGhpcy5lbmRMaXN0RnJhZ21lbnRzW3R5cGVdO1xuICAgIHJldHVybiBsYXN0RnJhZ21lbnRFbnRpdHkgIT09IHVuZGVmaW5lZCAmJiAobGFzdEZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkIHx8IGlzUGFydGlhbChsYXN0RnJhZ21lbnRFbnRpdHkpKTtcbiAgfVxuICBnZXRTdGF0ZShmcmFnbWVudCkge1xuICAgIGNvbnN0IGZyYWdLZXkgPSBnZXRGcmFnbWVudEtleShmcmFnbWVudCk7XG4gICAgY29uc3QgZnJhZ21lbnRFbnRpdHkgPSB0aGlzLmZyYWdtZW50c1tmcmFnS2V5XTtcbiAgICBpZiAoZnJhZ21lbnRFbnRpdHkpIHtcbiAgICAgIGlmICghZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQpIHtcbiAgICAgICAgcmV0dXJuIEZyYWdtZW50U3RhdGUuQVBQRU5ESU5HO1xuICAgICAgfSBlbHNlIGlmIChpc1BhcnRpYWwoZnJhZ21lbnRFbnRpdHkpKSB7XG4gICAgICAgIHJldHVybiBGcmFnbWVudFN0YXRlLlBBUlRJQUw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gRnJhZ21lbnRTdGF0ZS5PSztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEZyYWdtZW50U3RhdGUuTk9UX0xPQURFRDtcbiAgfVxuICBpc1RpbWVCdWZmZXJlZChzdGFydFBUUywgZW5kUFRTLCB0aW1lUmFuZ2UpIHtcbiAgICBsZXQgc3RhcnRUaW1lO1xuICAgIGxldCBlbmRUaW1lO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGltZVJhbmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzdGFydFRpbWUgPSB0aW1lUmFuZ2Uuc3RhcnQoaSkgLSB0aGlzLmJ1ZmZlclBhZGRpbmc7XG4gICAgICBlbmRUaW1lID0gdGltZVJhbmdlLmVuZChpKSArIHRoaXMuYnVmZmVyUGFkZGluZztcbiAgICAgIGlmIChzdGFydFBUUyA+PSBzdGFydFRpbWUgJiYgZW5kUFRTIDw9IGVuZFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoZW5kUFRTIDw9IHN0YXJ0VGltZSkge1xuICAgICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIHRoZSByZXN0IG9mIHRoZSB0aW1lUmFuZ2UgYXMgaXQgaXMgaW4gb3JkZXJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgb25GcmFnTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIHBhcnRcbiAgICB9ID0gZGF0YTtcbiAgICAvLyBkb24ndCB0cmFjayBpbml0c2VnbWVudCAoZm9yIHdoaWNoIHNuIGlzIG5vdCBhIG51bWJlcilcbiAgICAvLyBkb24ndCB0cmFjayBmcmFncyB1c2VkIGZvciBiaXRyYXRlVGVzdCwgdGhleSdyZSBpcnJlbGV2YW50LlxuICAgIGlmIChmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnIHx8IGZyYWcuYml0cmF0ZVRlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBGcmFnbWVudCBlbnRpdHkgYGxvYWRlZGAgRnJhZ0xvYWRlZERhdGEgaXMgbnVsbCB3aGVuIGxvYWRpbmcgcGFydHNcbiAgICBjb25zdCBsb2FkZWQgPSBwYXJ0ID8gbnVsbCA6IGRhdGE7XG4gICAgY29uc3QgZnJhZ0tleSA9IGdldEZyYWdtZW50S2V5KGZyYWcpO1xuICAgIHRoaXMuZnJhZ21lbnRzW2ZyYWdLZXldID0ge1xuICAgICAgYm9keTogZnJhZyxcbiAgICAgIGFwcGVuZGVkUFRTOiBudWxsLFxuICAgICAgbG9hZGVkLFxuICAgICAgYnVmZmVyZWQ6IGZhbHNlLFxuICAgICAgcmFuZ2U6IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICB9O1xuICB9XG4gIG9uQnVmZmVyQXBwZW5kZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnLFxuICAgICAgcGFydCxcbiAgICAgIHRpbWVSYW5nZXNcbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoZnJhZy5zbiA9PT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwbGF5bGlzdFR5cGUgPSBmcmFnLnR5cGU7XG4gICAgaWYgKHBhcnQpIHtcbiAgICAgIGxldCBhY3RpdmVQYXJ0cyA9IHRoaXMuYWN0aXZlUGFydExpc3RzW3BsYXlsaXN0VHlwZV07XG4gICAgICBpZiAoIWFjdGl2ZVBhcnRzKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlUGFydExpc3RzW3BsYXlsaXN0VHlwZV0gPSBhY3RpdmVQYXJ0cyA9IFtdO1xuICAgICAgfVxuICAgICAgYWN0aXZlUGFydHMucHVzaChwYXJ0KTtcbiAgICB9XG4gICAgLy8gU3RvcmUgdGhlIGxhdGVzdCB0aW1lUmFuZ2VzIGxvYWRlZCBpbiB0aGUgYnVmZmVyXG4gICAgdGhpcy50aW1lUmFuZ2VzID0gdGltZVJhbmdlcztcbiAgICBPYmplY3Qua2V5cyh0aW1lUmFuZ2VzKS5mb3JFYWNoKGVsZW1lbnRhcnlTdHJlYW0gPT4ge1xuICAgICAgY29uc3QgdGltZVJhbmdlID0gdGltZVJhbmdlc1tlbGVtZW50YXJ5U3RyZWFtXTtcbiAgICAgIHRoaXMuZGV0ZWN0RXZpY3RlZEZyYWdtZW50cyhlbGVtZW50YXJ5U3RyZWFtLCB0aW1lUmFuZ2UsIHBsYXlsaXN0VHlwZSwgcGFydCk7XG4gICAgfSk7XG4gIH1cbiAgb25GcmFnQnVmZmVyZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLmRldGVjdFBhcnRpYWxGcmFnbWVudHMoZGF0YSk7XG4gIH1cbiAgaGFzRnJhZ21lbnQoZnJhZ21lbnQpIHtcbiAgICBjb25zdCBmcmFnS2V5ID0gZ2V0RnJhZ21lbnRLZXkoZnJhZ21lbnQpO1xuICAgIHJldHVybiAhIXRoaXMuZnJhZ21lbnRzW2ZyYWdLZXldO1xuICB9XG4gIGhhc1BhcnRzKHR5cGUpIHtcbiAgICB2YXIgX3RoaXMkYWN0aXZlUGFydExpc3RzO1xuICAgIHJldHVybiAhISgoX3RoaXMkYWN0aXZlUGFydExpc3RzID0gdGhpcy5hY3RpdmVQYXJ0TGlzdHNbdHlwZV0pICE9IG51bGwgJiYgX3RoaXMkYWN0aXZlUGFydExpc3RzLmxlbmd0aCk7XG4gIH1cbiAgcmVtb3ZlRnJhZ21lbnRzSW5SYW5nZShzdGFydCwgZW5kLCBwbGF5bGlzdFR5cGUsIHdpdGhHYXBPbmx5LCB1bmJ1ZmZlcmVkT25seSkge1xuICAgIGlmICh3aXRoR2FwT25seSAmJiAhdGhpcy5oYXNHYXBzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKHRoaXMuZnJhZ21lbnRzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBmcmFnbWVudEVudGl0eSA9IHRoaXMuZnJhZ21lbnRzW2tleV07XG4gICAgICBpZiAoIWZyYWdtZW50RW50aXR5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZyYWcgPSBmcmFnbWVudEVudGl0eS5ib2R5O1xuICAgICAgaWYgKGZyYWcudHlwZSAhPT0gcGxheWxpc3RUeXBlIHx8IHdpdGhHYXBPbmx5ICYmICFmcmFnLmdhcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZnJhZy5zdGFydCA8IGVuZCAmJiBmcmFnLmVuZCA+IHN0YXJ0ICYmIChmcmFnbWVudEVudGl0eS5idWZmZXJlZCB8fCB1bmJ1ZmZlcmVkT25seSkpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZW1vdmVGcmFnbWVudChmcmFnbWVudCkge1xuICAgIGNvbnN0IGZyYWdLZXkgPSBnZXRGcmFnbWVudEtleShmcmFnbWVudCk7XG4gICAgZnJhZ21lbnQuc3RhdHMubG9hZGVkID0gMDtcbiAgICBmcmFnbWVudC5jbGVhckVsZW1lbnRhcnlTdHJlYW1JbmZvKCk7XG4gICAgY29uc3QgYWN0aXZlUGFydHMgPSB0aGlzLmFjdGl2ZVBhcnRMaXN0c1tmcmFnbWVudC50eXBlXTtcbiAgICBpZiAoYWN0aXZlUGFydHMpIHtcbiAgICAgIGNvbnN0IHNuVG9SZW1vdmUgPSBmcmFnbWVudC5zbjtcbiAgICAgIHRoaXMuYWN0aXZlUGFydExpc3RzW2ZyYWdtZW50LnR5cGVdID0gYWN0aXZlUGFydHMuZmlsdGVyKHBhcnQgPT4gcGFydC5mcmFnbWVudC5zbiAhPT0gc25Ub1JlbW92ZSk7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLmZyYWdtZW50c1tmcmFnS2V5XTtcbiAgICBpZiAoZnJhZ21lbnQuZW5kTGlzdCkge1xuICAgICAgZGVsZXRlIHRoaXMuZW5kTGlzdEZyYWdtZW50c1tmcmFnbWVudC50eXBlXTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlQWxsRnJhZ21lbnRzKCkge1xuICAgIHRoaXMuZnJhZ21lbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmVuZExpc3RGcmFnbWVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuYWN0aXZlUGFydExpc3RzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmhhc0dhcHMgPSBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gaXNQYXJ0aWFsKGZyYWdtZW50RW50aXR5KSB7XG4gIHZhciBfZnJhZ21lbnRFbnRpdHkkcmFuZ2UsIF9mcmFnbWVudEVudGl0eSRyYW5nZTIsIF9mcmFnbWVudEVudGl0eSRyYW5nZTM7XG4gIHJldHVybiBmcmFnbWVudEVudGl0eS5idWZmZXJlZCAmJiAoZnJhZ21lbnRFbnRpdHkuYm9keS5nYXAgfHwgKChfZnJhZ21lbnRFbnRpdHkkcmFuZ2UgPSBmcmFnbWVudEVudGl0eS5yYW5nZS52aWRlbykgPT0gbnVsbCA/IHZvaWQgMCA6IF9mcmFnbWVudEVudGl0eSRyYW5nZS5wYXJ0aWFsKSB8fCAoKF9mcmFnbWVudEVudGl0eSRyYW5nZTIgPSBmcmFnbWVudEVudGl0eS5yYW5nZS5hdWRpbykgPT0gbnVsbCA/IHZvaWQgMCA6IF9mcmFnbWVudEVudGl0eSRyYW5nZTIucGFydGlhbCkgfHwgKChfZnJhZ21lbnRFbnRpdHkkcmFuZ2UzID0gZnJhZ21lbnRFbnRpdHkucmFuZ2UuYXVkaW92aWRlbykgPT0gbnVsbCA/IHZvaWQgMCA6IF9mcmFnbWVudEVudGl0eSRyYW5nZTMucGFydGlhbCkpO1xufVxuZnVuY3Rpb24gZ2V0RnJhZ21lbnRLZXkoZnJhZ21lbnQpIHtcbiAgcmV0dXJuIGAke2ZyYWdtZW50LnR5cGV9XyR7ZnJhZ21lbnQubGV2ZWx9XyR7ZnJhZ21lbnQuc259YDtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBtZXRob2RzIGRlYWxpbmcgd2l0aCBidWZmZXIgbGVuZ3RoIHJldHJpZXZhbCBmb3IgZXhhbXBsZS5cbiAqXG4gKiBJbiBnZW5lcmFsLCBhIGhlbHBlciBhcm91bmQgSFRNTDUgTWVkaWFFbGVtZW50IFRpbWVSYW5nZXMgZ2F0aGVyZWQgZnJvbSBgYnVmZmVyZWRgIHByb3BlcnR5LlxuICpcbiAqIEFsc28gQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTE1lZGlhRWxlbWVudC9idWZmZXJlZFxuICovXG5cbmNvbnN0IG5vb3BCdWZmZXJlZCA9IHtcbiAgbGVuZ3RoOiAwLFxuICBzdGFydDogKCkgPT4gMCxcbiAgZW5kOiAoKSA9PiAwXG59O1xuY2xhc3MgQnVmZmVySGVscGVyIHtcbiAgLyoqXG4gICAqIFJldHVybiB0cnVlIGlmIGBtZWRpYWAncyBidWZmZXJlZCBpbmNsdWRlIGBwb3NpdGlvbmBcbiAgICovXG4gIHN0YXRpYyBpc0J1ZmZlcmVkKG1lZGlhLCBwb3NpdGlvbikge1xuICAgIHRyeSB7XG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyZWQgPSBCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQobWVkaWEpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHBvc2l0aW9uID49IGJ1ZmZlcmVkLnN0YXJ0KGkpICYmIHBvc2l0aW9uIDw9IGJ1ZmZlcmVkLmVuZChpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIHRoaXMgaXMgdG8gY2F0Y2hcbiAgICAgIC8vIEludmFsaWRTdGF0ZUVycm9yOiBGYWlsZWQgdG8gcmVhZCB0aGUgJ2J1ZmZlcmVkJyBwcm9wZXJ0eSBmcm9tICdTb3VyY2VCdWZmZXInOlxuICAgICAgLy8gVGhpcyBTb3VyY2VCdWZmZXIgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnQgbWVkaWEgc291cmNlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgYnVmZmVySW5mbyhtZWRpYSwgcG9zLCBtYXhIb2xlRHVyYXRpb24pIHtcbiAgICB0cnkge1xuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIGNvbnN0IHZidWZmZXJlZCA9IEJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZChtZWRpYSk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlcmVkID0gW107XG4gICAgICAgIGxldCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYnVmZmVyZWQucHVzaCh7XG4gICAgICAgICAgICBzdGFydDogdmJ1ZmZlcmVkLnN0YXJ0KGkpLFxuICAgICAgICAgICAgZW5kOiB2YnVmZmVyZWQuZW5kKGkpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyZWRJbmZvKGJ1ZmZlcmVkLCBwb3MsIG1heEhvbGVEdXJhdGlvbik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIHRoaXMgaXMgdG8gY2F0Y2hcbiAgICAgIC8vIEludmFsaWRTdGF0ZUVycm9yOiBGYWlsZWQgdG8gcmVhZCB0aGUgJ2J1ZmZlcmVkJyBwcm9wZXJ0eSBmcm9tICdTb3VyY2VCdWZmZXInOlxuICAgICAgLy8gVGhpcyBTb3VyY2VCdWZmZXIgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnQgbWVkaWEgc291cmNlXG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBsZW46IDAsXG4gICAgICBzdGFydDogcG9zLFxuICAgICAgZW5kOiBwb3MsXG4gICAgICBuZXh0U3RhcnQ6IHVuZGVmaW5lZFxuICAgIH07XG4gIH1cbiAgc3RhdGljIGJ1ZmZlcmVkSW5mbyhidWZmZXJlZCwgcG9zLCBtYXhIb2xlRHVyYXRpb24pIHtcbiAgICBwb3MgPSBNYXRoLm1heCgwLCBwb3MpO1xuICAgIC8vIHNvcnQgb24gYnVmZmVyLnN0YXJ0L3NtYWxsZXIgZW5kIChJRSBkb2VzIG5vdCBhbHdheXMgcmV0dXJuIHNvcnRlZCBidWZmZXJlZCByYW5nZSlcbiAgICBidWZmZXJlZC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICBjb25zdCBkaWZmID0gYS5zdGFydCAtIGIuc3RhcnQ7XG4gICAgICBpZiAoZGlmZikge1xuICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBiLmVuZCAtIGEuZW5kO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBidWZmZXJlZDIgPSBbXTtcbiAgICBpZiAobWF4SG9sZUR1cmF0aW9uKSB7XG4gICAgICAvLyB0aGVyZSBtaWdodCBiZSBzb21lIHNtYWxsIGhvbGVzIGJldHdlZW4gYnVmZmVyIHRpbWUgcmFuZ2VcbiAgICAgIC8vIGNvbnNpZGVyIHRoYXQgaG9sZXMgc21hbGxlciB0aGFuIG1heEhvbGVEdXJhdGlvbiBhcmUgaXJyZWxldmFudCBhbmQgYnVpbGQgYW5vdGhlclxuICAgICAgLy8gYnVmZmVyIHRpbWUgcmFuZ2UgcmVwcmVzZW50YXRpb25zIHRoYXQgZGlzY2FyZHMgdGhvc2UgaG9sZXNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYnVmMmxlbiA9IGJ1ZmZlcmVkMi5sZW5ndGg7XG4gICAgICAgIGlmIChidWYybGVuKSB7XG4gICAgICAgICAgY29uc3QgYnVmMmVuZCA9IGJ1ZmZlcmVkMltidWYybGVuIC0gMV0uZW5kO1xuICAgICAgICAgIC8vIGlmIHNtYWxsIGhvbGUgKHZhbHVlIGJldHdlZW4gMCBvciBtYXhIb2xlRHVyYXRpb24gKSBvciBvdmVybGFwcGluZyAobmVnYXRpdmUpXG4gICAgICAgICAgaWYgKGJ1ZmZlcmVkW2ldLnN0YXJ0IC0gYnVmMmVuZCA8IG1heEhvbGVEdXJhdGlvbikge1xuICAgICAgICAgICAgLy8gbWVyZ2Ugb3ZlcmxhcHBpbmcgdGltZSByYW5nZXNcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBsYXN0UmFuZ2UuZW5kIG9ubHkgaWYgc21hbGxlciB0aGFuIGl0ZW0uZW5kXG4gICAgICAgICAgICAvLyBlLmcuICBbIDEsIDE1XSB3aXRoICBbIDIsOF0gPT4gWyAxLDE1XSAobm8gbmVlZCB0byBtb2RpZnkgbGFzdFJhbmdlLmVuZClcbiAgICAgICAgICAgIC8vIHdoZXJlYXMgWyAxLCA4XSB3aXRoICBbIDIsMTVdID0+IFsgMSwxNV0gKCBsYXN0UmFuZ2Ugc2hvdWxkIHN3aXRjaCBmcm9tIFsxLDhdIHRvIFsxLDE1XSlcbiAgICAgICAgICAgIGlmIChidWZmZXJlZFtpXS5lbmQgPiBidWYyZW5kKSB7XG4gICAgICAgICAgICAgIGJ1ZmZlcmVkMltidWYybGVuIC0gMV0uZW5kID0gYnVmZmVyZWRbaV0uZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBiaWcgaG9sZVxuICAgICAgICAgICAgYnVmZmVyZWQyLnB1c2goYnVmZmVyZWRbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBmaXJzdCB2YWx1ZVxuICAgICAgICAgIGJ1ZmZlcmVkMi5wdXNoKGJ1ZmZlcmVkW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXJlZDIgPSBidWZmZXJlZDtcbiAgICB9XG4gICAgbGV0IGJ1ZmZlckxlbiA9IDA7XG5cbiAgICAvLyBidWZmZXJTdGFydE5leHQgY2FuIHBvc3NpYmx5IGJlIHVuZGVmaW5lZCBiYXNlZCBvbiB0aGUgY29uZGl0aW9uYWwgbG9naWMgYmVsb3dcbiAgICBsZXQgYnVmZmVyU3RhcnROZXh0O1xuXG4gICAgLy8gYnVmZmVyU3RhcnQgYW5kIGJ1ZmZlckVuZCBhcmUgYnVmZmVyIGJvdW5kYXJpZXMgYXJvdW5kIGN1cnJlbnQgdmlkZW8gcG9zaXRpb25cbiAgICBsZXQgYnVmZmVyU3RhcnQgPSBwb3M7XG4gICAgbGV0IGJ1ZmZlckVuZCA9IHBvcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlcmVkMi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc3RhcnQgPSBidWZmZXJlZDJbaV0uc3RhcnQ7XG4gICAgICBjb25zdCBlbmQgPSBidWZmZXJlZDJbaV0uZW5kO1xuICAgICAgLy8gbG9nZ2VyLmxvZygnYnVmIHN0YXJ0L2VuZDonICsgYnVmZmVyZWQuc3RhcnQoaSkgKyAnLycgKyBidWZmZXJlZC5lbmQoaSkpO1xuICAgICAgaWYgKHBvcyArIG1heEhvbGVEdXJhdGlvbiA+PSBzdGFydCAmJiBwb3MgPCBlbmQpIHtcbiAgICAgICAgLy8gcGxheSBwb3NpdGlvbiBpcyBpbnNpZGUgdGhpcyBidWZmZXIgVGltZVJhbmdlLCByZXRyaWV2ZSBlbmQgb2YgYnVmZmVyIHBvc2l0aW9uIGFuZCBidWZmZXIgbGVuZ3RoXG4gICAgICAgIGJ1ZmZlclN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIGJ1ZmZlckVuZCA9IGVuZDtcbiAgICAgICAgYnVmZmVyTGVuID0gYnVmZmVyRW5kIC0gcG9zO1xuICAgICAgfSBlbHNlIGlmIChwb3MgKyBtYXhIb2xlRHVyYXRpb24gPCBzdGFydCkge1xuICAgICAgICBidWZmZXJTdGFydE5leHQgPSBzdGFydDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBsZW46IGJ1ZmZlckxlbixcbiAgICAgIHN0YXJ0OiBidWZmZXJTdGFydCB8fCAwLFxuICAgICAgZW5kOiBidWZmZXJFbmQgfHwgMCxcbiAgICAgIG5leHRTdGFydDogYnVmZmVyU3RhcnROZXh0XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTYWZlIG1ldGhvZCB0byBnZXQgYnVmZmVyZWQgcHJvcGVydHkuXG4gICAqIFNvdXJjZUJ1ZmZlci5idWZmZXJlZCBtYXkgdGhyb3cgaWYgU291cmNlQnVmZmVyIGlzIHJlbW92ZWQgZnJvbSBpdCdzIE1lZGlhU291cmNlXG4gICAqL1xuICBzdGF0aWMgZ2V0QnVmZmVyZWQobWVkaWEpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG1lZGlhLmJ1ZmZlcmVkO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ2dlci5sb2coJ2ZhaWxlZCB0byBnZXQgbWVkaWEuYnVmZmVyZWQnLCBlKTtcbiAgICAgIHJldHVybiBub29wQnVmZmVyZWQ7XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIENodW5rTWV0YWRhdGEge1xuICBjb25zdHJ1Y3RvcihsZXZlbCwgc24sIGlkLCBzaXplID0gMCwgcGFydCA9IC0xLCBwYXJ0aWFsID0gZmFsc2UpIHtcbiAgICB0aGlzLmxldmVsID0gdm9pZCAwO1xuICAgIHRoaXMuc24gPSB2b2lkIDA7XG4gICAgdGhpcy5wYXJ0ID0gdm9pZCAwO1xuICAgIHRoaXMuaWQgPSB2b2lkIDA7XG4gICAgdGhpcy5zaXplID0gdm9pZCAwO1xuICAgIHRoaXMucGFydGlhbCA9IHZvaWQgMDtcbiAgICB0aGlzLnRyYW5zbXV4aW5nID0gZ2V0TmV3UGVyZm9ybWFuY2VUaW1pbmcoKTtcbiAgICB0aGlzLmJ1ZmZlcmluZyA9IHtcbiAgICAgIGF1ZGlvOiBnZXROZXdQZXJmb3JtYW5jZVRpbWluZygpLFxuICAgICAgdmlkZW86IGdldE5ld1BlcmZvcm1hbmNlVGltaW5nKCksXG4gICAgICBhdWRpb3ZpZGVvOiBnZXROZXdQZXJmb3JtYW5jZVRpbWluZygpXG4gICAgfTtcbiAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gICAgdGhpcy5zbiA9IHNuO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIHRoaXMucGFydCA9IHBhcnQ7XG4gICAgdGhpcy5wYXJ0aWFsID0gcGFydGlhbDtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0TmV3UGVyZm9ybWFuY2VUaW1pbmcoKSB7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IDAsXG4gICAgZXhlY3V0ZVN0YXJ0OiAwLFxuICAgIGV4ZWN1dGVFbmQ6IDAsXG4gICAgZW5kOiAwXG4gIH07XG59XG5cbmZ1bmN0aW9uIGZpbmRGaXJzdEZyYWdXaXRoQ0MoZnJhZ21lbnRzLCBjYykge1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gZnJhZ21lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIF9mcmFnbWVudHMkaTtcbiAgICBpZiAoKChfZnJhZ21lbnRzJGkgPSBmcmFnbWVudHNbaV0pID09IG51bGwgPyB2b2lkIDAgOiBfZnJhZ21lbnRzJGkuY2MpID09PSBjYykge1xuICAgICAgcmV0dXJuIGZyYWdtZW50c1tpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBzaG91bGRBbGlnbk9uRGlzY29udGludWl0aWVzKGxhc3RGcmFnLCBzd2l0Y2hEZXRhaWxzLCBkZXRhaWxzKSB7XG4gIGlmIChzd2l0Y2hEZXRhaWxzKSB7XG4gICAgaWYgKGRldGFpbHMuZW5kQ0MgPiBkZXRhaWxzLnN0YXJ0Q0MgfHwgbGFzdEZyYWcgJiYgbGFzdEZyYWcuY2MgPCBkZXRhaWxzLnN0YXJ0Q0MpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIEZpbmQgdGhlIGZpcnN0IGZyYWcgaW4gdGhlIHByZXZpb3VzIGxldmVsIHdoaWNoIG1hdGNoZXMgdGhlIENDIG9mIHRoZSBmaXJzdCBmcmFnIG9mIHRoZSBuZXcgbGV2ZWxcbmZ1bmN0aW9uIGZpbmREaXNjb250aW51b3VzUmVmZXJlbmNlRnJhZyhwcmV2RGV0YWlscywgY3VyRGV0YWlscykge1xuICBjb25zdCBwcmV2RnJhZ3MgPSBwcmV2RGV0YWlscy5mcmFnbWVudHM7XG4gIGNvbnN0IGN1ckZyYWdzID0gY3VyRGV0YWlscy5mcmFnbWVudHM7XG4gIGlmICghY3VyRnJhZ3MubGVuZ3RoIHx8ICFwcmV2RnJhZ3MubGVuZ3RoKSB7XG4gICAgbG9nZ2VyLmxvZygnTm8gZnJhZ21lbnRzIHRvIGFsaWduJyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHByZXZTdGFydEZyYWcgPSBmaW5kRmlyc3RGcmFnV2l0aENDKHByZXZGcmFncywgY3VyRnJhZ3NbMF0uY2MpO1xuICBpZiAoIXByZXZTdGFydEZyYWcgfHwgcHJldlN0YXJ0RnJhZyAmJiAhcHJldlN0YXJ0RnJhZy5zdGFydFBUUykge1xuICAgIGxvZ2dlci5sb2coJ05vIGZyYWcgaW4gcHJldmlvdXMgbGV2ZWwgdG8gYWxpZ24gb24nKTtcbiAgICByZXR1cm47XG4gIH1cbiAgcmV0dXJuIHByZXZTdGFydEZyYWc7XG59XG5mdW5jdGlvbiBhZGp1c3RGcmFnbWVudFN0YXJ0KGZyYWcsIHNsaWRpbmcpIHtcbiAgaWYgKGZyYWcpIHtcbiAgICBjb25zdCBzdGFydCA9IGZyYWcuc3RhcnQgKyBzbGlkaW5nO1xuICAgIGZyYWcuc3RhcnQgPSBmcmFnLnN0YXJ0UFRTID0gc3RhcnQ7XG4gICAgZnJhZy5lbmRQVFMgPSBzdGFydCArIGZyYWcuZHVyYXRpb247XG4gIH1cbn1cbmZ1bmN0aW9uIGFkanVzdFNsaWRpbmdTdGFydChzbGlkaW5nLCBkZXRhaWxzKSB7XG4gIC8vIFVwZGF0ZSBzZWdtZW50c1xuICBjb25zdCBmcmFnbWVudHMgPSBkZXRhaWxzLmZyYWdtZW50cztcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGZyYWdtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGFkanVzdEZyYWdtZW50U3RhcnQoZnJhZ21lbnRzW2ldLCBzbGlkaW5nKTtcbiAgfVxuICAvLyBVcGRhdGUgTEwtSExTIHBhcnRzIGF0IHRoZSBlbmQgb2YgdGhlIHBsYXlsaXN0XG4gIGlmIChkZXRhaWxzLmZyYWdtZW50SGludCkge1xuICAgIGFkanVzdEZyYWdtZW50U3RhcnQoZGV0YWlscy5mcmFnbWVudEhpbnQsIHNsaWRpbmcpO1xuICB9XG4gIGRldGFpbHMuYWxpZ25lZFNsaWRpbmcgPSB0cnVlO1xufVxuXG4vKipcbiAqIFVzaW5nIHRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBsYXN0IGxldmVsLCB0aGlzIGZ1bmN0aW9uIGNvbXB1dGVzIFBUUycgb2YgdGhlIG5ldyBmcmFnbWVudHMgc28gdGhhdCB0aGV5IGZvcm0gYVxuICogY29udGlndW91cyBzdHJlYW0gd2l0aCB0aGUgbGFzdCBmcmFnbWVudHMuXG4gKiBUaGUgUFRTIG9mIGEgZnJhZ21lbnQgbGV0cyBIbHMuanMga25vdyB3aGVyZSBpdCBmaXRzIGludG8gYSBzdHJlYW0gLSBieSBrbm93aW5nIGV2ZXJ5IFBUUywgd2Uga25vdyB3aGljaCBmcmFnbWVudCB0b1xuICogZG93bmxvYWQgYXQgYW55IGdpdmVuIHRpbWUuIFBUUyBpcyBub3JtYWxseSBjb21wdXRlZCB3aGVuIHRoZSBmcmFnbWVudCBpcyBkZW11eGVkLCBzbyB0YWtpbmcgdGhpcyBzdGVwIHNhdmVzIHVzIHRpbWVcbiAqIGFuZCBhbiBleHRyYSBkb3dubG9hZC5cbiAqIEBwYXJhbSBsYXN0RnJhZ1xuICogQHBhcmFtIGxhc3RMZXZlbFxuICogQHBhcmFtIGRldGFpbHNcbiAqL1xuZnVuY3Rpb24gYWxpZ25TdHJlYW0obGFzdEZyYWcsIHN3aXRjaERldGFpbHMsIGRldGFpbHMpIHtcbiAgaWYgKCFzd2l0Y2hEZXRhaWxzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFsaWduRGlzY29udGludWl0aWVzKGxhc3RGcmFnLCBkZXRhaWxzLCBzd2l0Y2hEZXRhaWxzKTtcbiAgaWYgKCFkZXRhaWxzLmFsaWduZWRTbGlkaW5nICYmIHN3aXRjaERldGFpbHMpIHtcbiAgICAvLyBJZiB0aGUgUFRTIHdhc24ndCBmaWd1cmVkIG91dCB2aWEgZGlzY29udGludWl0eSBzZXF1ZW5jZSB0aGF0IG1lYW5zIHRoZXJlIHdhcyBubyBDQyBpbmNyZWFzZSB3aXRoaW4gdGhlIGxldmVsLlxuICAgIC8vIEFsaWduaW5nIHZpYSBQcm9ncmFtIERhdGUgVGltZSBzaG91bGQgdGhlcmVmb3JlIGJlIHJlbGlhYmxlLCBzaW5jZSBQRFQgc2hvdWxkIGJlIHRoZSBzYW1lIHdpdGhpbiB0aGUgc2FtZVxuICAgIC8vIGRpc2NvbnRpbnVpdHkgc2VxdWVuY2UuXG4gICAgYWxpZ25NZWRpYVBsYXlsaXN0QnlQRFQoZGV0YWlscywgc3dpdGNoRGV0YWlscyk7XG4gIH1cbiAgaWYgKCFkZXRhaWxzLmFsaWduZWRTbGlkaW5nICYmIHN3aXRjaERldGFpbHMgJiYgIWRldGFpbHMuc2tpcHBlZFNlZ21lbnRzKSB7XG4gICAgLy8gVHJ5IHRvIGFsaWduIG9uIHNuIHNvIHRoYXQgd2UgcGljayBhIGJldHRlciBzdGFydCBmcmFnbWVudC5cbiAgICAvLyBEbyBub3QgcGVyZm9ybSB0aGlzIG9uIHBsYXlsaXN0cyB3aXRoIGRlbHRhIHVwZGF0ZXMgYXMgdGhpcyBpcyBvbmx5IHRvIGFsaWduIGxldmVscyBvbiBzd2l0Y2hcbiAgICAvLyBhbmQgYWRqdXN0U2xpZGluZyBvbmx5IGFkanVzdHMgZnJhZ21lbnRzIGFmdGVyIHNraXBwZWRTZWdtZW50cy5cbiAgICBhZGp1c3RTbGlkaW5nKHN3aXRjaERldGFpbHMsIGRldGFpbHMpO1xuICB9XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIFBUUyBpZiBhIG5ldyBsZXZlbCdzIGZyYWdtZW50cyB1c2luZyB0aGUgUFRTIG9mIGEgZnJhZ21lbnQgaW4gdGhlIGxhc3QgbGV2ZWwgd2hpY2ggc2hhcmVzIHRoZSBzYW1lXG4gKiBkaXNjb250aW51aXR5IHNlcXVlbmNlLlxuICogQHBhcmFtIGxhc3RGcmFnIC0gVGhlIGxhc3QgRnJhZ21lbnQgd2hpY2ggc2hhcmVzIHRoZSBzYW1lIGRpc2NvbnRpbnVpdHkgc2VxdWVuY2VcbiAqIEBwYXJhbSBsYXN0TGV2ZWwgLSBUaGUgZGV0YWlscyBvZiB0aGUgbGFzdCBsb2FkZWQgbGV2ZWxcbiAqIEBwYXJhbSBkZXRhaWxzIC0gVGhlIGRldGFpbHMgb2YgdGhlIG5ldyBsZXZlbFxuICovXG5mdW5jdGlvbiBhbGlnbkRpc2NvbnRpbnVpdGllcyhsYXN0RnJhZywgZGV0YWlscywgc3dpdGNoRGV0YWlscykge1xuICBpZiAoc2hvdWxkQWxpZ25PbkRpc2NvbnRpbnVpdGllcyhsYXN0RnJhZywgc3dpdGNoRGV0YWlscywgZGV0YWlscykpIHtcbiAgICBjb25zdCByZWZlcmVuY2VGcmFnID0gZmluZERpc2NvbnRpbnVvdXNSZWZlcmVuY2VGcmFnKHN3aXRjaERldGFpbHMsIGRldGFpbHMpO1xuICAgIGlmIChyZWZlcmVuY2VGcmFnICYmIGlzRmluaXRlTnVtYmVyKHJlZmVyZW5jZUZyYWcuc3RhcnQpKSB7XG4gICAgICBsb2dnZXIubG9nKGBBZGp1c3RpbmcgUFRTIHVzaW5nIGxhc3QgbGV2ZWwgZHVlIHRvIENDIGluY3JlYXNlIHdpdGhpbiBjdXJyZW50IGxldmVsICR7ZGV0YWlscy51cmx9YCk7XG4gICAgICBhZGp1c3RTbGlkaW5nU3RhcnQocmVmZXJlbmNlRnJhZy5zdGFydCwgZGV0YWlscyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRW5zdXJlcyBhcHByb3ByaWF0ZSB0aW1lLWFsaWdubWVudCBiZXR3ZWVuIHJlbmRpdGlvbnMgYmFzZWQgb24gUERULlxuICogVGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoZSB0aW1lbGluZXMgcmVwcmVzZW50ZWQgaW4gYHJlZkRldGFpbHNgIGFyZSBhY2N1cmF0ZSwgaW5jbHVkaW5nIHRoZSBQRFRzXG4gKiBmb3IgdGhlIGxhc3QgZGlzY29udGludWl0eSBzZXF1ZW5jZSBudW1iZXIgc2hhcmVkIGJ5IGJvdGggcGxheWxpc3RzIHdoZW4gcHJlc2VudCxcbiAqIGFuZCB1c2VzIHRoZSBcIndhbGxjbG9ja1wiL1BEVCB0aW1lbGluZSBhcyBhIGNyb3NzLXJlZmVyZW5jZSB0byBgZGV0YWlsc2AsIGFkanVzdGluZyB0aGUgcHJlc2VudGF0aW9uXG4gKiB0aW1lcy90aW1lbGluZXMgb2YgYGRldGFpbHNgIGFjY29yZGluZ2x5LlxuICogR2l2ZW4gdGhlIGFzeW5jaHJvbm91cyBuYXR1cmUgb2YgZmV0Y2hlcyBhbmQgaW5pdGlhbCBsb2FkcyBvZiBsaXZlIGBtYWluYCBhbmQgYXVkaW8vc3VidGl0bGUgdHJhY2tzLFxuICogdGhlIHByaW1hcnkgcHVycG9zZSBvZiB0aGlzIGZ1bmN0aW9uIGlzIHRvIGVuc3VyZSB0aGUgXCJsb2NhbCB0aW1lbGluZXNcIiBvZiBhdWRpby9zdWJ0aXRsZSB0cmFja3NcbiAqIGFyZSBhbGlnbmVkIHRvIHRoZSBtYWluL3ZpZGVvIHRpbWVsaW5lLCB1c2luZyBQRFQgYXMgdGhlIGNyb3NzLXJlZmVyZW5jZS9cImFuY2hvclwiIHRoYXQgc2hvdWxkXG4gKiBiZSBjb25zaXN0ZW50IGFjcm9zcyBwbGF5bGlzdHMsIHBlciB0aGUgSExTIHNwZWMuXG4gKiBAcGFyYW0gZGV0YWlscyAtIFRoZSBkZXRhaWxzIG9mIHRoZSByZW5kaXRpb24geW91J2QgbGlrZSB0byB0aW1lLWFsaWduIChlLmcuIGFuIGF1ZGlvIHJlbmRpdGlvbikuXG4gKiBAcGFyYW0gcmVmRGV0YWlscyAtIFRoZSBkZXRhaWxzIG9mIHRoZSByZWZlcmVuY2UgcmVuZGl0aW9uIHdpdGggc3RhcnQgYW5kIFBEVCB0aW1lcyBmb3IgYWxpZ25tZW50LlxuICovXG5mdW5jdGlvbiBhbGlnbk1lZGlhUGxheWxpc3RCeVBEVChkZXRhaWxzLCByZWZEZXRhaWxzKSB7XG4gIGlmICghZGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUgfHwgIXJlZkRldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGZyYWdtZW50cyA9IGRldGFpbHMuZnJhZ21lbnRzO1xuICBjb25zdCByZWZGcmFnbWVudHMgPSByZWZEZXRhaWxzLmZyYWdtZW50cztcbiAgaWYgKCFmcmFnbWVudHMubGVuZ3RoIHx8ICFyZWZGcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIGEgZGVsdGEgdG8gYXBwbHkgdG8gYWxsIGZyYWdtZW50cyBhY2NvcmRpbmcgdG8gdGhlIGRlbHRhIGluIFBEVCB0aW1lcyBhbmQgc3RhcnQgdGltZXNcbiAgLy8gb2YgYSBmcmFnbWVudCBpbiB0aGUgcmVmZXJlbmNlIGRldGFpbHMsIGFuZCBhIGZyYWdtZW50IGluIHRoZSB0YXJnZXQgZGV0YWlscyBvZiB0aGUgc2FtZSBkaXNjb250aW51aXR5LlxuICAvLyBJZiBhIGZyYWdtZW50IG9mIHRoZSBzYW1lIGRpc2NvbnRpbnVpdHkgd2FzIG5vdCBmb3VuZCB1c2UgdGhlIG1pZGRsZSBmcmFnbWVudCBvZiBib3RoLlxuICBsZXQgcmVmRnJhZztcbiAgbGV0IGZyYWc7XG4gIGNvbnN0IHRhcmdldENDID0gTWF0aC5taW4ocmVmRGV0YWlscy5lbmRDQywgZGV0YWlscy5lbmRDQyk7XG4gIGlmIChyZWZEZXRhaWxzLnN0YXJ0Q0MgPCB0YXJnZXRDQyAmJiBkZXRhaWxzLnN0YXJ0Q0MgPCB0YXJnZXRDQykge1xuICAgIHJlZkZyYWcgPSBmaW5kRmlyc3RGcmFnV2l0aENDKHJlZkZyYWdtZW50cywgdGFyZ2V0Q0MpO1xuICAgIGZyYWcgPSBmaW5kRmlyc3RGcmFnV2l0aENDKGZyYWdtZW50cywgdGFyZ2V0Q0MpO1xuICB9XG4gIGlmICghcmVmRnJhZyB8fCAhZnJhZykge1xuICAgIHJlZkZyYWcgPSByZWZGcmFnbWVudHNbTWF0aC5mbG9vcihyZWZGcmFnbWVudHMubGVuZ3RoIC8gMildO1xuICAgIGZyYWcgPSBmaW5kRmlyc3RGcmFnV2l0aENDKGZyYWdtZW50cywgcmVmRnJhZy5jYykgfHwgZnJhZ21lbnRzW01hdGguZmxvb3IoZnJhZ21lbnRzLmxlbmd0aCAvIDIpXTtcbiAgfVxuICBjb25zdCByZWZQRFQgPSByZWZGcmFnLnByb2dyYW1EYXRlVGltZTtcbiAgY29uc3QgdGFyZ2V0UERUID0gZnJhZy5wcm9ncmFtRGF0ZVRpbWU7XG4gIGlmICghcmVmUERUIHx8ICF0YXJnZXRQRFQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZGVsdGEgPSAodGFyZ2V0UERUIC0gcmVmUERUKSAvIDEwMDAgLSAoZnJhZy5zdGFydCAtIHJlZkZyYWcuc3RhcnQpO1xuICBhZGp1c3RTbGlkaW5nU3RhcnQoZGVsdGEsIGRldGFpbHMpO1xufVxuXG5jb25zdCBNSU5fQ0hVTktfU0laRSA9IE1hdGgucG93KDIsIDE3KTsgLy8gMTI4a2JcblxuY2xhc3MgRnJhZ21lbnRMb2FkZXIge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgdGhpcy5wYXJ0TG9hZFRpbWVvdXQgPSAtMTtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmxvYWRlcikge1xuICAgICAgdGhpcy5sb2FkZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICBhYm9ydCgpIHtcbiAgICBpZiAodGhpcy5sb2FkZXIpIHtcbiAgICAgIC8vIEFib3J0IHRoZSBsb2FkZXIgZm9yIGN1cnJlbnQgZnJhZ21lbnQuIE9ubHkgb25lIG1heSBsb2FkIGF0IGFueSBnaXZlbiB0aW1lXG4gICAgICB0aGlzLmxvYWRlci5hYm9ydCgpO1xuICAgIH1cbiAgfVxuICBsb2FkKGZyYWcsIG9uUHJvZ3Jlc3MpIHtcbiAgICBjb25zdCB1cmwgPSBmcmFnLnVybDtcbiAgICBpZiAoIXVybCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBMb2FkRXJyb3Ioe1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1IsXG4gICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgZnJhZyxcbiAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihgRnJhZ21lbnQgZG9lcyBub3QgaGF2ZSBhICR7dXJsID8gJ3BhcnQgbGlzdCcgOiAndXJsJ31gKSxcbiAgICAgICAgbmV0d29ya0RldGFpbHM6IG51bGxcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgdGhpcy5hYm9ydCgpO1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGNvbnN0IEZyYWdtZW50SUxvYWRlciA9IGNvbmZpZy5mTG9hZGVyO1xuICAgIGNvbnN0IERlZmF1bHRJTG9hZGVyID0gY29uZmlnLmxvYWRlcjtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMubG9hZGVyKSB7XG4gICAgICAgIHRoaXMubG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIGlmIChmcmFnLmdhcCkge1xuICAgICAgICBpZiAoZnJhZy50YWdMaXN0LnNvbWUodGFncyA9PiB0YWdzWzBdID09PSAnR0FQJykpIHtcbiAgICAgICAgICByZWplY3QoY3JlYXRlR2FwTG9hZEVycm9yKGZyYWcpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUmVzZXQgdGVtcG9yYXJ5IHRyZWF0bWVudCBhcyBHQVAgdGFnXG4gICAgICAgICAgZnJhZy5nYXAgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgbG9hZGVyID0gdGhpcy5sb2FkZXIgPSBmcmFnLmxvYWRlciA9IEZyYWdtZW50SUxvYWRlciA/IG5ldyBGcmFnbWVudElMb2FkZXIoY29uZmlnKSA6IG5ldyBEZWZhdWx0SUxvYWRlcihjb25maWcpO1xuICAgICAgY29uc3QgbG9hZGVyQ29udGV4dCA9IGNyZWF0ZUxvYWRlckNvbnRleHQoZnJhZyk7XG4gICAgICBjb25zdCBsb2FkUG9saWN5ID0gZ2V0TG9hZGVyQ29uZmlnV2l0aG91dFJldGllcyhjb25maWcuZnJhZ0xvYWRQb2xpY3kuZGVmYXVsdCk7XG4gICAgICBjb25zdCBsb2FkZXJDb25maWcgPSB7XG4gICAgICAgIGxvYWRQb2xpY3ksXG4gICAgICAgIHRpbWVvdXQ6IGxvYWRQb2xpY3kubWF4TG9hZFRpbWVNcyxcbiAgICAgICAgbWF4UmV0cnk6IDAsXG4gICAgICAgIHJldHJ5RGVsYXk6IDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXk6IDAsXG4gICAgICAgIGhpZ2hXYXRlck1hcms6IGZyYWcuc24gPT09ICdpbml0U2VnbWVudCcgPyBJbmZpbml0eSA6IE1JTl9DSFVOS19TSVpFXG4gICAgICB9O1xuICAgICAgLy8gQXNzaWduIGZyYWcgc3RhdHMgdG8gdGhlIGxvYWRlcidzIHN0YXRzIHJlZmVyZW5jZVxuICAgICAgZnJhZy5zdGF0cyA9IGxvYWRlci5zdGF0cztcbiAgICAgIGxvYWRlci5sb2FkKGxvYWRlckNvbnRleHQsIGxvYWRlckNvbmZpZywge1xuICAgICAgICBvblN1Y2Nlc3M6IChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuICAgICAgICAgIGxldCBwYXlsb2FkID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgICBpZiAoY29udGV4dC5yZXNldElWICYmIGZyYWcuZGVjcnlwdGRhdGEpIHtcbiAgICAgICAgICAgIGZyYWcuZGVjcnlwdGRhdGEuaXYgPSBuZXcgVWludDhBcnJheShwYXlsb2FkLnNsaWNlKDAsIDE2KSk7XG4gICAgICAgICAgICBwYXlsb2FkID0gcGF5bG9hZC5zbGljZSgxNik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgIHBhcnQ6IG51bGwsXG4gICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgbmV0d29ya0RldGFpbHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvcjogKHJlc3BvbnNlLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscywgc3RhdHMpID0+IHtcbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGVyKGZyYWcsIGxvYWRlcik7XG4gICAgICAgICAgcmVqZWN0KG5ldyBMb2FkRXJyb3Ioe1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUixcbiAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICByZXNwb25zZTogX29iamVjdFNwcmVhZDIoe1xuICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgIGRhdGE6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSwgcmVzcG9uc2UpLFxuICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihgSFRUUCBFcnJvciAke3Jlc3BvbnNlLmNvZGV9ICR7cmVzcG9uc2UudGV4dH1gKSxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgc3RhdHNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQWJvcnQ6IChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpID0+IHtcbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGVyKGZyYWcsIGxvYWRlcik7XG4gICAgICAgICAgcmVqZWN0KG5ldyBMb2FkRXJyb3Ioe1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLklOVEVSTkFMX0FCT1JURUQsXG4gICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcignQWJvcnRlZCcpLFxuICAgICAgICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgICBzdGF0c1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25UaW1lb3V0OiAoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuICAgICAgICAgIHJlamVjdChuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVCxcbiAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKGBUaW1lb3V0IGFmdGVyICR7bG9hZGVyQ29uZmlnLnRpbWVvdXR9bXNgKSxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgc3RhdHNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUHJvZ3Jlc3M6IChzdGF0cywgY29udGV4dCwgZGF0YSwgbmV0d29ya0RldGFpbHMpID0+IHtcbiAgICAgICAgICBpZiAob25Qcm9ncmVzcykge1xuICAgICAgICAgICAgb25Qcm9ncmVzcyh7XG4gICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgIHBhcnQ6IG51bGwsXG4gICAgICAgICAgICAgIHBheWxvYWQ6IGRhdGEsXG4gICAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGxvYWRQYXJ0KGZyYWcsIHBhcnQsIG9uUHJvZ3Jlc3MpIHtcbiAgICB0aGlzLmFib3J0KCk7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgY29uc3QgRnJhZ21lbnRJTG9hZGVyID0gY29uZmlnLmZMb2FkZXI7XG4gICAgY29uc3QgRGVmYXVsdElMb2FkZXIgPSBjb25maWcubG9hZGVyO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAodGhpcy5sb2FkZXIpIHtcbiAgICAgICAgdGhpcy5sb2FkZXIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgaWYgKGZyYWcuZ2FwIHx8IHBhcnQuZ2FwKSB7XG4gICAgICAgIHJlamVjdChjcmVhdGVHYXBMb2FkRXJyb3IoZnJhZywgcGFydCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBsb2FkZXIgPSB0aGlzLmxvYWRlciA9IGZyYWcubG9hZGVyID0gRnJhZ21lbnRJTG9hZGVyID8gbmV3IEZyYWdtZW50SUxvYWRlcihjb25maWcpIDogbmV3IERlZmF1bHRJTG9hZGVyKGNvbmZpZyk7XG4gICAgICBjb25zdCBsb2FkZXJDb250ZXh0ID0gY3JlYXRlTG9hZGVyQ29udGV4dChmcmFnLCBwYXJ0KTtcbiAgICAgIC8vIFNob3VsZCB3ZSBkZWZpbmUgYW5vdGhlciBsb2FkIHBvbGljeSBmb3IgcGFydHM/XG4gICAgICBjb25zdCBsb2FkUG9saWN5ID0gZ2V0TG9hZGVyQ29uZmlnV2l0aG91dFJldGllcyhjb25maWcuZnJhZ0xvYWRQb2xpY3kuZGVmYXVsdCk7XG4gICAgICBjb25zdCBsb2FkZXJDb25maWcgPSB7XG4gICAgICAgIGxvYWRQb2xpY3ksXG4gICAgICAgIHRpbWVvdXQ6IGxvYWRQb2xpY3kubWF4TG9hZFRpbWVNcyxcbiAgICAgICAgbWF4UmV0cnk6IDAsXG4gICAgICAgIHJldHJ5RGVsYXk6IDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXk6IDAsXG4gICAgICAgIGhpZ2hXYXRlck1hcms6IE1JTl9DSFVOS19TSVpFXG4gICAgICB9O1xuICAgICAgLy8gQXNzaWduIHBhcnQgc3RhdHMgdG8gdGhlIGxvYWRlcidzIHN0YXRzIHJlZmVyZW5jZVxuICAgICAgcGFydC5zdGF0cyA9IGxvYWRlci5zdGF0cztcbiAgICAgIGxvYWRlci5sb2FkKGxvYWRlckNvbnRleHQsIGxvYWRlckNvbmZpZywge1xuICAgICAgICBvblN1Y2Nlc3M6IChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuICAgICAgICAgIHRoaXMudXBkYXRlU3RhdHNGcm9tUGFydChmcmFnLCBwYXJ0KTtcbiAgICAgICAgICBjb25zdCBwYXJ0TG9hZGVkRGF0YSA9IHtcbiAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgcGF5bG9hZDogcmVzcG9uc2UuZGF0YSxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzXG4gICAgICAgICAgfTtcbiAgICAgICAgICBvblByb2dyZXNzKHBhcnRMb2FkZWREYXRhKTtcbiAgICAgICAgICByZXNvbHZlKHBhcnRMb2FkZWREYXRhKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvcjogKHJlc3BvbnNlLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscywgc3RhdHMpID0+IHtcbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGVyKGZyYWcsIGxvYWRlcik7XG4gICAgICAgICAgcmVqZWN0KG5ldyBMb2FkRXJyb3Ioe1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUixcbiAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgcmVzcG9uc2U6IF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgICAgICAgdXJsOiBsb2FkZXJDb250ZXh0LnVybCxcbiAgICAgICAgICAgICAgZGF0YTogdW5kZWZpbmVkXG4gICAgICAgICAgICB9LCByZXNwb25zZSksXG4gICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKGBIVFRQIEVycm9yICR7cmVzcG9uc2UuY29kZX0gJHtyZXNwb25zZS50ZXh0fWApLFxuICAgICAgICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgICBzdGF0c1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25BYm9ydDogKHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICAgIGZyYWcuc3RhdHMuYWJvcnRlZCA9IHBhcnQuc3RhdHMuYWJvcnRlZDtcbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGVyKGZyYWcsIGxvYWRlcik7XG4gICAgICAgICAgcmVqZWN0KG5ldyBMb2FkRXJyb3Ioe1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLklOVEVSTkFMX0FCT1JURUQsXG4gICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgcGFydCxcbiAgICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoJ0Fib3J0ZWQnKSxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgc3RhdHNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uVGltZW91dDogKHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcbiAgICAgICAgICByZWplY3QobmV3IExvYWRFcnJvcih7XG4gICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQsXG4gICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgcGFydCxcbiAgICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoYFRpbWVvdXQgYWZ0ZXIgJHtsb2FkZXJDb25maWcudGltZW91dH1tc2ApLFxuICAgICAgICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgICBzdGF0c1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlU3RhdHNGcm9tUGFydChmcmFnLCBwYXJ0KSB7XG4gICAgY29uc3QgZnJhZ1N0YXRzID0gZnJhZy5zdGF0cztcbiAgICBjb25zdCBwYXJ0U3RhdHMgPSBwYXJ0LnN0YXRzO1xuICAgIGNvbnN0IHBhcnRUb3RhbCA9IHBhcnRTdGF0cy50b3RhbDtcbiAgICBmcmFnU3RhdHMubG9hZGVkICs9IHBhcnRTdGF0cy5sb2FkZWQ7XG4gICAgaWYgKHBhcnRUb3RhbCkge1xuICAgICAgY29uc3QgZXN0VG90YWxQYXJ0cyA9IE1hdGgucm91bmQoZnJhZy5kdXJhdGlvbiAvIHBhcnQuZHVyYXRpb24pO1xuICAgICAgY29uc3QgZXN0TG9hZGVkUGFydHMgPSBNYXRoLm1pbihNYXRoLnJvdW5kKGZyYWdTdGF0cy5sb2FkZWQgLyBwYXJ0VG90YWwpLCBlc3RUb3RhbFBhcnRzKTtcbiAgICAgIGNvbnN0IGVzdFJlbWFpbmluZ1BhcnRzID0gZXN0VG90YWxQYXJ0cyAtIGVzdExvYWRlZFBhcnRzO1xuICAgICAgY29uc3QgZXN0UmVtYWluaW5nQnl0ZXMgPSBlc3RSZW1haW5pbmdQYXJ0cyAqIE1hdGgucm91bmQoZnJhZ1N0YXRzLmxvYWRlZCAvIGVzdExvYWRlZFBhcnRzKTtcbiAgICAgIGZyYWdTdGF0cy50b3RhbCA9IGZyYWdTdGF0cy5sb2FkZWQgKyBlc3RSZW1haW5pbmdCeXRlcztcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhZ1N0YXRzLnRvdGFsID0gTWF0aC5tYXgoZnJhZ1N0YXRzLmxvYWRlZCwgZnJhZ1N0YXRzLnRvdGFsKTtcbiAgICB9XG4gICAgY29uc3QgZnJhZ0xvYWRpbmcgPSBmcmFnU3RhdHMubG9hZGluZztcbiAgICBjb25zdCBwYXJ0TG9hZGluZyA9IHBhcnRTdGF0cy5sb2FkaW5nO1xuICAgIGlmIChmcmFnTG9hZGluZy5zdGFydCkge1xuICAgICAgLy8gYWRkIHRvIGZyYWdtZW50IGxvYWRlciBsYXRlbmN5XG4gICAgICBmcmFnTG9hZGluZy5maXJzdCArPSBwYXJ0TG9hZGluZy5maXJzdCAtIHBhcnRMb2FkaW5nLnN0YXJ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBmcmFnTG9hZGluZy5zdGFydCA9IHBhcnRMb2FkaW5nLnN0YXJ0O1xuICAgICAgZnJhZ0xvYWRpbmcuZmlyc3QgPSBwYXJ0TG9hZGluZy5maXJzdDtcbiAgICB9XG4gICAgZnJhZ0xvYWRpbmcuZW5kID0gcGFydExvYWRpbmcuZW5kO1xuICB9XG4gIHJlc2V0TG9hZGVyKGZyYWcsIGxvYWRlcikge1xuICAgIGZyYWcubG9hZGVyID0gbnVsbDtcbiAgICBpZiAodGhpcy5sb2FkZXIgPT09IGxvYWRlcikge1xuICAgICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5wYXJ0TG9hZFRpbWVvdXQpO1xuICAgICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICAgIH1cbiAgICBsb2FkZXIuZGVzdHJveSgpO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVMb2FkZXJDb250ZXh0KGZyYWcsIHBhcnQgPSBudWxsKSB7XG4gIGNvbnN0IHNlZ21lbnQgPSBwYXJ0IHx8IGZyYWc7XG4gIGNvbnN0IGxvYWRlckNvbnRleHQgPSB7XG4gICAgZnJhZyxcbiAgICBwYXJ0LFxuICAgIHJlc3BvbnNlVHlwZTogJ2FycmF5YnVmZmVyJyxcbiAgICB1cmw6IHNlZ21lbnQudXJsLFxuICAgIGhlYWRlcnM6IHt9LFxuICAgIHJhbmdlU3RhcnQ6IDAsXG4gICAgcmFuZ2VFbmQ6IDBcbiAgfTtcbiAgY29uc3Qgc3RhcnQgPSBzZWdtZW50LmJ5dGVSYW5nZVN0YXJ0T2Zmc2V0O1xuICBjb25zdCBlbmQgPSBzZWdtZW50LmJ5dGVSYW5nZUVuZE9mZnNldDtcbiAgaWYgKGlzRmluaXRlTnVtYmVyKHN0YXJ0KSAmJiBpc0Zpbml0ZU51bWJlcihlbmQpKSB7XG4gICAgdmFyIF9mcmFnJGRlY3J5cHRkYXRhO1xuICAgIGxldCBieXRlUmFuZ2VTdGFydCA9IHN0YXJ0O1xuICAgIGxldCBieXRlUmFuZ2VFbmQgPSBlbmQ7XG4gICAgaWYgKGZyYWcuc24gPT09ICdpbml0U2VnbWVudCcgJiYgKChfZnJhZyRkZWNyeXB0ZGF0YSA9IGZyYWcuZGVjcnlwdGRhdGEpID09IG51bGwgPyB2b2lkIDAgOiBfZnJhZyRkZWNyeXB0ZGF0YS5tZXRob2QpID09PSAnQUVTLTEyOCcpIHtcbiAgICAgIC8vIE1BUCBzZWdtZW50IGVuY3J5cHRlZCB3aXRoIG1ldGhvZCAnQUVTLTEyOCcsIHdoZW4gc2VydmVkIHdpdGggSFRUUCBSYW5nZSxcbiAgICAgIC8vIGhhcyB0aGUgdW5lbmNyeXB0ZWQgc2l6ZSBzcGVjaWZpZWQgaW4gdGhlIHJhbmdlLlxuICAgICAgLy8gUmVmOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtcGFudG9zLWhscy1yZmM4MjE2YmlzLTA4I3NlY3Rpb24tNi4zLjZcbiAgICAgIGNvbnN0IGZyYWdtZW50TGVuID0gZW5kIC0gc3RhcnQ7XG4gICAgICBpZiAoZnJhZ21lbnRMZW4gJSAxNikge1xuICAgICAgICBieXRlUmFuZ2VFbmQgPSBlbmQgKyAoMTYgLSBmcmFnbWVudExlbiAlIDE2KTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCAhPT0gMCkge1xuICAgICAgICBsb2FkZXJDb250ZXh0LnJlc2V0SVYgPSB0cnVlO1xuICAgICAgICBieXRlUmFuZ2VTdGFydCA9IHN0YXJ0IC0gMTY7XG4gICAgICB9XG4gICAgfVxuICAgIGxvYWRlckNvbnRleHQucmFuZ2VTdGFydCA9IGJ5dGVSYW5nZVN0YXJ0O1xuICAgIGxvYWRlckNvbnRleHQucmFuZ2VFbmQgPSBieXRlUmFuZ2VFbmQ7XG4gIH1cbiAgcmV0dXJuIGxvYWRlckNvbnRleHQ7XG59XG5mdW5jdGlvbiBjcmVhdGVHYXBMb2FkRXJyb3IoZnJhZywgcGFydCkge1xuICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgR0FQICR7ZnJhZy5nYXAgPyAndGFnJyA6ICdhdHRyaWJ1dGUnfSBmb3VuZGApO1xuICBjb25zdCBlcnJvckRhdGEgPSB7XG4gICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19HQVAsXG4gICAgZmF0YWw6IGZhbHNlLFxuICAgIGZyYWcsXG4gICAgZXJyb3IsXG4gICAgbmV0d29ya0RldGFpbHM6IG51bGxcbiAgfTtcbiAgaWYgKHBhcnQpIHtcbiAgICBlcnJvckRhdGEucGFydCA9IHBhcnQ7XG4gIH1cbiAgKHBhcnQgPyBwYXJ0IDogZnJhZykuc3RhdHMuYWJvcnRlZCA9IHRydWU7XG4gIHJldHVybiBuZXcgTG9hZEVycm9yKGVycm9yRGF0YSk7XG59XG5jbGFzcyBMb2FkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcihkYXRhLmVycm9yLm1lc3NhZ2UpO1xuICAgIHRoaXMuZGF0YSA9IHZvaWQgMDtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICB9XG59XG5cbmNsYXNzIEFFU0NyeXB0byB7XG4gIGNvbnN0cnVjdG9yKHN1YnRsZSwgaXYpIHtcbiAgICB0aGlzLnN1YnRsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmFlc0lWID0gdm9pZCAwO1xuICAgIHRoaXMuc3VidGxlID0gc3VidGxlO1xuICAgIHRoaXMuYWVzSVYgPSBpdjtcbiAgfVxuICBkZWNyeXB0KGRhdGEsIGtleSkge1xuICAgIHJldHVybiB0aGlzLnN1YnRsZS5kZWNyeXB0KHtcbiAgICAgIG5hbWU6ICdBRVMtQ0JDJyxcbiAgICAgIGl2OiB0aGlzLmFlc0lWXG4gICAgfSwga2V5LCBkYXRhKTtcbiAgfVxufVxuXG5jbGFzcyBGYXN0QUVTS2V5IHtcbiAgY29uc3RydWN0b3Ioc3VidGxlLCBrZXkpIHtcbiAgICB0aGlzLnN1YnRsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLnN1YnRsZSA9IHN1YnRsZTtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgfVxuICBleHBhbmRLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3VidGxlLmltcG9ydEtleSgncmF3JywgdGhpcy5rZXksIHtcbiAgICAgIG5hbWU6ICdBRVMtQ0JDJ1xuICAgIH0sIGZhbHNlLCBbJ2VuY3J5cHQnLCAnZGVjcnlwdCddKTtcbiAgfVxufVxuXG4vLyBQS0NTN1xuZnVuY3Rpb24gcmVtb3ZlUGFkZGluZyhhcnJheSkge1xuICBjb25zdCBvdXRwdXRCeXRlcyA9IGFycmF5LmJ5dGVMZW5ndGg7XG4gIGNvbnN0IHBhZGRpbmdCeXRlcyA9IG91dHB1dEJ5dGVzICYmIG5ldyBEYXRhVmlldyhhcnJheS5idWZmZXIpLmdldFVpbnQ4KG91dHB1dEJ5dGVzIC0gMSk7XG4gIGlmIChwYWRkaW5nQnl0ZXMpIHtcbiAgICByZXR1cm4gc2xpY2VVaW50OChhcnJheSwgMCwgb3V0cHV0Qnl0ZXMgLSBwYWRkaW5nQnl0ZXMpO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cbmNsYXNzIEFFU0RlY3J5cHRvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucmNvbiA9IFsweDAsIDB4MSwgMHgyLCAweDQsIDB4OCwgMHgxMCwgMHgyMCwgMHg0MCwgMHg4MCwgMHgxYiwgMHgzNl07XG4gICAgdGhpcy5zdWJNaXggPSBbbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NildO1xuICAgIHRoaXMuaW52U3ViTWl4ID0gW25ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpXTtcbiAgICB0aGlzLnNCb3ggPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICB0aGlzLmludlNCb3ggPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICB0aGlzLmtleSA9IG5ldyBVaW50MzJBcnJheSgwKTtcbiAgICB0aGlzLmtzUm93cyA9IDA7XG4gICAgdGhpcy5rZXlTaXplID0gMDtcbiAgICB0aGlzLmtleVNjaGVkdWxlID0gdm9pZCAwO1xuICAgIHRoaXMuaW52S2V5U2NoZWR1bGUgPSB2b2lkIDA7XG4gICAgdGhpcy5pbml0VGFibGUoKTtcbiAgfVxuXG4gIC8vIFVzaW5nIHZpZXcuZ2V0VWludDMyKCkgYWxzbyBzd2FwcyB0aGUgYnl0ZSBvcmRlci5cbiAgdWludDhBcnJheVRvVWludDMyQXJyYXlfKGFycmF5QnVmZmVyKSB7XG4gICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlcik7XG4gICAgY29uc3QgbmV3QXJyYXkgPSBuZXcgVWludDMyQXJyYXkoNCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIG5ld0FycmF5W2ldID0gdmlldy5nZXRVaW50MzIoaSAqIDQpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3QXJyYXk7XG4gIH1cbiAgaW5pdFRhYmxlKCkge1xuICAgIGNvbnN0IHNCb3ggPSB0aGlzLnNCb3g7XG4gICAgY29uc3QgaW52U0JveCA9IHRoaXMuaW52U0JveDtcbiAgICBjb25zdCBzdWJNaXggPSB0aGlzLnN1Yk1peDtcbiAgICBjb25zdCBzdWJNaXgwID0gc3ViTWl4WzBdO1xuICAgIGNvbnN0IHN1Yk1peDEgPSBzdWJNaXhbMV07XG4gICAgY29uc3Qgc3ViTWl4MiA9IHN1Yk1peFsyXTtcbiAgICBjb25zdCBzdWJNaXgzID0gc3ViTWl4WzNdO1xuICAgIGNvbnN0IGludlN1Yk1peCA9IHRoaXMuaW52U3ViTWl4O1xuICAgIGNvbnN0IGludlN1Yk1peDAgPSBpbnZTdWJNaXhbMF07XG4gICAgY29uc3QgaW52U3ViTWl4MSA9IGludlN1Yk1peFsxXTtcbiAgICBjb25zdCBpbnZTdWJNaXgyID0gaW52U3ViTWl4WzJdO1xuICAgIGNvbnN0IGludlN1Yk1peDMgPSBpbnZTdWJNaXhbM107XG4gICAgY29uc3QgZCA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgIGxldCB4ID0gMDtcbiAgICBsZXQgeGkgPSAwO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgIGlmIChpIDwgMTI4KSB7XG4gICAgICAgIGRbaV0gPSBpIDw8IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkW2ldID0gaSA8PCAxIF4gMHgxMWI7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgbGV0IHN4ID0geGkgXiB4aSA8PCAxIF4geGkgPDwgMiBeIHhpIDw8IDMgXiB4aSA8PCA0O1xuICAgICAgc3ggPSBzeCA+Pj4gOCBeIHN4ICYgMHhmZiBeIDB4NjM7XG4gICAgICBzQm94W3hdID0gc3g7XG4gICAgICBpbnZTQm94W3N4XSA9IHg7XG5cbiAgICAgIC8vIENvbXB1dGUgbXVsdGlwbGljYXRpb25cbiAgICAgIGNvbnN0IHgyID0gZFt4XTtcbiAgICAgIGNvbnN0IHg0ID0gZFt4Ml07XG4gICAgICBjb25zdCB4OCA9IGRbeDRdO1xuXG4gICAgICAvLyBDb21wdXRlIHN1Yi9pbnZTdWIgYnl0ZXMsIG1peCBjb2x1bW5zIHRhYmxlc1xuICAgICAgbGV0IHQgPSBkW3N4XSAqIDB4MTAxIF4gc3ggKiAweDEwMTAxMDA7XG4gICAgICBzdWJNaXgwW3hdID0gdCA8PCAyNCB8IHQgPj4+IDg7XG4gICAgICBzdWJNaXgxW3hdID0gdCA8PCAxNiB8IHQgPj4+IDE2O1xuICAgICAgc3ViTWl4Mlt4XSA9IHQgPDwgOCB8IHQgPj4+IDI0O1xuICAgICAgc3ViTWl4M1t4XSA9IHQ7XG5cbiAgICAgIC8vIENvbXB1dGUgaW52IHN1YiBieXRlcywgaW52IG1peCBjb2x1bW5zIHRhYmxlc1xuICAgICAgdCA9IHg4ICogMHgxMDEwMTAxIF4geDQgKiAweDEwMDAxIF4geDIgKiAweDEwMSBeIHggKiAweDEwMTAxMDA7XG4gICAgICBpbnZTdWJNaXgwW3N4XSA9IHQgPDwgMjQgfCB0ID4+PiA4O1xuICAgICAgaW52U3ViTWl4MVtzeF0gPSB0IDw8IDE2IHwgdCA+Pj4gMTY7XG4gICAgICBpbnZTdWJNaXgyW3N4XSA9IHQgPDwgOCB8IHQgPj4+IDI0O1xuICAgICAgaW52U3ViTWl4M1tzeF0gPSB0O1xuXG4gICAgICAvLyBDb21wdXRlIG5leHQgY291bnRlclxuICAgICAgaWYgKCF4KSB7XG4gICAgICAgIHggPSB4aSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0geDIgXiBkW2RbZFt4OCBeIHgyXV1dO1xuICAgICAgICB4aSBePSBkW2RbeGldXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZXhwYW5kS2V5KGtleUJ1ZmZlcikge1xuICAgIC8vIGNvbnZlcnQga2V5QnVmZmVyIHRvIFVpbnQzMkFycmF5XG4gICAgY29uc3Qga2V5ID0gdGhpcy51aW50OEFycmF5VG9VaW50MzJBcnJheV8oa2V5QnVmZmVyKTtcbiAgICBsZXQgc2FtZUtleSA9IHRydWU7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgd2hpbGUgKG9mZnNldCA8IGtleS5sZW5ndGggJiYgc2FtZUtleSkge1xuICAgICAgc2FtZUtleSA9IGtleVtvZmZzZXRdID09PSB0aGlzLmtleVtvZmZzZXRdO1xuICAgICAgb2Zmc2V0Kys7XG4gICAgfVxuICAgIGlmIChzYW1lS2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIGNvbnN0IGtleVNpemUgPSB0aGlzLmtleVNpemUgPSBrZXkubGVuZ3RoO1xuICAgIGlmIChrZXlTaXplICE9PSA0ICYmIGtleVNpemUgIT09IDYgJiYga2V5U2l6ZSAhPT0gOCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFlcyBrZXkgc2l6ZT0nICsga2V5U2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGtzUm93cyA9IHRoaXMua3NSb3dzID0gKGtleVNpemUgKyA2ICsgMSkgKiA0O1xuICAgIGxldCBrc1JvdztcbiAgICBsZXQgaW52S3NSb3c7XG4gICAgY29uc3Qga2V5U2NoZWR1bGUgPSB0aGlzLmtleVNjaGVkdWxlID0gbmV3IFVpbnQzMkFycmF5KGtzUm93cyk7XG4gICAgY29uc3QgaW52S2V5U2NoZWR1bGUgPSB0aGlzLmludktleVNjaGVkdWxlID0gbmV3IFVpbnQzMkFycmF5KGtzUm93cyk7XG4gICAgY29uc3Qgc2JveCA9IHRoaXMuc0JveDtcbiAgICBjb25zdCByY29uID0gdGhpcy5yY29uO1xuICAgIGNvbnN0IGludlN1Yk1peCA9IHRoaXMuaW52U3ViTWl4O1xuICAgIGNvbnN0IGludlN1Yk1peDAgPSBpbnZTdWJNaXhbMF07XG4gICAgY29uc3QgaW52U3ViTWl4MSA9IGludlN1Yk1peFsxXTtcbiAgICBjb25zdCBpbnZTdWJNaXgyID0gaW52U3ViTWl4WzJdO1xuICAgIGNvbnN0IGludlN1Yk1peDMgPSBpbnZTdWJNaXhbM107XG4gICAgbGV0IHByZXY7XG4gICAgbGV0IHQ7XG4gICAgZm9yIChrc1JvdyA9IDA7IGtzUm93IDwga3NSb3dzOyBrc1JvdysrKSB7XG4gICAgICBpZiAoa3NSb3cgPCBrZXlTaXplKSB7XG4gICAgICAgIHByZXYgPSBrZXlTY2hlZHVsZVtrc1Jvd10gPSBrZXlba3NSb3ddO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHQgPSBwcmV2O1xuICAgICAgaWYgKGtzUm93ICUga2V5U2l6ZSA9PT0gMCkge1xuICAgICAgICAvLyBSb3Qgd29yZFxuICAgICAgICB0ID0gdCA8PCA4IHwgdCA+Pj4gMjQ7XG5cbiAgICAgICAgLy8gU3ViIHdvcmRcbiAgICAgICAgdCA9IHNib3hbdCA+Pj4gMjRdIDw8IDI0IHwgc2JveFt0ID4+PiAxNiAmIDB4ZmZdIDw8IDE2IHwgc2JveFt0ID4+PiA4ICYgMHhmZl0gPDwgOCB8IHNib3hbdCAmIDB4ZmZdO1xuXG4gICAgICAgIC8vIE1peCBSY29uXG4gICAgICAgIHQgXj0gcmNvbltrc1JvdyAvIGtleVNpemUgfCAwXSA8PCAyNDtcbiAgICAgIH0gZWxzZSBpZiAoa2V5U2l6ZSA+IDYgJiYga3NSb3cgJSBrZXlTaXplID09PSA0KSB7XG4gICAgICAgIC8vIFN1YiB3b3JkXG4gICAgICAgIHQgPSBzYm94W3QgPj4+IDI0XSA8PCAyNCB8IHNib3hbdCA+Pj4gMTYgJiAweGZmXSA8PCAxNiB8IHNib3hbdCA+Pj4gOCAmIDB4ZmZdIDw8IDggfCBzYm94W3QgJiAweGZmXTtcbiAgICAgIH1cbiAgICAgIGtleVNjaGVkdWxlW2tzUm93XSA9IHByZXYgPSAoa2V5U2NoZWR1bGVba3NSb3cgLSBrZXlTaXplXSBeIHQpID4+PiAwO1xuICAgIH1cbiAgICBmb3IgKGludktzUm93ID0gMDsgaW52S3NSb3cgPCBrc1Jvd3M7IGludktzUm93KyspIHtcbiAgICAgIGtzUm93ID0ga3NSb3dzIC0gaW52S3NSb3c7XG4gICAgICBpZiAoaW52S3NSb3cgJiAzKSB7XG4gICAgICAgIHQgPSBrZXlTY2hlZHVsZVtrc1Jvd107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ID0ga2V5U2NoZWR1bGVba3NSb3cgLSA0XTtcbiAgICAgIH1cbiAgICAgIGlmIChpbnZLc1JvdyA8IDQgfHwga3NSb3cgPD0gNCkge1xuICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSB0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gaW52U3ViTWl4MFtzYm94W3QgPj4+IDI0XV0gXiBpbnZTdWJNaXgxW3Nib3hbdCA+Pj4gMTYgJiAweGZmXV0gXiBpbnZTdWJNaXgyW3Nib3hbdCA+Pj4gOCAmIDB4ZmZdXSBeIGludlN1Yk1peDNbc2JveFt0ICYgMHhmZl1dO1xuICAgICAgfVxuICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID4+PiAwO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFkZGluZyB0aGlzIGFzIGEgbWV0aG9kIGdyZWF0bHkgaW1wcm92ZXMgcGVyZm9ybWFuY2UuXG4gIG5ldHdvcmtUb0hvc3RPcmRlclN3YXAod29yZCkge1xuICAgIHJldHVybiB3b3JkIDw8IDI0IHwgKHdvcmQgJiAweGZmMDApIDw8IDggfCAod29yZCAmIDB4ZmYwMDAwKSA+PiA4IHwgd29yZCA+Pj4gMjQ7XG4gIH1cbiAgZGVjcnlwdChpbnB1dEFycmF5QnVmZmVyLCBvZmZzZXQsIGFlc0lWKSB7XG4gICAgY29uc3QgblJvdW5kcyA9IHRoaXMua2V5U2l6ZSArIDY7XG4gICAgY29uc3QgaW52S2V5U2NoZWR1bGUgPSB0aGlzLmludktleVNjaGVkdWxlO1xuICAgIGNvbnN0IGludlNCT1ggPSB0aGlzLmludlNCb3g7XG4gICAgY29uc3QgaW52U3ViTWl4ID0gdGhpcy5pbnZTdWJNaXg7XG4gICAgY29uc3QgaW52U3ViTWl4MCA9IGludlN1Yk1peFswXTtcbiAgICBjb25zdCBpbnZTdWJNaXgxID0gaW52U3ViTWl4WzFdO1xuICAgIGNvbnN0IGludlN1Yk1peDIgPSBpbnZTdWJNaXhbMl07XG4gICAgY29uc3QgaW52U3ViTWl4MyA9IGludlN1Yk1peFszXTtcbiAgICBjb25zdCBpbml0VmVjdG9yID0gdGhpcy51aW50OEFycmF5VG9VaW50MzJBcnJheV8oYWVzSVYpO1xuICAgIGxldCBpbml0VmVjdG9yMCA9IGluaXRWZWN0b3JbMF07XG4gICAgbGV0IGluaXRWZWN0b3IxID0gaW5pdFZlY3RvclsxXTtcbiAgICBsZXQgaW5pdFZlY3RvcjIgPSBpbml0VmVjdG9yWzJdO1xuICAgIGxldCBpbml0VmVjdG9yMyA9IGluaXRWZWN0b3JbM107XG4gICAgY29uc3QgaW5wdXRJbnQzMiA9IG5ldyBJbnQzMkFycmF5KGlucHV0QXJyYXlCdWZmZXIpO1xuICAgIGNvbnN0IG91dHB1dEludDMyID0gbmV3IEludDMyQXJyYXkoaW5wdXRJbnQzMi5sZW5ndGgpO1xuICAgIGxldCB0MCwgdDEsIHQyLCB0MztcbiAgICBsZXQgczAsIHMxLCBzMiwgczM7XG4gICAgbGV0IGlucHV0V29yZHMwLCBpbnB1dFdvcmRzMSwgaW5wdXRXb3JkczIsIGlucHV0V29yZHMzO1xuICAgIGxldCBrc1JvdywgaTtcbiAgICBjb25zdCBzd2FwV29yZCA9IHRoaXMubmV0d29ya1RvSG9zdE9yZGVyU3dhcDtcbiAgICB3aGlsZSAob2Zmc2V0IDwgaW5wdXRJbnQzMi5sZW5ndGgpIHtcbiAgICAgIGlucHV0V29yZHMwID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXRdKTtcbiAgICAgIGlucHV0V29yZHMxID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXQgKyAxXSk7XG4gICAgICBpbnB1dFdvcmRzMiA9IHN3YXBXb3JkKGlucHV0SW50MzJbb2Zmc2V0ICsgMl0pO1xuICAgICAgaW5wdXRXb3JkczMgPSBzd2FwV29yZChpbnB1dEludDMyW29mZnNldCArIDNdKTtcbiAgICAgIHMwID0gaW5wdXRXb3JkczAgXiBpbnZLZXlTY2hlZHVsZVswXTtcbiAgICAgIHMxID0gaW5wdXRXb3JkczMgXiBpbnZLZXlTY2hlZHVsZVsxXTtcbiAgICAgIHMyID0gaW5wdXRXb3JkczIgXiBpbnZLZXlTY2hlZHVsZVsyXTtcbiAgICAgIHMzID0gaW5wdXRXb3JkczEgXiBpbnZLZXlTY2hlZHVsZVszXTtcbiAgICAgIGtzUm93ID0gNDtcblxuICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSByb3VuZHMgb2YgZGVjcnlwdGlvblxuICAgICAgZm9yIChpID0gMTsgaSA8IG5Sb3VuZHM7IGkrKykge1xuICAgICAgICB0MCA9IGludlN1Yk1peDBbczAgPj4+IDI0XSBeIGludlN1Yk1peDFbczEgPj4gMTYgJiAweGZmXSBeIGludlN1Yk1peDJbczIgPj4gOCAmIDB4ZmZdIF4gaW52U3ViTWl4M1tzMyAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3ddO1xuICAgICAgICB0MSA9IGludlN1Yk1peDBbczEgPj4+IDI0XSBeIGludlN1Yk1peDFbczIgPj4gMTYgJiAweGZmXSBeIGludlN1Yk1peDJbczMgPj4gOCAmIDB4ZmZdIF4gaW52U3ViTWl4M1tzMCAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAxXTtcbiAgICAgICAgdDIgPSBpbnZTdWJNaXgwW3MyID4+PiAyNF0gXiBpbnZTdWJNaXgxW3MzID4+IDE2ICYgMHhmZl0gXiBpbnZTdWJNaXgyW3MwID4+IDggJiAweGZmXSBeIGludlN1Yk1peDNbczEgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgMl07XG4gICAgICAgIHQzID0gaW52U3ViTWl4MFtzMyA+Pj4gMjRdIF4gaW52U3ViTWl4MVtzMCA+PiAxNiAmIDB4ZmZdIF4gaW52U3ViTWl4MltzMSA+PiA4ICYgMHhmZl0gXiBpbnZTdWJNaXgzW3MyICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDNdO1xuICAgICAgICAvLyBVcGRhdGUgc3RhdGVcbiAgICAgICAgczAgPSB0MDtcbiAgICAgICAgczEgPSB0MTtcbiAgICAgICAgczIgPSB0MjtcbiAgICAgICAgczMgPSB0MztcbiAgICAgICAga3NSb3cgPSBrc1JvdyArIDQ7XG4gICAgICB9XG5cbiAgICAgIC8vIFNoaWZ0IHJvd3MsIHN1YiBieXRlcywgYWRkIHJvdW5kIGtleVxuICAgICAgdDAgPSBpbnZTQk9YW3MwID4+PiAyNF0gPDwgMjQgXiBpbnZTQk9YW3MxID4+IDE2ICYgMHhmZl0gPDwgMTYgXiBpbnZTQk9YW3MyID4+IDggJiAweGZmXSA8PCA4IF4gaW52U0JPWFtzMyAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3ddO1xuICAgICAgdDEgPSBpbnZTQk9YW3MxID4+PiAyNF0gPDwgMjQgXiBpbnZTQk9YW3MyID4+IDE2ICYgMHhmZl0gPDwgMTYgXiBpbnZTQk9YW3MzID4+IDggJiAweGZmXSA8PCA4IF4gaW52U0JPWFtzMCAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAxXTtcbiAgICAgIHQyID0gaW52U0JPWFtzMiA+Pj4gMjRdIDw8IDI0IF4gaW52U0JPWFtzMyA+PiAxNiAmIDB4ZmZdIDw8IDE2IF4gaW52U0JPWFtzMCA+PiA4ICYgMHhmZl0gPDwgOCBeIGludlNCT1hbczEgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgMl07XG4gICAgICB0MyA9IGludlNCT1hbczMgPj4+IDI0XSA8PCAyNCBeIGludlNCT1hbczAgPj4gMTYgJiAweGZmXSA8PCAxNiBeIGludlNCT1hbczEgPj4gOCAmIDB4ZmZdIDw8IDggXiBpbnZTQk9YW3MyICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDNdO1xuXG4gICAgICAvLyBXcml0ZVxuICAgICAgb3V0cHV0SW50MzJbb2Zmc2V0XSA9IHN3YXBXb3JkKHQwIF4gaW5pdFZlY3RvcjApO1xuICAgICAgb3V0cHV0SW50MzJbb2Zmc2V0ICsgMV0gPSBzd2FwV29yZCh0MyBeIGluaXRWZWN0b3IxKTtcbiAgICAgIG91dHB1dEludDMyW29mZnNldCArIDJdID0gc3dhcFdvcmQodDIgXiBpbml0VmVjdG9yMik7XG4gICAgICBvdXRwdXRJbnQzMltvZmZzZXQgKyAzXSA9IHN3YXBXb3JkKHQxIF4gaW5pdFZlY3RvcjMpO1xuXG4gICAgICAvLyByZXNldCBpbml0VmVjdG9yIHRvIGxhc3QgNCB1bnNpZ25lZCBpbnRcbiAgICAgIGluaXRWZWN0b3IwID0gaW5wdXRXb3JkczA7XG4gICAgICBpbml0VmVjdG9yMSA9IGlucHV0V29yZHMxO1xuICAgICAgaW5pdFZlY3RvcjIgPSBpbnB1dFdvcmRzMjtcbiAgICAgIGluaXRWZWN0b3IzID0gaW5wdXRXb3JkczM7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgKyA0O1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0SW50MzIuYnVmZmVyO1xuICB9XG59XG5cbmNvbnN0IENIVU5LX1NJWkUgPSAxNjsgLy8gMTYgYnl0ZXMsIDEyOCBiaXRzXG5cbmNsYXNzIERlY3J5cHRlciB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZywge1xuICAgIHJlbW92ZVBLQ1M3UGFkZGluZyA9IHRydWVcbiAgfSA9IHt9KSB7XG4gICAgdGhpcy5sb2dFbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLnJlbW92ZVBLQ1M3UGFkZGluZyA9IHZvaWQgMDtcbiAgICB0aGlzLnN1YnRsZSA9IG51bGw7XG4gICAgdGhpcy5zb2Z0d2FyZURlY3J5cHRlciA9IG51bGw7XG4gICAgdGhpcy5rZXkgPSBudWxsO1xuICAgIHRoaXMuZmFzdEFlc0tleSA9IG51bGw7XG4gICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRJViA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50UmVzdWx0ID0gbnVsbDtcbiAgICB0aGlzLnVzZVNvZnR3YXJlID0gdm9pZCAwO1xuICAgIHRoaXMudXNlU29mdHdhcmUgPSBjb25maWcuZW5hYmxlU29mdHdhcmVBRVM7XG4gICAgdGhpcy5yZW1vdmVQS0NTN1BhZGRpbmcgPSByZW1vdmVQS0NTN1BhZGRpbmc7XG4gICAgLy8gYnVpbHQgaW4gZGVjcnlwdG9yIGV4cGVjdHMgUEtDUzcgcGFkZGluZ1xuICAgIGlmIChyZW1vdmVQS0NTN1BhZGRpbmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGJyb3dzZXJDcnlwdG8gPSBzZWxmLmNyeXB0bztcbiAgICAgICAgaWYgKGJyb3dzZXJDcnlwdG8pIHtcbiAgICAgICAgICB0aGlzLnN1YnRsZSA9IGJyb3dzZXJDcnlwdG8uc3VidGxlIHx8IGJyb3dzZXJDcnlwdG8ud2Via2l0U3VidGxlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8qIG5vLW9wICovXG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnN1YnRsZSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy51c2VTb2Z0d2FyZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJ0bGUgPSBudWxsO1xuICAgIHRoaXMuc29mdHdhcmVEZWNyeXB0ZXIgPSBudWxsO1xuICAgIHRoaXMua2V5ID0gbnVsbDtcbiAgICB0aGlzLmZhc3RBZXNLZXkgPSBudWxsO1xuICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50SVYgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudFJlc3VsdCA9IG51bGw7XG4gIH1cbiAgaXNTeW5jKCkge1xuICAgIHJldHVybiB0aGlzLnVzZVNvZnR3YXJlO1xuICB9XG4gIGZsdXNoKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGN1cnJlbnRSZXN1bHQsXG4gICAgICByZW1haW5kZXJEYXRhXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFjdXJyZW50UmVzdWx0IHx8IHJlbWFpbmRlckRhdGEpIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoY3VycmVudFJlc3VsdCk7XG4gICAgdGhpcy5yZXNldCgpO1xuICAgIGlmICh0aGlzLnJlbW92ZVBLQ1M3UGFkZGluZykge1xuICAgICAgcmV0dXJuIHJlbW92ZVBhZGRpbmcoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuY3VycmVudFJlc3VsdCA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50SVYgPSBudWxsO1xuICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgaWYgKHRoaXMuc29mdHdhcmVEZWNyeXB0ZXIpIHtcbiAgICAgIHRoaXMuc29mdHdhcmVEZWNyeXB0ZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICBkZWNyeXB0KGRhdGEsIGtleSwgaXYpIHtcbiAgICBpZiAodGhpcy51c2VTb2Z0d2FyZSkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdGhpcy5zb2Z0d2FyZURlY3J5cHQobmV3IFVpbnQ4QXJyYXkoZGF0YSksIGtleSwgaXYpO1xuICAgICAgICBjb25zdCBkZWNyeXB0UmVzdWx0ID0gdGhpcy5mbHVzaCgpO1xuICAgICAgICBpZiAoZGVjcnlwdFJlc3VsdCkge1xuICAgICAgICAgIHJlc29sdmUoZGVjcnlwdFJlc3VsdC5idWZmZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1tzb2Z0d2FyZURlY3J5cHRdIEZhaWxlZCB0byBkZWNyeXB0IGRhdGEnKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy53ZWJDcnlwdG9EZWNyeXB0KG5ldyBVaW50OEFycmF5KGRhdGEpLCBrZXksIGl2KTtcbiAgfVxuXG4gIC8vIFNvZnR3YXJlIGRlY3J5cHRpb24gaXMgcHJvZ3Jlc3NpdmUuIFByb2dyZXNzaXZlIGRlY3J5cHRpb24gbWF5IG5vdCByZXR1cm4gYSByZXN1bHQgb24gZWFjaCBjYWxsLiBBbnkgY2FjaGVkXG4gIC8vIGRhdGEgaXMgaGFuZGxlZCBpbiB0aGUgZmx1c2goKSBjYWxsXG4gIHNvZnR3YXJlRGVjcnlwdChkYXRhLCBrZXksIGl2KSB7XG4gICAgY29uc3Qge1xuICAgICAgY3VycmVudElWLFxuICAgICAgY3VycmVudFJlc3VsdCxcbiAgICAgIHJlbWFpbmRlckRhdGFcbiAgICB9ID0gdGhpcztcbiAgICB0aGlzLmxvZ09uY2UoJ0pTIEFFUyBkZWNyeXB0Jyk7XG4gICAgLy8gVGhlIG91dHB1dCBpcyBzdGFnZ2VyZWQgZHVyaW5nIHByb2dyZXNzaXZlIHBhcnNpbmcgLSB0aGUgY3VycmVudCByZXN1bHQgaXMgY2FjaGVkLCBhbmQgZW1pdHRlZCBvbiB0aGUgbmV4dCBjYWxsXG4gICAgLy8gVGhpcyBpcyBkb25lIGluIG9yZGVyIHRvIHN0cmlwIFBLQ1M3IHBhZGRpbmcsIHdoaWNoIGlzIGZvdW5kIGF0IHRoZSBlbmQgb2YgZWFjaCBzZWdtZW50LiBXZSBvbmx5IGtub3cgd2UndmUgcmVhY2hlZFxuICAgIC8vIHRoZSBlbmQgb24gZmx1c2goKSwgYnV0IGJ5IHRoYXQgdGltZSB3ZSBoYXZlIGFscmVhZHkgcmVjZWl2ZWQgYWxsIGJ5dGVzIGZvciB0aGUgc2VnbWVudC5cbiAgICAvLyBQcm9ncmVzc2l2ZSBkZWNyeXB0aW9uIGRvZXMgbm90IHdvcmsgd2l0aCBXZWJDcnlwdG9cblxuICAgIGlmIChyZW1haW5kZXJEYXRhKSB7XG4gICAgICBkYXRhID0gYXBwZW5kVWludDhBcnJheShyZW1haW5kZXJEYXRhLCBkYXRhKTtcbiAgICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gQnl0ZSBsZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2IChBRVMtMTI4ID0gMTI4IGJpdCBibG9ja3MgPSAxNiBieXRlcylcbiAgICBjb25zdCBjdXJyZW50Q2h1bmsgPSB0aGlzLmdldFZhbGlkQ2h1bmsoZGF0YSk7XG4gICAgaWYgKCFjdXJyZW50Q2h1bmsubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRJVikge1xuICAgICAgaXYgPSBjdXJyZW50SVY7XG4gICAgfVxuICAgIGxldCBzb2Z0d2FyZURlY3J5cHRlciA9IHRoaXMuc29mdHdhcmVEZWNyeXB0ZXI7XG4gICAgaWYgKCFzb2Z0d2FyZURlY3J5cHRlcikge1xuICAgICAgc29mdHdhcmVEZWNyeXB0ZXIgPSB0aGlzLnNvZnR3YXJlRGVjcnlwdGVyID0gbmV3IEFFU0RlY3J5cHRvcigpO1xuICAgIH1cbiAgICBzb2Z0d2FyZURlY3J5cHRlci5leHBhbmRLZXkoa2V5KTtcbiAgICBjb25zdCByZXN1bHQgPSBjdXJyZW50UmVzdWx0O1xuICAgIHRoaXMuY3VycmVudFJlc3VsdCA9IHNvZnR3YXJlRGVjcnlwdGVyLmRlY3J5cHQoY3VycmVudENodW5rLmJ1ZmZlciwgMCwgaXYpO1xuICAgIHRoaXMuY3VycmVudElWID0gc2xpY2VVaW50OChjdXJyZW50Q2h1bmssIC0xNikuYnVmZmVyO1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB3ZWJDcnlwdG9EZWNyeXB0KGRhdGEsIGtleSwgaXYpIHtcbiAgICBjb25zdCBzdWJ0bGUgPSB0aGlzLnN1YnRsZTtcbiAgICBpZiAodGhpcy5rZXkgIT09IGtleSB8fCAhdGhpcy5mYXN0QWVzS2V5KSB7XG4gICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgIHRoaXMuZmFzdEFlc0tleSA9IG5ldyBGYXN0QUVTS2V5KHN1YnRsZSwga2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmFzdEFlc0tleS5leHBhbmRLZXkoKS50aGVuKGFlc0tleSA9PiB7XG4gICAgICAvLyBkZWNyeXB0IHVzaW5nIHdlYiBjcnlwdG9cbiAgICAgIGlmICghc3VidGxlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ3dlYiBjcnlwdG8gbm90IGluaXRpYWxpemVkJykpO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2dPbmNlKCdXZWJDcnlwdG8gQUVTIGRlY3J5cHQnKTtcbiAgICAgIGNvbnN0IGNyeXB0byA9IG5ldyBBRVNDcnlwdG8oc3VidGxlLCBuZXcgVWludDhBcnJheShpdikpO1xuICAgICAgcmV0dXJuIGNyeXB0by5kZWNyeXB0KGRhdGEuYnVmZmVyLCBhZXNLZXkpO1xuICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICBsb2dnZXIud2FybihgW2RlY3J5cHRlcl06IFdlYkNyeXB0byBFcnJvciwgZGlzYWJsZSBXZWJDcnlwdG8gQVBJLCAke2Vyci5uYW1lfTogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgIHJldHVybiB0aGlzLm9uV2ViQ3J5cHRvRXJyb3IoZGF0YSwga2V5LCBpdik7XG4gICAgfSk7XG4gIH1cbiAgb25XZWJDcnlwdG9FcnJvcihkYXRhLCBrZXksIGl2KSB7XG4gICAgdGhpcy51c2VTb2Z0d2FyZSA9IHRydWU7XG4gICAgdGhpcy5sb2dFbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLnNvZnR3YXJlRGVjcnlwdChkYXRhLCBrZXksIGl2KTtcbiAgICBjb25zdCBkZWNyeXB0UmVzdWx0ID0gdGhpcy5mbHVzaCgpO1xuICAgIGlmIChkZWNyeXB0UmVzdWx0KSB7XG4gICAgICByZXR1cm4gZGVjcnlwdFJlc3VsdC5idWZmZXI7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignV2ViQ3J5cHRvIGFuZCBzb2Z0d2FyZURlY3J5cHQ6IGZhaWxlZCB0byBkZWNyeXB0IGRhdGEnKTtcbiAgfVxuICBnZXRWYWxpZENodW5rKGRhdGEpIHtcbiAgICBsZXQgY3VycmVudENodW5rID0gZGF0YTtcbiAgICBjb25zdCBzcGxpdFBvaW50ID0gZGF0YS5sZW5ndGggLSBkYXRhLmxlbmd0aCAlIENIVU5LX1NJWkU7XG4gICAgaWYgKHNwbGl0UG9pbnQgIT09IGRhdGEubGVuZ3RoKSB7XG4gICAgICBjdXJyZW50Q2h1bmsgPSBzbGljZVVpbnQ4KGRhdGEsIDAsIHNwbGl0UG9pbnQpO1xuICAgICAgdGhpcy5yZW1haW5kZXJEYXRhID0gc2xpY2VVaW50OChkYXRhLCBzcGxpdFBvaW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnRDaHVuaztcbiAgfVxuICBsb2dPbmNlKG1zZykge1xuICAgIGlmICghdGhpcy5sb2dFbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxvZ2dlci5sb2coYFtkZWNyeXB0ZXJdOiAke21zZ31gKTtcbiAgICB0aGlzLmxvZ0VuYWJsZWQgPSBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqICBUaW1lUmFuZ2VzIHRvIHN0cmluZyBoZWxwZXJcbiAqL1xuXG5jb25zdCBUaW1lUmFuZ2VzID0ge1xuICB0b1N0cmluZzogZnVuY3Rpb24gKHIpIHtcbiAgICBsZXQgbG9nID0gJyc7XG4gICAgY29uc3QgbGVuID0gci5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgbG9nICs9IGBbJHtyLnN0YXJ0KGkpLnRvRml4ZWQoMyl9LSR7ci5lbmQoaSkudG9GaXhlZCgzKX1dYDtcbiAgICB9XG4gICAgcmV0dXJuIGxvZztcbiAgfVxufTtcblxuY29uc3QgU3RhdGUgPSB7XG4gIFNUT1BQRUQ6ICdTVE9QUEVEJyxcbiAgSURMRTogJ0lETEUnLFxuICBLRVlfTE9BRElORzogJ0tFWV9MT0FESU5HJyxcbiAgRlJBR19MT0FESU5HOiAnRlJBR19MT0FESU5HJyxcbiAgRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk6ICdGUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWScsXG4gIFdBSVRJTkdfVFJBQ0s6ICdXQUlUSU5HX1RSQUNLJyxcbiAgUEFSU0lORzogJ1BBUlNJTkcnLFxuICBQQVJTRUQ6ICdQQVJTRUQnLFxuICBFTkRFRDogJ0VOREVEJyxcbiAgRVJST1I6ICdFUlJPUicsXG4gIFdBSVRJTkdfSU5JVF9QVFM6ICdXQUlUSU5HX0lOSVRfUFRTJyxcbiAgV0FJVElOR19MRVZFTDogJ1dBSVRJTkdfTEVWRUwnXG59O1xuY2xhc3MgQmFzZVN0cmVhbUNvbnRyb2xsZXIgZXh0ZW5kcyBUYXNrTG9vcCB7XG4gIGNvbnN0cnVjdG9yKGhscywgZnJhZ21lbnRUcmFja2VyLCBrZXlMb2FkZXIsIGxvZ1ByZWZpeCwgcGxheWxpc3RUeXBlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIgPSB2b2lkIDA7XG4gICAgdGhpcy50cmFuc211eGVyID0gbnVsbDtcbiAgICB0aGlzLl9zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gICAgdGhpcy5wbGF5bGlzdFR5cGUgPSB2b2lkIDA7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5tZWRpYUJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy5iaXRyYXRlVGVzdCA9IGZhbHNlO1xuICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSAwO1xuICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IDA7XG4gICAgdGhpcy5zdGFydFRpbWVPZmZzZXQgPSBudWxsO1xuICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSBmYWxzZTtcbiAgICB0aGlzLnJldHJ5RGF0ZSA9IDA7XG4gICAgdGhpcy5sZXZlbHMgPSBudWxsO1xuICAgIHRoaXMuZnJhZ21lbnRMb2FkZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXlMb2FkZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5sZXZlbExhc3RMb2FkZWQgPSBudWxsO1xuICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgdGhpcy5kZWNyeXB0ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5pbml0UFRTID0gW107XG4gICAgdGhpcy5vbnZzZWVraW5nID0gbnVsbDtcbiAgICB0aGlzLm9udmVuZGVkID0gbnVsbDtcbiAgICB0aGlzLmxvZ1ByZWZpeCA9ICcnO1xuICAgIHRoaXMubG9nID0gdm9pZCAwO1xuICAgIHRoaXMud2FybiA9IHZvaWQgMDtcbiAgICB0aGlzLnBsYXlsaXN0VHlwZSA9IHBsYXlsaXN0VHlwZTtcbiAgICB0aGlzLmxvZ1ByZWZpeCA9IGxvZ1ByZWZpeDtcbiAgICB0aGlzLmxvZyA9IGxvZ2dlci5sb2cuYmluZChsb2dnZXIsIGAke2xvZ1ByZWZpeH06YCk7XG4gICAgdGhpcy53YXJuID0gbG9nZ2VyLndhcm4uYmluZChsb2dnZXIsIGAke2xvZ1ByZWZpeH06YCk7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5mcmFnbWVudExvYWRlciA9IG5ldyBGcmFnbWVudExvYWRlcihobHMuY29uZmlnKTtcbiAgICB0aGlzLmtleUxvYWRlciA9IGtleUxvYWRlcjtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlciA9IGZyYWdtZW50VHJhY2tlcjtcbiAgICB0aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgdGhpcy5kZWNyeXB0ZXIgPSBuZXcgRGVjcnlwdGVyKGhscy5jb25maWcpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICB9XG4gIGRvVGljaygpIHtcbiAgICB0aGlzLm9uVGlja0VuZCgpO1xuICB9XG4gIG9uVGlja0VuZCgpIHt9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICBzdGFydExvYWQoc3RhcnRQb3NpdGlvbikge31cbiAgc3RvcExvYWQoKSB7XG4gICAgdGhpcy5mcmFnbWVudExvYWRlci5hYm9ydCgpO1xuICAgIHRoaXMua2V5TG9hZGVyLmFib3J0KHRoaXMucGxheWxpc3RUeXBlKTtcbiAgICBjb25zdCBmcmFnID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBpZiAoZnJhZyAhPSBudWxsICYmIGZyYWcubG9hZGVyKSB7XG4gICAgICBmcmFnLmFib3J0UmVxdWVzdHMoKTtcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgIH1cbiAgICB0aGlzLnJlc2V0VHJhbnNtdXhlcigpO1xuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICB0aGlzLmNsZWFySW50ZXJ2YWwoKTtcbiAgICB0aGlzLmNsZWFyTmV4dFRpY2soKTtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgfVxuICBfc3RyZWFtRW5kZWQoYnVmZmVySW5mbywgbGV2ZWxEZXRhaWxzKSB7XG4gICAgLy8gSWYgcGxheWxpc3QgaXMgbGl2ZSwgdGhlcmUgaXMgYW5vdGhlciBidWZmZXJlZCByYW5nZSBhZnRlciB0aGUgY3VycmVudCByYW5nZSwgbm90aGluZyBidWZmZXJlZCwgbWVkaWEgaXMgZGV0YWNoZWQsXG4gICAgLy8gb2Ygbm90aGluZyBsb2FkaW5nL2xvYWRlZCByZXR1cm4gZmFsc2VcbiAgICBpZiAobGV2ZWxEZXRhaWxzLmxpdmUgfHwgYnVmZmVySW5mby5uZXh0U3RhcnQgfHwgIWJ1ZmZlckluZm8uZW5kIHx8ICF0aGlzLm1lZGlhKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHBhcnRMaXN0ID0gbGV2ZWxEZXRhaWxzLnBhcnRMaXN0O1xuICAgIC8vIFNpbmNlIHRoZSBsYXN0IHBhcnQgaXNuJ3QgZ3VhcmFudGVlZCB0byBjb3JyZXNwb25kIHRvIHRoZSBsYXN0IHBsYXlsaXN0IHNlZ21lbnQgZm9yIExvdy1MYXRlbmN5IEhMUyxcbiAgICAvLyBjaGVjayBpbnN0ZWFkIGlmIHRoZSBsYXN0IHBhcnQgaXMgYnVmZmVyZWQuXG4gICAgaWYgKHBhcnRMaXN0ICE9IG51bGwgJiYgcGFydExpc3QubGVuZ3RoKSB7XG4gICAgICBjb25zdCBsYXN0UGFydCA9IHBhcnRMaXN0W3BhcnRMaXN0Lmxlbmd0aCAtIDFdO1xuXG4gICAgICAvLyBDaGVja2luZyB0aGUgbWlkcG9pbnQgb2YgdGhlIHBhcnQgZm9yIHBvdGVudGlhbCBtYXJnaW4gb2YgZXJyb3IgYW5kIHJlbGF0ZWQgaXNzdWVzLlxuICAgICAgLy8gTk9URTogVGVjaG5pY2FsbHkgSSBiZWxpZXZlIHBhcnRzIGNvdWxkIHlpZWxkIGNvbnRlbnQgdGhhdCBpcyA8IHRoZSBjb21wdXRlZCBkdXJhdGlvbiAoaW5jbHVkaW5nIHBvdGVudGlhbCBhIGR1cmF0aW9uIG9mIDApXG4gICAgICAvLyBhbmQgc3RpbGwgYmUgc3BlYy1jb21wbGlhbnQsIHNvIHRoZXJlIG1heSBzdGlsbCBiZSBlZGdlIGNhc2VzIGhlcmUuIExpa2V3aXNlLCB0aGVyZSBjb3VsZCBiZSBpc3N1ZXMgaW4gZW5kIG9mIHN0cmVhbVxuICAgICAgLy8gcGFydCBtaXNtYXRjaGVzIGZvciBpbmRlcGVuZGVudCBhdWRpbyBhbmQgdmlkZW8gcGxheWxpc3RzL3NlZ21lbnRzLlxuICAgICAgY29uc3QgbGFzdFBhcnRCdWZmZXJlZCA9IEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKHRoaXMubWVkaWEsIGxhc3RQYXJ0LnN0YXJ0ICsgbGFzdFBhcnQuZHVyYXRpb24gLyAyKTtcbiAgICAgIHJldHVybiBsYXN0UGFydEJ1ZmZlcmVkO1xuICAgIH1cbiAgICBjb25zdCBwbGF5bGlzdFR5cGUgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRzW2xldmVsRGV0YWlscy5mcmFnbWVudHMubGVuZ3RoIC0gMV0udHlwZTtcbiAgICByZXR1cm4gdGhpcy5mcmFnbWVudFRyYWNrZXIuaXNFbmRMaXN0QXBwZW5kZWQocGxheWxpc3RUeXBlKTtcbiAgfVxuICBnZXRMZXZlbERldGFpbHMoKSB7XG4gICAgaWYgKHRoaXMubGV2ZWxzICYmIHRoaXMubGV2ZWxMYXN0TG9hZGVkICE9PSBudWxsKSB7XG4gICAgICB2YXIgX3RoaXMkbGV2ZWxMYXN0TG9hZGVkO1xuICAgICAgcmV0dXJuIChfdGhpcyRsZXZlbExhc3RMb2FkZWQgPSB0aGlzLmxldmVsTGFzdExvYWRlZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGxldmVsTGFzdExvYWRlZC5kZXRhaWxzO1xuICAgIH1cbiAgfVxuICBvbk1lZGlhQXR0YWNoZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID0gZGF0YS5tZWRpYTtcbiAgICB0aGlzLm9udnNlZWtpbmcgPSB0aGlzLm9uTWVkaWFTZWVraW5nLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbnZlbmRlZCA9IHRoaXMub25NZWRpYUVuZGVkLmJpbmQodGhpcyk7XG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignc2Vla2luZycsIHRoaXMub252c2Vla2luZyk7XG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLm9udmVuZGVkKTtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBpZiAodGhpcy5sZXZlbHMgJiYgY29uZmlnLmF1dG9TdGFydExvYWQgJiYgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuU1RPUFBFRCkge1xuICAgICAgdGhpcy5zdGFydExvYWQoY29uZmlnLnN0YXJ0UG9zaXRpb24pO1xuICAgIH1cbiAgfVxuICBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAobWVkaWEgIT0gbnVsbCAmJiBtZWRpYS5lbmRlZCkge1xuICAgICAgdGhpcy5sb2coJ01TRSBkZXRhY2hpbmcgYW5kIHZpZGVvIGVuZGVkLCByZXNldCBzdGFydFBvc2l0aW9uJyk7XG4gICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIHZpZGVvIGxpc3RlbmVyc1xuICAgIGlmIChtZWRpYSAmJiB0aGlzLm9udnNlZWtpbmcgJiYgdGhpcy5vbnZlbmRlZCkge1xuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vla2luZycsIHRoaXMub252c2Vla2luZyk7XG4gICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMub252ZW5kZWQpO1xuICAgICAgdGhpcy5vbnZzZWVraW5nID0gdGhpcy5vbnZlbmRlZCA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmtleUxvYWRlcikge1xuICAgICAgdGhpcy5rZXlMb2FkZXIuZGV0YWNoKCk7XG4gICAgfVxuICAgIHRoaXMubWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlQWxsRnJhZ21lbnRzKCk7XG4gICAgdGhpcy5zdG9wTG9hZCgpO1xuICB9XG4gIG9uTWVkaWFTZWVraW5nKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbmZpZyxcbiAgICAgIGZyYWdDdXJyZW50LFxuICAgICAgbWVkaWEsXG4gICAgICBtZWRpYUJ1ZmZlcixcbiAgICAgIHN0YXRlXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYSA/IG1lZGlhLmN1cnJlbnRUaW1lIDogMDtcbiAgICBjb25zdCBidWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8obWVkaWFCdWZmZXIgPyBtZWRpYUJ1ZmZlciA6IG1lZGlhLCBjdXJyZW50VGltZSwgY29uZmlnLm1heEJ1ZmZlckhvbGUpO1xuICAgIHRoaXMubG9nKGBtZWRpYSBzZWVraW5nIHRvICR7aXNGaW5pdGVOdW1iZXIoY3VycmVudFRpbWUpID8gY3VycmVudFRpbWUudG9GaXhlZCgzKSA6IGN1cnJlbnRUaW1lfSwgc3RhdGU6ICR7c3RhdGV9YCk7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkVOREVEKSB7XG4gICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgfSBlbHNlIGlmIChmcmFnQ3VycmVudCkge1xuICAgICAgLy8gU2Vla2luZyB3aGlsZSBmcmFnIGxvYWQgaXMgaW4gcHJvZ3Jlc3NcbiAgICAgIGNvbnN0IHRvbGVyYW5jZSA9IGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlO1xuICAgICAgY29uc3QgZnJhZ1N0YXJ0T2Zmc2V0ID0gZnJhZ0N1cnJlbnQuc3RhcnQgLSB0b2xlcmFuY2U7XG4gICAgICBjb25zdCBmcmFnRW5kT2Zmc2V0ID0gZnJhZ0N1cnJlbnQuc3RhcnQgKyBmcmFnQ3VycmVudC5kdXJhdGlvbiArIHRvbGVyYW5jZTtcbiAgICAgIC8vIGlmIHNlZWtpbmcgb3V0IG9mIGJ1ZmZlcmVkIHJhbmdlIG9yIGludG8gbmV3IG9uZVxuICAgICAgaWYgKCFidWZmZXJJbmZvLmxlbiB8fCBmcmFnRW5kT2Zmc2V0IDwgYnVmZmVySW5mby5zdGFydCB8fCBmcmFnU3RhcnRPZmZzZXQgPiBidWZmZXJJbmZvLmVuZCkge1xuICAgICAgICBjb25zdCBwYXN0RnJhZ21lbnQgPSBjdXJyZW50VGltZSA+IGZyYWdFbmRPZmZzZXQ7XG4gICAgICAgIC8vIGlmIHRoZSBzZWVrIHBvc2l0aW9uIGlzIG91dHNpZGUgdGhlIGN1cnJlbnQgZnJhZ21lbnQgcmFuZ2VcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lIDwgZnJhZ1N0YXJ0T2Zmc2V0IHx8IHBhc3RGcmFnbWVudCkge1xuICAgICAgICAgIGlmIChwYXN0RnJhZ21lbnQgJiYgZnJhZ0N1cnJlbnQubG9hZGVyKSB7XG4gICAgICAgICAgICB0aGlzLmxvZygnc2Vla2luZyBvdXRzaWRlIG9mIGJ1ZmZlciB3aGlsZSBmcmFnbWVudCBsb2FkIGluIHByb2dyZXNzLCBjYW5jZWwgZnJhZ21lbnQgbG9hZCcpO1xuICAgICAgICAgICAgZnJhZ0N1cnJlbnQuYWJvcnRSZXF1ZXN0cygpO1xuICAgICAgICAgICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICAvLyBSZW1vdmUgZ2FwIGZyYWdtZW50c1xuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnRzSW5SYW5nZShjdXJyZW50VGltZSwgSW5maW5pdHksIHRoaXMucGxheWxpc3RUeXBlLCB0cnVlKTtcbiAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgfVxuXG4gICAgLy8gaW4gY2FzZSBzZWVraW5nIG9jY3VycyBhbHRob3VnaCBubyBtZWRpYSBidWZmZXJlZCwgYWRqdXN0IHN0YXJ0UG9zaXRpb24gYW5kIG5leHRMb2FkUG9zaXRpb24gdG8gc2VlayB0YXJnZXRcbiAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEgJiYgIWJ1ZmZlckluZm8ubGVuKSB7XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb24gPSBjdXJyZW50VGltZTtcbiAgICB9XG5cbiAgICAvLyBBc3luYyB0aWNrIHRvIHNwZWVkIHVwIHByb2Nlc3NpbmdcbiAgICB0aGlzLnRpY2tJbW1lZGlhdGUoKTtcbiAgfVxuICBvbk1lZGlhRW5kZWQoKSB7XG4gICAgLy8gcmVzZXQgc3RhcnRQb3NpdGlvbiBhbmQgbGFzdEN1cnJlbnRUaW1lIHRvIHJlc3RhcnQgcGxheWJhY2sgQCBzdHJlYW0gYmVnaW5uaW5nXG4gICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLnN0YXJ0VGltZU9mZnNldCA9IGRhdGEuc3RhcnRUaW1lT2Zmc2V0O1xuICAgIHRoaXMuaW5pdFBUUyA9IFtdO1xuICB9XG4gIG9uSGFuZGxlckRlc3Ryb3lpbmcoKSB7XG4gICAgdGhpcy5obHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FERUQsIHRoaXMub25NYW5pZmVzdExvYWRlZCwgdGhpcyk7XG4gICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgIHN1cGVyLm9uSGFuZGxlckRlc3Ryb3lpbmcoKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSBudWxsO1xuICB9XG4gIG9uSGFuZGxlckRlc3Ryb3llZCgpIHtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgICBpZiAodGhpcy5mcmFnbWVudExvYWRlcikge1xuICAgICAgdGhpcy5mcmFnbWVudExvYWRlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmtleUxvYWRlcikge1xuICAgICAgdGhpcy5rZXlMb2FkZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5kZWNyeXB0ZXIpIHtcbiAgICAgIHRoaXMuZGVjcnlwdGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5obHMgPSB0aGlzLmxvZyA9IHRoaXMud2FybiA9IHRoaXMuZGVjcnlwdGVyID0gdGhpcy5rZXlMb2FkZXIgPSB0aGlzLmZyYWdtZW50TG9hZGVyID0gdGhpcy5mcmFnbWVudFRyYWNrZXIgPSBudWxsO1xuICAgIHN1cGVyLm9uSGFuZGxlckRlc3Ryb3llZCgpO1xuICB9XG4gIGxvYWRGcmFnbWVudChmcmFnLCBsZXZlbCwgdGFyZ2V0QnVmZmVyVGltZSkge1xuICAgIHRoaXMuX2xvYWRGcmFnRm9yUGxheWJhY2soZnJhZywgbGV2ZWwsIHRhcmdldEJ1ZmZlclRpbWUpO1xuICB9XG4gIF9sb2FkRnJhZ0ZvclBsYXliYWNrKGZyYWcsIGxldmVsLCB0YXJnZXRCdWZmZXJUaW1lKSB7XG4gICAgY29uc3QgcHJvZ3Jlc3NDYWxsYmFjayA9IGRhdGEgPT4ge1xuICAgICAgaWYgKHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpKSB7XG4gICAgICAgIHRoaXMud2FybihgRnJhZ21lbnQgJHtmcmFnLnNufSR7ZGF0YS5wYXJ0ID8gJyBwOiAnICsgZGF0YS5wYXJ0LmluZGV4IDogJyd9IG9mIGxldmVsICR7ZnJhZy5sZXZlbH0gd2FzIGRyb3BwZWQgZHVyaW5nIGRvd25sb2FkLmApO1xuICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZnJhZy5zdGF0cy5jaHVua0NvdW50Kys7XG4gICAgICB0aGlzLl9oYW5kbGVGcmFnbWVudExvYWRQcm9ncmVzcyhkYXRhKTtcbiAgICB9O1xuICAgIHRoaXMuX2RvRnJhZ0xvYWQoZnJhZywgbGV2ZWwsIHRhcmdldEJ1ZmZlclRpbWUsIHByb2dyZXNzQ2FsbGJhY2spLnRoZW4oZGF0YSA9PiB7XG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgLy8gaWYgd2UncmUgaGVyZSB3ZSBwcm9iYWJseSBuZWVkZWQgdG8gYmFja3RyYWNrIG9yIGFyZSB3YWl0aW5nIGZvciBtb3JlIHBhcnRzXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgIGlmICh0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgICBpZiAoc3RhdGUgPT09IFN0YXRlLkZSQUdfTE9BRElORyB8fCAhdGhpcy5mcmFnQ3VycmVudCAmJiBzdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICgncGF5bG9hZCcgaW4gZGF0YSkge1xuICAgICAgICB0aGlzLmxvZyhgTG9hZGVkIGZyYWdtZW50ICR7ZnJhZy5zbn0gb2YgbGV2ZWwgJHtmcmFnLmxldmVsfWApO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0xPQURFRCwgZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFBhc3MgdGhyb3VnaCB0aGUgd2hvbGUgcGF5bG9hZDsgY29udHJvbGxlcnMgbm90IGltcGxlbWVudGluZyBwcm9ncmVzc2l2ZSBsb2FkaW5nIHJlY2VpdmUgZGF0YSBmcm9tIHRoaXMgY2FsbGJhY2tcbiAgICAgIHRoaXMuX2hhbmRsZUZyYWdtZW50TG9hZENvbXBsZXRlKGRhdGEpO1xuICAgIH0pLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuU1RPUFBFRCB8fCB0aGlzLnN0YXRlID09PSBTdGF0ZS5FUlJPUikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLndhcm4ocmVhc29uKTtcbiAgICAgIHRoaXMucmVzZXRGcmFnbWVudExvYWRpbmcoZnJhZyk7XG4gICAgfSk7XG4gIH1cbiAgY2xlYXJUcmFja2VySWZOZWVkZWQoZnJhZykge1xuICAgIHZhciBfdGhpcyRtZWRpYUJ1ZmZlcjtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnbWVudFRyYWNrZXJcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBmcmFnU3RhdGUgPSBmcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZyk7XG4gICAgaWYgKGZyYWdTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5BUFBFTkRJTkcpIHtcbiAgICAgIC8vIExvd2VyIHRoZSBidWZmZXIgc2l6ZSBhbmQgdHJ5IGFnYWluXG4gICAgICBjb25zdCBwbGF5bGlzdFR5cGUgPSBmcmFnLnR5cGU7XG4gICAgICBjb25zdCBidWZmZXJlZEluZm8gPSB0aGlzLmdldEZ3ZEJ1ZmZlckluZm8odGhpcy5tZWRpYUJ1ZmZlciwgcGxheWxpc3RUeXBlKTtcbiAgICAgIGNvbnN0IG1pbkZvcndhcmRCdWZmZXJMZW5ndGggPSBNYXRoLm1heChmcmFnLmR1cmF0aW9uLCBidWZmZXJlZEluZm8gPyBidWZmZXJlZEluZm8ubGVuIDogdGhpcy5jb25maWcubWF4QnVmZmVyTGVuZ3RoKTtcbiAgICAgIGlmICh0aGlzLnJlZHVjZU1heEJ1ZmZlckxlbmd0aChtaW5Gb3J3YXJkQnVmZmVyTGVuZ3RoKSkge1xuICAgICAgICBmcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgoKF90aGlzJG1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYUJ1ZmZlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG1lZGlhQnVmZmVyLmJ1ZmZlcmVkLmxlbmd0aCkgPT09IDApIHtcbiAgICAgIC8vIFN0b3AgZ2FwIGZvciBiYWQgdHJhY2tlciAvIGJ1ZmZlciBmbHVzaCBiZWhhdmlvclxuICAgICAgZnJhZ21lbnRUcmFja2VyLnJlbW92ZUFsbEZyYWdtZW50cygpO1xuICAgIH0gZWxzZSBpZiAoZnJhZ21lbnRUcmFja2VyLmhhc1BhcnRzKGZyYWcudHlwZSkpIHtcbiAgICAgIC8vIEluIGxvdyBsYXRlbmN5IG1vZGUsIHJlbW92ZSBmcmFnbWVudHMgZm9yIHdoaWNoIG9ubHkgc29tZSBwYXJ0cyB3ZXJlIGJ1ZmZlcmVkXG4gICAgICBmcmFnbWVudFRyYWNrZXIuZGV0ZWN0UGFydGlhbEZyYWdtZW50cyh7XG4gICAgICAgIGZyYWcsXG4gICAgICAgIHBhcnQ6IG51bGwsXG4gICAgICAgIHN0YXRzOiBmcmFnLnN0YXRzLFxuICAgICAgICBpZDogZnJhZy50eXBlXG4gICAgICB9KTtcbiAgICAgIGlmIChmcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZykgPT09IEZyYWdtZW50U3RhdGUuUEFSVElBTCkge1xuICAgICAgICBmcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNoZWNrTGl2ZVVwZGF0ZShkZXRhaWxzKSB7XG4gICAgaWYgKGRldGFpbHMudXBkYXRlZCAmJiAhZGV0YWlscy5saXZlKSB7XG4gICAgICAvLyBMaXZlIHN0cmVhbSBlbmRlZCwgdXBkYXRlIGZyYWdtZW50IHRyYWNrZXJcbiAgICAgIGNvbnN0IGxhc3RGcmFnbWVudCA9IGRldGFpbHMuZnJhZ21lbnRzW2RldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIuZGV0ZWN0UGFydGlhbEZyYWdtZW50cyh7XG4gICAgICAgIGZyYWc6IGxhc3RGcmFnbWVudCxcbiAgICAgICAgcGFydDogbnVsbCxcbiAgICAgICAgc3RhdHM6IGxhc3RGcmFnbWVudC5zdGF0cyxcbiAgICAgICAgaWQ6IGxhc3RGcmFnbWVudC50eXBlXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFkZXRhaWxzLmZyYWdtZW50c1swXSkge1xuICAgICAgZGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIGZsdXNoTWFpbkJ1ZmZlcihzdGFydE9mZnNldCwgZW5kT2Zmc2V0LCB0eXBlID0gbnVsbCkge1xuICAgIGlmICghKHN0YXJ0T2Zmc2V0IC0gZW5kT2Zmc2V0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBXaGVuIGFsdGVybmF0ZSBhdWRpbyBpcyBwbGF5aW5nLCB0aGUgYXVkaW8tc3RyZWFtLWNvbnRyb2xsZXIgaXMgcmVzcG9uc2libGUgZm9yIHRoZSBhdWRpbyBidWZmZXIuIE90aGVyd2lzZSxcbiAgICAvLyBwYXNzaW5nIGEgbnVsbCB0eXBlIGZsdXNoZXMgYm90aCBidWZmZXJzXG4gICAgY29uc3QgZmx1c2hTY29wZSA9IHtcbiAgICAgIHN0YXJ0T2Zmc2V0LFxuICAgICAgZW5kT2Zmc2V0LFxuICAgICAgdHlwZVxuICAgIH07XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0ZMVVNISU5HLCBmbHVzaFNjb3BlKTtcbiAgfVxuICBfbG9hZEluaXRTZWdtZW50KGZyYWcsIGxldmVsKSB7XG4gICAgdGhpcy5fZG9GcmFnTG9hZChmcmFnLCBsZXZlbCkudGhlbihkYXRhID0+IHtcbiAgICAgIGlmICghZGF0YSB8fCB0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSB8fCAhdGhpcy5sZXZlbHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbml0IGxvYWQgYWJvcnRlZCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSkudGhlbihkYXRhID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaGxzXG4gICAgICB9ID0gdGhpcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGF5bG9hZFxuICAgICAgfSA9IGRhdGE7XG4gICAgICBjb25zdCBkZWNyeXB0RGF0YSA9IGZyYWcuZGVjcnlwdGRhdGE7XG5cbiAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiB0aGUgcGF5bG9hZCBuZWVkcyB0byBiZSBkZWNyeXB0ZWRcbiAgICAgIGlmIChwYXlsb2FkICYmIHBheWxvYWQuYnl0ZUxlbmd0aCA+IDAgJiYgZGVjcnlwdERhdGEgIT0gbnVsbCAmJiBkZWNyeXB0RGF0YS5rZXkgJiYgZGVjcnlwdERhdGEuaXYgJiYgZGVjcnlwdERhdGEubWV0aG9kID09PSAnQUVTLTEyOCcpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgLy8gZGVjcnlwdCBpbml0IHNlZ21lbnQgZGF0YVxuICAgICAgICByZXR1cm4gdGhpcy5kZWNyeXB0ZXIuZGVjcnlwdChuZXcgVWludDhBcnJheShwYXlsb2FkKSwgZGVjcnlwdERhdGEua2V5LmJ1ZmZlciwgZGVjcnlwdERhdGEuaXYuYnVmZmVyKS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0RFQ1JZUFRfRVJST1IsXG4gICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogZXJyLFxuICAgICAgICAgICAgcmVhc29uOiBlcnIubWVzc2FnZSxcbiAgICAgICAgICAgIGZyYWdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0pLnRoZW4oZGVjcnlwdGVkRGF0YSA9PiB7XG4gICAgICAgICAgY29uc3QgZW5kVGltZSA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfREVDUllQVEVELCB7XG4gICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgcGF5bG9hZDogZGVjcnlwdGVkRGF0YSxcbiAgICAgICAgICAgIHN0YXRzOiB7XG4gICAgICAgICAgICAgIHRzdGFydDogc3RhcnRUaW1lLFxuICAgICAgICAgICAgICB0ZGVjcnlwdDogZW5kVGltZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGRhdGEucGF5bG9hZCA9IGRlY3J5cHRlZERhdGE7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGVJbml0U2VnbWVudExvYWQoZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGVJbml0U2VnbWVudExvYWQoZGF0YSk7XG4gICAgfSkuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5TVE9QUEVEIHx8IHRoaXMuc3RhdGUgPT09IFN0YXRlLkVSUk9SKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMud2FybihyZWFzb24pO1xuICAgICAgdGhpcy5yZXNldEZyYWdtZW50TG9hZGluZyhmcmFnKTtcbiAgICB9KTtcbiAgfVxuICBjb21wbGV0ZUluaXRTZWdtZW50TG9hZChkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWxzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFsZXZlbHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW5pdCBsb2FkIGFib3J0ZWQsIG1pc3NpbmcgbGV2ZWxzJyk7XG4gICAgfVxuICAgIGNvbnN0IHN0YXRzID0gZGF0YS5mcmFnLnN0YXRzO1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIGRhdGEuZnJhZy5kYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5wYXlsb2FkKTtcbiAgICBzdGF0cy5wYXJzaW5nLnN0YXJ0ID0gc3RhdHMuYnVmZmVyaW5nLnN0YXJ0ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICBzdGF0cy5wYXJzaW5nLmVuZCA9IHN0YXRzLmJ1ZmZlcmluZy5lbmQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHRoaXMudGljaygpO1xuICB9XG4gIGZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZ0N1cnJlbnRcbiAgICB9ID0gdGhpcztcbiAgICByZXR1cm4gIWZyYWcgfHwgIWZyYWdDdXJyZW50IHx8IGZyYWcuc24gIT09IGZyYWdDdXJyZW50LnNuIHx8IGZyYWcubGV2ZWwgIT09IGZyYWdDdXJyZW50LmxldmVsO1xuICB9XG4gIGZyYWdCdWZmZXJlZENvbXBsZXRlKGZyYWcsIHBhcnQpIHtcbiAgICB2YXIgX2ZyYWckc3RhcnRQVFMsIF9mcmFnJGVuZFBUUywgX3RoaXMkZnJhZ0N1cnJlbnQsIF90aGlzJGZyYWdQcmV2aW91cztcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogdGhpcy5tZWRpYTtcbiAgICB0aGlzLmxvZyhgQnVmZmVyZWQgJHtmcmFnLnR5cGV9IHNuOiAke2ZyYWcuc259JHtwYXJ0ID8gJyBwYXJ0OiAnICsgcGFydC5pbmRleCA6ICcnfSBvZiAke3RoaXMucGxheWxpc3RUeXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOID8gJ2xldmVsJyA6ICd0cmFjayd9ICR7ZnJhZy5sZXZlbH0gKGZyYWc6WyR7KChfZnJhZyRzdGFydFBUUyA9IGZyYWcuc3RhcnRQVFMpICE9IG51bGwgPyBfZnJhZyRzdGFydFBUUyA6IE5hTikudG9GaXhlZCgzKX0tJHsoKF9mcmFnJGVuZFBUUyA9IGZyYWcuZW5kUFRTKSAhPSBudWxsID8gX2ZyYWckZW5kUFRTIDogTmFOKS50b0ZpeGVkKDMpfV0gPiBidWZmZXI6JHttZWRpYSA/IFRpbWVSYW5nZXMudG9TdHJpbmcoQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKG1lZGlhKSkgOiAnKGRldGFjaGVkKSd9KWApO1xuICAgIGlmIChmcmFnLnNuICE9PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICB2YXIgX3RoaXMkbGV2ZWxzO1xuICAgICAgaWYgKGZyYWcudHlwZSAhPT0gUGxheWxpc3RMZXZlbFR5cGUuU1VCVElUTEUpIHtcbiAgICAgICAgY29uc3QgZWwgPSBmcmFnLmVsZW1lbnRhcnlTdHJlYW1zO1xuICAgICAgICBpZiAoIU9iamVjdC5rZXlzKGVsKS5zb21lKHR5cGUgPT4gISFlbFt0eXBlXSkpIHtcbiAgICAgICAgICAvLyBlbXB0eSBzZWdtZW50XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBsZXZlbCA9IChfdGhpcyRsZXZlbHMgPSB0aGlzLmxldmVscykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGxldmVsc1tmcmFnLmxldmVsXTtcbiAgICAgIGlmIChsZXZlbCAhPSBudWxsICYmIGxldmVsLmZyYWdtZW50RXJyb3IpIHtcbiAgICAgICAgdGhpcy5sb2coYFJlc2V0dGluZyBsZXZlbCBmcmFnbWVudCBlcnJvciBjb3VudCBvZiAke2xldmVsLmZyYWdtZW50RXJyb3J9IG9uIGZyYWcgYnVmZmVyZWRgKTtcbiAgICAgICAgbGV2ZWwuZnJhZ21lbnRFcnJvciA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIGlmICghbWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhICYmIGZyYWcudHlwZSA9PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOICYmIG1lZGlhLmJ1ZmZlcmVkLmxlbmd0aCAmJiAoKF90aGlzJGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGZyYWdDdXJyZW50LnNuKSA9PT0gKChfdGhpcyRmcmFnUHJldmlvdXMgPSB0aGlzLmZyYWdQcmV2aW91cykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGZyYWdQcmV2aW91cy5zbikpIHtcbiAgICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSB0cnVlO1xuICAgICAgdGhpcy5zZWVrVG9TdGFydFBvcygpO1xuICAgIH1cbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuICBzZWVrVG9TdGFydFBvcygpIHt9XG4gIF9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZShmcmFnTG9hZGVkRW5kRGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHRyYW5zbXV4ZXJcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIXRyYW5zbXV4ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIHBhcnQsXG4gICAgICBwYXJ0c0xvYWRlZFxuICAgIH0gPSBmcmFnTG9hZGVkRW5kRGF0YTtcbiAgICAvLyBJZiB3ZSBkaWQgbm90IGxvYWQgcGFydHMsIG9yIGxvYWRlZCBhbGwgcGFydHMsIHdlIGhhdmUgY29tcGxldGUgKG5vdCBwYXJ0aWFsKSBmcmFnbWVudCBkYXRhXG4gICAgY29uc3QgY29tcGxldGUgPSAhcGFydHNMb2FkZWQgfHwgcGFydHNMb2FkZWQubGVuZ3RoID09PSAwIHx8IHBhcnRzTG9hZGVkLnNvbWUoZnJhZ0xvYWRlZCA9PiAhZnJhZ0xvYWRlZCk7XG4gICAgY29uc3QgY2h1bmtNZXRhID0gbmV3IENodW5rTWV0YWRhdGEoZnJhZy5sZXZlbCwgZnJhZy5zbiwgZnJhZy5zdGF0cy5jaHVua0NvdW50ICsgMSwgMCwgcGFydCA/IHBhcnQuaW5kZXggOiAtMSwgIWNvbXBsZXRlKTtcbiAgICB0cmFuc211eGVyLmZsdXNoKGNodW5rTWV0YSk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIF9oYW5kbGVGcmFnbWVudExvYWRQcm9ncmVzcyhmcmFnKSB7fVxuICBfZG9GcmFnTG9hZChmcmFnLCBsZXZlbCwgdGFyZ2V0QnVmZmVyVGltZSA9IG51bGwsIHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICB2YXIgX2ZyYWckZGVjcnlwdGRhdGE7XG4gICAgY29uc3QgZGV0YWlscyA9IGxldmVsID09IG51bGwgPyB2b2lkIDAgOiBsZXZlbC5kZXRhaWxzO1xuICAgIGlmICghdGhpcy5sZXZlbHMgfHwgIWRldGFpbHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgZnJhZyBsb2FkIGFib3J0ZWQsIG1pc3NpbmcgbGV2ZWwke2RldGFpbHMgPyAnJyA6ICcgZGV0YWlsJ31zYCk7XG4gICAgfVxuICAgIGxldCBrZXlMb2FkaW5nUHJvbWlzZSA9IG51bGw7XG4gICAgaWYgKGZyYWcuZW5jcnlwdGVkICYmICEoKF9mcmFnJGRlY3J5cHRkYXRhID0gZnJhZy5kZWNyeXB0ZGF0YSkgIT0gbnVsbCAmJiBfZnJhZyRkZWNyeXB0ZGF0YS5rZXkpKSB7XG4gICAgICB0aGlzLmxvZyhgTG9hZGluZyBrZXkgZm9yICR7ZnJhZy5zbn0gb2YgWyR7ZGV0YWlscy5zdGFydFNOfS0ke2RldGFpbHMuZW5kU059XSwgJHt0aGlzLmxvZ1ByZWZpeCA9PT0gJ1tzdHJlYW0tY29udHJvbGxlcl0nID8gJ2xldmVsJyA6ICd0cmFjayd9ICR7ZnJhZy5sZXZlbH1gKTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5LRVlfTE9BRElORztcbiAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBmcmFnO1xuICAgICAga2V5TG9hZGluZ1Byb21pc2UgPSB0aGlzLmtleUxvYWRlci5sb2FkKGZyYWcpLnRoZW4oa2V5TG9hZGVkRGF0YSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5mcmFnQ29udGV4dENoYW5nZWQoa2V5TG9hZGVkRGF0YS5mcmFnKSkge1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLktFWV9MT0FERUQsIGtleUxvYWRlZERhdGEpO1xuICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5LRVlfTE9BRElORykge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBrZXlMb2FkZWREYXRhO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLktFWV9MT0FESU5HLCB7XG4gICAgICAgIGZyYWdcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMuZnJhZ0N1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAga2V5TG9hZGluZ1Byb21pc2UgPSBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYGZyYWcgbG9hZCBhYm9ydGVkLCBjb250ZXh0IGNoYW5nZWQgaW4gS0VZX0xPQURJTkdgKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghZnJhZy5lbmNyeXB0ZWQgJiYgZGV0YWlscy5lbmNyeXB0ZWRGcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmtleUxvYWRlci5sb2FkQ2xlYXIoZnJhZywgZGV0YWlscy5lbmNyeXB0ZWRGcmFnbWVudHMpO1xuICAgIH1cbiAgICB0YXJnZXRCdWZmZXJUaW1lID0gTWF0aC5tYXgoZnJhZy5zdGFydCwgdGFyZ2V0QnVmZmVyVGltZSB8fCAwKTtcbiAgICBpZiAodGhpcy5jb25maWcubG93TGF0ZW5jeU1vZGUgJiYgZnJhZy5zbiAhPT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgY29uc3QgcGFydExpc3QgPSBkZXRhaWxzLnBhcnRMaXN0O1xuICAgICAgaWYgKHBhcnRMaXN0ICYmIHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRhcmdldEJ1ZmZlclRpbWUgPiBmcmFnLmVuZCAmJiBkZXRhaWxzLmZyYWdtZW50SGludCkge1xuICAgICAgICAgIGZyYWcgPSBkZXRhaWxzLmZyYWdtZW50SGludDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJ0SW5kZXggPSB0aGlzLmdldE5leHRQYXJ0KHBhcnRMaXN0LCBmcmFnLCB0YXJnZXRCdWZmZXJUaW1lKTtcbiAgICAgICAgaWYgKHBhcnRJbmRleCA+IC0xKSB7XG4gICAgICAgICAgY29uc3QgcGFydCA9IHBhcnRMaXN0W3BhcnRJbmRleF07XG4gICAgICAgICAgdGhpcy5sb2coYExvYWRpbmcgcGFydCBzbjogJHtmcmFnLnNufSBwOiAke3BhcnQuaW5kZXh9IGNjOiAke2ZyYWcuY2N9IG9mIHBsYXlsaXN0IFske2RldGFpbHMuc3RhcnRTTn0tJHtkZXRhaWxzLmVuZFNOfV0gcGFydHMgWzAtJHtwYXJ0SW5kZXh9LSR7cGFydExpc3QubGVuZ3RoIC0gMX1dICR7dGhpcy5sb2dQcmVmaXggPT09ICdbc3RyZWFtLWNvbnRyb2xsZXJdJyA/ICdsZXZlbCcgOiAndHJhY2snfTogJHtmcmFnLmxldmVsfSwgdGFyZ2V0OiAke3BhcnNlRmxvYXQodGFyZ2V0QnVmZmVyVGltZS50b0ZpeGVkKDMpKX1gKTtcbiAgICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBwYXJ0LnN0YXJ0ICsgcGFydC5kdXJhdGlvbjtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HO1xuICAgICAgICAgIGxldCBfcmVzdWx0O1xuICAgICAgICAgIGlmIChrZXlMb2FkaW5nUHJvbWlzZSkge1xuICAgICAgICAgICAgX3Jlc3VsdCA9IGtleUxvYWRpbmdQcm9taXNlLnRoZW4oa2V5TG9hZGVkRGF0YSA9PiB7XG4gICAgICAgICAgICAgIGlmICgha2V5TG9hZGVkRGF0YSB8fCB0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChrZXlMb2FkZWREYXRhLmZyYWcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9GcmFnUGFydHNMb2FkKGZyYWcsIHBhcnQsIGxldmVsLCBwcm9ncmVzc0NhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHRoaXMuaGFuZGxlRnJhZ0xvYWRFcnJvcihlcnJvcikpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfcmVzdWx0ID0gdGhpcy5kb0ZyYWdQYXJ0c0xvYWQoZnJhZywgcGFydCwgbGV2ZWwsIHByb2dyZXNzQ2FsbGJhY2spLmNhdGNoKGVycm9yID0+IHRoaXMuaGFuZGxlRnJhZ0xvYWRFcnJvcihlcnJvcikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0xPQURJTkcsIHtcbiAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgdGFyZ2V0QnVmZmVyVGltZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICh0aGlzLmZyYWdDdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBmcmFnIGxvYWQgYWJvcnRlZCwgY29udGV4dCBjaGFuZ2VkIGluIEZSQUdfTE9BRElORyBwYXJ0c2ApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9yZXN1bHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIWZyYWcudXJsIHx8IHRoaXMubG9hZGVkRW5kT2ZQYXJ0cyhwYXJ0TGlzdCwgdGFyZ2V0QnVmZmVyVGltZSkpIHtcbiAgICAgICAgICAvLyBGcmFnbWVudCBoaW50IGhhcyBubyBwYXJ0c1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sb2coYExvYWRpbmcgZnJhZ21lbnQgJHtmcmFnLnNufSBjYzogJHtmcmFnLmNjfSAke2RldGFpbHMgPyAnb2YgWycgKyBkZXRhaWxzLnN0YXJ0U04gKyAnLScgKyBkZXRhaWxzLmVuZFNOICsgJ10gJyA6ICcnfSR7dGhpcy5sb2dQcmVmaXggPT09ICdbc3RyZWFtLWNvbnRyb2xsZXJdJyA/ICdsZXZlbCcgOiAndHJhY2snfTogJHtmcmFnLmxldmVsfSwgdGFyZ2V0OiAke3BhcnNlRmxvYXQodGFyZ2V0QnVmZmVyVGltZS50b0ZpeGVkKDMpKX1gKTtcbiAgICAvLyBEb24ndCB1cGRhdGUgbmV4dExvYWRQb3NpdGlvbiBmb3IgZnJhZ21lbnRzIHdoaWNoIGFyZSBub3QgYnVmZmVyZWRcbiAgICBpZiAoaXNGaW5pdGVOdW1iZXIoZnJhZy5zbikgJiYgIXRoaXMuYml0cmF0ZVRlc3QpIHtcbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IGZyYWcuc3RhcnQgKyBmcmFnLmR1cmF0aW9uO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HO1xuXG4gICAgLy8gTG9hZCBrZXkgYmVmb3JlIHN0cmVhbWluZyBmcmFnbWVudCBkYXRhXG4gICAgY29uc3QgZGF0YU9uUHJvZ3Jlc3MgPSB0aGlzLmNvbmZpZy5wcm9ncmVzc2l2ZTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmIChkYXRhT25Qcm9ncmVzcyAmJiBrZXlMb2FkaW5nUHJvbWlzZSkge1xuICAgICAgcmVzdWx0ID0ga2V5TG9hZGluZ1Byb21pc2UudGhlbihrZXlMb2FkZWREYXRhID0+IHtcbiAgICAgICAgaWYgKCFrZXlMb2FkZWREYXRhIHx8IHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGtleUxvYWRlZERhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGtleUxvYWRlZERhdGEuZnJhZykpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5mcmFnbWVudExvYWRlci5sb2FkKGZyYWcsIHByb2dyZXNzQ2FsbGJhY2spO1xuICAgICAgfSkuY2F0Y2goZXJyb3IgPT4gdGhpcy5oYW5kbGVGcmFnTG9hZEVycm9yKGVycm9yKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxvYWQgdW5lbmNyeXB0ZWQgZnJhZ21lbnQgZGF0YSB3aXRoIHByb2dyZXNzIGV2ZW50LFxuICAgICAgLy8gb3IgaGFuZGxlIGZyYWdtZW50IHJlc3VsdCBhZnRlciBrZXkgYW5kIGZyYWdtZW50IGFyZSBmaW5pc2hlZCBsb2FkaW5nXG4gICAgICByZXN1bHQgPSBQcm9taXNlLmFsbChbdGhpcy5mcmFnbWVudExvYWRlci5sb2FkKGZyYWcsIGRhdGFPblByb2dyZXNzID8gcHJvZ3Jlc3NDYWxsYmFjayA6IHVuZGVmaW5lZCksIGtleUxvYWRpbmdQcm9taXNlXSkudGhlbigoW2ZyYWdMb2FkZWREYXRhXSkgPT4ge1xuICAgICAgICBpZiAoIWRhdGFPblByb2dyZXNzICYmIGZyYWdMb2FkZWREYXRhICYmIHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICAgICAgICBwcm9ncmVzc0NhbGxiYWNrKGZyYWdMb2FkZWREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJhZ0xvYWRlZERhdGE7XG4gICAgICB9KS5jYXRjaChlcnJvciA9PiB0aGlzLmhhbmRsZUZyYWdMb2FkRXJyb3IoZXJyb3IpKTtcbiAgICB9XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRlJBR19MT0FESU5HLCB7XG4gICAgICBmcmFnLFxuICAgICAgdGFyZ2V0QnVmZmVyVGltZVxuICAgIH0pO1xuICAgIGlmICh0aGlzLmZyYWdDdXJyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBmcmFnIGxvYWQgYWJvcnRlZCwgY29udGV4dCBjaGFuZ2VkIGluIEZSQUdfTE9BRElOR2ApKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkb0ZyYWdQYXJ0c0xvYWQoZnJhZywgZnJvbVBhcnQsIGxldmVsLCBwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHZhciBfbGV2ZWwkZGV0YWlscztcbiAgICAgIGNvbnN0IHBhcnRzTG9hZGVkID0gW107XG4gICAgICBjb25zdCBpbml0aWFsUGFydExpc3QgPSAoX2xldmVsJGRldGFpbHMgPSBsZXZlbC5kZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX2xldmVsJGRldGFpbHMucGFydExpc3Q7XG4gICAgICBjb25zdCBsb2FkUGFydCA9IHBhcnQgPT4ge1xuICAgICAgICB0aGlzLmZyYWdtZW50TG9hZGVyLmxvYWRQYXJ0KGZyYWcsIHBhcnQsIHByb2dyZXNzQ2FsbGJhY2spLnRoZW4ocGFydExvYWRlZERhdGEgPT4ge1xuICAgICAgICAgIHBhcnRzTG9hZGVkW3BhcnQuaW5kZXhdID0gcGFydExvYWRlZERhdGE7XG4gICAgICAgICAgY29uc3QgbG9hZGVkUGFydCA9IHBhcnRMb2FkZWREYXRhLnBhcnQ7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRlJBR19MT0FERUQsIHBhcnRMb2FkZWREYXRhKTtcbiAgICAgICAgICBjb25zdCBuZXh0UGFydCA9IGdldFBhcnRXaXRoKGxldmVsLCBmcmFnLnNuLCBwYXJ0LmluZGV4ICsgMSkgfHwgZmluZFBhcnQoaW5pdGlhbFBhcnRMaXN0LCBmcmFnLnNuLCBwYXJ0LmluZGV4ICsgMSk7XG4gICAgICAgICAgaWYgKG5leHRQYXJ0KSB7XG4gICAgICAgICAgICBsb2FkUGFydChuZXh0UGFydCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHtcbiAgICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgICAgcGFydDogbG9hZGVkUGFydCxcbiAgICAgICAgICAgICAgcGFydHNMb2FkZWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgIH07XG4gICAgICBsb2FkUGFydChmcm9tUGFydCk7XG4gICAgfSk7XG4gIH1cbiAgaGFuZGxlRnJhZ0xvYWRFcnJvcihlcnJvcikge1xuICAgIGlmICgnZGF0YScgaW4gZXJyb3IpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBlcnJvci5kYXRhO1xuICAgICAgaWYgKGVycm9yLmRhdGEgJiYgZGF0YS5kZXRhaWxzID09PSBFcnJvckRldGFpbHMuSU5URVJOQUxfQUJPUlRFRCkge1xuICAgICAgICB0aGlzLmhhbmRsZUZyYWdMb2FkQWJvcnRlZChkYXRhLmZyYWcsIGRhdGEucGFydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwgZGF0YSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuT1RIRVJfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5JTlRFUk5BTF9FWENFUFRJT04sXG4gICAgICAgIGVycjogZXJyb3IsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIF9oYW5kbGVUcmFuc211eGVyRmx1c2goY2h1bmtNZXRhKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ2V0Q3VycmVudENvbnRleHQoY2h1bmtNZXRhKTtcbiAgICBpZiAoIWNvbnRleHQgfHwgdGhpcy5zdGF0ZSAhPT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgaWYgKCF0aGlzLmZyYWdDdXJyZW50ICYmIHRoaXMuc3RhdGUgIT09IFN0YXRlLlNUT1BQRUQgJiYgdGhpcy5zdGF0ZSAhPT0gU3RhdGUuRVJST1IpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGZyYWcsXG4gICAgICBwYXJ0LFxuICAgICAgbGV2ZWxcbiAgICB9ID0gY29udGV4dDtcbiAgICBjb25zdCBub3cgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGZyYWcuc3RhdHMucGFyc2luZy5lbmQgPSBub3c7XG4gICAgaWYgKHBhcnQpIHtcbiAgICAgIHBhcnQuc3RhdHMucGFyc2luZy5lbmQgPSBub3c7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlTGV2ZWxUaW1pbmcoZnJhZywgcGFydCwgbGV2ZWwsIGNodW5rTWV0YS5wYXJ0aWFsKTtcbiAgfVxuICBnZXRDdXJyZW50Q29udGV4dChjaHVua01ldGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBsZXZlbHMsXG4gICAgICBmcmFnQ3VycmVudFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIGxldmVsOiBsZXZlbEluZGV4LFxuICAgICAgc24sXG4gICAgICBwYXJ0OiBwYXJ0SW5kZXhcbiAgICB9ID0gY2h1bmtNZXRhO1xuICAgIGlmICghKGxldmVscyAhPSBudWxsICYmIGxldmVsc1tsZXZlbEluZGV4XSkpIHtcbiAgICAgIHRoaXMud2FybihgTGV2ZWxzIG9iamVjdCB3YXMgdW5zZXQgd2hpbGUgYnVmZmVyaW5nIGZyYWdtZW50ICR7c259IG9mIGxldmVsICR7bGV2ZWxJbmRleH0uIFRoZSBjdXJyZW50IGNodW5rIHdpbGwgbm90IGJlIGJ1ZmZlcmVkLmApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGxldmVsID0gbGV2ZWxzW2xldmVsSW5kZXhdO1xuICAgIGNvbnN0IHBhcnQgPSBwYXJ0SW5kZXggPiAtMSA/IGdldFBhcnRXaXRoKGxldmVsLCBzbiwgcGFydEluZGV4KSA6IG51bGw7XG4gICAgY29uc3QgZnJhZyA9IHBhcnQgPyBwYXJ0LmZyYWdtZW50IDogZ2V0RnJhZ21lbnRXaXRoU04obGV2ZWwsIHNuLCBmcmFnQ3VycmVudCk7XG4gICAgaWYgKCFmcmFnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGZyYWdDdXJyZW50ICYmIGZyYWdDdXJyZW50ICE9PSBmcmFnKSB7XG4gICAgICBmcmFnLnN0YXRzID0gZnJhZ0N1cnJlbnQuc3RhdHM7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBmcmFnLFxuICAgICAgcGFydCxcbiAgICAgIGxldmVsXG4gICAgfTtcbiAgfVxuICBidWZmZXJGcmFnbWVudERhdGEoZGF0YSwgZnJhZywgcGFydCwgY2h1bmtNZXRhLCBub0JhY2t0cmFja2luZykge1xuICAgIHZhciBfYnVmZmVyO1xuICAgIGlmICghZGF0YSB8fCB0aGlzLnN0YXRlICE9PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGRhdGExLFxuICAgICAgZGF0YTJcbiAgICB9ID0gZGF0YTtcbiAgICBsZXQgYnVmZmVyID0gZGF0YTE7XG4gICAgaWYgKGRhdGExICYmIGRhdGEyKSB7XG4gICAgICAvLyBDb21iaW5lIHRoZSBtb29mICsgbWRhdCBzbyB0aGF0IHdlIGJ1ZmZlciB3aXRoIGEgc2luZ2xlIGFwcGVuZFxuICAgICAgYnVmZmVyID0gYXBwZW5kVWludDhBcnJheShkYXRhMSwgZGF0YTIpO1xuICAgIH1cbiAgICBpZiAoISgoX2J1ZmZlciA9IGJ1ZmZlcikgIT0gbnVsbCAmJiBfYnVmZmVyLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VnbWVudCA9IHtcbiAgICAgIHR5cGU6IGRhdGEudHlwZSxcbiAgICAgIGZyYWcsXG4gICAgICBwYXJ0LFxuICAgICAgY2h1bmtNZXRhLFxuICAgICAgcGFyZW50OiBmcmFnLnR5cGUsXG4gICAgICBkYXRhOiBidWZmZXJcbiAgICB9O1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9BUFBFTkRJTkcsIHNlZ21lbnQpO1xuICAgIGlmIChkYXRhLmRyb3BwZWQgJiYgZGF0YS5pbmRlcGVuZGVudCAmJiAhcGFydCkge1xuICAgICAgaWYgKG5vQmFja3RyYWNraW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIENsZWFyIGJ1ZmZlciBzbyB0aGF0IHdlIHJlbG9hZCBwcmV2aW91cyBzZWdtZW50cyBzZXF1ZW50aWFsbHkgaWYgcmVxdWlyZWRcbiAgICAgIHRoaXMuZmx1c2hCdWZmZXJHYXAoZnJhZyk7XG4gICAgfVxuICB9XG4gIGZsdXNoQnVmZmVyR2FwKGZyYWcpIHtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiBjdXJyZW50VGltZSBpcyBub3QgYnVmZmVyZWQsIGNsZWFyIHRoZSBiYWNrIGJ1ZmZlciBzbyB0aGF0IHdlIGNhbiBiYWNrdHJhY2sgYXMgbXVjaCBhcyBuZWVkZWRcbiAgICBpZiAoIUJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKG1lZGlhLCBtZWRpYS5jdXJyZW50VGltZSkpIHtcbiAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKDAsIGZyYWcuc3RhcnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgYmFjay1idWZmZXIgd2l0aG91dCBpbnRlcnJ1cHRpbmcgcGxheWJhY2sgdG8gYWxsb3cgYmFjayB0cmFja2luZ1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgY29uc3QgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKG1lZGlhLCBjdXJyZW50VGltZSwgMCk7XG4gICAgY29uc3QgZnJhZ0R1cmF0aW9uID0gZnJhZy5kdXJhdGlvbjtcbiAgICBjb25zdCBzZWdtZW50RnJhY3Rpb24gPSBNYXRoLm1pbih0aGlzLmNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlICogMiwgZnJhZ0R1cmF0aW9uICogMC4yNSk7XG4gICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heChNYXRoLm1pbihmcmFnLnN0YXJ0IC0gc2VnbWVudEZyYWN0aW9uLCBidWZmZXJJbmZvLmVuZCAtIHNlZ21lbnRGcmFjdGlvbiksIGN1cnJlbnRUaW1lICsgc2VnbWVudEZyYWN0aW9uKTtcbiAgICBpZiAoZnJhZy5zdGFydCAtIHN0YXJ0ID4gc2VnbWVudEZyYWN0aW9uKSB7XG4gICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcihzdGFydCwgZnJhZy5zdGFydCk7XG4gICAgfVxuICB9XG4gIGdldEZ3ZEJ1ZmZlckluZm8oYnVmZmVyYWJsZSwgdHlwZSkge1xuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0TG9hZFBvc2l0aW9uKCk7XG4gICAgaWYgKCFpc0Zpbml0ZU51bWJlcihwb3MpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0RndkQnVmZmVySW5mb0F0UG9zKGJ1ZmZlcmFibGUsIHBvcywgdHlwZSk7XG4gIH1cbiAgZ2V0RndkQnVmZmVySW5mb0F0UG9zKGJ1ZmZlcmFibGUsIHBvcywgdHlwZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbmZpZzoge1xuICAgICAgICBtYXhCdWZmZXJIb2xlXG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKGJ1ZmZlcmFibGUsIHBvcywgbWF4QnVmZmVySG9sZSk7XG4gICAgLy8gV29ya2Fyb3VuZCBmbGF3IGluIGdldHRpbmcgZm9yd2FyZCBidWZmZXIgd2hlbiBtYXhCdWZmZXJIb2xlIGlzIHNtYWxsZXIgdGhhbiBnYXAgYXQgY3VycmVudCBwb3NcbiAgICBpZiAoYnVmZmVySW5mby5sZW4gPT09IDAgJiYgYnVmZmVySW5mby5uZXh0U3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgYnVmZmVyZWRGcmFnQXRQb3MgPSB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRCdWZmZXJlZEZyYWcocG9zLCB0eXBlKTtcbiAgICAgIGlmIChidWZmZXJlZEZyYWdBdFBvcyAmJiBidWZmZXJJbmZvLm5leHRTdGFydCA8IGJ1ZmZlcmVkRnJhZ0F0UG9zLmVuZCkge1xuICAgICAgICByZXR1cm4gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8oYnVmZmVyYWJsZSwgcG9zLCBNYXRoLm1heChidWZmZXJJbmZvLm5leHRTdGFydCwgbWF4QnVmZmVySG9sZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnVmZmVySW5mbztcbiAgfVxuICBnZXRNYXhCdWZmZXJMZW5ndGgobGV2ZWxCaXRyYXRlKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29uZmlnXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IG1heEJ1ZkxlbjtcbiAgICBpZiAobGV2ZWxCaXRyYXRlKSB7XG4gICAgICBtYXhCdWZMZW4gPSBNYXRoLm1heCg4ICogY29uZmlnLm1heEJ1ZmZlclNpemUgLyBsZXZlbEJpdHJhdGUsIGNvbmZpZy5tYXhCdWZmZXJMZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXhCdWZMZW4gPSBjb25maWcubWF4QnVmZmVyTGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5taW4obWF4QnVmTGVuLCBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoKTtcbiAgfVxuICByZWR1Y2VNYXhCdWZmZXJMZW5ndGgodGhyZXNob2xkKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgY29uc3QgbWluTGVuZ3RoID0gdGhyZXNob2xkIHx8IGNvbmZpZy5tYXhCdWZmZXJMZW5ndGg7XG4gICAgaWYgKGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGggPj0gbWluTGVuZ3RoKSB7XG4gICAgICAvLyByZWR1Y2UgbWF4IGJ1ZmZlciBsZW5ndGggYXMgaXQgbWlnaHQgYmUgdG9vIGhpZ2guIHdlIGRvIHRoaXMgdG8gYXZvaWQgbG9vcCBmbHVzaGluZyAuLi5cbiAgICAgIGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGggLz0gMjtcbiAgICAgIHRoaXMud2FybihgUmVkdWNlIG1heCBidWZmZXIgbGVuZ3RoIHRvICR7Y29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aH1zYCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGdldEFwcGVuZGVkRnJhZyhwb3NpdGlvbiwgcGxheWxpc3RUeXBlID0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTikge1xuICAgIGNvbnN0IGZyYWdPclBhcnQgPSB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRBcHBlbmRlZEZyYWcocG9zaXRpb24sIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pO1xuICAgIGlmIChmcmFnT3JQYXJ0ICYmICdmcmFnbWVudCcgaW4gZnJhZ09yUGFydCkge1xuICAgICAgcmV0dXJuIGZyYWdPclBhcnQuZnJhZ21lbnQ7XG4gICAgfVxuICAgIHJldHVybiBmcmFnT3JQYXJ0O1xuICB9XG4gIGdldE5leHRGcmFnbWVudChwb3MsIGxldmVsRGV0YWlscykge1xuICAgIGNvbnN0IGZyYWdtZW50cyA9IGxldmVsRGV0YWlscy5mcmFnbWVudHM7XG4gICAgY29uc3QgZnJhZ0xlbiA9IGZyYWdtZW50cy5sZW5ndGg7XG4gICAgaWYgKCFmcmFnTGVuKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBmaW5kIGZyYWdtZW50IGluZGV4LCBjb250aWd1b3VzIHdpdGggZW5kIG9mIGJ1ZmZlciBwb3NpdGlvblxuICAgIGNvbnN0IHtcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHN0YXJ0ID0gZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgIGxldCBmcmFnO1xuICAgIGlmIChsZXZlbERldGFpbHMubGl2ZSkge1xuICAgICAgY29uc3QgaW5pdGlhbExpdmVNYW5pZmVzdFNpemUgPSBjb25maWcuaW5pdGlhbExpdmVNYW5pZmVzdFNpemU7XG4gICAgICBpZiAoZnJhZ0xlbiA8IGluaXRpYWxMaXZlTWFuaWZlc3RTaXplKSB7XG4gICAgICAgIHRoaXMud2FybihgTm90IGVub3VnaCBmcmFnbWVudHMgdG8gc3RhcnQgcGxheWJhY2sgKGhhdmU6ICR7ZnJhZ0xlbn0sIG5lZWQ6ICR7aW5pdGlhbExpdmVNYW5pZmVzdFNpemV9KWApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8vIFRoZSByZWFsIGZyYWdtZW50IHN0YXJ0IHRpbWVzIGZvciBhIGxpdmUgc3RyZWFtIGFyZSBvbmx5IGtub3duIGFmdGVyIHRoZSBQVFMgcmFuZ2UgZm9yIHRoYXQgbGV2ZWwgaXMga25vd24uXG4gICAgICAvLyBJbiBvcmRlciB0byBkaXNjb3ZlciB0aGUgcmFuZ2UsIHdlIGxvYWQgdGhlIGJlc3QgbWF0Y2hpbmcgZnJhZ21lbnQgZm9yIHRoYXQgbGV2ZWwgYW5kIGRlbXV4IGl0LlxuICAgICAgLy8gRG8gbm90IGxvYWQgdXNpbmcgbGl2ZSBsb2dpYyBpZiB0aGUgc3RhcnRpbmcgZnJhZyBpcyByZXF1ZXN0ZWQgLSB3ZSB3YW50IHRvIHVzZSBnZXRGcmFnbWVudEF0UG9zaXRpb24oKSBzbyB0aGF0XG4gICAgICAvLyB3ZSBnZXQgdGhlIGZyYWdtZW50IG1hdGNoaW5nIHRoYXQgc3RhcnQgdGltZVxuICAgICAgaWYgKCFsZXZlbERldGFpbHMuUFRTS25vd24gJiYgIXRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkICYmIHRoaXMuc3RhcnRQb3NpdGlvbiA9PT0gLTEgfHwgcG9zIDwgc3RhcnQpIHtcbiAgICAgICAgZnJhZyA9IHRoaXMuZ2V0SW5pdGlhbExpdmVGcmFnbWVudChsZXZlbERldGFpbHMsIGZyYWdtZW50cyk7XG4gICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IGZyYWcgPyB0aGlzLmhscy5saXZlU3luY1Bvc2l0aW9uIHx8IGZyYWcuc3RhcnQgOiBwb3M7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwb3MgPD0gc3RhcnQpIHtcbiAgICAgIC8vIFZvRCBwbGF5bGlzdDogaWYgbG9hZFBvc2l0aW9uIGJlZm9yZSBzdGFydCBvZiBwbGF5bGlzdCwgbG9hZCBmaXJzdCBmcmFnbWVudFxuICAgICAgZnJhZyA9IGZyYWdtZW50c1swXTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBoYXZlbid0IHJ1biBpbnRvIGFueSBzcGVjaWFsIGNhc2VzIGFscmVhZHksIGp1c3QgbG9hZCB0aGUgZnJhZ21lbnQgbW9zdCBjbG9zZWx5IG1hdGNoaW5nIHRoZSByZXF1ZXN0ZWQgcG9zaXRpb25cbiAgICBpZiAoIWZyYWcpIHtcbiAgICAgIGNvbnN0IGVuZCA9IGNvbmZpZy5sb3dMYXRlbmN5TW9kZSA/IGxldmVsRGV0YWlscy5wYXJ0RW5kIDogbGV2ZWxEZXRhaWxzLmZyYWdtZW50RW5kO1xuICAgICAgZnJhZyA9IHRoaXMuZ2V0RnJhZ21lbnRBdFBvc2l0aW9uKHBvcywgZW5kLCBsZXZlbERldGFpbHMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tYXBUb0luaXRGcmFnV2hlblJlcXVpcmVkKGZyYWcpO1xuICB9XG4gIGlzTG9vcExvYWRpbmcoZnJhZywgdGFyZ2V0QnVmZmVyVGltZSkge1xuICAgIGNvbnN0IHRyYWNrZXJTdGF0ZSA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGZyYWcpO1xuICAgIHJldHVybiAodHJhY2tlclN0YXRlID09PSBGcmFnbWVudFN0YXRlLk9LIHx8IHRyYWNrZXJTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5QQVJUSUFMICYmICEhZnJhZy5nYXApICYmIHRoaXMubmV4dExvYWRQb3NpdGlvbiA+IHRhcmdldEJ1ZmZlclRpbWU7XG4gIH1cbiAgZ2V0TmV4dEZyYWdtZW50TG9vcExvYWRpbmcoZnJhZywgbGV2ZWxEZXRhaWxzLCBidWZmZXJJbmZvLCBwbGF5bGlzdFR5cGUsIG1heEJ1Zkxlbikge1xuICAgIGNvbnN0IGdhcFN0YXJ0ID0gZnJhZy5nYXA7XG4gICAgY29uc3QgbmV4dEZyYWdtZW50ID0gdGhpcy5nZXROZXh0RnJhZ21lbnQodGhpcy5uZXh0TG9hZFBvc2l0aW9uLCBsZXZlbERldGFpbHMpO1xuICAgIGlmIChuZXh0RnJhZ21lbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBuZXh0RnJhZ21lbnQ7XG4gICAgfVxuICAgIGZyYWcgPSBuZXh0RnJhZ21lbnQ7XG4gICAgaWYgKGdhcFN0YXJ0ICYmIGZyYWcgJiYgIWZyYWcuZ2FwICYmIGJ1ZmZlckluZm8ubmV4dFN0YXJ0KSB7XG4gICAgICAvLyBNZWRpYSBidWZmZXJlZCBhZnRlciBHQVAgdGFncyBzaG91bGQgbm90IG1ha2UgdGhlIG5leHQgYnVmZmVyIHRpbWVyYW5nZSBleGNlZWQgZm9yd2FyZCBidWZmZXIgbGVuZ3RoXG4gICAgICBjb25zdCBuZXh0YnVmZmVySW5mbyA9IHRoaXMuZ2V0RndkQnVmZmVySW5mb0F0UG9zKHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogdGhpcy5tZWRpYSwgYnVmZmVySW5mby5uZXh0U3RhcnQsIHBsYXlsaXN0VHlwZSk7XG4gICAgICBpZiAobmV4dGJ1ZmZlckluZm8gIT09IG51bGwgJiYgYnVmZmVySW5mby5sZW4gKyBuZXh0YnVmZmVySW5mby5sZW4gPj0gbWF4QnVmTGVuKSB7XG4gICAgICAgIC8vIFJldHVybmluZyBoZXJlIG1pZ2h0IHJlc3VsdCBpbiBub3QgZmluZGluZyBhbiBhdWRpbyBhbmQgdmlkZW8gY2FuZGlhdGUgdG8gc2tpcCB0b1xuICAgICAgICB0aGlzLmxvZyhgYnVmZmVyIGZ1bGwgYWZ0ZXIgZ2FwcyBpbiBcIiR7cGxheWxpc3RUeXBlfVwiIHBsYXlsaXN0IHN0YXJ0aW5nIGF0IHNuOiAke2ZyYWcuc259YCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnJhZztcbiAgfVxuICBtYXBUb0luaXRGcmFnV2hlblJlcXVpcmVkKGZyYWcpIHtcbiAgICAvLyBJZiBhbiBpbml0U2VnbWVudCBpcyBwcmVzZW50LCBpdCBtdXN0IGJlIGJ1ZmZlcmVkIGZpcnN0XG4gICAgaWYgKGZyYWcgIT0gbnVsbCAmJiBmcmFnLmluaXRTZWdtZW50ICYmICEoZnJhZyAhPSBudWxsICYmIGZyYWcuaW5pdFNlZ21lbnQuZGF0YSkgJiYgIXRoaXMuYml0cmF0ZVRlc3QpIHtcbiAgICAgIHJldHVybiBmcmFnLmluaXRTZWdtZW50O1xuICAgIH1cbiAgICByZXR1cm4gZnJhZztcbiAgfVxuICBnZXROZXh0UGFydChwYXJ0TGlzdCwgZnJhZywgdGFyZ2V0QnVmZmVyVGltZSkge1xuICAgIGxldCBuZXh0UGFydCA9IC0xO1xuICAgIGxldCBjb250aWd1b3VzID0gZmFsc2U7XG4gICAgbGV0IGluZGVwZW5kZW50QXR0ck9taXR0ZWQgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBwYXJ0TGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgcGFydCA9IHBhcnRMaXN0W2ldO1xuICAgICAgaW5kZXBlbmRlbnRBdHRyT21pdHRlZCA9IGluZGVwZW5kZW50QXR0ck9taXR0ZWQgJiYgIXBhcnQuaW5kZXBlbmRlbnQ7XG4gICAgICBpZiAobmV4dFBhcnQgPiAtMSAmJiB0YXJnZXRCdWZmZXJUaW1lIDwgcGFydC5zdGFydCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxvYWRlZCA9IHBhcnQubG9hZGVkO1xuICAgICAgaWYgKGxvYWRlZCkge1xuICAgICAgICBuZXh0UGFydCA9IC0xO1xuICAgICAgfSBlbHNlIGlmICgoY29udGlndW91cyB8fCBwYXJ0LmluZGVwZW5kZW50IHx8IGluZGVwZW5kZW50QXR0ck9taXR0ZWQpICYmIHBhcnQuZnJhZ21lbnQgPT09IGZyYWcpIHtcbiAgICAgICAgbmV4dFBhcnQgPSBpO1xuICAgICAgfVxuICAgICAgY29udGlndW91cyA9IGxvYWRlZDtcbiAgICB9XG4gICAgcmV0dXJuIG5leHRQYXJ0O1xuICB9XG4gIGxvYWRlZEVuZE9mUGFydHMocGFydExpc3QsIHRhcmdldEJ1ZmZlclRpbWUpIHtcbiAgICBjb25zdCBsYXN0UGFydCA9IHBhcnRMaXN0W3BhcnRMaXN0Lmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBsYXN0UGFydCAmJiB0YXJnZXRCdWZmZXJUaW1lID4gbGFzdFBhcnQuc3RhcnQgJiYgbGFzdFBhcnQubG9hZGVkO1xuICB9XG5cbiAgLypcbiAgIFRoaXMgbWV0aG9kIGlzIHVzZWQgZmluZCB0aGUgYmVzdCBtYXRjaGluZyBmaXJzdCBmcmFnbWVudCBmb3IgYSBsaXZlIHBsYXlsaXN0LiBUaGlzIGZyYWdtZW50IGlzIHVzZWQgdG8gY2FsY3VsYXRlIHRoZVxuICAgXCJzbGlkaW5nXCIgb2YgdGhlIHBsYXlsaXN0LCB3aGljaCBpcyBpdHMgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIHBsYXliYWNrLiBBZnRlciBzbGlkaW5nIHdlIGNhbiBjb21wdXRlIHRoZSByZWFsXG4gICBzdGFydCBhbmQgZW5kIHRpbWVzIGZvciBlYWNoIGZyYWdtZW50IGluIHRoZSBwbGF5bGlzdCAoYWZ0ZXIgd2hpY2ggdGhpcyBtZXRob2Qgd2lsbCBub3QgbmVlZCB0byBiZSBjYWxsZWQpLlxuICAqL1xuICBnZXRJbml0aWFsTGl2ZUZyYWdtZW50KGxldmVsRGV0YWlscywgZnJhZ21lbnRzKSB7XG4gICAgY29uc3QgZnJhZ1ByZXZpb3VzID0gdGhpcy5mcmFnUHJldmlvdXM7XG4gICAgbGV0IGZyYWcgPSBudWxsO1xuICAgIGlmIChmcmFnUHJldmlvdXMpIHtcbiAgICAgIGlmIChsZXZlbERldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgICAgIC8vIFByZWZlciB1c2luZyBQRFQsIGJlY2F1c2UgaXQgY2FuIGJlIGFjY3VyYXRlIGVub3VnaCB0byBjaG9vc2UgdGhlIGNvcnJlY3QgZnJhZ21lbnQgd2l0aG91dCBrbm93aW5nIHRoZSBsZXZlbCBzbGlkaW5nXG4gICAgICAgIHRoaXMubG9nKGBMaXZlIHBsYXlsaXN0LCBzd2l0Y2hpbmcgcGxheWxpc3QsIGxvYWQgZnJhZyB3aXRoIHNhbWUgUERUOiAke2ZyYWdQcmV2aW91cy5wcm9ncmFtRGF0ZVRpbWV9YCk7XG4gICAgICAgIGZyYWcgPSBmaW5kRnJhZ21lbnRCeVBEVChmcmFnbWVudHMsIGZyYWdQcmV2aW91cy5lbmRQcm9ncmFtRGF0ZVRpbWUsIHRoaXMuY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UpO1xuICAgICAgfVxuICAgICAgaWYgKCFmcmFnKSB7XG4gICAgICAgIC8vIFNOIGRvZXMgbm90IG5lZWQgdG8gYmUgYWNjdXJhdGUgYmV0d2VlbiByZW5kaXRpb25zLCBidXQgZGVwZW5kaW5nIG9uIHRoZSBwYWNrYWdpbmcgaXQgbWF5IGJlIHNvLlxuICAgICAgICBjb25zdCB0YXJnZXRTTiA9IGZyYWdQcmV2aW91cy5zbiArIDE7XG4gICAgICAgIGlmICh0YXJnZXRTTiA+PSBsZXZlbERldGFpbHMuc3RhcnRTTiAmJiB0YXJnZXRTTiA8PSBsZXZlbERldGFpbHMuZW5kU04pIHtcbiAgICAgICAgICBjb25zdCBmcmFnTmV4dCA9IGZyYWdtZW50c1t0YXJnZXRTTiAtIGxldmVsRGV0YWlscy5zdGFydFNOXTtcbiAgICAgICAgICAvLyBFbnN1cmUgdGhhdCB3ZSdyZSBzdGF5aW5nIHdpdGhpbiB0aGUgY29udGludWl0eSByYW5nZSwgc2luY2UgUFRTIHJlc2V0cyB1cG9uIGEgbmV3IHJhbmdlXG4gICAgICAgICAgaWYgKGZyYWdQcmV2aW91cy5jYyA9PT0gZnJhZ05leHQuY2MpIHtcbiAgICAgICAgICAgIGZyYWcgPSBmcmFnTmV4dDtcbiAgICAgICAgICAgIHRoaXMubG9nKGBMaXZlIHBsYXlsaXN0LCBzd2l0Y2hpbmcgcGxheWxpc3QsIGxvYWQgZnJhZyB3aXRoIG5leHQgU046ICR7ZnJhZy5zbn1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXQncyBpbXBvcnRhbnQgdG8gc3RheSB3aXRoaW4gdGhlIGNvbnRpbnVpdHkgcmFuZ2UgaWYgYXZhaWxhYmxlOyBvdGhlcndpc2UgdGhlIGZyYWdtZW50cyBpbiB0aGUgcGxheWxpc3RcbiAgICAgICAgLy8gd2lsbCBoYXZlIHRoZSB3cm9uZyBzdGFydCB0aW1lc1xuICAgICAgICBpZiAoIWZyYWcpIHtcbiAgICAgICAgICBmcmFnID0gZmluZEZyYWdXaXRoQ0MoZnJhZ21lbnRzLCBmcmFnUHJldmlvdXMuY2MpO1xuICAgICAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgICAgICB0aGlzLmxvZyhgTGl2ZSBwbGF5bGlzdCwgc3dpdGNoaW5nIHBsYXlsaXN0LCBsb2FkIGZyYWcgd2l0aCBzYW1lIENDOiAke2ZyYWcuc259YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZpbmQgYSBuZXcgc3RhcnQgZnJhZ21lbnQgd2hlbiBmcmFnUHJldmlvdXMgaXMgbnVsbFxuICAgICAgY29uc3QgbGl2ZVN0YXJ0ID0gdGhpcy5obHMubGl2ZVN5bmNQb3NpdGlvbjtcbiAgICAgIGlmIChsaXZlU3RhcnQgIT09IG51bGwpIHtcbiAgICAgICAgZnJhZyA9IHRoaXMuZ2V0RnJhZ21lbnRBdFBvc2l0aW9uKGxpdmVTdGFydCwgdGhpcy5iaXRyYXRlVGVzdCA/IGxldmVsRGV0YWlscy5mcmFnbWVudEVuZCA6IGxldmVsRGV0YWlscy5lZGdlLCBsZXZlbERldGFpbHMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnJhZztcbiAgfVxuXG4gIC8qXG4gIFRoaXMgbWV0aG9kIGZpbmRzIHRoZSBiZXN0IG1hdGNoaW5nIGZyYWdtZW50IGdpdmVuIHRoZSBwcm92aWRlZCBwb3NpdGlvbi5cbiAgICovXG4gIGdldEZyYWdtZW50QXRQb3NpdGlvbihidWZmZXJFbmQsIGVuZCwgbGV2ZWxEZXRhaWxzKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29uZmlnXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHtcbiAgICAgIGZyYWdQcmV2aW91c1xuICAgIH0gPSB0aGlzO1xuICAgIGxldCB7XG4gICAgICBmcmFnbWVudHMsXG4gICAgICBlbmRTTlxuICAgIH0gPSBsZXZlbERldGFpbHM7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZ21lbnRIaW50XG4gICAgfSA9IGxldmVsRGV0YWlscztcbiAgICBjb25zdCB0b2xlcmFuY2UgPSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTtcbiAgICBjb25zdCBwYXJ0TGlzdCA9IGxldmVsRGV0YWlscy5wYXJ0TGlzdDtcbiAgICBjb25zdCBsb2FkaW5nUGFydHMgPSAhIShjb25maWcubG93TGF0ZW5jeU1vZGUgJiYgcGFydExpc3QgIT0gbnVsbCAmJiBwYXJ0TGlzdC5sZW5ndGggJiYgZnJhZ21lbnRIaW50KTtcbiAgICBpZiAobG9hZGluZ1BhcnRzICYmIGZyYWdtZW50SGludCAmJiAhdGhpcy5iaXRyYXRlVGVzdCkge1xuICAgICAgLy8gSW5jbHVkZSBpbmNvbXBsZXRlIGZyYWdtZW50IHdpdGggcGFydHMgYXQgZW5kXG4gICAgICBmcmFnbWVudHMgPSBmcmFnbWVudHMuY29uY2F0KGZyYWdtZW50SGludCk7XG4gICAgICBlbmRTTiA9IGZyYWdtZW50SGludC5zbjtcbiAgICB9XG4gICAgbGV0IGZyYWc7XG4gICAgaWYgKGJ1ZmZlckVuZCA8IGVuZCkge1xuICAgICAgY29uc3QgbG9va3VwVG9sZXJhbmNlID0gYnVmZmVyRW5kID4gZW5kIC0gdG9sZXJhbmNlID8gMCA6IHRvbGVyYW5jZTtcbiAgICAgIC8vIFJlbW92ZSB0aGUgdG9sZXJhbmNlIGlmIGl0IHdvdWxkIHB1dCB0aGUgYnVmZmVyRW5kIHBhc3QgdGhlIGFjdHVhbCBlbmQgb2Ygc3RyZWFtXG4gICAgICAvLyBVc2VzIGJ1ZmZlciBhbmQgc2VxdWVuY2UgbnVtYmVyIHRvIGNhbGN1bGF0ZSBzd2l0Y2ggc2VnbWVudCAocmVxdWlyZWQgaWYgdXNpbmcgRVhULVgtRElTQ09OVElOVUlUWS1TRVFVRU5DRSlcbiAgICAgIGZyYWcgPSBmaW5kRnJhZ21lbnRCeVBUUyhmcmFnUHJldmlvdXMsIGZyYWdtZW50cywgYnVmZmVyRW5kLCBsb29rdXBUb2xlcmFuY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZWFjaCBlbmQgb2YgcGxheWxpc3RcbiAgICAgIGZyYWcgPSBmcmFnbWVudHNbZnJhZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBpZiAoZnJhZykge1xuICAgICAgY29uc3QgY3VyU05JZHggPSBmcmFnLnNuIC0gbGV2ZWxEZXRhaWxzLnN0YXJ0U047XG4gICAgICAvLyBNb3ZlIGZyYWdQcmV2aW91cyBmb3J3YXJkIHRvIHN1cHBvcnQgZm9yY2luZyB0aGUgbmV4dCBmcmFnbWVudCB0byBsb2FkXG4gICAgICAvLyB3aGVuIHRoZSBidWZmZXIgY2F0Y2hlcyB1cCB0byBhIHByZXZpb3VzbHkgYnVmZmVyZWQgcmFuZ2UuXG4gICAgICBjb25zdCBmcmFnU3RhdGUgPSB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnKTtcbiAgICAgIGlmIChmcmFnU3RhdGUgPT09IEZyYWdtZW50U3RhdGUuT0sgfHwgZnJhZ1N0YXRlID09PSBGcmFnbWVudFN0YXRlLlBBUlRJQUwgJiYgZnJhZy5nYXApIHtcbiAgICAgICAgZnJhZ1ByZXZpb3VzID0gZnJhZztcbiAgICAgIH1cbiAgICAgIGlmIChmcmFnUHJldmlvdXMgJiYgZnJhZy5zbiA9PT0gZnJhZ1ByZXZpb3VzLnNuICYmICghbG9hZGluZ1BhcnRzIHx8IHBhcnRMaXN0WzBdLmZyYWdtZW50LnNuID4gZnJhZy5zbikpIHtcbiAgICAgICAgLy8gRm9yY2UgdGhlIG5leHQgZnJhZ21lbnQgdG8gbG9hZCBpZiB0aGUgcHJldmlvdXMgb25lIHdhcyBhbHJlYWR5IHNlbGVjdGVkLiBUaGlzIGNhbiBvY2Nhc2lvbmFsbHkgaGFwcGVuIHdpdGhcbiAgICAgICAgLy8gbm9uLXVuaWZvcm0gZnJhZ21lbnQgZHVyYXRpb25zXG4gICAgICAgIGNvbnN0IHNhbWVMZXZlbCA9IGZyYWdQcmV2aW91cyAmJiBmcmFnLmxldmVsID09PSBmcmFnUHJldmlvdXMubGV2ZWw7XG4gICAgICAgIGlmIChzYW1lTGV2ZWwpIHtcbiAgICAgICAgICBjb25zdCBuZXh0RnJhZyA9IGZyYWdtZW50c1tjdXJTTklkeCArIDFdO1xuICAgICAgICAgIGlmIChmcmFnLnNuIDwgZW5kU04gJiYgdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUobmV4dEZyYWcpICE9PSBGcmFnbWVudFN0YXRlLk9LKSB7XG4gICAgICAgICAgICBmcmFnID0gbmV4dEZyYWc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyYWcgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnJhZztcbiAgfVxuICBzeW5jaHJvbml6ZVRvTGl2ZUVkZ2UobGV2ZWxEZXRhaWxzKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29uZmlnLFxuICAgICAgbWVkaWFcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIW1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxpdmVTeW5jUG9zaXRpb24gPSB0aGlzLmhscy5saXZlU3luY1Bvc2l0aW9uO1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgY29uc3Qgc3RhcnQgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgIGNvbnN0IGVuZCA9IGxldmVsRGV0YWlscy5lZGdlO1xuICAgIGNvbnN0IHdpdGhpblNsaWRpbmdXaW5kb3cgPSBjdXJyZW50VGltZSA+PSBzdGFydCAtIGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlICYmIGN1cnJlbnRUaW1lIDw9IGVuZDtcbiAgICAvLyBDb250aW51ZSBpZiB3ZSBjYW4gc2VlayBmb3J3YXJkIHRvIHN5bmMgcG9zaXRpb24gb3IgaWYgY3VycmVudCB0aW1lIGlzIG91dHNpZGUgb2Ygc2xpZGluZyB3aW5kb3dcbiAgICBpZiAobGl2ZVN5bmNQb3NpdGlvbiAhPT0gbnVsbCAmJiBtZWRpYS5kdXJhdGlvbiA+IGxpdmVTeW5jUG9zaXRpb24gJiYgKGN1cnJlbnRUaW1lIDwgbGl2ZVN5bmNQb3NpdGlvbiB8fCAhd2l0aGluU2xpZGluZ1dpbmRvdykpIHtcbiAgICAgIC8vIENvbnRpbnVlIGlmIGJ1ZmZlciBpcyBzdGFydmluZyBvciBpZiBjdXJyZW50IHRpbWUgaXMgYmVoaW5kIG1heCBsYXRlbmN5XG4gICAgICBjb25zdCBtYXhMYXRlbmN5ID0gY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uIDogY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCAqIGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbjtcbiAgICAgIGlmICghd2l0aGluU2xpZGluZ1dpbmRvdyAmJiBtZWRpYS5yZWFkeVN0YXRlIDwgNCB8fCBjdXJyZW50VGltZSA8IGVuZCAtIG1heExhdGVuY3kpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhKSB7XG4gICAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gbGl2ZVN5bmNQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IHNlZWsgaWYgcmVhZHkgYW5kIHRoZXJlIGlzIG5vdCBhIHNpZ25pZmljYW50IGZvcndhcmQgYnVmZmVyIGF2YWlsYWJsZSBmb3IgcGxheWJhY2tcbiAgICAgICAgaWYgKG1lZGlhLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICB0aGlzLndhcm4oYFBsYXliYWNrOiAke2N1cnJlbnRUaW1lLnRvRml4ZWQoMyl9IGlzIGxvY2F0ZWQgdG9vIGZhciBmcm9tIHRoZSBlbmQgb2YgbGl2ZSBzbGlkaW5nIHBsYXlsaXN0OiAke2VuZH0sIHJlc2V0IGN1cnJlbnRUaW1lIHRvIDogJHtsaXZlU3luY1Bvc2l0aW9uLnRvRml4ZWQoMyl9YCk7XG4gICAgICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSBsaXZlU3luY1Bvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFsaWduUGxheWxpc3RzKGRldGFpbHMsIHByZXZpb3VzRGV0YWlscywgc3dpdGNoRGV0YWlscykge1xuICAgIC8vIEZJWE1FOiBJZiBub3QgZm9yIGBzaG91bGRBbGlnbk9uRGlzY29udGludWl0aWVzYCByZXF1aXJpbmcgZnJhZ1ByZXZpb3VzLmNjLFxuICAgIC8vICB0aGlzIGNvdWxkIGFsbCBnbyBpbiBsZXZlbC1oZWxwZXIgbWVyZ2VEZXRhaWxzKClcbiAgICBjb25zdCBsZW5ndGggPSBkZXRhaWxzLmZyYWdtZW50cy5sZW5ndGg7XG4gICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgIHRoaXMud2FybihgTm8gZnJhZ21lbnRzIGluIGxpdmUgcGxheWxpc3RgKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdCBzbGlkaW5nU3RhcnQgPSBkZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydDtcbiAgICBjb25zdCBmaXJzdExldmVsTG9hZCA9ICFwcmV2aW91c0RldGFpbHM7XG4gICAgY29uc3QgYWxpZ25lZCA9IGRldGFpbHMuYWxpZ25lZFNsaWRpbmcgJiYgaXNGaW5pdGVOdW1iZXIoc2xpZGluZ1N0YXJ0KTtcbiAgICBpZiAoZmlyc3RMZXZlbExvYWQgfHwgIWFsaWduZWQgJiYgIXNsaWRpbmdTdGFydCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBmcmFnUHJldmlvdXNcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgYWxpZ25TdHJlYW0oZnJhZ1ByZXZpb3VzLCBzd2l0Y2hEZXRhaWxzLCBkZXRhaWxzKTtcbiAgICAgIGNvbnN0IGFsaWduZWRTbGlkaW5nU3RhcnQgPSBkZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydDtcbiAgICAgIHRoaXMubG9nKGBMaXZlIHBsYXlsaXN0IHNsaWRpbmc6ICR7YWxpZ25lZFNsaWRpbmdTdGFydC50b0ZpeGVkKDIpfSBzdGFydC1zbjogJHtwcmV2aW91c0RldGFpbHMgPyBwcmV2aW91c0RldGFpbHMuc3RhcnRTTiA6ICduYSd9LT4ke2RldGFpbHMuc3RhcnRTTn0gcHJldi1zbjogJHtmcmFnUHJldmlvdXMgPyBmcmFnUHJldmlvdXMuc24gOiAnbmEnfSBmcmFnbWVudHM6ICR7bGVuZ3RofWApO1xuICAgICAgcmV0dXJuIGFsaWduZWRTbGlkaW5nU3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiBzbGlkaW5nU3RhcnQ7XG4gIH1cbiAgd2FpdEZvckNkblR1bmVJbihkZXRhaWxzKSB7XG4gICAgLy8gV2FpdCBmb3IgTG93LUxhdGVuY3kgQ0ROIFR1bmUtaW4gdG8gZ2V0IGFuIHVwZGF0ZWQgcGxheWxpc3RcbiAgICBjb25zdCBhZHZhbmNlUGFydExpbWl0ID0gMztcbiAgICByZXR1cm4gZGV0YWlscy5saXZlICYmIGRldGFpbHMuY2FuQmxvY2tSZWxvYWQgJiYgZGV0YWlscy5wYXJ0VGFyZ2V0ICYmIGRldGFpbHMudHVuZUluR29hbCA+IE1hdGgubWF4KGRldGFpbHMucGFydEhvbGRCYWNrLCBkZXRhaWxzLnBhcnRUYXJnZXQgKiBhZHZhbmNlUGFydExpbWl0KTtcbiAgfVxuICBzZXRTdGFydFBvc2l0aW9uKGRldGFpbHMsIHNsaWRpbmcpIHtcbiAgICAvLyBjb21wdXRlIHN0YXJ0IHBvc2l0aW9uIGlmIHNldCB0byAtMS4gdXNlIGl0IHN0cmFpZ2h0IGF3YXkgaWYgdmFsdWUgaXMgZGVmaW5lZFxuICAgIGxldCBzdGFydFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uO1xuICAgIGlmIChzdGFydFBvc2l0aW9uIDwgc2xpZGluZykge1xuICAgICAgc3RhcnRQb3NpdGlvbiA9IC0xO1xuICAgIH1cbiAgICBpZiAoc3RhcnRQb3NpdGlvbiA9PT0gLTEgfHwgdGhpcy5sYXN0Q3VycmVudFRpbWUgPT09IC0xKSB7XG4gICAgICAvLyBVc2UgUGxheWxpc3QgRVhULVgtU1RBUlQ6VElNRS1PRkZTRVQgd2hlbiBzZXRcbiAgICAgIC8vIFByaW9yaXRpemUgTXVsdGl2YXJpYW50IFBsYXlsaXN0IG9mZnNldCBzbyB0aGF0IG1haW4sIGF1ZGlvLCBhbmQgc3VidGl0bGUgc3RyZWFtLWNvbnRyb2xsZXIgc3RhcnQgdGltZXMgbWF0Y2hcbiAgICAgIGNvbnN0IG9mZnNldEluTXVsdGl2YXJpYW50UGxheWxpc3QgPSB0aGlzLnN0YXJ0VGltZU9mZnNldCAhPT0gbnVsbDtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZU9mZnNldCA9IG9mZnNldEluTXVsdGl2YXJpYW50UGxheWxpc3QgPyB0aGlzLnN0YXJ0VGltZU9mZnNldCA6IGRldGFpbHMuc3RhcnRUaW1lT2Zmc2V0O1xuICAgICAgaWYgKHN0YXJ0VGltZU9mZnNldCAhPT0gbnVsbCAmJiBpc0Zpbml0ZU51bWJlcihzdGFydFRpbWVPZmZzZXQpKSB7XG4gICAgICAgIHN0YXJ0UG9zaXRpb24gPSBzbGlkaW5nICsgc3RhcnRUaW1lT2Zmc2V0O1xuICAgICAgICBpZiAoc3RhcnRUaW1lT2Zmc2V0IDwgMCkge1xuICAgICAgICAgIHN0YXJ0UG9zaXRpb24gKz0gZGV0YWlscy50b3RhbGR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0UG9zaXRpb24gPSBNYXRoLm1pbihNYXRoLm1heChzbGlkaW5nLCBzdGFydFBvc2l0aW9uKSwgc2xpZGluZyArIGRldGFpbHMudG90YWxkdXJhdGlvbik7XG4gICAgICAgIHRoaXMubG9nKGBTdGFydCB0aW1lIG9mZnNldCAke3N0YXJ0VGltZU9mZnNldH0gZm91bmQgaW4gJHtvZmZzZXRJbk11bHRpdmFyaWFudFBsYXlsaXN0ID8gJ211bHRpdmFyaWFudCcgOiAnbWVkaWEnfSBwbGF5bGlzdCwgYWRqdXN0IHN0YXJ0UG9zaXRpb24gdG8gJHtzdGFydFBvc2l0aW9ufWApO1xuICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBzdGFydFBvc2l0aW9uO1xuICAgICAgfSBlbHNlIGlmIChkZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgLy8gTGVhdmUgdGhpcy5zdGFydFBvc2l0aW9uIGF0IC0xLCBzbyB0aGF0IHdlIGNhbiB1c2UgYGdldEluaXRpYWxMaXZlRnJhZ21lbnRgIGxvZ2ljIHdoZW4gc3RhcnRQb3NpdGlvbiBoYXNcbiAgICAgICAgLy8gbm90IGJlZW4gc3BlY2lmaWVkIHZpYSB0aGUgY29uZmlnIG9yIGFuIGFzIGFuIGFyZ3VtZW50IHRvIHN0YXJ0TG9hZCAoIzM3MzYpLlxuICAgICAgICBzdGFydFBvc2l0aW9uID0gdGhpcy5obHMubGl2ZVN5bmNQb3NpdGlvbiB8fCBzbGlkaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbiA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHN0YXJ0UG9zaXRpb247XG4gICAgfVxuICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb247XG4gIH1cbiAgZ2V0TG9hZFBvc2l0aW9uKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lZGlhXG4gICAgfSA9IHRoaXM7XG4gICAgLy8gaWYgd2UgaGF2ZSBub3QgeWV0IGxvYWRlZCBhbnkgZnJhZ21lbnQsIHN0YXJ0IGxvYWRpbmcgZnJvbSBzdGFydCBwb3NpdGlvblxuICAgIGxldCBwb3MgPSAwO1xuICAgIGlmICh0aGlzLmxvYWRlZG1ldGFkYXRhICYmIG1lZGlhKSB7XG4gICAgICBwb3MgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubmV4dExvYWRQb3NpdGlvbikge1xuICAgICAgcG9zID0gdGhpcy5uZXh0TG9hZFBvc2l0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gcG9zO1xuICB9XG4gIGhhbmRsZUZyYWdMb2FkQWJvcnRlZChmcmFnLCBwYXJ0KSB7XG4gICAgaWYgKHRoaXMudHJhbnNtdXhlciAmJiBmcmFnLnNuICE9PSAnaW5pdFNlZ21lbnQnICYmIGZyYWcuc3RhdHMuYWJvcnRlZCkge1xuICAgICAgdGhpcy53YXJuKGBGcmFnbWVudCAke2ZyYWcuc259JHtwYXJ0ID8gJyBwYXJ0ICcgKyBwYXJ0LmluZGV4IDogJyd9IG9mIGxldmVsICR7ZnJhZy5sZXZlbH0gd2FzIGFib3J0ZWRgKTtcbiAgICAgIHRoaXMucmVzZXRGcmFnbWVudExvYWRpbmcoZnJhZyk7XG4gICAgfVxuICB9XG4gIHJlc2V0RnJhZ21lbnRMb2FkaW5nKGZyYWcpIHtcbiAgICBpZiAoIXRoaXMuZnJhZ0N1cnJlbnQgfHwgIXRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpICYmIHRoaXMuc3RhdGUgIT09IFN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICB9XG4gIH1cbiAgb25GcmFnbWVudE9yS2V5TG9hZEVycm9yKGZpbHRlclR5cGUsIGRhdGEpIHtcbiAgICBpZiAoZGF0YS5jaHVua01ldGEgJiYgIWRhdGEuZnJhZykge1xuICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ2V0Q3VycmVudENvbnRleHQoZGF0YS5jaHVua01ldGEpO1xuICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgZGF0YS5mcmFnID0gY29udGV4dC5mcmFnO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmcmFnID0gZGF0YS5mcmFnO1xuICAgIC8vIEhhbmRsZSBmcmFnIGVycm9yIHJlbGF0ZWQgdG8gY2FsbGVyJ3MgZmlsdGVyVHlwZVxuICAgIGlmICghZnJhZyB8fCBmcmFnLnR5cGUgIT09IGZpbHRlclR5cGUgfHwgIXRoaXMubGV2ZWxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgdmFyIF90aGlzJGZyYWdDdXJyZW50MjtcbiAgICAgIHRoaXMud2FybihgRnJhZyBsb2FkIGVycm9yIG11c3QgbWF0Y2ggY3VycmVudCBmcmFnIHRvIHJldHJ5ICR7ZnJhZy51cmx9ID4gJHsoX3RoaXMkZnJhZ0N1cnJlbnQyID0gdGhpcy5mcmFnQ3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGZyYWdDdXJyZW50Mi51cmx9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGdhcFRhZ0VuY291bnRlcmVkID0gZGF0YS5kZXRhaWxzID09PSBFcnJvckRldGFpbHMuRlJBR19HQVA7XG4gICAgaWYgKGdhcFRhZ0VuY291bnRlcmVkKSB7XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5mcmFnQnVmZmVyZWQoZnJhZywgdHJ1ZSk7XG4gICAgfVxuICAgIC8vIGtlZXAgcmV0cnlpbmcgdW50aWwgdGhlIGxpbWl0IHdpbGwgYmUgcmVhY2hlZFxuICAgIGNvbnN0IGVycm9yQWN0aW9uID0gZGF0YS5lcnJvckFjdGlvbjtcbiAgICBjb25zdCB7XG4gICAgICBhY3Rpb24sXG4gICAgICByZXRyeUNvdW50ID0gMCxcbiAgICAgIHJldHJ5Q29uZmlnXG4gICAgfSA9IGVycm9yQWN0aW9uIHx8IHt9O1xuICAgIGlmIChlcnJvckFjdGlvbiAmJiBhY3Rpb24gPT09IE5ldHdvcmtFcnJvckFjdGlvbi5SZXRyeVJlcXVlc3QgJiYgcmV0cnlDb25maWcpIHtcbiAgICAgIHRoaXMucmVzZXRTdGFydFdoZW5Ob3RMb2FkZWQodGhpcy5sZXZlbExhc3RMb2FkZWQpO1xuICAgICAgY29uc3QgZGVsYXkgPSBnZXRSZXRyeURlbGF5KHJldHJ5Q29uZmlnLCByZXRyeUNvdW50KTtcbiAgICAgIHRoaXMud2FybihgRnJhZ21lbnQgJHtmcmFnLnNufSBvZiAke2ZpbHRlclR5cGV9ICR7ZnJhZy5sZXZlbH0gZXJyb3JlZCB3aXRoICR7ZGF0YS5kZXRhaWxzfSwgcmV0cnlpbmcgbG9hZGluZyAke3JldHJ5Q291bnQgKyAxfS8ke3JldHJ5Q29uZmlnLm1heE51bVJldHJ5fSBpbiAke2RlbGF5fW1zYCk7XG4gICAgICBlcnJvckFjdGlvbi5yZXNvbHZlZCA9IHRydWU7XG4gICAgICB0aGlzLnJldHJ5RGF0ZSA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCkgKyBkZWxheTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTtcbiAgICB9IGVsc2UgaWYgKHJldHJ5Q29uZmlnICYmIGVycm9yQWN0aW9uKSB7XG4gICAgICB0aGlzLnJlc2V0RnJhZ21lbnRFcnJvcnMoZmlsdGVyVHlwZSk7XG4gICAgICBpZiAocmV0cnlDb3VudCA8IHJldHJ5Q29uZmlnLm1heE51bVJldHJ5KSB7XG4gICAgICAgIC8vIE5ldHdvcmsgcmV0cnkgaXMgc2tpcHBlZCB3aGVuIGxldmVsIHN3aXRjaCBpcyBwcmVmZXJyZWRcbiAgICAgICAgaWYgKCFnYXBUYWdFbmNvdW50ZXJlZCAmJiBhY3Rpb24gIT09IE5ldHdvcmtFcnJvckFjdGlvbi5SZW1vdmVBbHRlcm5hdGVQZXJtYW5lbnRseSkge1xuICAgICAgICAgIGVycm9yQWN0aW9uLnJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oYCR7ZGF0YS5kZXRhaWxzfSByZWFjaGVkIG9yIGV4Y2VlZGVkIG1heCByZXRyeSAoJHtyZXRyeUNvdW50fSlgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKGVycm9yQWN0aW9uID09IG51bGwgPyB2b2lkIDAgOiBlcnJvckFjdGlvbi5hY3Rpb24pID09PSBOZXR3b3JrRXJyb3JBY3Rpb24uU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveCkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLldBSVRJTkdfTEVWRUw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FUlJPUjtcbiAgICB9XG4gICAgLy8gUGVyZm9ybSBuZXh0IGFzeW5jIHRpY2sgc29vbmVyIHRvIHNwZWVkIHVwIGVycm9yIGFjdGlvbiByZXNvbHV0aW9uXG4gICAgdGhpcy50aWNrSW1tZWRpYXRlKCk7XG4gIH1cbiAgcmVkdWNlTGVuZ3RoQW5kRmx1c2hCdWZmZXIoZGF0YSkge1xuICAgIC8vIGlmIGluIGFwcGVuZGluZyBzdGF0ZVxuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HIHx8IHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNFRCkge1xuICAgICAgY29uc3QgcGxheWxpc3RUeXBlID0gZGF0YS5wYXJlbnQ7XG4gICAgICBjb25zdCBidWZmZXJlZEluZm8gPSB0aGlzLmdldEZ3ZEJ1ZmZlckluZm8odGhpcy5tZWRpYUJ1ZmZlciwgcGxheWxpc3RUeXBlKTtcbiAgICAgIC8vIDAuNSA6IHRvbGVyYW5jZSBuZWVkZWQgYXMgc29tZSBicm93c2VycyBzdGFsbHMgcGxheWJhY2sgYmVmb3JlIHJlYWNoaW5nIGJ1ZmZlcmVkIGVuZFxuICAgICAgLy8gcmVkdWNlIG1heCBidWYgbGVuIGlmIGN1cnJlbnQgcG9zaXRpb24gaXMgYnVmZmVyZWRcbiAgICAgIGNvbnN0IGJ1ZmZlcmVkID0gYnVmZmVyZWRJbmZvICYmIGJ1ZmZlcmVkSW5mby5sZW4gPiAwLjU7XG4gICAgICBpZiAoYnVmZmVyZWQpIHtcbiAgICAgICAgdGhpcy5yZWR1Y2VNYXhCdWZmZXJMZW5ndGgoYnVmZmVyZWRJbmZvLmxlbik7XG4gICAgICB9XG4gICAgICBjb25zdCBmbHVzaEJ1ZmZlciA9ICFidWZmZXJlZDtcbiAgICAgIGlmIChmbHVzaEJ1ZmZlcikge1xuICAgICAgICAvLyBjdXJyZW50IHBvc2l0aW9uIGlzIG5vdCBidWZmZXJlZCwgYnV0IGJyb3dzZXIgaXMgc3RpbGwgY29tcGxhaW5pbmcgYWJvdXQgYnVmZmVyIGZ1bGwgZXJyb3JcbiAgICAgICAgLy8gdGhpcyBoYXBwZW5zIG9uIElFL0VkZ2UsIHJlZmVyIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL3B1bGwvNzA4XG4gICAgICAgIC8vIGluIHRoYXQgY2FzZSBmbHVzaCB0aGUgd2hvbGUgYXVkaW8gYnVmZmVyIHRvIHJlY292ZXJcbiAgICAgICAgdGhpcy53YXJuKGBCdWZmZXIgZnVsbCBlcnJvciB3aGlsZSBtZWRpYS5jdXJyZW50VGltZSBpcyBub3QgYnVmZmVyZWQsIGZsdXNoICR7cGxheWxpc3RUeXBlfSBidWZmZXJgKTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLmZyYWcpIHtcbiAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZGF0YS5mcmFnKTtcbiAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gZGF0YS5mcmFnLnN0YXJ0O1xuICAgICAgfVxuICAgICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICAgICAgcmV0dXJuIGZsdXNoQnVmZmVyO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmVzZXRGcmFnbWVudEVycm9ycyhmaWx0ZXJUeXBlKSB7XG4gICAgaWYgKGZpbHRlclR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLkFVRElPKSB7XG4gICAgICAvLyBSZXNldCBjdXJyZW50IGZyYWdtZW50IHNpbmNlIGF1ZGlvIHRyYWNrIGF1ZGlvIGlzIGVzc2VudGlhbCBhbmQgbWF5IG5vdCBoYXZlIGEgZmFpbC1vdmVyIHRyYWNrXG4gICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gICAgLy8gRnJhZ21lbnQgZXJyb3JzIHRoYXQgcmVzdWx0IGluIGEgbGV2ZWwgc3dpdGNoIG9yIHJlZHVuZGFudCBmYWlsLW92ZXJcbiAgICAvLyBzaG91bGQgcmVzZXQgdGhlIHN0cmVhbSBjb250cm9sbGVyIHN0YXRlIHRvIGlkbGVcbiAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlICE9PSBTdGF0ZS5TVE9QUEVEKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICB9XG4gIH1cbiAgYWZ0ZXJCdWZmZXJGbHVzaGVkKG1lZGlhLCBidWZmZXJUeXBlLCBwbGF5bGlzdFR5cGUpIHtcbiAgICBpZiAoIW1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIEFmdGVyIHN1Y2Nlc3NmdWwgYnVmZmVyIGZsdXNoaW5nLCBmaWx0ZXIgZmx1c2hlZCBmcmFnbWVudHMgZnJvbSBidWZmZXJlZEZyYWdzIHVzZSBtZWRpYUJ1ZmZlcmVkIGluc3RlYWQgb2YgbWVkaWFcbiAgICAvLyAoc28gdGhhdCB3ZSB3aWxsIGNoZWNrIGFnYWluc3QgdmlkZW8uYnVmZmVyZWQgcmFuZ2VzIGluIGNhc2Ugb2YgYWx0IGF1ZGlvIHRyYWNrKVxuICAgIGNvbnN0IGJ1ZmZlcmVkVGltZVJhbmdlcyA9IEJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZChtZWRpYSk7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIuZGV0ZWN0RXZpY3RlZEZyYWdtZW50cyhidWZmZXJUeXBlLCBidWZmZXJlZFRpbWVSYW5nZXMsIHBsYXlsaXN0VHlwZSk7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkVOREVEKSB7XG4gICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgfVxuICB9XG4gIHJlc2V0TG9hZGluZ1N0YXRlKCkge1xuICAgIHRoaXMubG9nKCdSZXNldCBsb2FkaW5nIHN0YXRlJyk7XG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICB9XG4gIHJlc2V0U3RhcnRXaGVuTm90TG9hZGVkKGxldmVsKSB7XG4gICAgLy8gaWYgbG9hZGVkbWV0YWRhdGEgaXMgbm90IHNldCwgaXQgbWVhbnMgdGhhdCBmaXJzdCBmcmFnIHJlcXVlc3QgZmFpbGVkXG4gICAgLy8gaW4gdGhhdCBjYXNlLCByZXNldCBzdGFydEZyYWdSZXF1ZXN0ZWQgZmxhZ1xuICAgIGlmICghdGhpcy5sb2FkZWRtZXRhZGF0YSkge1xuICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGRldGFpbHMgPSBsZXZlbCA/IGxldmVsLmRldGFpbHMgOiBudWxsO1xuICAgICAgaWYgKGRldGFpbHMgIT0gbnVsbCAmJiBkZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBzdGFydCBwb3NpdGlvbiBhbmQgcmV0dXJuIHRvIElETEUgdG8gcmVjb3ZlciBsaXZlIHN0YXJ0XG4gICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IC0xO1xuICAgICAgICB0aGlzLnNldFN0YXJ0UG9zaXRpb24oZGV0YWlscywgMCk7XG4gICAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVzZXRXaGVuTWlzc2luZ0NvbnRleHQoY2h1bmtNZXRhKSB7XG4gICAgdGhpcy53YXJuKGBUaGUgbG9hZGluZyBjb250ZXh0IGNoYW5nZWQgd2hpbGUgYnVmZmVyaW5nIGZyYWdtZW50ICR7Y2h1bmtNZXRhLnNufSBvZiBsZXZlbCAke2NodW5rTWV0YS5sZXZlbH0uIFRoaXMgY2h1bmsgd2lsbCBub3QgYmUgYnVmZmVyZWQuYCk7XG4gICAgdGhpcy5yZW1vdmVVbmJ1ZmZlcmVkRnJhZ3MoKTtcbiAgICB0aGlzLnJlc2V0U3RhcnRXaGVuTm90TG9hZGVkKHRoaXMubGV2ZWxMYXN0TG9hZGVkKTtcbiAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gIH1cbiAgcmVtb3ZlVW5idWZmZXJlZEZyYWdzKHN0YXJ0ID0gMCkge1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50c0luUmFuZ2Uoc3RhcnQsIEluZmluaXR5LCB0aGlzLnBsYXlsaXN0VHlwZSwgZmFsc2UsIHRydWUpO1xuICB9XG4gIHVwZGF0ZUxldmVsVGltaW5nKGZyYWcsIHBhcnQsIGxldmVsLCBwYXJ0aWFsKSB7XG4gICAgdmFyIF90aGlzJHRyYW5zbXV4ZXI7XG4gICAgY29uc3QgZGV0YWlscyA9IGxldmVsLmRldGFpbHM7XG4gICAgaWYgKCFkZXRhaWxzKSB7XG4gICAgICB0aGlzLndhcm4oJ2xldmVsLmRldGFpbHMgdW5kZWZpbmVkJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZCA9IE9iamVjdC5rZXlzKGZyYWcuZWxlbWVudGFyeVN0cmVhbXMpLnJlZHVjZSgocmVzdWx0LCB0eXBlKSA9PiB7XG4gICAgICBjb25zdCBpbmZvID0gZnJhZy5lbGVtZW50YXJ5U3RyZWFtc1t0eXBlXTtcbiAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZER1cmF0aW9uID0gaW5mby5lbmRQVFMgLSBpbmZvLnN0YXJ0UFRTO1xuICAgICAgICBpZiAocGFyc2VkRHVyYXRpb24gPD0gMCkge1xuICAgICAgICAgIC8vIERlc3Ryb3kgdGhlIHRyYW5zbXV4ZXIgYWZ0ZXIgaXQncyBuZXh0IHRpbWUgb2Zmc2V0IGZhaWxlZCB0byBhZHZhbmNlIGJlY2F1c2UgZHVyYXRpb24gd2FzIDw9IDAuXG4gICAgICAgICAgLy8gVGhlIG5ldyB0cmFuc211eGVyIHdpbGwgYmUgY29uZmlndXJlZCB3aXRoIGEgdGltZSBvZmZzZXQgbWF0Y2hpbmcgdGhlIG5leHQgZnJhZ21lbnQgc3RhcnQsXG4gICAgICAgICAgLy8gcHJldmVudGluZyB0aGUgdGltZWxpbmUgZnJvbSBzaGlmdGluZy5cbiAgICAgICAgICB0aGlzLndhcm4oYENvdWxkIG5vdCBwYXJzZSBmcmFnbWVudCAke2ZyYWcuc259ICR7dHlwZX0gZHVyYXRpb24gcmVsaWFibHkgKCR7cGFyc2VkRHVyYXRpb259KWApO1xuICAgICAgICAgIHJldHVybiByZXN1bHQgfHwgZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZHJpZnQgPSBwYXJ0aWFsID8gMCA6IHVwZGF0ZUZyYWdQVFNEVFMoZGV0YWlscywgZnJhZywgaW5mby5zdGFydFBUUywgaW5mby5lbmRQVFMsIGluZm8uc3RhcnREVFMsIGluZm8uZW5kRFRTKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTEVWRUxfUFRTX1VQREFURUQsIHtcbiAgICAgICAgICBkZXRhaWxzLFxuICAgICAgICAgIGxldmVsLFxuICAgICAgICAgIGRyaWZ0LFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgZnJhZyxcbiAgICAgICAgICBzdGFydDogaW5mby5zdGFydFBUUyxcbiAgICAgICAgICBlbmQ6IGluZm8uZW5kUFRTXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgZmFsc2UpO1xuICAgIGlmICghcGFyc2VkICYmICgoX3RoaXMkdHJhbnNtdXhlciA9IHRoaXMudHJhbnNtdXhlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHRyYW5zbXV4ZXIuZXJyb3IpID09PSBudWxsKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgRm91bmQgbm8gbWVkaWEgaW4gZnJhZ21lbnQgJHtmcmFnLnNufSBvZiBsZXZlbCAke2ZyYWcubGV2ZWx9IHJlc2V0dGluZyB0cmFuc211eGVyIHRvIGZhbGxiYWNrIHRvIHBsYXlsaXN0IHRpbWluZ2ApO1xuICAgICAgaWYgKGxldmVsLmZyYWdtZW50RXJyb3IgPT09IDApIHtcbiAgICAgICAgLy8gTWFyayBhbmQgdHJhY2sgdGhlIG9kZCBlbXB0eSBzZWdtZW50IGFzIGEgZ2FwIHRvIGF2b2lkIHJlbG9hZGluZ1xuICAgICAgICBsZXZlbC5mcmFnbWVudEVycm9yKys7XG4gICAgICAgIGZyYWcuZ2FwID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLmZyYWdCdWZmZXJlZChmcmFnLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMud2FybihlcnJvci5tZXNzYWdlKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsXG4gICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGZyYWcsXG4gICAgICAgIHJlYXNvbjogYEZvdW5kIG5vIG1lZGlhIGluIG1zbiAke2ZyYWcuc259IG9mIGxldmVsIFwiJHtsZXZlbC51cmx9XCJgXG4gICAgICB9KTtcbiAgICAgIGlmICghdGhpcy5obHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXNldFRyYW5zbXV4ZXIoKTtcbiAgICAgIC8vIEZvciB0aGlzIGVycm9yIGZhbGx0aHJvdWdoLiBNYXJraW5nIHBhcnNlZCB3aWxsIGFsbG93IGFkdmFuY2luZyB0byBuZXh0IGZyYWdtZW50LlxuICAgIH1cbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFSU0VEO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfUEFSU0VELCB7XG4gICAgICBmcmFnLFxuICAgICAgcGFydFxuICAgIH0pO1xuICB9XG4gIHJlc2V0VHJhbnNtdXhlcigpIHtcbiAgICBpZiAodGhpcy50cmFuc211eGVyKSB7XG4gICAgICB0aGlzLnRyYW5zbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy50cmFuc211eGVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgcmVjb3ZlcldvcmtlckVycm9yKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5ldmVudCA9PT0gJ2RlbXV4ZXJXb3JrZXInKSB7XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVBbGxGcmFnbWVudHMoKTtcbiAgICAgIHRoaXMucmVzZXRUcmFuc211eGVyKCk7XG4gICAgICB0aGlzLnJlc2V0U3RhcnRXaGVuTm90TG9hZGVkKHRoaXMubGV2ZWxMYXN0TG9hZGVkKTtcbiAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICB9XG4gIH1cbiAgc2V0IHN0YXRlKG5leHRTdGF0ZSkge1xuICAgIGNvbnN0IHByZXZpb3VzU3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICBpZiAocHJldmlvdXNTdGF0ZSAhPT0gbmV4dFN0YXRlKSB7XG4gICAgICB0aGlzLl9zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgIHRoaXMubG9nKGAke3ByZXZpb3VzU3RhdGV9LT4ke25leHRTdGF0ZX1gKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgfVxufVxuXG5jbGFzcyBDaHVua0NhY2hlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jaHVua3MgPSBbXTtcbiAgICB0aGlzLmRhdGFMZW5ndGggPSAwO1xuICB9XG4gIHB1c2goY2h1bmspIHtcbiAgICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbiAgICB0aGlzLmRhdGFMZW5ndGggKz0gY2h1bmsubGVuZ3RoO1xuICB9XG4gIGZsdXNoKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNodW5rcyxcbiAgICAgIGRhdGFMZW5ndGhcbiAgICB9ID0gdGhpcztcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmICghY2h1bmtzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICAgIH0gZWxzZSBpZiAoY2h1bmtzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmVzdWx0ID0gY2h1bmtzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBjb25jYXRVaW50OEFycmF5cyhjaHVua3MsIGRhdGFMZW5ndGgpO1xuICAgIH1cbiAgICB0aGlzLnJlc2V0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLmNodW5rcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuZGF0YUxlbmd0aCA9IDA7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbmNhdFVpbnQ4QXJyYXlzKGNodW5rcywgZGF0YUxlbmd0aCkge1xuICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShkYXRhTGVuZ3RoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2h1bmsgPSBjaHVua3NbaV07XG4gICAgcmVzdWx0LnNldChjaHVuaywgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gY2h1bmsubGVuZ3RoO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIGVuc3VyZSB0aGUgd29ya2VyIGVuZHMgdXAgaW4gdGhlIGJ1bmRsZVxuLy8gSWYgdGhlIHdvcmtlciBzaG91bGQgbm90IGJlIGluY2x1ZGVkIHRoaXMgZ2V0cyBhbGlhc2VkIHRvIGVtcHR5LmpzXG5mdW5jdGlvbiBoYXNVTURXb3JrZXIoKSB7XG4gIHJldHVybiB0eXBlb2YgX19ITFNfV09SS0VSX0JVTkRMRV9fID09PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gaW5qZWN0V29ya2VyKCkge1xuICBjb25zdCBibG9iID0gbmV3IHNlbGYuQmxvYihbYHZhciBleHBvcnRzPXt9O3ZhciBtb2R1bGU9e2V4cG9ydHM6ZXhwb3J0c307ZnVuY3Rpb24gZGVmaW5lKGYpe2YoKX07ZGVmaW5lLmFtZD10cnVlOygke19fSExTX1dPUktFUl9CVU5ETEVfXy50b1N0cmluZygpfSkodHJ1ZSk7YF0sIHtcbiAgICB0eXBlOiAndGV4dC9qYXZhc2NyaXB0J1xuICB9KTtcbiAgY29uc3Qgb2JqZWN0VVJMID0gc2VsZi5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICBjb25zdCB3b3JrZXIgPSBuZXcgc2VsZi5Xb3JrZXIob2JqZWN0VVJMKTtcbiAgcmV0dXJuIHtcbiAgICB3b3JrZXIsXG4gICAgb2JqZWN0VVJMXG4gIH07XG59XG5mdW5jdGlvbiBsb2FkV29ya2VyKHBhdGgpIHtcbiAgY29uc3Qgc2NyaXB0VVJMID0gbmV3IHNlbGYuVVJMKHBhdGgsIHNlbGYubG9jYXRpb24uaHJlZikuaHJlZjtcbiAgY29uc3Qgd29ya2VyID0gbmV3IHNlbGYuV29ya2VyKHNjcmlwdFVSTCk7XG4gIHJldHVybiB7XG4gICAgd29ya2VyLFxuICAgIHNjcmlwdFVSTFxuICB9O1xufVxuXG5mdW5jdGlvbiBkdW1teVRyYWNrKHR5cGUgPSAnJywgaW5wdXRUaW1lU2NhbGUgPSA5MDAwMCkge1xuICByZXR1cm4ge1xuICAgIHR5cGUsXG4gICAgaWQ6IC0xLFxuICAgIHBpZDogLTEsXG4gICAgaW5wdXRUaW1lU2NhbGUsXG4gICAgc2VxdWVuY2VOdW1iZXI6IC0xLFxuICAgIHNhbXBsZXM6IFtdLFxuICAgIGRyb3BwZWQ6IDBcbiAgfTtcbn1cblxuY2xhc3MgQmFzZUF1ZGlvRGVtdXhlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5faWQzVHJhY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5mcmFtZUluZGV4ID0gMDtcbiAgICB0aGlzLmNhY2hlZERhdGEgPSBudWxsO1xuICAgIHRoaXMuYmFzZVBUUyA9IG51bGw7XG4gICAgdGhpcy5pbml0UFRTID0gbnVsbDtcbiAgICB0aGlzLmxhc3RQVFMgPSBudWxsO1xuICB9XG4gIHJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRyYWNrRHVyYXRpb24pIHtcbiAgICB0aGlzLl9pZDNUcmFjayA9IHtcbiAgICAgIHR5cGU6ICdpZDMnLFxuICAgICAgaWQ6IDMsXG4gICAgICBwaWQ6IC0xLFxuICAgICAgaW5wdXRUaW1lU2NhbGU6IDkwMDAwLFxuICAgICAgc2VxdWVuY2VOdW1iZXI6IDAsXG4gICAgICBzYW1wbGVzOiBbXSxcbiAgICAgIGRyb3BwZWQ6IDBcbiAgICB9O1xuICB9XG4gIHJlc2V0VGltZVN0YW1wKGRlYXVsdFRpbWVzdGFtcCkge1xuICAgIHRoaXMuaW5pdFBUUyA9IGRlYXVsdFRpbWVzdGFtcDtcbiAgICB0aGlzLnJlc2V0Q29udGlndWl0eSgpO1xuICB9XG4gIHJlc2V0Q29udGlndWl0eSgpIHtcbiAgICB0aGlzLmJhc2VQVFMgPSBudWxsO1xuICAgIHRoaXMubGFzdFBUUyA9IG51bGw7XG4gICAgdGhpcy5mcmFtZUluZGV4ID0gMDtcbiAgfVxuICBjYW5QYXJzZShkYXRhLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCkge31cblxuICAvLyBmZWVkIGluY29taW5nIGRhdGEgdG8gdGhlIGZyb250IG9mIHRoZSBwYXJzaW5nIHBpcGVsaW5lXG4gIGRlbXV4KGRhdGEsIHRpbWVPZmZzZXQpIHtcbiAgICBpZiAodGhpcy5jYWNoZWREYXRhKSB7XG4gICAgICBkYXRhID0gYXBwZW5kVWludDhBcnJheSh0aGlzLmNhY2hlZERhdGEsIGRhdGEpO1xuICAgICAgdGhpcy5jYWNoZWREYXRhID0gbnVsbDtcbiAgICB9XG4gICAgbGV0IGlkM0RhdGEgPSBnZXRJRDNEYXRhKGRhdGEsIDApO1xuICAgIGxldCBvZmZzZXQgPSBpZDNEYXRhID8gaWQzRGF0YS5sZW5ndGggOiAwO1xuICAgIGxldCBsYXN0RGF0YUluZGV4O1xuICAgIGNvbnN0IHRyYWNrID0gdGhpcy5fYXVkaW9UcmFjaztcbiAgICBjb25zdCBpZDNUcmFjayA9IHRoaXMuX2lkM1RyYWNrO1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IGlkM0RhdGEgPyBnZXRUaW1lU3RhbXAoaWQzRGF0YSkgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgaWYgKHRoaXMuYmFzZVBUUyA9PT0gbnVsbCB8fCB0aGlzLmZyYW1lSW5kZXggPT09IDAgJiYgaXNGaW5pdGVOdW1iZXIodGltZXN0YW1wKSkge1xuICAgICAgdGhpcy5iYXNlUFRTID0gaW5pdFBUU0ZuKHRpbWVzdGFtcCwgdGltZU9mZnNldCwgdGhpcy5pbml0UFRTKTtcbiAgICAgIHRoaXMubGFzdFBUUyA9IHRoaXMuYmFzZVBUUztcbiAgICB9XG4gICAgaWYgKHRoaXMubGFzdFBUUyA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5sYXN0UFRTID0gdGhpcy5iYXNlUFRTO1xuICAgIH1cblxuICAgIC8vIG1vcmUgZXhwcmVzc2l2ZSB0aGFuIGFsdGVybmF0aXZlOiBpZDNEYXRhPy5sZW5ndGhcbiAgICBpZiAoaWQzRGF0YSAmJiBpZDNEYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgIGlkM1RyYWNrLnNhbXBsZXMucHVzaCh7XG4gICAgICAgIHB0czogdGhpcy5sYXN0UFRTLFxuICAgICAgICBkdHM6IHRoaXMubGFzdFBUUyxcbiAgICAgICAgZGF0YTogaWQzRGF0YSxcbiAgICAgICAgdHlwZTogTWV0YWRhdGFTY2hlbWEuYXVkaW9JZDMsXG4gICAgICAgIGR1cmF0aW9uOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlcbiAgICAgIH0pO1xuICAgIH1cbiAgICB3aGlsZSAob2Zmc2V0IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5jYW5QYXJzZShkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgIGNvbnN0IGZyYW1lID0gdGhpcy5hcHBlbmRGcmFtZSh0cmFjaywgZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgICAgdGhpcy5mcmFtZUluZGV4Kys7XG4gICAgICAgICAgdGhpcy5sYXN0UFRTID0gZnJhbWUuc2FtcGxlLnB0cztcbiAgICAgICAgICBvZmZzZXQgKz0gZnJhbWUubGVuZ3RoO1xuICAgICAgICAgIGxhc3REYXRhSW5kZXggPSBvZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Zmc2V0ID0gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNhblBhcnNlJDIoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICAvLyBhZnRlciBhIElEMy5jYW5QYXJzZSwgYSBjYWxsIHRvIElEMy5nZXRJRDNEYXRhICpzaG91bGQqIGFsd2F5cyByZXR1cm5zIHNvbWUgZGF0YVxuICAgICAgICBpZDNEYXRhID0gZ2V0SUQzRGF0YShkYXRhLCBvZmZzZXQpO1xuICAgICAgICBpZDNUcmFjay5zYW1wbGVzLnB1c2goe1xuICAgICAgICAgIHB0czogdGhpcy5sYXN0UFRTLFxuICAgICAgICAgIGR0czogdGhpcy5sYXN0UFRTLFxuICAgICAgICAgIGRhdGE6IGlkM0RhdGEsXG4gICAgICAgICAgdHlwZTogTWV0YWRhdGFTY2hlbWEuYXVkaW9JZDMsXG4gICAgICAgICAgZHVyYXRpb246IE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxuICAgICAgICB9KTtcbiAgICAgICAgb2Zmc2V0ICs9IGlkM0RhdGEubGVuZ3RoO1xuICAgICAgICBsYXN0RGF0YUluZGV4ID0gb2Zmc2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICB9XG4gICAgICBpZiAob2Zmc2V0ID09PSBsZW5ndGggJiYgbGFzdERhdGFJbmRleCAhPT0gbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHBhcnRpYWxEYXRhID0gc2xpY2VVaW50OChkYXRhLCBsYXN0RGF0YUluZGV4KTtcbiAgICAgICAgaWYgKHRoaXMuY2FjaGVkRGF0YSkge1xuICAgICAgICAgIHRoaXMuY2FjaGVkRGF0YSA9IGFwcGVuZFVpbnQ4QXJyYXkodGhpcy5jYWNoZWREYXRhLCBwYXJ0aWFsRGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jYWNoZWREYXRhID0gcGFydGlhbERhdGE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGF1ZGlvVHJhY2s6IHRyYWNrLFxuICAgICAgdmlkZW9UcmFjazogZHVtbXlUcmFjaygpLFxuICAgICAgaWQzVHJhY2ssXG4gICAgICB0ZXh0VHJhY2s6IGR1bW15VHJhY2soKVxuICAgIH07XG4gIH1cbiAgZGVtdXhTYW1wbGVBZXMoZGF0YSwga2V5RGF0YSwgdGltZU9mZnNldCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYFske3RoaXN9XSBUaGlzIGRlbXV4ZXIgZG9lcyBub3Qgc3VwcG9ydCBTYW1wbGUtQUVTIGRlY3J5cHRpb25gKSk7XG4gIH1cbiAgZmx1c2godGltZU9mZnNldCkge1xuICAgIC8vIFBhcnNlIGNhY2hlIGluIGNhc2Ugb2YgcmVtYWluaW5nIGZyYW1lcy5cbiAgICBjb25zdCBjYWNoZWREYXRhID0gdGhpcy5jYWNoZWREYXRhO1xuICAgIGlmIChjYWNoZWREYXRhKSB7XG4gICAgICB0aGlzLmNhY2hlZERhdGEgPSBudWxsO1xuICAgICAgdGhpcy5kZW11eChjYWNoZWREYXRhLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGF1ZGlvVHJhY2s6IHRoaXMuX2F1ZGlvVHJhY2ssXG4gICAgICB2aWRlb1RyYWNrOiBkdW1teVRyYWNrKCksXG4gICAgICBpZDNUcmFjazogdGhpcy5faWQzVHJhY2ssXG4gICAgICB0ZXh0VHJhY2s6IGR1bW15VHJhY2soKVxuICAgIH07XG4gIH1cbiAgZGVzdHJveSgpIHt9XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBQVFNcbiAqIDxwPlxuICogICAgdXNlIHRpbWVzdGFtcCB1bmxlc3MgaXQgaXMgdW5kZWZpbmVkLCBOYU4gb3IgSW5maW5pdHlcbiAqIDwvcD5cbiAqL1xuY29uc3QgaW5pdFBUU0ZuID0gKHRpbWVzdGFtcCwgdGltZU9mZnNldCwgaW5pdFBUUykgPT4ge1xuICBpZiAoaXNGaW5pdGVOdW1iZXIodGltZXN0YW1wKSkge1xuICAgIHJldHVybiB0aW1lc3RhbXAgKiA5MDtcbiAgfVxuICBjb25zdCBpbml0OTBrSHogPSBpbml0UFRTID8gaW5pdFBUUy5iYXNlVGltZSAqIDkwMDAwIC8gaW5pdFBUUy50aW1lc2NhbGUgOiAwO1xuICByZXR1cm4gdGltZU9mZnNldCAqIDkwMDAwICsgaW5pdDkwa0h6O1xufTtcblxuLyoqXG4gKiBBRFRTIHBhcnNlciBoZWxwZXJcbiAqIEBsaW5rIGh0dHBzOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1BRFRTXG4gKi9cbmZ1bmN0aW9uIGdldEF1ZGlvQ29uZmlnKG9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIGF1ZGlvQ29kZWMpIHtcbiAgbGV0IGFkdHNPYmplY3RUeXBlO1xuICBsZXQgYWR0c0V4dGVuc2lvblNhbXBsaW5nSW5kZXg7XG4gIGxldCBhZHRzQ2hhbm5lbENvbmZpZztcbiAgbGV0IGNvbmZpZztcbiAgY29uc3QgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCBtYW5pZmVzdENvZGVjID0gYXVkaW9Db2RlYztcbiAgY29uc3QgYWR0c1NhbXBsaW5nUmF0ZXMgPSBbOTYwMDAsIDg4MjAwLCA2NDAwMCwgNDgwMDAsIDQ0MTAwLCAzMjAwMCwgMjQwMDAsIDIyMDUwLCAxNjAwMCwgMTIwMDAsIDExMDI1LCA4MDAwLCA3MzUwXTtcbiAgLy8gYnl0ZSAyXG4gIGFkdHNPYmplY3RUeXBlID0gKChkYXRhW29mZnNldCArIDJdICYgMHhjMCkgPj4+IDYpICsgMTtcbiAgY29uc3QgYWR0c1NhbXBsaW5nSW5kZXggPSAoZGF0YVtvZmZzZXQgKyAyXSAmIDB4M2MpID4+PiAyO1xuICBpZiAoYWR0c1NhbXBsaW5nSW5kZXggPiBhZHRzU2FtcGxpbmdSYXRlcy5sZW5ndGggLSAxKSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGludmFsaWQgQURUUyBzYW1wbGluZyBpbmRleDoke2FkdHNTYW1wbGluZ0luZGV4fWApO1xuICAgIG9ic2VydmVyLmVtaXQoRXZlbnRzLkVSUk9SLCBFdmVudHMuRVJST1IsIHtcbiAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLFxuICAgICAgZmF0YWw6IHRydWUsXG4gICAgICBlcnJvcixcbiAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZVxuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICBhZHRzQ2hhbm5lbENvbmZpZyA9IChkYXRhW29mZnNldCArIDJdICYgMHgwMSkgPDwgMjtcbiAgLy8gYnl0ZSAzXG4gIGFkdHNDaGFubmVsQ29uZmlnIHw9IChkYXRhW29mZnNldCArIDNdICYgMHhjMCkgPj4+IDY7XG4gIGxvZ2dlci5sb2coYG1hbmlmZXN0IGNvZGVjOiR7YXVkaW9Db2RlY30sIEFEVFMgdHlwZToke2FkdHNPYmplY3RUeXBlfSwgc2FtcGxpbmdJbmRleDoke2FkdHNTYW1wbGluZ0luZGV4fWApO1xuICAvLyBmaXJlZm94OiBmcmVxIGxlc3MgdGhhbiAyNGtIeiA9IEFBQyBTQlIgKEhFLUFBQylcbiAgaWYgKC9maXJlZm94L2kudGVzdCh1c2VyQWdlbnQpKSB7XG4gICAgaWYgKGFkdHNTYW1wbGluZ0luZGV4ID49IDYpIHtcbiAgICAgIGFkdHNPYmplY3RUeXBlID0gNTtcbiAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSg0KTtcbiAgICAgIC8vIEhFLUFBQyB1c2VzIFNCUiAoU3BlY3RyYWwgQmFuZCBSZXBsaWNhdGlvbikgLCBoaWdoIGZyZXF1ZW5jaWVzIGFyZSBjb25zdHJ1Y3RlZCBmcm9tIGxvdyBmcmVxdWVuY2llc1xuICAgICAgLy8gdGhlcmUgaXMgYSBmYWN0b3IgMiBiZXR3ZWVuIGZyYW1lIHNhbXBsZSByYXRlIGFuZCBvdXRwdXQgc2FtcGxlIHJhdGVcbiAgICAgIC8vIG11bHRpcGx5IGZyZXF1ZW5jeSBieSAyIChzZWUgdGFibGUgYmVsb3csIGVxdWl2YWxlbnQgdG8gc3Vic3RyYWN0IDMpXG4gICAgICBhZHRzRXh0ZW5zaW9uU2FtcGxpbmdJbmRleCA9IGFkdHNTYW1wbGluZ0luZGV4IC0gMztcbiAgICB9IGVsc2Uge1xuICAgICAgYWR0c09iamVjdFR5cGUgPSAyO1xuICAgICAgY29uZmlnID0gbmV3IEFycmF5KDIpO1xuICAgICAgYWR0c0V4dGVuc2lvblNhbXBsaW5nSW5kZXggPSBhZHRzU2FtcGxpbmdJbmRleDtcbiAgICB9XG4gICAgLy8gQW5kcm9pZCA6IGFsd2F5cyB1c2UgQUFDXG4gIH0gZWxzZSBpZiAodXNlckFnZW50LmluZGV4T2YoJ2FuZHJvaWQnKSAhPT0gLTEpIHtcbiAgICBhZHRzT2JqZWN0VHlwZSA9IDI7XG4gICAgY29uZmlnID0gbmV3IEFycmF5KDIpO1xuICAgIGFkdHNFeHRlbnNpb25TYW1wbGluZ0luZGV4ID0gYWR0c1NhbXBsaW5nSW5kZXg7XG4gIH0gZWxzZSB7XG4gICAgLyogIGZvciBvdGhlciBicm93c2VycyAoQ2hyb21lL1ZpdmFsZGkvT3BlcmEgLi4uKVxuICAgICAgICBhbHdheXMgZm9yY2UgYXVkaW8gdHlwZSB0byBiZSBIRS1BQUMgU0JSLCBhcyBzb21lIGJyb3dzZXJzIGRvIG5vdCBzdXBwb3J0IGF1ZGlvIGNvZGVjIHN3aXRjaCBwcm9wZXJseSAobGlrZSBDaHJvbWUgLi4uKVxuICAgICovXG4gICAgYWR0c09iamVjdFR5cGUgPSA1O1xuICAgIGNvbmZpZyA9IG5ldyBBcnJheSg0KTtcbiAgICAvLyBpZiAobWFuaWZlc3QgY29kZWMgaXMgSEUtQUFDIG9yIEhFLUFBQ3YyKSBPUiAobWFuaWZlc3QgY29kZWMgbm90IHNwZWNpZmllZCBBTkQgZnJlcXVlbmN5IGxlc3MgdGhhbiAyNGtIeilcbiAgICBpZiAoYXVkaW9Db2RlYyAmJiAoYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjI5JykgIT09IC0xIHx8IGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09IC0xKSB8fCAhYXVkaW9Db2RlYyAmJiBhZHRzU2FtcGxpbmdJbmRleCA+PSA2KSB7XG4gICAgICAvLyBIRS1BQUMgdXNlcyBTQlIgKFNwZWN0cmFsIEJhbmQgUmVwbGljYXRpb24pICwgaGlnaCBmcmVxdWVuY2llcyBhcmUgY29uc3RydWN0ZWQgZnJvbSBsb3cgZnJlcXVlbmNpZXNcbiAgICAgIC8vIHRoZXJlIGlzIGEgZmFjdG9yIDIgYmV0d2VlbiBmcmFtZSBzYW1wbGUgcmF0ZSBhbmQgb3V0cHV0IHNhbXBsZSByYXRlXG4gICAgICAvLyBtdWx0aXBseSBmcmVxdWVuY3kgYnkgMiAoc2VlIHRhYmxlIGJlbG93LCBlcXVpdmFsZW50IHRvIHN1YnN0cmFjdCAzKVxuICAgICAgYWR0c0V4dGVuc2lvblNhbXBsaW5nSW5kZXggPSBhZHRzU2FtcGxpbmdJbmRleCAtIDM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIChtYW5pZmVzdCBjb2RlYyBpcyBBQUMpIEFORCAoZnJlcXVlbmN5IGxlc3MgdGhhbiAyNGtIeiBBTkQgbmIgY2hhbm5lbCBpcyAxKSBPUiAobWFuaWZlc3QgY29kZWMgbm90IHNwZWNpZmllZCBhbmQgbW9ubyBhdWRpbylcbiAgICAgIC8vIENocm9tZSBmYWlscyB0byBwbGF5IGJhY2sgd2l0aCBsb3cgZnJlcXVlbmN5IEFBQyBMQyBtb25vIHdoZW4gaW5pdGlhbGl6ZWQgd2l0aCBIRS1BQUMuICBUaGlzIGlzIG5vdCBhIHByb2JsZW0gd2l0aCBzdGVyZW8uXG4gICAgICBpZiAoYXVkaW9Db2RlYyAmJiBhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuMicpICE9PSAtMSAmJiAoYWR0c1NhbXBsaW5nSW5kZXggPj0gNiAmJiBhZHRzQ2hhbm5lbENvbmZpZyA9PT0gMSB8fCAvdml2YWxkaS9pLnRlc3QodXNlckFnZW50KSkgfHwgIWF1ZGlvQ29kZWMgJiYgYWR0c0NoYW5uZWxDb25maWcgPT09IDEpIHtcbiAgICAgICAgYWR0c09iamVjdFR5cGUgPSAyO1xuICAgICAgICBjb25maWcgPSBuZXcgQXJyYXkoMik7XG4gICAgICB9XG4gICAgICBhZHRzRXh0ZW5zaW9uU2FtcGxpbmdJbmRleCA9IGFkdHNTYW1wbGluZ0luZGV4O1xuICAgIH1cbiAgfVxuICAvKiByZWZlciB0byBodHRwOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1NUEVHLTRfQXVkaW8jQXVkaW9fU3BlY2lmaWNfQ29uZmlnXG4gICAgICBJU08gMTQ0OTYtMyAoQUFDKS5wZGYgLSBUYWJsZSAxLjEzIOKAlCBTeW50YXggb2YgQXVkaW9TcGVjaWZpY0NvbmZpZygpXG4gICAgQXVkaW8gUHJvZmlsZSAvIEF1ZGlvIE9iamVjdCBUeXBlXG4gICAgMDogTnVsbFxuICAgIDE6IEFBQyBNYWluXG4gICAgMjogQUFDIExDIChMb3cgQ29tcGxleGl0eSlcbiAgICAzOiBBQUMgU1NSIChTY2FsYWJsZSBTYW1wbGUgUmF0ZSlcbiAgICA0OiBBQUMgTFRQIChMb25nIFRlcm0gUHJlZGljdGlvbilcbiAgICA1OiBTQlIgKFNwZWN0cmFsIEJhbmQgUmVwbGljYXRpb24pXG4gICAgNjogQUFDIFNjYWxhYmxlXG4gICBzYW1wbGluZyBmcmVxXG4gICAgMDogOTYwMDAgSHpcbiAgICAxOiA4ODIwMCBIelxuICAgIDI6IDY0MDAwIEh6XG4gICAgMzogNDgwMDAgSHpcbiAgICA0OiA0NDEwMCBIelxuICAgIDU6IDMyMDAwIEh6XG4gICAgNjogMjQwMDAgSHpcbiAgICA3OiAyMjA1MCBIelxuICAgIDg6IDE2MDAwIEh6XG4gICAgOTogMTIwMDAgSHpcbiAgICAxMDogMTEwMjUgSHpcbiAgICAxMTogODAwMCBIelxuICAgIDEyOiA3MzUwIEh6XG4gICAgMTM6IFJlc2VydmVkXG4gICAgMTQ6IFJlc2VydmVkXG4gICAgMTU6IGZyZXF1ZW5jeSBpcyB3cml0dGVuIGV4cGxpY3RseVxuICAgIENoYW5uZWwgQ29uZmlndXJhdGlvbnNcbiAgICBUaGVzZSBhcmUgdGhlIGNoYW5uZWwgY29uZmlndXJhdGlvbnM6XG4gICAgMDogRGVmaW5lZCBpbiBBT1QgU3BlY2lmYyBDb25maWdcbiAgICAxOiAxIGNoYW5uZWw6IGZyb250LWNlbnRlclxuICAgIDI6IDIgY2hhbm5lbHM6IGZyb250LWxlZnQsIGZyb250LXJpZ2h0XG4gICovXG4gIC8vIGF1ZGlvT2JqZWN0VHlwZSA9IHByb2ZpbGUgPT4gcHJvZmlsZSwgdGhlIE1QRUctNCBBdWRpbyBPYmplY3QgVHlwZSBtaW51cyAxXG4gIGNvbmZpZ1swXSA9IGFkdHNPYmplY3RUeXBlIDw8IDM7XG4gIC8vIHNhbXBsaW5nRnJlcXVlbmN5SW5kZXhcbiAgY29uZmlnWzBdIHw9IChhZHRzU2FtcGxpbmdJbmRleCAmIDB4MGUpID4+IDE7XG4gIGNvbmZpZ1sxXSB8PSAoYWR0c1NhbXBsaW5nSW5kZXggJiAweDAxKSA8PCA3O1xuICAvLyBjaGFubmVsQ29uZmlndXJhdGlvblxuICBjb25maWdbMV0gfD0gYWR0c0NoYW5uZWxDb25maWcgPDwgMztcbiAgaWYgKGFkdHNPYmplY3RUeXBlID09PSA1KSB7XG4gICAgLy8gYWR0c0V4dGVuc2lvblNhbXBsaW5nSW5kZXhcbiAgICBjb25maWdbMV0gfD0gKGFkdHNFeHRlbnNpb25TYW1wbGluZ0luZGV4ICYgMHgwZSkgPj4gMTtcbiAgICBjb25maWdbMl0gPSAoYWR0c0V4dGVuc2lvblNhbXBsaW5nSW5kZXggJiAweDAxKSA8PCA3O1xuICAgIC8vIGFkdHNPYmplY3RUeXBlIChmb3JjZSB0byAyLCBjaHJvbWUgaXMgY2hlY2tpbmcgdGhhdCBvYmplY3QgdHlwZSBpcyBsZXNzIHRoYW4gNSA/Pz9cbiAgICAvLyAgICBodHRwczovL2Nocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjLmdpdC8rL21hc3Rlci9tZWRpYS9mb3JtYXRzL21wNC9hYWMuY2NcbiAgICBjb25maWdbMl0gfD0gMiA8PCAyO1xuICAgIGNvbmZpZ1szXSA9IDA7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjb25maWcsXG4gICAgc2FtcGxlcmF0ZTogYWR0c1NhbXBsaW5nUmF0ZXNbYWR0c1NhbXBsaW5nSW5kZXhdLFxuICAgIGNoYW5uZWxDb3VudDogYWR0c0NoYW5uZWxDb25maWcsXG4gICAgY29kZWM6ICdtcDRhLjQwLicgKyBhZHRzT2JqZWN0VHlwZSxcbiAgICBtYW5pZmVzdENvZGVjXG4gIH07XG59XG5mdW5jdGlvbiBpc0hlYWRlclBhdHRlcm4kMShkYXRhLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGRhdGFbb2Zmc2V0XSA9PT0gMHhmZiAmJiAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4ZjYpID09PSAweGYwO1xufVxuZnVuY3Rpb24gZ2V0SGVhZGVyTGVuZ3RoKGRhdGEsIG9mZnNldCkge1xuICByZXR1cm4gZGF0YVtvZmZzZXQgKyAxXSAmIDB4MDEgPyA3IDogOTtcbn1cbmZ1bmN0aW9uIGdldEZ1bGxGcmFtZUxlbmd0aChkYXRhLCBvZmZzZXQpIHtcbiAgcmV0dXJuIChkYXRhW29mZnNldCArIDNdICYgMHgwMykgPDwgMTEgfCBkYXRhW29mZnNldCArIDRdIDw8IDMgfCAoZGF0YVtvZmZzZXQgKyA1XSAmIDB4ZTApID4+PiA1O1xufVxuZnVuY3Rpb24gY2FuR2V0RnJhbWVMZW5ndGgoZGF0YSwgb2Zmc2V0KSB7XG4gIHJldHVybiBvZmZzZXQgKyA1IDwgZGF0YS5sZW5ndGg7XG59XG5mdW5jdGlvbiBpc0hlYWRlciQxKGRhdGEsIG9mZnNldCkge1xuICAvLyBMb29rIGZvciBBRFRTIGhlYWRlciB8IDExMTEgMTExMSB8IDExMTEgWDAwWCB8IHdoZXJlIFggY2FuIGJlIGVpdGhlciAwIG9yIDFcbiAgLy8gTGF5ZXIgYml0cyAocG9zaXRpb24gMTQgYW5kIDE1KSBpbiBoZWFkZXIgc2hvdWxkIGJlIGFsd2F5cyAwIGZvciBBRFRTXG4gIC8vIE1vcmUgaW5mbyBodHRwczovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9QURUU1xuICByZXR1cm4gb2Zmc2V0ICsgMSA8IGRhdGEubGVuZ3RoICYmIGlzSGVhZGVyUGF0dGVybiQxKGRhdGEsIG9mZnNldCk7XG59XG5mdW5jdGlvbiBjYW5QYXJzZSQxKGRhdGEsIG9mZnNldCkge1xuICByZXR1cm4gY2FuR2V0RnJhbWVMZW5ndGgoZGF0YSwgb2Zmc2V0KSAmJiBpc0hlYWRlclBhdHRlcm4kMShkYXRhLCBvZmZzZXQpICYmIGdldEZ1bGxGcmFtZUxlbmd0aChkYXRhLCBvZmZzZXQpIDw9IGRhdGEubGVuZ3RoIC0gb2Zmc2V0O1xufVxuZnVuY3Rpb24gcHJvYmUkMShkYXRhLCBvZmZzZXQpIHtcbiAgLy8gc2FtZSBhcyBpc0hlYWRlciBidXQgd2UgYWxzbyBjaGVjayB0aGF0IEFEVFMgZnJhbWUgZm9sbG93cyBsYXN0IEFEVFMgZnJhbWVcbiAgLy8gb3IgZW5kIG9mIGRhdGEgaXMgcmVhY2hlZFxuICBpZiAoaXNIZWFkZXIkMShkYXRhLCBvZmZzZXQpKSB7XG4gICAgLy8gQURUUyBoZWFkZXIgTGVuZ3RoXG4gICAgY29uc3QgaGVhZGVyTGVuZ3RoID0gZ2V0SGVhZGVyTGVuZ3RoKGRhdGEsIG9mZnNldCk7XG4gICAgaWYgKG9mZnNldCArIGhlYWRlckxlbmd0aCA+PSBkYXRhLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBBRFRTIGZyYW1lIExlbmd0aFxuICAgIGNvbnN0IGZyYW1lTGVuZ3RoID0gZ2V0RnVsbEZyYW1lTGVuZ3RoKGRhdGEsIG9mZnNldCk7XG4gICAgaWYgKGZyYW1lTGVuZ3RoIDw9IGhlYWRlckxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBuZXdPZmZzZXQgPSBvZmZzZXQgKyBmcmFtZUxlbmd0aDtcbiAgICByZXR1cm4gbmV3T2Zmc2V0ID09PSBkYXRhLmxlbmd0aCB8fCBpc0hlYWRlciQxKGRhdGEsIG5ld09mZnNldCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaW5pdFRyYWNrQ29uZmlnKHRyYWNrLCBvYnNlcnZlciwgZGF0YSwgb2Zmc2V0LCBhdWRpb0NvZGVjKSB7XG4gIGlmICghdHJhY2suc2FtcGxlcmF0ZSkge1xuICAgIGNvbnN0IGNvbmZpZyA9IGdldEF1ZGlvQ29uZmlnKG9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIGF1ZGlvQ29kZWMpO1xuICAgIGlmICghY29uZmlnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyYWNrLmNvbmZpZyA9IGNvbmZpZy5jb25maWc7XG4gICAgdHJhY2suc2FtcGxlcmF0ZSA9IGNvbmZpZy5zYW1wbGVyYXRlO1xuICAgIHRyYWNrLmNoYW5uZWxDb3VudCA9IGNvbmZpZy5jaGFubmVsQ291bnQ7XG4gICAgdHJhY2suY29kZWMgPSBjb25maWcuY29kZWM7XG4gICAgdHJhY2subWFuaWZlc3RDb2RlYyA9IGNvbmZpZy5tYW5pZmVzdENvZGVjO1xuICAgIGxvZ2dlci5sb2coYHBhcnNlZCBjb2RlYzoke3RyYWNrLmNvZGVjfSwgcmF0ZToke2NvbmZpZy5zYW1wbGVyYXRlfSwgY2hhbm5lbHM6JHtjb25maWcuY2hhbm5lbENvdW50fWApO1xuICB9XG59XG5mdW5jdGlvbiBnZXRGcmFtZUR1cmF0aW9uKHNhbXBsZXJhdGUpIHtcbiAgcmV0dXJuIDEwMjQgKiA5MDAwMCAvIHNhbXBsZXJhdGU7XG59XG5mdW5jdGlvbiBwYXJzZUZyYW1lSGVhZGVyKGRhdGEsIG9mZnNldCkge1xuICAvLyBUaGUgcHJvdGVjdGlvbiBza2lwIGJpdCB0ZWxscyB1cyBpZiB3ZSBoYXZlIDIgYnl0ZXMgb2YgQ1JDIGRhdGEgYXQgdGhlIGVuZCBvZiB0aGUgQURUUyBoZWFkZXJcbiAgY29uc3QgaGVhZGVyTGVuZ3RoID0gZ2V0SGVhZGVyTGVuZ3RoKGRhdGEsIG9mZnNldCk7XG4gIGlmIChvZmZzZXQgKyBoZWFkZXJMZW5ndGggPD0gZGF0YS5sZW5ndGgpIHtcbiAgICAvLyByZXRyaWV2ZSBmcmFtZSBzaXplXG4gICAgY29uc3QgZnJhbWVMZW5ndGggPSBnZXRGdWxsRnJhbWVMZW5ndGgoZGF0YSwgb2Zmc2V0KSAtIGhlYWRlckxlbmd0aDtcbiAgICBpZiAoZnJhbWVMZW5ndGggPiAwKSB7XG4gICAgICAvLyBsb2dnZXIubG9nKGBBQUMgZnJhbWUsIG9mZnNldC9sZW5ndGgvdG90YWwvcHRzOiR7b2Zmc2V0K2hlYWRlckxlbmd0aH0vJHtmcmFtZUxlbmd0aH0vJHtkYXRhLmJ5dGVMZW5ndGh9YCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBoZWFkZXJMZW5ndGgsXG4gICAgICAgIGZyYW1lTGVuZ3RoXG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYXBwZW5kRnJhbWUkMih0cmFjaywgZGF0YSwgb2Zmc2V0LCBwdHMsIGZyYW1lSW5kZXgpIHtcbiAgY29uc3QgZnJhbWVEdXJhdGlvbiA9IGdldEZyYW1lRHVyYXRpb24odHJhY2suc2FtcGxlcmF0ZSk7XG4gIGNvbnN0IHN0YW1wID0gcHRzICsgZnJhbWVJbmRleCAqIGZyYW1lRHVyYXRpb247XG4gIGNvbnN0IGhlYWRlciA9IHBhcnNlRnJhbWVIZWFkZXIoZGF0YSwgb2Zmc2V0KTtcbiAgbGV0IHVuaXQ7XG4gIGlmIChoZWFkZXIpIHtcbiAgICBjb25zdCB7XG4gICAgICBmcmFtZUxlbmd0aCxcbiAgICAgIGhlYWRlckxlbmd0aFxuICAgIH0gPSBoZWFkZXI7XG4gICAgY29uc3QgX2xlbmd0aCA9IGhlYWRlckxlbmd0aCArIGZyYW1lTGVuZ3RoO1xuICAgIGNvbnN0IG1pc3NpbmcgPSBNYXRoLm1heCgwLCBvZmZzZXQgKyBfbGVuZ3RoIC0gZGF0YS5sZW5ndGgpO1xuICAgIC8vIGxvZ2dlci5sb2coYEFBQyBmcmFtZSAke2ZyYW1lSW5kZXh9LCBwdHM6JHtzdGFtcH0gbGVuZ3RoQG9mZnNldC90b3RhbDogJHtmcmFtZUxlbmd0aH1AJHtvZmZzZXQraGVhZGVyTGVuZ3RofS8ke2RhdGEuYnl0ZUxlbmd0aH0gbWlzc2luZzogJHttaXNzaW5nfWApO1xuICAgIGlmIChtaXNzaW5nKSB7XG4gICAgICB1bml0ID0gbmV3IFVpbnQ4QXJyYXkoX2xlbmd0aCAtIGhlYWRlckxlbmd0aCk7XG4gICAgICB1bml0LnNldChkYXRhLnN1YmFycmF5KG9mZnNldCArIGhlYWRlckxlbmd0aCwgZGF0YS5sZW5ndGgpLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdW5pdCA9IGRhdGEuc3ViYXJyYXkob2Zmc2V0ICsgaGVhZGVyTGVuZ3RoLCBvZmZzZXQgKyBfbGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3QgX3NhbXBsZSA9IHtcbiAgICAgIHVuaXQsXG4gICAgICBwdHM6IHN0YW1wXG4gICAgfTtcbiAgICBpZiAoIW1pc3NpbmcpIHtcbiAgICAgIHRyYWNrLnNhbXBsZXMucHVzaChfc2FtcGxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHNhbXBsZTogX3NhbXBsZSxcbiAgICAgIGxlbmd0aDogX2xlbmd0aCxcbiAgICAgIG1pc3NpbmdcbiAgICB9O1xuICB9XG4gIC8vIG92ZXJmbG93IGluY29tcGxldGUgaGVhZGVyXG4gIGNvbnN0IGxlbmd0aCA9IGRhdGEubGVuZ3RoIC0gb2Zmc2V0O1xuICB1bml0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgdW5pdC5zZXQoZGF0YS5zdWJhcnJheShvZmZzZXQsIGRhdGEubGVuZ3RoKSwgMCk7XG4gIGNvbnN0IHNhbXBsZSA9IHtcbiAgICB1bml0LFxuICAgIHB0czogc3RhbXBcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBzYW1wbGUsXG4gICAgbGVuZ3RoLFxuICAgIG1pc3Npbmc6IC0xXG4gIH07XG59XG5cbi8qKlxuICogIE1QRUcgcGFyc2VyIGhlbHBlclxuICovXG5cbmxldCBjaHJvbWVWZXJzaW9uJDEgPSBudWxsO1xuY29uc3QgQml0cmF0ZXNNYXAgPSBbMzIsIDY0LCA5NiwgMTI4LCAxNjAsIDE5MiwgMjI0LCAyNTYsIDI4OCwgMzIwLCAzNTIsIDM4NCwgNDE2LCA0NDgsIDMyLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNjAsIDE5MiwgMjI0LCAyNTYsIDMyMCwgMzg0LCAzMiwgNDAsIDQ4LCA1NiwgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE2MCwgMTkyLCAyMjQsIDI1NiwgMzIwLCAzMiwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTQ0LCAxNjAsIDE3NiwgMTkyLCAyMjQsIDI1NiwgOCwgMTYsIDI0LCAzMiwgNDAsIDQ4LCA1NiwgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE0NCwgMTYwXTtcbmNvbnN0IFNhbXBsaW5nUmF0ZU1hcCA9IFs0NDEwMCwgNDgwMDAsIDMyMDAwLCAyMjA1MCwgMjQwMDAsIDE2MDAwLCAxMTAyNSwgMTIwMDAsIDgwMDBdO1xuY29uc3QgU2FtcGxlc0NvZWZmaWNpZW50cyA9IFtcbi8vIE1QRUcgMi41XG5bMCxcbi8vIFJlc2VydmVkXG43Mixcbi8vIExheWVyM1xuMTQ0LFxuLy8gTGF5ZXIyXG4xMiAvLyBMYXllcjFcbl0sXG4vLyBSZXNlcnZlZFxuWzAsXG4vLyBSZXNlcnZlZFxuMCxcbi8vIExheWVyM1xuMCxcbi8vIExheWVyMlxuMCAvLyBMYXllcjFcbl0sXG4vLyBNUEVHIDJcblswLFxuLy8gUmVzZXJ2ZWRcbjcyLFxuLy8gTGF5ZXIzXG4xNDQsXG4vLyBMYXllcjJcbjEyIC8vIExheWVyMVxuXSxcbi8vIE1QRUcgMVxuWzAsXG4vLyBSZXNlcnZlZFxuMTQ0LFxuLy8gTGF5ZXIzXG4xNDQsXG4vLyBMYXllcjJcbjEyIC8vIExheWVyMVxuXV07XG5jb25zdCBCeXRlc0luU2xvdCA9IFswLFxuLy8gUmVzZXJ2ZWRcbjEsXG4vLyBMYXllcjNcbjEsXG4vLyBMYXllcjJcbjQgLy8gTGF5ZXIxXG5dO1xuZnVuY3Rpb24gYXBwZW5kRnJhbWUkMSh0cmFjaywgZGF0YSwgb2Zmc2V0LCBwdHMsIGZyYW1lSW5kZXgpIHtcbiAgLy8gVXNpbmcgaHR0cDovL3d3dy5kYXRhdm95YWdlLmNvbS9tcGdzY3JpcHQvbXBlZ2hkci5odG0gYXMgYSByZWZlcmVuY2VcbiAgaWYgKG9mZnNldCArIDI0ID4gZGF0YS5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaGVhZGVyID0gcGFyc2VIZWFkZXIoZGF0YSwgb2Zmc2V0KTtcbiAgaWYgKGhlYWRlciAmJiBvZmZzZXQgKyBoZWFkZXIuZnJhbWVMZW5ndGggPD0gZGF0YS5sZW5ndGgpIHtcbiAgICBjb25zdCBmcmFtZUR1cmF0aW9uID0gaGVhZGVyLnNhbXBsZXNQZXJGcmFtZSAqIDkwMDAwIC8gaGVhZGVyLnNhbXBsZVJhdGU7XG4gICAgY29uc3Qgc3RhbXAgPSBwdHMgKyBmcmFtZUluZGV4ICogZnJhbWVEdXJhdGlvbjtcbiAgICBjb25zdCBzYW1wbGUgPSB7XG4gICAgICB1bml0OiBkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgaGVhZGVyLmZyYW1lTGVuZ3RoKSxcbiAgICAgIHB0czogc3RhbXAsXG4gICAgICBkdHM6IHN0YW1wXG4gICAgfTtcbiAgICB0cmFjay5jb25maWcgPSBbXTtcbiAgICB0cmFjay5jaGFubmVsQ291bnQgPSBoZWFkZXIuY2hhbm5lbENvdW50O1xuICAgIHRyYWNrLnNhbXBsZXJhdGUgPSBoZWFkZXIuc2FtcGxlUmF0ZTtcbiAgICB0cmFjay5zYW1wbGVzLnB1c2goc2FtcGxlKTtcbiAgICByZXR1cm4ge1xuICAgICAgc2FtcGxlLFxuICAgICAgbGVuZ3RoOiBoZWFkZXIuZnJhbWVMZW5ndGgsXG4gICAgICBtaXNzaW5nOiAwXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VIZWFkZXIoZGF0YSwgb2Zmc2V0KSB7XG4gIGNvbnN0IG1wZWdWZXJzaW9uID0gZGF0YVtvZmZzZXQgKyAxXSA+PiAzICYgMztcbiAgY29uc3QgbXBlZ0xheWVyID0gZGF0YVtvZmZzZXQgKyAxXSA+PiAxICYgMztcbiAgY29uc3QgYml0UmF0ZUluZGV4ID0gZGF0YVtvZmZzZXQgKyAyXSA+PiA0ICYgMTU7XG4gIGNvbnN0IHNhbXBsZVJhdGVJbmRleCA9IGRhdGFbb2Zmc2V0ICsgMl0gPj4gMiAmIDM7XG4gIGlmIChtcGVnVmVyc2lvbiAhPT0gMSAmJiBiaXRSYXRlSW5kZXggIT09IDAgJiYgYml0UmF0ZUluZGV4ICE9PSAxNSAmJiBzYW1wbGVSYXRlSW5kZXggIT09IDMpIHtcbiAgICBjb25zdCBwYWRkaW5nQml0ID0gZGF0YVtvZmZzZXQgKyAyXSA+PiAxICYgMTtcbiAgICBjb25zdCBjaGFubmVsTW9kZSA9IGRhdGFbb2Zmc2V0ICsgM10gPj4gNjtcbiAgICBjb25zdCBjb2x1bW5JbkJpdHJhdGVzID0gbXBlZ1ZlcnNpb24gPT09IDMgPyAzIC0gbXBlZ0xheWVyIDogbXBlZ0xheWVyID09PSAzID8gMyA6IDQ7XG4gICAgY29uc3QgYml0UmF0ZSA9IEJpdHJhdGVzTWFwW2NvbHVtbkluQml0cmF0ZXMgKiAxNCArIGJpdFJhdGVJbmRleCAtIDFdICogMTAwMDtcbiAgICBjb25zdCBjb2x1bW5JblNhbXBsZVJhdGVzID0gbXBlZ1ZlcnNpb24gPT09IDMgPyAwIDogbXBlZ1ZlcnNpb24gPT09IDIgPyAxIDogMjtcbiAgICBjb25zdCBzYW1wbGVSYXRlID0gU2FtcGxpbmdSYXRlTWFwW2NvbHVtbkluU2FtcGxlUmF0ZXMgKiAzICsgc2FtcGxlUmF0ZUluZGV4XTtcbiAgICBjb25zdCBjaGFubmVsQ291bnQgPSBjaGFubmVsTW9kZSA9PT0gMyA/IDEgOiAyOyAvLyBJZiBiaXRzIG9mIGNoYW5uZWwgbW9kZSBhcmUgYDExYCB0aGVuIGl0IGlzIGEgc2luZ2xlIGNoYW5uZWwgKE1vbm8pXG4gICAgY29uc3Qgc2FtcGxlQ29lZmZpY2llbnQgPSBTYW1wbGVzQ29lZmZpY2llbnRzW21wZWdWZXJzaW9uXVttcGVnTGF5ZXJdO1xuICAgIGNvbnN0IGJ5dGVzSW5TbG90ID0gQnl0ZXNJblNsb3RbbXBlZ0xheWVyXTtcbiAgICBjb25zdCBzYW1wbGVzUGVyRnJhbWUgPSBzYW1wbGVDb2VmZmljaWVudCAqIDggKiBieXRlc0luU2xvdDtcbiAgICBjb25zdCBmcmFtZUxlbmd0aCA9IE1hdGguZmxvb3Ioc2FtcGxlQ29lZmZpY2llbnQgKiBiaXRSYXRlIC8gc2FtcGxlUmF0ZSArIHBhZGRpbmdCaXQpICogYnl0ZXNJblNsb3Q7XG4gICAgaWYgKGNocm9tZVZlcnNpb24kMSA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJztcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspL2kpO1xuICAgICAgY2hyb21lVmVyc2lvbiQxID0gcmVzdWx0ID8gcGFyc2VJbnQocmVzdWx0WzFdKSA6IDA7XG4gICAgfVxuICAgIGNvbnN0IG5lZWRDaHJvbWVGaXggPSAhIWNocm9tZVZlcnNpb24kMSAmJiBjaHJvbWVWZXJzaW9uJDEgPD0gODc7XG4gICAgaWYgKG5lZWRDaHJvbWVGaXggJiYgbXBlZ0xheWVyID09PSAyICYmIGJpdFJhdGUgPj0gMjI0MDAwICYmIGNoYW5uZWxNb2RlID09PSAwKSB7XG4gICAgICAvLyBXb3JrIGFyb3VuZCBidWcgaW4gQ2hyb21pdW0gYnkgc2V0dGluZyBjaGFubmVsTW9kZSB0byBkdWFsLWNoYW5uZWwgKDAxKSBpbnN0ZWFkIG9mIHN0ZXJlbyAoMDApXG4gICAgICBkYXRhW29mZnNldCArIDNdID0gZGF0YVtvZmZzZXQgKyAzXSB8IDB4ODA7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzYW1wbGVSYXRlLFxuICAgICAgY2hhbm5lbENvdW50LFxuICAgICAgZnJhbWVMZW5ndGgsXG4gICAgICBzYW1wbGVzUGVyRnJhbWVcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBpc0hlYWRlclBhdHRlcm4oZGF0YSwgb2Zmc2V0KSB7XG4gIHJldHVybiBkYXRhW29mZnNldF0gPT09IDB4ZmYgJiYgKGRhdGFbb2Zmc2V0ICsgMV0gJiAweGUwKSA9PT0gMHhlMCAmJiAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4MDYpICE9PSAweDAwO1xufVxuZnVuY3Rpb24gaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSB7XG4gIC8vIExvb2sgZm9yIE1QRUcgaGVhZGVyIHwgMTExMSAxMTExIHwgMTExWCBYWVpYIHwgd2hlcmUgWCBjYW4gYmUgZWl0aGVyIDAgb3IgMSBhbmQgWSBvciBaIHNob3VsZCBiZSAxXG4gIC8vIExheWVyIGJpdHMgKHBvc2l0aW9uIDE0IGFuZCAxNSkgaW4gaGVhZGVyIHNob3VsZCBiZSBhbHdheXMgZGlmZmVyZW50IGZyb20gMCAoTGF5ZXIgSSBvciBMYXllciBJSSBvciBMYXllciBJSUkpXG4gIC8vIE1vcmUgaW5mbyBodHRwOi8vd3d3Lm1wMy10ZWNoLm9yZy9wcm9ncmFtbWVyL2ZyYW1lX2hlYWRlci5odG1sXG4gIHJldHVybiBvZmZzZXQgKyAxIDwgZGF0YS5sZW5ndGggJiYgaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG9mZnNldCk7XG59XG5mdW5jdGlvbiBjYW5QYXJzZShkYXRhLCBvZmZzZXQpIHtcbiAgY29uc3QgaGVhZGVyU2l6ZSA9IDQ7XG4gIHJldHVybiBpc0hlYWRlclBhdHRlcm4oZGF0YSwgb2Zmc2V0KSAmJiBoZWFkZXJTaXplIDw9IGRhdGEubGVuZ3RoIC0gb2Zmc2V0O1xufVxuZnVuY3Rpb24gcHJvYmUoZGF0YSwgb2Zmc2V0KSB7XG4gIC8vIHNhbWUgYXMgaXNIZWFkZXIgYnV0IHdlIGFsc28gY2hlY2sgdGhhdCBNUEVHIGZyYW1lIGZvbGxvd3MgbGFzdCBNUEVHIGZyYW1lXG4gIC8vIG9yIGVuZCBvZiBkYXRhIGlzIHJlYWNoZWRcbiAgaWYgKG9mZnNldCArIDEgPCBkYXRhLmxlbmd0aCAmJiBpc0hlYWRlclBhdHRlcm4oZGF0YSwgb2Zmc2V0KSkge1xuICAgIC8vIE1QRUcgaGVhZGVyIExlbmd0aFxuICAgIGNvbnN0IGhlYWRlckxlbmd0aCA9IDQ7XG4gICAgLy8gTVBFRyBmcmFtZSBMZW5ndGhcbiAgICBjb25zdCBoZWFkZXIgPSBwYXJzZUhlYWRlcihkYXRhLCBvZmZzZXQpO1xuICAgIGxldCBmcmFtZUxlbmd0aCA9IGhlYWRlckxlbmd0aDtcbiAgICBpZiAoaGVhZGVyICE9IG51bGwgJiYgaGVhZGVyLmZyYW1lTGVuZ3RoKSB7XG4gICAgICBmcmFtZUxlbmd0aCA9IGhlYWRlci5mcmFtZUxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgbmV3T2Zmc2V0ID0gb2Zmc2V0ICsgZnJhbWVMZW5ndGg7XG4gICAgcmV0dXJuIG5ld09mZnNldCA9PT0gZGF0YS5sZW5ndGggfHwgaXNIZWFkZXIoZGF0YSwgbmV3T2Zmc2V0KTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQUFDIGRlbXV4ZXJcbiAqL1xuY2xhc3MgQUFDRGVtdXhlciBleHRlbmRzIEJhc2VBdWRpb0RlbXV4ZXIge1xuICBjb25zdHJ1Y3RvcihvYnNlcnZlciwgY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9ic2VydmVyID0gdm9pZCAwO1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgfVxuICByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0cmFja0R1cmF0aW9uKSB7XG4gICAgc3VwZXIucmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbik7XG4gICAgdGhpcy5fYXVkaW9UcmFjayA9IHtcbiAgICAgIGNvbnRhaW5lcjogJ2F1ZGlvL2FkdHMnLFxuICAgICAgdHlwZTogJ2F1ZGlvJyxcbiAgICAgIGlkOiAyLFxuICAgICAgcGlkOiAtMSxcbiAgICAgIHNlcXVlbmNlTnVtYmVyOiAwLFxuICAgICAgc2VnbWVudENvZGVjOiAnYWFjJyxcbiAgICAgIHNhbXBsZXM6IFtdLFxuICAgICAgbWFuaWZlc3RDb2RlYzogYXVkaW9Db2RlYyxcbiAgICAgIGR1cmF0aW9uOiB0cmFja0R1cmF0aW9uLFxuICAgICAgaW5wdXRUaW1lU2NhbGU6IDkwMDAwLFxuICAgICAgZHJvcHBlZDogMFxuICAgIH07XG4gIH1cblxuICAvLyBTb3VyY2UgZm9yIHByb2JlIGluZm8gLSBodHRwczovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9QURUU1xuICBzdGF0aWMgcHJvYmUoZGF0YSkge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciB0aGUgQURUUyBzeW5jIHdvcmRcbiAgICAvLyBMb29rIGZvciBBRFRTIGhlYWRlciB8IDExMTEgMTExMSB8IDExMTEgWDAwWCB8IHdoZXJlIFggY2FuIGJlIGVpdGhlciAwIG9yIDFcbiAgICAvLyBMYXllciBiaXRzIChwb3NpdGlvbiAxNCBhbmQgMTUpIGluIGhlYWRlciBzaG91bGQgYmUgYWx3YXlzIDAgZm9yIEFEVFNcbiAgICAvLyBNb3JlIGluZm8gaHR0cHM6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwP3RpdGxlPUFEVFNcbiAgICBjb25zdCBpZDNEYXRhID0gZ2V0SUQzRGF0YShkYXRhLCAwKTtcbiAgICBsZXQgb2Zmc2V0ID0gKGlkM0RhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGlkM0RhdGEubGVuZ3RoKSB8fCAwO1xuICAgIGlmIChwcm9iZShkYXRhLCBvZmZzZXQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGxlbmd0aCA9IGRhdGEubGVuZ3RoOyBvZmZzZXQgPCBsZW5ndGg7IG9mZnNldCsrKSB7XG4gICAgICBpZiAocHJvYmUkMShkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ0FEVFMgc3luYyB3b3JkIGZvdW5kICEnKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjYW5QYXJzZShkYXRhLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gY2FuUGFyc2UkMShkYXRhLCBvZmZzZXQpO1xuICB9XG4gIGFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQpIHtcbiAgICBpbml0VHJhY2tDb25maWcodHJhY2ssIHRoaXMub2JzZXJ2ZXIsIGRhdGEsIG9mZnNldCwgdHJhY2subWFuaWZlc3RDb2RlYyk7XG4gICAgY29uc3QgZnJhbWUgPSBhcHBlbmRGcmFtZSQyKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHRoaXMuYmFzZVBUUywgdGhpcy5mcmFtZUluZGV4KTtcbiAgICBpZiAoZnJhbWUgJiYgZnJhbWUubWlzc2luZyA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBlbXNnU2NoZW1lUGF0dGVybiA9IC9cXC9lbXNnWy0vXUlEMy9pO1xuY2xhc3MgTVA0RGVtdXhlciB7XG4gIGNvbnN0cnVjdG9yKG9ic2VydmVyLCBjb25maWcpIHtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIHRoaXMudGltZU9mZnNldCA9IDA7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy52aWRlb1RyYWNrID0gdm9pZCAwO1xuICAgIHRoaXMuYXVkaW9UcmFjayA9IHZvaWQgMDtcbiAgICB0aGlzLmlkM1RyYWNrID0gdm9pZCAwO1xuICAgIHRoaXMudHh0VHJhY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gIH1cbiAgcmVzZXRUaW1lU3RhbXAoKSB7fVxuICByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0cmFja0R1cmF0aW9uKSB7XG4gICAgY29uc3QgdmlkZW9UcmFjayA9IHRoaXMudmlkZW9UcmFjayA9IGR1bW15VHJhY2soJ3ZpZGVvJywgMSk7XG4gICAgY29uc3QgYXVkaW9UcmFjayA9IHRoaXMuYXVkaW9UcmFjayA9IGR1bW15VHJhY2soJ2F1ZGlvJywgMSk7XG4gICAgY29uc3QgY2FwdGlvblRyYWNrID0gdGhpcy50eHRUcmFjayA9IGR1bW15VHJhY2soJ3RleHQnLCAxKTtcbiAgICB0aGlzLmlkM1RyYWNrID0gZHVtbXlUcmFjaygnaWQzJywgMSk7XG4gICAgdGhpcy50aW1lT2Zmc2V0ID0gMDtcbiAgICBpZiAoIShpbml0U2VnbWVudCAhPSBudWxsICYmIGluaXRTZWdtZW50LmJ5dGVMZW5ndGgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGluaXREYXRhID0gcGFyc2VJbml0U2VnbWVudChpbml0U2VnbWVudCk7XG4gICAgaWYgKGluaXREYXRhLnZpZGVvKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGlkLFxuICAgICAgICB0aW1lc2NhbGUsXG4gICAgICAgIGNvZGVjXG4gICAgICB9ID0gaW5pdERhdGEudmlkZW87XG4gICAgICB2aWRlb1RyYWNrLmlkID0gaWQ7XG4gICAgICB2aWRlb1RyYWNrLnRpbWVzY2FsZSA9IGNhcHRpb25UcmFjay50aW1lc2NhbGUgPSB0aW1lc2NhbGU7XG4gICAgICB2aWRlb1RyYWNrLmNvZGVjID0gY29kZWM7XG4gICAgfVxuICAgIGlmIChpbml0RGF0YS5hdWRpbykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBpZCxcbiAgICAgICAgdGltZXNjYWxlLFxuICAgICAgICBjb2RlY1xuICAgICAgfSA9IGluaXREYXRhLmF1ZGlvO1xuICAgICAgYXVkaW9UcmFjay5pZCA9IGlkO1xuICAgICAgYXVkaW9UcmFjay50aW1lc2NhbGUgPSB0aW1lc2NhbGU7XG4gICAgICBhdWRpb1RyYWNrLmNvZGVjID0gY29kZWM7XG4gICAgfVxuICAgIGNhcHRpb25UcmFjay5pZCA9IFJlbXV4ZXJUcmFja0lkQ29uZmlnLnRleHQ7XG4gICAgdmlkZW9UcmFjay5zYW1wbGVEdXJhdGlvbiA9IDA7XG4gICAgdmlkZW9UcmFjay5kdXJhdGlvbiA9IGF1ZGlvVHJhY2suZHVyYXRpb24gPSB0cmFja0R1cmF0aW9uO1xuICB9XG4gIHJlc2V0Q29udGlndWl0eSgpIHtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICB9XG4gIHN0YXRpYyBwcm9iZShkYXRhKSB7XG4gICAgcmV0dXJuIGhhc01vb2ZEYXRhKGRhdGEpO1xuICB9XG4gIGRlbXV4KGRhdGEsIHRpbWVPZmZzZXQpIHtcbiAgICB0aGlzLnRpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0O1xuICAgIC8vIExvYWQgYWxsIGRhdGEgaW50byB0aGUgYXZjIHRyYWNrLiBUaGUgQ01BRiByZW11eGVyIHdpbGwgbG9vayBmb3IgdGhlIGRhdGEgaW4gdGhlIHNhbXBsZXMgb2JqZWN0OyB0aGUgcmVzdCBvZiB0aGUgZmllbGRzIGRvIG5vdCBtYXR0ZXJcbiAgICBsZXQgdmlkZW9TYW1wbGVzID0gZGF0YTtcbiAgICBjb25zdCB2aWRlb1RyYWNrID0gdGhpcy52aWRlb1RyYWNrO1xuICAgIGNvbnN0IHRleHRUcmFjayA9IHRoaXMudHh0VHJhY2s7XG4gICAgaWYgKHRoaXMuY29uZmlnLnByb2dyZXNzaXZlKSB7XG4gICAgICAvLyBTcGxpdCB0aGUgYnl0ZXN0cmVhbSBpbnRvIHR3byByYW5nZXM6IG9uZSBlbmNvbXBhc3NpbmcgYWxsIGRhdGEgdXAgdW50aWwgdGhlIHN0YXJ0IG9mIHRoZSBsYXN0IG1vb2YsIGFuZCBldmVyeXRoaW5nIGVsc2UuXG4gICAgICAvLyBUaGlzIGlzIGRvbmUgdG8gZ3VhcmFudGVlIHRoYXQgd2UncmUgc2VuZGluZyB2YWxpZCBkYXRhIHRvIE1TRSAtIHdoZW4gZGVtdXhpbmcgcHJvZ3Jlc3NpdmVseSwgd2UgaGF2ZSBubyBndWFyYW50ZWVcbiAgICAgIC8vIHRoYXQgdGhlIGZldGNoIGxvYWRlciBnaXZlcyB1cyBmbHVzaCBtb29mK21kYXQgcGFpcnMuIElmIHdlIHB1c2ggamFnZ2VkIGRhdGEgdG8gTVNFLCBpdCB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbi5cbiAgICAgIGlmICh0aGlzLnJlbWFpbmRlckRhdGEpIHtcbiAgICAgICAgdmlkZW9TYW1wbGVzID0gYXBwZW5kVWludDhBcnJheSh0aGlzLnJlbWFpbmRlckRhdGEsIGRhdGEpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2VnbWVudGVkRGF0YSA9IHNlZ21lbnRWYWxpZFJhbmdlKHZpZGVvU2FtcGxlcyk7XG4gICAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBzZWdtZW50ZWREYXRhLnJlbWFpbmRlcjtcbiAgICAgIHZpZGVvVHJhY2suc2FtcGxlcyA9IHNlZ21lbnRlZERhdGEudmFsaWQgfHwgbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmlkZW9UcmFjay5zYW1wbGVzID0gdmlkZW9TYW1wbGVzO1xuICAgIH1cbiAgICBjb25zdCBpZDNUcmFjayA9IHRoaXMuZXh0cmFjdElEM1RyYWNrKHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQpO1xuICAgIHRleHRUcmFjay5zYW1wbGVzID0gcGFyc2VTYW1wbGVzKHRpbWVPZmZzZXQsIHZpZGVvVHJhY2spO1xuICAgIHJldHVybiB7XG4gICAgICB2aWRlb1RyYWNrLFxuICAgICAgYXVkaW9UcmFjazogdGhpcy5hdWRpb1RyYWNrLFxuICAgICAgaWQzVHJhY2ssXG4gICAgICB0ZXh0VHJhY2s6IHRoaXMudHh0VHJhY2tcbiAgICB9O1xuICB9XG4gIGZsdXNoKCkge1xuICAgIGNvbnN0IHRpbWVPZmZzZXQgPSB0aGlzLnRpbWVPZmZzZXQ7XG4gICAgY29uc3QgdmlkZW9UcmFjayA9IHRoaXMudmlkZW9UcmFjaztcbiAgICBjb25zdCB0ZXh0VHJhY2sgPSB0aGlzLnR4dFRyYWNrO1xuICAgIHZpZGVvVHJhY2suc2FtcGxlcyA9IHRoaXMucmVtYWluZGVyRGF0YSB8fCBuZXcgVWludDhBcnJheSgpO1xuICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgY29uc3QgaWQzVHJhY2sgPSB0aGlzLmV4dHJhY3RJRDNUcmFjayh2aWRlb1RyYWNrLCB0aGlzLnRpbWVPZmZzZXQpO1xuICAgIHRleHRUcmFjay5zYW1wbGVzID0gcGFyc2VTYW1wbGVzKHRpbWVPZmZzZXQsIHZpZGVvVHJhY2spO1xuICAgIHJldHVybiB7XG4gICAgICB2aWRlb1RyYWNrLFxuICAgICAgYXVkaW9UcmFjazogZHVtbXlUcmFjaygpLFxuICAgICAgaWQzVHJhY2ssXG4gICAgICB0ZXh0VHJhY2s6IGR1bW15VHJhY2soKVxuICAgIH07XG4gIH1cbiAgZXh0cmFjdElEM1RyYWNrKHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQpIHtcbiAgICBjb25zdCBpZDNUcmFjayA9IHRoaXMuaWQzVHJhY2s7XG4gICAgaWYgKHZpZGVvVHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGVtc2dzID0gZmluZEJveCh2aWRlb1RyYWNrLnNhbXBsZXMsIFsnZW1zZyddKTtcbiAgICAgIGlmIChlbXNncykge1xuICAgICAgICBlbXNncy5mb3JFYWNoKGRhdGEgPT4ge1xuICAgICAgICAgIGNvbnN0IGVtc2dJbmZvID0gcGFyc2VFbXNnKGRhdGEpO1xuICAgICAgICAgIGlmIChlbXNnU2NoZW1lUGF0dGVybi50ZXN0KGVtc2dJbmZvLnNjaGVtZUlkVXJpKSkge1xuICAgICAgICAgICAgY29uc3QgcHRzID0gaXNGaW5pdGVOdW1iZXIoZW1zZ0luZm8ucHJlc2VudGF0aW9uVGltZSkgPyBlbXNnSW5mby5wcmVzZW50YXRpb25UaW1lIC8gZW1zZ0luZm8udGltZVNjYWxlIDogdGltZU9mZnNldCArIGVtc2dJbmZvLnByZXNlbnRhdGlvblRpbWVEZWx0YSAvIGVtc2dJbmZvLnRpbWVTY2FsZTtcbiAgICAgICAgICAgIGxldCBkdXJhdGlvbiA9IGVtc2dJbmZvLmV2ZW50RHVyYXRpb24gPT09IDB4ZmZmZmZmZmYgPyBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgOiBlbXNnSW5mby5ldmVudER1cmF0aW9uIC8gZW1zZ0luZm8udGltZVNjYWxlO1xuICAgICAgICAgICAgLy8gU2FmYXJpIHRha2VzIGFueXRoaW5nIDw9IDAuMDAxIHNlY29uZHMgYW5kIG1hcHMgaXQgdG8gSW5maW5pdHlcbiAgICAgICAgICAgIGlmIChkdXJhdGlvbiA8PSAwLjAwMSkge1xuICAgICAgICAgICAgICBkdXJhdGlvbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBlbXNnSW5mby5wYXlsb2FkO1xuICAgICAgICAgICAgaWQzVHJhY2suc2FtcGxlcy5wdXNoKHtcbiAgICAgICAgICAgICAgZGF0YTogcGF5bG9hZCxcbiAgICAgICAgICAgICAgbGVuOiBwYXlsb2FkLmJ5dGVMZW5ndGgsXG4gICAgICAgICAgICAgIGR0czogcHRzLFxuICAgICAgICAgICAgICBwdHM6IHB0cyxcbiAgICAgICAgICAgICAgdHlwZTogTWV0YWRhdGFTY2hlbWEuZW1zZyxcbiAgICAgICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaWQzVHJhY2s7XG4gIH1cbiAgZGVtdXhTYW1wbGVBZXMoZGF0YSwga2V5RGF0YSwgdGltZU9mZnNldCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1RoZSBNUDQgZGVtdXhlciBkb2VzIG5vdCBzdXBwb3J0IFNBTVBMRS1BRVMgZGVjcnlwdGlvbicpKTtcbiAgfVxuICBkZXN0cm95KCkge31cbn1cblxuY29uc3QgZ2V0QXVkaW9CU0lEID0gKGRhdGEsIG9mZnNldCkgPT4ge1xuICAvLyBjaGVjayB0aGUgYnNpZCB0byBjb25maXJtIGFjLTMgfCBlYy0zXG4gIGxldCBic2lkID0gMDtcbiAgbGV0IG51bUJpdHMgPSA1O1xuICBvZmZzZXQgKz0gbnVtQml0cztcbiAgY29uc3QgdGVtcCA9IG5ldyBVaW50MzJBcnJheSgxKTsgLy8gdW5zaWduZWQgMzIgYml0IGZvciB0ZW1wb3Jhcnkgc3RvcmFnZVxuICBjb25zdCBtYXNrID0gbmV3IFVpbnQzMkFycmF5KDEpOyAvLyB1bnNpZ25lZCAzMiBiaXQgbWFzayB2YWx1ZVxuICBjb25zdCBieXRlID0gbmV3IFVpbnQ4QXJyYXkoMSk7IC8vIHVuc2lnbmVkIDggYml0IGZvciB0ZW1wb3Jhcnkgc3RvcmFnZVxuICB3aGlsZSAobnVtQml0cyA+IDApIHtcbiAgICBieXRlWzBdID0gZGF0YVtvZmZzZXRdO1xuICAgIC8vIHJlYWQgcmVtYWluaW5nIGJpdHMsIHVwdG8gOCBiaXRzIGF0IGEgdGltZVxuICAgIGNvbnN0IGJpdHMgPSBNYXRoLm1pbihudW1CaXRzLCA4KTtcbiAgICBjb25zdCBzaGlmdCA9IDggLSBiaXRzO1xuICAgIG1hc2tbMF0gPSAweGZmMDAwMDAwID4+PiAyNCArIHNoaWZ0IDw8IHNoaWZ0O1xuICAgIHRlbXBbMF0gPSAoYnl0ZVswXSAmIG1hc2tbMF0pID4+IHNoaWZ0O1xuICAgIGJzaWQgPSAhYnNpZCA/IHRlbXBbMF0gOiBic2lkIDw8IGJpdHMgfCB0ZW1wWzBdO1xuICAgIG9mZnNldCArPSAxO1xuICAgIG51bUJpdHMgLT0gYml0cztcbiAgfVxuICByZXR1cm4gYnNpZDtcbn07XG5cbmNsYXNzIEFDM0RlbXV4ZXIgZXh0ZW5kcyBCYXNlQXVkaW9EZW11eGVyIHtcbiAgY29uc3RydWN0b3Iob2JzZXJ2ZXIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICB9XG4gIHJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRyYWNrRHVyYXRpb24pIHtcbiAgICBzdXBlci5yZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0cmFja0R1cmF0aW9uKTtcbiAgICB0aGlzLl9hdWRpb1RyYWNrID0ge1xuICAgICAgY29udGFpbmVyOiAnYXVkaW8vYWMtMycsXG4gICAgICB0eXBlOiAnYXVkaW8nLFxuICAgICAgaWQ6IDIsXG4gICAgICBwaWQ6IC0xLFxuICAgICAgc2VxdWVuY2VOdW1iZXI6IDAsXG4gICAgICBzZWdtZW50Q29kZWM6ICdhYzMnLFxuICAgICAgc2FtcGxlczogW10sXG4gICAgICBtYW5pZmVzdENvZGVjOiBhdWRpb0NvZGVjLFxuICAgICAgZHVyYXRpb246IHRyYWNrRHVyYXRpb24sXG4gICAgICBpbnB1dFRpbWVTY2FsZTogOTAwMDAsXG4gICAgICBkcm9wcGVkOiAwXG4gICAgfTtcbiAgfVxuICBjYW5QYXJzZShkYXRhLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gb2Zmc2V0ICsgNjQgPCBkYXRhLmxlbmd0aDtcbiAgfVxuICBhcHBlbmRGcmFtZSh0cmFjaywgZGF0YSwgb2Zmc2V0KSB7XG4gICAgY29uc3QgZnJhbWVMZW5ndGggPSBhcHBlbmRGcmFtZSh0cmFjaywgZGF0YSwgb2Zmc2V0LCB0aGlzLmJhc2VQVFMsIHRoaXMuZnJhbWVJbmRleCk7XG4gICAgaWYgKGZyYW1lTGVuZ3RoICE9PSAtMSkge1xuICAgICAgY29uc3Qgc2FtcGxlID0gdHJhY2suc2FtcGxlc1t0cmFjay5zYW1wbGVzLmxlbmd0aCAtIDFdO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2FtcGxlLFxuICAgICAgICBsZW5ndGg6IGZyYW1lTGVuZ3RoLFxuICAgICAgICBtaXNzaW5nOiAwXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBzdGF0aWMgcHJvYmUoZGF0YSkge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBpZDNEYXRhID0gZ2V0SUQzRGF0YShkYXRhLCAwKTtcbiAgICBpZiAoIWlkM0RhdGEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBsb29rIGZvciB0aGUgYWMtMyBzeW5jIGJ5dGVzXG4gICAgY29uc3Qgb2Zmc2V0ID0gaWQzRGF0YS5sZW5ndGg7XG4gICAgaWYgKGRhdGFbb2Zmc2V0XSA9PT0gMHgwYiAmJiBkYXRhW29mZnNldCArIDFdID09PSAweDc3ICYmIGdldFRpbWVTdGFtcChpZDNEYXRhKSAhPT0gdW5kZWZpbmVkICYmXG4gICAgLy8gY2hlY2sgdGhlIGJzaWQgdG8gY29uZmlybSBhYy0zXG4gICAgZ2V0QXVkaW9CU0lEKGRhdGEsIG9mZnNldCkgPCAxNikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIHN0YXJ0LCBwdHMsIGZyYW1lSW5kZXgpIHtcbiAgaWYgKHN0YXJ0ICsgOCA+IGRhdGEubGVuZ3RoKSB7XG4gICAgcmV0dXJuIC0xOyAvLyBub3QgZW5vdWdoIGJ5dGVzIGxlZnRcbiAgfVxuICBpZiAoZGF0YVtzdGFydF0gIT09IDB4MGIgfHwgZGF0YVtzdGFydCArIDFdICE9PSAweDc3KSB7XG4gICAgcmV0dXJuIC0xOyAvLyBpbnZhbGlkIG1hZ2ljXG4gIH1cblxuICAvLyBnZXQgc2FtcGxlIHJhdGVcbiAgY29uc3Qgc2FtcGxpbmdSYXRlQ29kZSA9IGRhdGFbc3RhcnQgKyA0XSA+PiA2O1xuICBpZiAoc2FtcGxpbmdSYXRlQ29kZSA+PSAzKSB7XG4gICAgcmV0dXJuIC0xOyAvLyBpbnZhbGlkIHNhbXBsaW5nIHJhdGVcbiAgfVxuICBjb25zdCBzYW1wbGluZ1JhdGVNYXAgPSBbNDgwMDAsIDQ0MTAwLCAzMjAwMF07XG4gIGNvbnN0IHNhbXBsZVJhdGUgPSBzYW1wbGluZ1JhdGVNYXBbc2FtcGxpbmdSYXRlQ29kZV07XG5cbiAgLy8gZ2V0IGZyYW1lIHNpemVcbiAgY29uc3QgZnJhbWVTaXplQ29kZSA9IGRhdGFbc3RhcnQgKyA0XSAmIDB4M2Y7XG4gIGNvbnN0IGZyYW1lU2l6ZU1hcCA9IFs2NCwgNjksIDk2LCA2NCwgNzAsIDk2LCA4MCwgODcsIDEyMCwgODAsIDg4LCAxMjAsIDk2LCAxMDQsIDE0NCwgOTYsIDEwNSwgMTQ0LCAxMTIsIDEyMSwgMTY4LCAxMTIsIDEyMiwgMTY4LCAxMjgsIDEzOSwgMTkyLCAxMjgsIDE0MCwgMTkyLCAxNjAsIDE3NCwgMjQwLCAxNjAsIDE3NSwgMjQwLCAxOTIsIDIwOCwgMjg4LCAxOTIsIDIwOSwgMjg4LCAyMjQsIDI0MywgMzM2LCAyMjQsIDI0NCwgMzM2LCAyNTYsIDI3OCwgMzg0LCAyNTYsIDI3OSwgMzg0LCAzMjAsIDM0OCwgNDgwLCAzMjAsIDM0OSwgNDgwLCAzODQsIDQxNywgNTc2LCAzODQsIDQxOCwgNTc2LCA0NDgsIDQ4NywgNjcyLCA0NDgsIDQ4OCwgNjcyLCA1MTIsIDU1NywgNzY4LCA1MTIsIDU1OCwgNzY4LCA2NDAsIDY5NiwgOTYwLCA2NDAsIDY5NywgOTYwLCA3NjgsIDgzNSwgMTE1MiwgNzY4LCA4MzYsIDExNTIsIDg5NiwgOTc1LCAxMzQ0LCA4OTYsIDk3NiwgMTM0NCwgMTAyNCwgMTExNCwgMTUzNiwgMTAyNCwgMTExNSwgMTUzNiwgMTE1MiwgMTI1MywgMTcyOCwgMTE1MiwgMTI1NCwgMTcyOCwgMTI4MCwgMTM5MywgMTkyMCwgMTI4MCwgMTM5NCwgMTkyMF07XG4gIGNvbnN0IGZyYW1lTGVuZ3RoID0gZnJhbWVTaXplTWFwW2ZyYW1lU2l6ZUNvZGUgKiAzICsgc2FtcGxpbmdSYXRlQ29kZV0gKiAyO1xuICBpZiAoc3RhcnQgKyBmcmFtZUxlbmd0aCA+IGRhdGEubGVuZ3RoKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLy8gZ2V0IGNoYW5uZWwgY291bnRcbiAgY29uc3QgY2hhbm5lbE1vZGUgPSBkYXRhW3N0YXJ0ICsgNl0gPj4gNTtcbiAgbGV0IHNraXBDb3VudCA9IDA7XG4gIGlmIChjaGFubmVsTW9kZSA9PT0gMikge1xuICAgIHNraXBDb3VudCArPSAyO1xuICB9IGVsc2Uge1xuICAgIGlmIChjaGFubmVsTW9kZSAmIDEgJiYgY2hhbm5lbE1vZGUgIT09IDEpIHtcbiAgICAgIHNraXBDb3VudCArPSAyO1xuICAgIH1cbiAgICBpZiAoY2hhbm5lbE1vZGUgJiA0KSB7XG4gICAgICBza2lwQ291bnQgKz0gMjtcbiAgICB9XG4gIH1cbiAgY29uc3QgbGZlb24gPSAoZGF0YVtzdGFydCArIDZdIDw8IDggfCBkYXRhW3N0YXJ0ICsgN10pID4+IDEyIC0gc2tpcENvdW50ICYgMTtcbiAgY29uc3QgY2hhbm5lbHNNYXAgPSBbMiwgMSwgMiwgMywgMywgNCwgNCwgNV07XG4gIGNvbnN0IGNoYW5uZWxDb3VudCA9IGNoYW5uZWxzTWFwW2NoYW5uZWxNb2RlXSArIGxmZW9uO1xuXG4gIC8vIGJ1aWxkIGRhYzMgYm94XG4gIGNvbnN0IGJzaWQgPSBkYXRhW3N0YXJ0ICsgNV0gPj4gMztcbiAgY29uc3QgYnNtb2QgPSBkYXRhW3N0YXJ0ICsgNV0gJiA3O1xuICBjb25zdCBjb25maWcgPSBuZXcgVWludDhBcnJheShbc2FtcGxpbmdSYXRlQ29kZSA8PCA2IHwgYnNpZCA8PCAxIHwgYnNtb2QgPj4gMiwgKGJzbW9kICYgMykgPDwgNiB8IGNoYW5uZWxNb2RlIDw8IDMgfCBsZmVvbiA8PCAyIHwgZnJhbWVTaXplQ29kZSA+PiA0LCBmcmFtZVNpemVDb2RlIDw8IDQgJiAweGUwXSk7XG4gIGNvbnN0IGZyYW1lRHVyYXRpb24gPSAxNTM2IC8gc2FtcGxlUmF0ZSAqIDkwMDAwO1xuICBjb25zdCBzdGFtcCA9IHB0cyArIGZyYW1lSW5kZXggKiBmcmFtZUR1cmF0aW9uO1xuICBjb25zdCB1bml0ID0gZGF0YS5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBmcmFtZUxlbmd0aCk7XG4gIHRyYWNrLmNvbmZpZyA9IGNvbmZpZztcbiAgdHJhY2suY2hhbm5lbENvdW50ID0gY2hhbm5lbENvdW50O1xuICB0cmFjay5zYW1wbGVyYXRlID0gc2FtcGxlUmF0ZTtcbiAgdHJhY2suc2FtcGxlcy5wdXNoKHtcbiAgICB1bml0LFxuICAgIHB0czogc3RhbXBcbiAgfSk7XG4gIHJldHVybiBmcmFtZUxlbmd0aDtcbn1cblxuY2xhc3MgQmFzZVZpZGVvUGFyc2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5WaWRlb1NhbXBsZSA9IG51bGw7XG4gIH1cbiAgY3JlYXRlVmlkZW9TYW1wbGUoa2V5LCBwdHMsIGR0cywgZGVidWcpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2V5LFxuICAgICAgZnJhbWU6IGZhbHNlLFxuICAgICAgcHRzLFxuICAgICAgZHRzLFxuICAgICAgdW5pdHM6IFtdLFxuICAgICAgZGVidWcsXG4gICAgICBsZW5ndGg6IDBcbiAgICB9O1xuICB9XG4gIGdldExhc3ROYWxVbml0KHNhbXBsZXMpIHtcbiAgICB2YXIgX1ZpZGVvU2FtcGxlO1xuICAgIGxldCBWaWRlb1NhbXBsZSA9IHRoaXMuVmlkZW9TYW1wbGU7XG4gICAgbGV0IGxhc3RVbml0O1xuICAgIC8vIHRyeSB0byBmYWxsYmFjayB0byBwcmV2aW91cyBzYW1wbGUgaWYgY3VycmVudCBvbmUgaXMgZW1wdHlcbiAgICBpZiAoIVZpZGVvU2FtcGxlIHx8IFZpZGVvU2FtcGxlLnVuaXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgVmlkZW9TYW1wbGUgPSBzYW1wbGVzW3NhbXBsZXMubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIGlmICgoX1ZpZGVvU2FtcGxlID0gVmlkZW9TYW1wbGUpICE9IG51bGwgJiYgX1ZpZGVvU2FtcGxlLnVuaXRzKSB7XG4gICAgICBjb25zdCB1bml0cyA9IFZpZGVvU2FtcGxlLnVuaXRzO1xuICAgICAgbGFzdFVuaXQgPSB1bml0c1t1bml0cy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgcmV0dXJuIGxhc3RVbml0O1xuICB9XG4gIHB1c2hBY2Nlc3NVbml0KFZpZGVvU2FtcGxlLCB2aWRlb1RyYWNrKSB7XG4gICAgaWYgKFZpZGVvU2FtcGxlLnVuaXRzLmxlbmd0aCAmJiBWaWRlb1NhbXBsZS5mcmFtZSkge1xuICAgICAgLy8gaWYgc2FtcGxlIGRvZXMgbm90IGhhdmUgUFRTL0RUUywgcGF0Y2ggd2l0aCBsYXN0IHNhbXBsZSBQVFMvRFRTXG4gICAgICBpZiAoVmlkZW9TYW1wbGUucHRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qgc2FtcGxlcyA9IHZpZGVvVHJhY2suc2FtcGxlcztcbiAgICAgICAgY29uc3QgbmJTYW1wbGVzID0gc2FtcGxlcy5sZW5ndGg7XG4gICAgICAgIGlmIChuYlNhbXBsZXMpIHtcbiAgICAgICAgICBjb25zdCBsYXN0U2FtcGxlID0gc2FtcGxlc1tuYlNhbXBsZXMgLSAxXTtcbiAgICAgICAgICBWaWRlb1NhbXBsZS5wdHMgPSBsYXN0U2FtcGxlLnB0cztcbiAgICAgICAgICBWaWRlb1NhbXBsZS5kdHMgPSBsYXN0U2FtcGxlLmR0cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBkcm9wcGluZyBzYW1wbGVzLCBubyB0aW1lc3RhbXAgZm91bmRcbiAgICAgICAgICB2aWRlb1RyYWNrLmRyb3BwZWQrKztcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZpZGVvVHJhY2suc2FtcGxlcy5wdXNoKFZpZGVvU2FtcGxlKTtcbiAgICB9XG4gICAgaWYgKFZpZGVvU2FtcGxlLmRlYnVnLmxlbmd0aCkge1xuICAgICAgbG9nZ2VyLmxvZyhWaWRlb1NhbXBsZS5wdHMgKyAnLycgKyBWaWRlb1NhbXBsZS5kdHMgKyAnOicgKyBWaWRlb1NhbXBsZS5kZWJ1Zyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUGFyc2VyIGZvciBleHBvbmVudGlhbCBHb2xvbWIgY29kZXMsIGEgdmFyaWFibGUtYml0d2lkdGggbnVtYmVyIGVuY29kaW5nIHNjaGVtZSB1c2VkIGJ5IGgyNjQuXG4gKi9cblxuY2xhc3MgRXhwR29sb21iIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHRoaXMuZGF0YSA9IHZvaWQgMDtcbiAgICB0aGlzLmJ5dGVzQXZhaWxhYmxlID0gdm9pZCAwO1xuICAgIHRoaXMud29yZCA9IHZvaWQgMDtcbiAgICB0aGlzLmJpdHNBdmFpbGFibGUgPSB2b2lkIDA7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAvLyB0aGUgbnVtYmVyIG9mIGJ5dGVzIGxlZnQgdG8gZXhhbWluZSBpbiB0aGlzLmRhdGFcbiAgICB0aGlzLmJ5dGVzQXZhaWxhYmxlID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgIC8vIHRoZSBjdXJyZW50IHdvcmQgYmVpbmcgZXhhbWluZWRcbiAgICB0aGlzLndvcmQgPSAwOyAvLyA6dWludFxuICAgIC8vIHRoZSBudW1iZXIgb2YgYml0cyBsZWZ0IHRvIGV4YW1pbmUgaW4gdGhlIGN1cnJlbnQgd29yZFxuICAgIHRoaXMuYml0c0F2YWlsYWJsZSA9IDA7IC8vIDp1aW50XG4gIH1cblxuICAvLyAoKTp2b2lkXG4gIGxvYWRXb3JkKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3QgYnl0ZXNBdmFpbGFibGUgPSB0aGlzLmJ5dGVzQXZhaWxhYmxlO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gZGF0YS5ieXRlTGVuZ3RoIC0gYnl0ZXNBdmFpbGFibGU7XG4gICAgY29uc3Qgd29ya2luZ0J5dGVzID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgY29uc3QgYXZhaWxhYmxlQnl0ZXMgPSBNYXRoLm1pbig0LCBieXRlc0F2YWlsYWJsZSk7XG4gICAgaWYgKGF2YWlsYWJsZUJ5dGVzID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGJ5dGVzIGF2YWlsYWJsZScpO1xuICAgIH1cbiAgICB3b3JraW5nQnl0ZXMuc2V0KGRhdGEuc3ViYXJyYXkocG9zaXRpb24sIHBvc2l0aW9uICsgYXZhaWxhYmxlQnl0ZXMpKTtcbiAgICB0aGlzLndvcmQgPSBuZXcgRGF0YVZpZXcod29ya2luZ0J5dGVzLmJ1ZmZlcikuZ2V0VWludDMyKDApO1xuICAgIC8vIHRyYWNrIHRoZSBhbW91bnQgb2YgdGhpcy5kYXRhIHRoYXQgaGFzIGJlZW4gcHJvY2Vzc2VkXG4gICAgdGhpcy5iaXRzQXZhaWxhYmxlID0gYXZhaWxhYmxlQnl0ZXMgKiA4O1xuICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgLT0gYXZhaWxhYmxlQnl0ZXM7XG4gIH1cblxuICAvLyAoY291bnQ6aW50KTp2b2lkXG4gIHNraXBCaXRzKGNvdW50KSB7XG4gICAgbGV0IHNraXBCeXRlczsgLy8gOmludFxuICAgIGNvdW50ID0gTWF0aC5taW4oY291bnQsIHRoaXMuYnl0ZXNBdmFpbGFibGUgKiA4ICsgdGhpcy5iaXRzQXZhaWxhYmxlKTtcbiAgICBpZiAodGhpcy5iaXRzQXZhaWxhYmxlID4gY291bnQpIHtcbiAgICAgIHRoaXMud29yZCA8PD0gY291bnQ7XG4gICAgICB0aGlzLmJpdHNBdmFpbGFibGUgLT0gY291bnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50IC09IHRoaXMuYml0c0F2YWlsYWJsZTtcbiAgICAgIHNraXBCeXRlcyA9IGNvdW50ID4+IDM7XG4gICAgICBjb3VudCAtPSBza2lwQnl0ZXMgPDwgMztcbiAgICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgLT0gc2tpcEJ5dGVzO1xuICAgICAgdGhpcy5sb2FkV29yZCgpO1xuICAgICAgdGhpcy53b3JkIDw8PSBjb3VudDtcbiAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBjb3VudDtcbiAgICB9XG4gIH1cblxuICAvLyAoc2l6ZTppbnQpOnVpbnRcbiAgcmVhZEJpdHMoc2l6ZSkge1xuICAgIGxldCBiaXRzID0gTWF0aC5taW4odGhpcy5iaXRzQXZhaWxhYmxlLCBzaXplKTsgLy8gOnVpbnRcbiAgICBjb25zdCB2YWx1ID0gdGhpcy53b3JkID4+PiAzMiAtIGJpdHM7IC8vIDp1aW50XG4gICAgaWYgKHNpemUgPiAzMikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdDYW5ub3QgcmVhZCBtb3JlIHRoYW4gMzIgYml0cyBhdCBhIHRpbWUnKTtcbiAgICB9XG4gICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGJpdHM7XG4gICAgaWYgKHRoaXMuYml0c0F2YWlsYWJsZSA+IDApIHtcbiAgICAgIHRoaXMud29yZCA8PD0gYml0cztcbiAgICB9IGVsc2UgaWYgKHRoaXMuYnl0ZXNBdmFpbGFibGUgPiAwKSB7XG4gICAgICB0aGlzLmxvYWRXb3JkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gYml0cyBhdmFpbGFibGUnKTtcbiAgICB9XG4gICAgYml0cyA9IHNpemUgLSBiaXRzO1xuICAgIGlmIChiaXRzID4gMCAmJiB0aGlzLmJpdHNBdmFpbGFibGUpIHtcbiAgICAgIHJldHVybiB2YWx1IDw8IGJpdHMgfCB0aGlzLnJlYWRCaXRzKGJpdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsdTtcbiAgICB9XG4gIH1cblxuICAvLyAoKTp1aW50XG4gIHNraXBMWigpIHtcbiAgICBsZXQgbGVhZGluZ1plcm9Db3VudDsgLy8gOnVpbnRcbiAgICBmb3IgKGxlYWRpbmdaZXJvQ291bnQgPSAwOyBsZWFkaW5nWmVyb0NvdW50IDwgdGhpcy5iaXRzQXZhaWxhYmxlOyArK2xlYWRpbmdaZXJvQ291bnQpIHtcbiAgICAgIGlmICgodGhpcy53b3JkICYgMHg4MDAwMDAwMCA+Pj4gbGVhZGluZ1plcm9Db3VudCkgIT09IDApIHtcbiAgICAgICAgLy8gdGhlIGZpcnN0IGJpdCBvZiB3b3JraW5nIHdvcmQgaXMgMVxuICAgICAgICB0aGlzLndvcmQgPDw9IGxlYWRpbmdaZXJvQ291bnQ7XG4gICAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBsZWFkaW5nWmVyb0NvdW50O1xuICAgICAgICByZXR1cm4gbGVhZGluZ1plcm9Db3VudDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gd2UgZXhoYXVzdGVkIHdvcmQgYW5kIHN0aWxsIGhhdmUgbm90IGZvdW5kIGEgMVxuICAgIHRoaXMubG9hZFdvcmQoKTtcbiAgICByZXR1cm4gbGVhZGluZ1plcm9Db3VudCArIHRoaXMuc2tpcExaKCk7XG4gIH1cblxuICAvLyAoKTp2b2lkXG4gIHNraXBVRUcoKSB7XG4gICAgdGhpcy5za2lwQml0cygxICsgdGhpcy5za2lwTFooKSk7XG4gIH1cblxuICAvLyAoKTp2b2lkXG4gIHNraXBFRygpIHtcbiAgICB0aGlzLnNraXBCaXRzKDEgKyB0aGlzLnNraXBMWigpKTtcbiAgfVxuXG4gIC8vICgpOnVpbnRcbiAgcmVhZFVFRygpIHtcbiAgICBjb25zdCBjbHogPSB0aGlzLnNraXBMWigpOyAvLyA6dWludFxuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKGNseiArIDEpIC0gMTtcbiAgfVxuXG4gIC8vICgpOmludFxuICByZWFkRUcoKSB7XG4gICAgY29uc3QgdmFsdSA9IHRoaXMucmVhZFVFRygpOyAvLyA6aW50XG4gICAgaWYgKDB4MDEgJiB2YWx1KSB7XG4gICAgICAvLyB0aGUgbnVtYmVyIGlzIG9kZCBpZiB0aGUgbG93IG9yZGVyIGJpdCBpcyBzZXRcbiAgICAgIHJldHVybiAxICsgdmFsdSA+Pj4gMTsgLy8gYWRkIDEgdG8gbWFrZSBpdCBldmVuLCBhbmQgZGl2aWRlIGJ5IDJcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIC0xICogKHZhbHUgPj4+IDEpOyAvLyBkaXZpZGUgYnkgdHdvIHRoZW4gbWFrZSBpdCBuZWdhdGl2ZVxuICAgIH1cbiAgfVxuXG4gIC8vIFNvbWUgY29udmVuaWVuY2UgZnVuY3Rpb25zXG4gIC8vIDpCb29sZWFuXG4gIHJlYWRCb29sZWFuKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDEpID09PSAxO1xuICB9XG5cbiAgLy8gKCk6aW50XG4gIHJlYWRVQnl0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkQml0cyg4KTtcbiAgfVxuXG4gIC8vICgpOmludFxuICByZWFkVVNob3J0KCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDE2KTtcbiAgfVxuXG4gIC8vICgpOmludFxuICByZWFkVUludCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkQml0cygzMik7XG4gIH1cblxuICAvKipcbiAgICogQWR2YW5jZSB0aGUgRXhwR29sb21iIGRlY29kZXIgcGFzdCBhIHNjYWxpbmcgbGlzdC4gVGhlIHNjYWxpbmdcbiAgICogbGlzdCBpcyBvcHRpb25hbGx5IHRyYW5zbWl0dGVkIGFzIHBhcnQgb2YgYSBzZXF1ZW5jZSBwYXJhbWV0ZXJcbiAgICogc2V0IGFuZCBpcyBub3QgcmVsZXZhbnQgdG8gdHJhbnNtdXhpbmcuXG4gICAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhpcyBzY2FsaW5nIGxpc3RcbiAgICogQHNlZSBSZWNvbW1lbmRhdGlvbiBJVFUtVCBILjI2NCwgU2VjdGlvbiA3LjMuMi4xLjEuMVxuICAgKi9cbiAgc2tpcFNjYWxpbmdMaXN0KGNvdW50KSB7XG4gICAgbGV0IGxhc3RTY2FsZSA9IDg7XG4gICAgbGV0IG5leHRTY2FsZSA9IDg7XG4gICAgbGV0IGRlbHRhU2NhbGU7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICBpZiAobmV4dFNjYWxlICE9PSAwKSB7XG4gICAgICAgIGRlbHRhU2NhbGUgPSB0aGlzLnJlYWRFRygpO1xuICAgICAgICBuZXh0U2NhbGUgPSAobGFzdFNjYWxlICsgZGVsdGFTY2FsZSArIDI1NikgJSAyNTY7XG4gICAgICB9XG4gICAgICBsYXN0U2NhbGUgPSBuZXh0U2NhbGUgPT09IDAgPyBsYXN0U2NhbGUgOiBuZXh0U2NhbGU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgYSBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0IGFuZCByZXR1cm4gc29tZSBpbnRlcmVzdGluZyB2aWRlb1xuICAgKiBwcm9wZXJ0aWVzLiBBIHNlcXVlbmNlIHBhcmFtZXRlciBzZXQgaXMgdGhlIEgyNjQgbWV0YWRhdGEgdGhhdFxuICAgKiBkZXNjcmliZXMgdGhlIHByb3BlcnRpZXMgb2YgdXBjb21pbmcgdmlkZW8gZnJhbWVzLlxuICAgKiBAcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBjb25maWd1cmF0aW9uIHBhcnNlZCBmcm9tIHRoZVxuICAgKiBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0LCBpbmNsdWRpbmcgdGhlIGRpbWVuc2lvbnMgb2YgdGhlXG4gICAqIGFzc29jaWF0ZWQgdmlkZW8gZnJhbWVzLlxuICAgKi9cbiAgcmVhZFNQUygpIHtcbiAgICBsZXQgZnJhbWVDcm9wTGVmdE9mZnNldCA9IDA7XG4gICAgbGV0IGZyYW1lQ3JvcFJpZ2h0T2Zmc2V0ID0gMDtcbiAgICBsZXQgZnJhbWVDcm9wVG9wT2Zmc2V0ID0gMDtcbiAgICBsZXQgZnJhbWVDcm9wQm90dG9tT2Zmc2V0ID0gMDtcbiAgICBsZXQgbnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlO1xuICAgIGxldCBzY2FsaW5nTGlzdENvdW50O1xuICAgIGxldCBpO1xuICAgIGNvbnN0IHJlYWRVQnl0ZSA9IHRoaXMucmVhZFVCeXRlLmJpbmQodGhpcyk7XG4gICAgY29uc3QgcmVhZEJpdHMgPSB0aGlzLnJlYWRCaXRzLmJpbmQodGhpcyk7XG4gICAgY29uc3QgcmVhZFVFRyA9IHRoaXMucmVhZFVFRy5iaW5kKHRoaXMpO1xuICAgIGNvbnN0IHJlYWRCb29sZWFuID0gdGhpcy5yZWFkQm9vbGVhbi5iaW5kKHRoaXMpO1xuICAgIGNvbnN0IHNraXBCaXRzID0gdGhpcy5za2lwQml0cy5iaW5kKHRoaXMpO1xuICAgIGNvbnN0IHNraXBFRyA9IHRoaXMuc2tpcEVHLmJpbmQodGhpcyk7XG4gICAgY29uc3Qgc2tpcFVFRyA9IHRoaXMuc2tpcFVFRy5iaW5kKHRoaXMpO1xuICAgIGNvbnN0IHNraXBTY2FsaW5nTGlzdCA9IHRoaXMuc2tpcFNjYWxpbmdMaXN0LmJpbmQodGhpcyk7XG4gICAgcmVhZFVCeXRlKCk7XG4gICAgY29uc3QgcHJvZmlsZUlkYyA9IHJlYWRVQnl0ZSgpOyAvLyBwcm9maWxlX2lkY1xuICAgIHJlYWRCaXRzKDUpOyAvLyBwcm9maWxlQ29tcGF0IGNvbnN0cmFpbnRfc2V0WzAtNF1fZmxhZywgdSg1KVxuICAgIHNraXBCaXRzKDMpOyAvLyByZXNlcnZlZF96ZXJvXzNiaXRzIHUoMyksXG4gICAgcmVhZFVCeXRlKCk7IC8vIGxldmVsX2lkYyB1KDgpXG4gICAgc2tpcFVFRygpOyAvLyBzZXFfcGFyYW1ldGVyX3NldF9pZFxuICAgIC8vIHNvbWUgcHJvZmlsZXMgaGF2ZSBtb3JlIG9wdGlvbmFsIGRhdGEgd2UgZG9uJ3QgbmVlZFxuICAgIGlmIChwcm9maWxlSWRjID09PSAxMDAgfHwgcHJvZmlsZUlkYyA9PT0gMTEwIHx8IHByb2ZpbGVJZGMgPT09IDEyMiB8fCBwcm9maWxlSWRjID09PSAyNDQgfHwgcHJvZmlsZUlkYyA9PT0gNDQgfHwgcHJvZmlsZUlkYyA9PT0gODMgfHwgcHJvZmlsZUlkYyA9PT0gODYgfHwgcHJvZmlsZUlkYyA9PT0gMTE4IHx8IHByb2ZpbGVJZGMgPT09IDEyOCkge1xuICAgICAgY29uc3QgY2hyb21hRm9ybWF0SWRjID0gcmVhZFVFRygpO1xuICAgICAgaWYgKGNocm9tYUZvcm1hdElkYyA9PT0gMykge1xuICAgICAgICBza2lwQml0cygxKTtcbiAgICAgIH0gLy8gc2VwYXJhdGVfY29sb3VyX3BsYW5lX2ZsYWdcblxuICAgICAgc2tpcFVFRygpOyAvLyBiaXRfZGVwdGhfbHVtYV9taW51czhcbiAgICAgIHNraXBVRUcoKTsgLy8gYml0X2RlcHRoX2Nocm9tYV9taW51czhcbiAgICAgIHNraXBCaXRzKDEpOyAvLyBxcHByaW1lX3lfemVyb190cmFuc2Zvcm1fYnlwYXNzX2ZsYWdcbiAgICAgIGlmIChyZWFkQm9vbGVhbigpKSB7XG4gICAgICAgIC8vIHNlcV9zY2FsaW5nX21hdHJpeF9wcmVzZW50X2ZsYWdcbiAgICAgICAgc2NhbGluZ0xpc3RDb3VudCA9IGNocm9tYUZvcm1hdElkYyAhPT0gMyA/IDggOiAxMjtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNjYWxpbmdMaXN0Q291bnQ7IGkrKykge1xuICAgICAgICAgIGlmIChyZWFkQm9vbGVhbigpKSB7XG4gICAgICAgICAgICAvLyBzZXFfc2NhbGluZ19saXN0X3ByZXNlbnRfZmxhZ1sgaSBdXG4gICAgICAgICAgICBpZiAoaSA8IDYpIHtcbiAgICAgICAgICAgICAgc2tpcFNjYWxpbmdMaXN0KDE2KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNraXBTY2FsaW5nTGlzdCg2NCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHNraXBVRUcoKTsgLy8gbG9nMl9tYXhfZnJhbWVfbnVtX21pbnVzNFxuICAgIGNvbnN0IHBpY09yZGVyQ250VHlwZSA9IHJlYWRVRUcoKTtcbiAgICBpZiAocGljT3JkZXJDbnRUeXBlID09PSAwKSB7XG4gICAgICByZWFkVUVHKCk7IC8vIGxvZzJfbWF4X3BpY19vcmRlcl9jbnRfbHNiX21pbnVzNFxuICAgIH0gZWxzZSBpZiAocGljT3JkZXJDbnRUeXBlID09PSAxKSB7XG4gICAgICBza2lwQml0cygxKTsgLy8gZGVsdGFfcGljX29yZGVyX2Fsd2F5c196ZXJvX2ZsYWdcbiAgICAgIHNraXBFRygpOyAvLyBvZmZzZXRfZm9yX25vbl9yZWZfcGljXG4gICAgICBza2lwRUcoKTsgLy8gb2Zmc2V0X2Zvcl90b3BfdG9fYm90dG9tX2ZpZWxkXG4gICAgICBudW1SZWZGcmFtZXNJblBpY09yZGVyQ250Q3ljbGUgPSByZWFkVUVHKCk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlOyBpKyspIHtcbiAgICAgICAgc2tpcEVHKCk7XG4gICAgICB9IC8vIG9mZnNldF9mb3JfcmVmX2ZyYW1lWyBpIF1cbiAgICB9XG4gICAgc2tpcFVFRygpOyAvLyBtYXhfbnVtX3JlZl9mcmFtZXNcbiAgICBza2lwQml0cygxKTsgLy8gZ2Fwc19pbl9mcmFtZV9udW1fdmFsdWVfYWxsb3dlZF9mbGFnXG4gICAgY29uc3QgcGljV2lkdGhJbk1ic01pbnVzMSA9IHJlYWRVRUcoKTtcbiAgICBjb25zdCBwaWNIZWlnaHRJbk1hcFVuaXRzTWludXMxID0gcmVhZFVFRygpO1xuICAgIGNvbnN0IGZyYW1lTWJzT25seUZsYWcgPSByZWFkQml0cygxKTtcbiAgICBpZiAoZnJhbWVNYnNPbmx5RmxhZyA9PT0gMCkge1xuICAgICAgc2tpcEJpdHMoMSk7XG4gICAgfSAvLyBtYl9hZGFwdGl2ZV9mcmFtZV9maWVsZF9mbGFnXG5cbiAgICBza2lwQml0cygxKTsgLy8gZGlyZWN0Xzh4OF9pbmZlcmVuY2VfZmxhZ1xuICAgIGlmIChyZWFkQm9vbGVhbigpKSB7XG4gICAgICAvLyBmcmFtZV9jcm9wcGluZ19mbGFnXG4gICAgICBmcmFtZUNyb3BMZWZ0T2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgICAgZnJhbWVDcm9wUmlnaHRPZmZzZXQgPSByZWFkVUVHKCk7XG4gICAgICBmcmFtZUNyb3BUb3BPZmZzZXQgPSByZWFkVUVHKCk7XG4gICAgICBmcmFtZUNyb3BCb3R0b21PZmZzZXQgPSByZWFkVUVHKCk7XG4gICAgfVxuICAgIGxldCBwaXhlbFJhdGlvID0gWzEsIDFdO1xuICAgIGlmIChyZWFkQm9vbGVhbigpKSB7XG4gICAgICAvLyB2dWlfcGFyYW1ldGVyc19wcmVzZW50X2ZsYWdcbiAgICAgIGlmIChyZWFkQm9vbGVhbigpKSB7XG4gICAgICAgIC8vIGFzcGVjdF9yYXRpb19pbmZvX3ByZXNlbnRfZmxhZ1xuICAgICAgICBjb25zdCBhc3BlY3RSYXRpb0lkYyA9IHJlYWRVQnl0ZSgpO1xuICAgICAgICBzd2l0Y2ggKGFzcGVjdFJhdGlvSWRjKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxLCAxXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMTIsIDExXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMTAsIDExXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMTYsIDExXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbNDAsIDMzXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMjQsIDExXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMjAsIDExXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMzIsIDExXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbODAsIDMzXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzE4LCAxMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxNSwgMTFdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbNjQsIDMzXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzE2MCwgOTldO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbNCwgM107XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFszLCAyXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzIsIDFdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyNTU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbcmVhZFVCeXRlKCkgPDwgOCB8IHJlYWRVQnl0ZSgpLCByZWFkVUJ5dGUoKSA8PCA4IHwgcmVhZFVCeXRlKCldO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IE1hdGguY2VpbCgocGljV2lkdGhJbk1ic01pbnVzMSArIDEpICogMTYgLSBmcmFtZUNyb3BMZWZ0T2Zmc2V0ICogMiAtIGZyYW1lQ3JvcFJpZ2h0T2Zmc2V0ICogMiksXG4gICAgICBoZWlnaHQ6ICgyIC0gZnJhbWVNYnNPbmx5RmxhZykgKiAocGljSGVpZ2h0SW5NYXBVbml0c01pbnVzMSArIDEpICogMTYgLSAoZnJhbWVNYnNPbmx5RmxhZyA/IDIgOiA0KSAqIChmcmFtZUNyb3BUb3BPZmZzZXQgKyBmcmFtZUNyb3BCb3R0b21PZmZzZXQpLFxuICAgICAgcGl4ZWxSYXRpbzogcGl4ZWxSYXRpb1xuICAgIH07XG4gIH1cbiAgcmVhZFNsaWNlVHlwZSgpIHtcbiAgICAvLyBza2lwIE5BTHUgdHlwZVxuICAgIHRoaXMucmVhZFVCeXRlKCk7XG4gICAgLy8gZGlzY2FyZCBmaXJzdF9tYl9pbl9zbGljZVxuICAgIHRoaXMucmVhZFVFRygpO1xuICAgIC8vIHJldHVybiBzbGljZV90eXBlXG4gICAgcmV0dXJuIHRoaXMucmVhZFVFRygpO1xuICB9XG59XG5cbmNsYXNzIEF2Y1ZpZGVvUGFyc2VyIGV4dGVuZHMgQmFzZVZpZGVvUGFyc2VyIHtcbiAgcGFyc2VBVkNQRVModHJhY2ssIHRleHRUcmFjaywgcGVzLCBsYXN0LCBkdXJhdGlvbikge1xuICAgIGNvbnN0IHVuaXRzID0gdGhpcy5wYXJzZUFWQ05BTHUodHJhY2ssIHBlcy5kYXRhKTtcbiAgICBsZXQgVmlkZW9TYW1wbGUgPSB0aGlzLlZpZGVvU2FtcGxlO1xuICAgIGxldCBwdXNoO1xuICAgIGxldCBzcHNmb3VuZCA9IGZhbHNlO1xuICAgIC8vIGZyZWUgcGVzLmRhdGEgdG8gc2F2ZSB1cCBzb21lIG1lbW9yeVxuICAgIHBlcy5kYXRhID0gbnVsbDtcblxuICAgIC8vIGlmIG5ldyBOQUwgdW5pdHMgZm91bmQgYW5kIGxhc3Qgc2FtcGxlIHN0aWxsIHRoZXJlLCBsZXQncyBwdXNoIC4uLlxuICAgIC8vIHRoaXMgaGVscHMgcGFyc2luZyBzdHJlYW1zIHdpdGggbWlzc2luZyBBVUQgKG9ubHkgZG8gdGhpcyBpZiBBVUQgbmV2ZXIgZm91bmQpXG4gICAgaWYgKFZpZGVvU2FtcGxlICYmIHVuaXRzLmxlbmd0aCAmJiAhdHJhY2suYXVkRm91bmQpIHtcbiAgICAgIHRoaXMucHVzaEFjY2Vzc1VuaXQoVmlkZW9TYW1wbGUsIHRyYWNrKTtcbiAgICAgIFZpZGVvU2FtcGxlID0gdGhpcy5WaWRlb1NhbXBsZSA9IHRoaXMuY3JlYXRlVmlkZW9TYW1wbGUoZmFsc2UsIHBlcy5wdHMsIHBlcy5kdHMsICcnKTtcbiAgICB9XG4gICAgdW5pdHMuZm9yRWFjaCh1bml0ID0+IHtcbiAgICAgIHZhciBfVmlkZW9TYW1wbGUyO1xuICAgICAgc3dpdGNoICh1bml0LnR5cGUpIHtcbiAgICAgICAgLy8gTkRSXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBsZXQgaXNrZXkgPSBmYWxzZTtcbiAgICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHVuaXQuZGF0YTtcbiAgICAgICAgICAgIC8vIG9ubHkgY2hlY2sgc2xpY2UgdHlwZSB0byBkZXRlY3QgS0YgaW4gY2FzZSBTUFMgZm91bmQgaW4gc2FtZSBwYWNrZXQgKGFueSBrZXlmcmFtZSBpcyBwcmVjZWRlZCBieSBTUFMgLi4uKVxuICAgICAgICAgICAgaWYgKHNwc2ZvdW5kICYmIGRhdGEubGVuZ3RoID4gNCkge1xuICAgICAgICAgICAgICAvLyByZXRyaWV2ZSBzbGljZSB0eXBlIGJ5IHBhcnNpbmcgYmVnaW5uaW5nIG9mIE5BTCB1bml0IChmb2xsb3cgSDI2NCBzcGVjLCBzbGljZV9oZWFkZXIgZGVmaW5pdGlvbikgdG8gZGV0ZWN0IGtleWZyYW1lIGVtYmVkZGVkIGluIE5EUlxuICAgICAgICAgICAgICBjb25zdCBzbGljZVR5cGUgPSBuZXcgRXhwR29sb21iKGRhdGEpLnJlYWRTbGljZVR5cGUoKTtcbiAgICAgICAgICAgICAgLy8gMiA6IEkgc2xpY2UsIDQgOiBTSSBzbGljZSwgNyA6IEkgc2xpY2UsIDk6IFNJIHNsaWNlXG4gICAgICAgICAgICAgIC8vIFNJIHNsaWNlIDogQSBzbGljZSB0aGF0IGlzIGNvZGVkIHVzaW5nIGludHJhIHByZWRpY3Rpb24gb25seSBhbmQgdXNpbmcgcXVhbnRpc2F0aW9uIG9mIHRoZSBwcmVkaWN0aW9uIHNhbXBsZXMuXG4gICAgICAgICAgICAgIC8vIEFuIFNJIHNsaWNlIGNhbiBiZSBjb2RlZCBzdWNoIHRoYXQgaXRzIGRlY29kZWQgc2FtcGxlcyBjYW4gYmUgY29uc3RydWN0ZWQgaWRlbnRpY2FsbHkgdG8gYW4gU1Agc2xpY2UuXG4gICAgICAgICAgICAgIC8vIEkgc2xpY2U6IEEgc2xpY2UgdGhhdCBpcyBub3QgYW4gU0kgc2xpY2UgdGhhdCBpcyBkZWNvZGVkIHVzaW5nIGludHJhIHByZWRpY3Rpb24gb25seS5cbiAgICAgICAgICAgICAgLy8gaWYgKHNsaWNlVHlwZSA9PT0gMiB8fCBzbGljZVR5cGUgPT09IDcpIHtcbiAgICAgICAgICAgICAgaWYgKHNsaWNlVHlwZSA9PT0gMiB8fCBzbGljZVR5cGUgPT09IDQgfHwgc2xpY2VUeXBlID09PSA3IHx8IHNsaWNlVHlwZSA9PT0gOSkge1xuICAgICAgICAgICAgICAgIGlza2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlza2V5KSB7XG4gICAgICAgICAgICAgIHZhciBfVmlkZW9TYW1wbGU7XG4gICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgbm9uLWtleWZyYW1lIGRhdGEgYWxyZWFkeSwgdGhhdCBjYW5ub3QgYmVsb25nIHRvIHRoZSBzYW1lIGZyYW1lIGFzIGEga2V5ZnJhbWUsIHNvIGZvcmNlIGEgcHVzaFxuICAgICAgICAgICAgICBpZiAoKF9WaWRlb1NhbXBsZSA9IFZpZGVvU2FtcGxlKSAhPSBudWxsICYmIF9WaWRlb1NhbXBsZS5mcmFtZSAmJiAhVmlkZW9TYW1wbGUua2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoQWNjZXNzVW5pdChWaWRlb1NhbXBsZSwgdHJhY2spO1xuICAgICAgICAgICAgICAgIFZpZGVvU2FtcGxlID0gdGhpcy5WaWRlb1NhbXBsZSA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghVmlkZW9TYW1wbGUpIHtcbiAgICAgICAgICAgICAgVmlkZW9TYW1wbGUgPSB0aGlzLlZpZGVvU2FtcGxlID0gdGhpcy5jcmVhdGVWaWRlb1NhbXBsZSh0cnVlLCBwZXMucHRzLCBwZXMuZHRzLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBWaWRlb1NhbXBsZS5mcmFtZSA9IHRydWU7XG4gICAgICAgICAgICBWaWRlb1NhbXBsZS5rZXkgPSBpc2tleTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gSURSXG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgLy8gaGFuZGxlIFBFUyBub3Qgc3RhcnRpbmcgd2l0aCBBVURcbiAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGZyYW1lIGRhdGEgYWxyZWFkeSwgdGhhdCBjYW5ub3QgYmVsb25nIHRvIHRoZSBzYW1lIGZyYW1lLCBzbyBmb3JjZSBhIHB1c2hcbiAgICAgICAgICBpZiAoKF9WaWRlb1NhbXBsZTIgPSBWaWRlb1NhbXBsZSkgIT0gbnVsbCAmJiBfVmlkZW9TYW1wbGUyLmZyYW1lICYmICFWaWRlb1NhbXBsZS5rZXkpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaEFjY2Vzc1VuaXQoVmlkZW9TYW1wbGUsIHRyYWNrKTtcbiAgICAgICAgICAgIFZpZGVvU2FtcGxlID0gdGhpcy5WaWRlb1NhbXBsZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghVmlkZW9TYW1wbGUpIHtcbiAgICAgICAgICAgIFZpZGVvU2FtcGxlID0gdGhpcy5WaWRlb1NhbXBsZSA9IHRoaXMuY3JlYXRlVmlkZW9TYW1wbGUodHJ1ZSwgcGVzLnB0cywgcGVzLmR0cywgJycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBWaWRlb1NhbXBsZS5rZXkgPSB0cnVlO1xuICAgICAgICAgIFZpZGVvU2FtcGxlLmZyYW1lID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gU0VJXG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIHBhcnNlU0VJTWVzc2FnZUZyb21OQUx1KHVuaXQuZGF0YSwgMSwgcGVzLnB0cywgdGV4dFRyYWNrLnNhbXBsZXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBTUFNcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX3RyYWNrJHBpeGVsUmF0aW8sIF90cmFjayRwaXhlbFJhdGlvMjtcbiAgICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgICAgc3BzZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3Qgc3BzID0gdW5pdC5kYXRhO1xuICAgICAgICAgICAgY29uc3QgZXhwR29sb21iRGVjb2RlciA9IG5ldyBFeHBHb2xvbWIoc3BzKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFNQUygpO1xuICAgICAgICAgICAgaWYgKCF0cmFjay5zcHMgfHwgdHJhY2sud2lkdGggIT09IGNvbmZpZy53aWR0aCB8fCB0cmFjay5oZWlnaHQgIT09IGNvbmZpZy5oZWlnaHQgfHwgKChfdHJhY2skcGl4ZWxSYXRpbyA9IHRyYWNrLnBpeGVsUmF0aW8pID09IG51bGwgPyB2b2lkIDAgOiBfdHJhY2skcGl4ZWxSYXRpb1swXSkgIT09IGNvbmZpZy5waXhlbFJhdGlvWzBdIHx8ICgoX3RyYWNrJHBpeGVsUmF0aW8yID0gdHJhY2sucGl4ZWxSYXRpbykgPT0gbnVsbCA/IHZvaWQgMCA6IF90cmFjayRwaXhlbFJhdGlvMlsxXSkgIT09IGNvbmZpZy5waXhlbFJhdGlvWzFdKSB7XG4gICAgICAgICAgICAgIHRyYWNrLndpZHRoID0gY29uZmlnLndpZHRoO1xuICAgICAgICAgICAgICB0cmFjay5oZWlnaHQgPSBjb25maWcuaGVpZ2h0O1xuICAgICAgICAgICAgICB0cmFjay5waXhlbFJhdGlvID0gY29uZmlnLnBpeGVsUmF0aW87XG4gICAgICAgICAgICAgIHRyYWNrLnNwcyA9IFtzcHNdO1xuICAgICAgICAgICAgICB0cmFjay5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICAgICAgICBjb25zdCBjb2RlY2FycmF5ID0gc3BzLnN1YmFycmF5KDEsIDQpO1xuICAgICAgICAgICAgICBsZXQgY29kZWNzdHJpbmcgPSAnYXZjMS4nO1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBoID0gY29kZWNhcnJheVtpXS50b1N0cmluZygxNik7XG4gICAgICAgICAgICAgICAgaWYgKGgubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgICAgaCA9ICcwJyArIGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvZGVjc3RyaW5nICs9IGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdHJhY2suY29kZWMgPSBjb2RlY3N0cmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgLy8gUFBTXG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICB0cmFjay5wcHMgPSBbdW5pdC5kYXRhXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gQVVEXG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICB0cmFjay5hdWRGb3VuZCA9IHRydWU7XG4gICAgICAgICAgaWYgKFZpZGVvU2FtcGxlKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hBY2Nlc3NVbml0KFZpZGVvU2FtcGxlLCB0cmFjayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFZpZGVvU2FtcGxlID0gdGhpcy5WaWRlb1NhbXBsZSA9IHRoaXMuY3JlYXRlVmlkZW9TYW1wbGUoZmFsc2UsIHBlcy5wdHMsIHBlcy5kdHMsICcnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gRmlsbGVyIERhdGFcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoID0gZmFsc2U7XG4gICAgICAgICAgaWYgKFZpZGVvU2FtcGxlKSB7XG4gICAgICAgICAgICBWaWRlb1NhbXBsZS5kZWJ1ZyArPSAndW5rbm93biBOQUwgJyArIHVuaXQudHlwZSArICcgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoVmlkZW9TYW1wbGUgJiYgcHVzaCkge1xuICAgICAgICBjb25zdCB1bml0cyA9IFZpZGVvU2FtcGxlLnVuaXRzO1xuICAgICAgICB1bml0cy5wdXNoKHVuaXQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIGlmIGxhc3QgUEVTIHBhY2tldCwgcHVzaCBzYW1wbGVzXG4gICAgaWYgKGxhc3QgJiYgVmlkZW9TYW1wbGUpIHtcbiAgICAgIHRoaXMucHVzaEFjY2Vzc1VuaXQoVmlkZW9TYW1wbGUsIHRyYWNrKTtcbiAgICAgIHRoaXMuVmlkZW9TYW1wbGUgPSBudWxsO1xuICAgIH1cbiAgfVxuICBwYXJzZUFWQ05BTHUodHJhY2ssIGFycmF5KSB7XG4gICAgY29uc3QgbGVuID0gYXJyYXkuYnl0ZUxlbmd0aDtcbiAgICBsZXQgc3RhdGUgPSB0cmFjay5uYWx1U3RhdGUgfHwgMDtcbiAgICBjb25zdCBsYXN0U3RhdGUgPSBzdGF0ZTtcbiAgICBjb25zdCB1bml0cyA9IFtdO1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgdmFsdWU7XG4gICAgbGV0IG92ZXJmbG93O1xuICAgIGxldCB1bml0VHlwZTtcbiAgICBsZXQgbGFzdFVuaXRTdGFydCA9IC0xO1xuICAgIGxldCBsYXN0VW5pdFR5cGUgPSAwO1xuICAgIC8vIGxvZ2dlci5sb2coJ1BFUzonICsgSGV4LmhleER1bXAoYXJyYXkpKTtcblxuICAgIGlmIChzdGF0ZSA9PT0gLTEpIHtcbiAgICAgIC8vIHNwZWNpYWwgdXNlIGNhc2Ugd2hlcmUgd2UgZm91bmQgMyBvciA0LWJ5dGUgc3RhcnQgY29kZXMgZXhhY3RseSBhdCB0aGUgZW5kIG9mIHByZXZpb3VzIFBFUyBwYWNrZXRcbiAgICAgIGxhc3RVbml0U3RhcnQgPSAwO1xuICAgICAgLy8gTkFMdSB0eXBlIGlzIHZhbHVlIHJlYWQgZnJvbSBvZmZzZXQgMFxuICAgICAgbGFzdFVuaXRUeXBlID0gYXJyYXlbMF0gJiAweDFmO1xuICAgICAgc3RhdGUgPSAwO1xuICAgICAgaSA9IDE7XG4gICAgfVxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICB2YWx1ZSA9IGFycmF5W2krK107XG4gICAgICAvLyBvcHRpbWl6YXRpb24uIHN0YXRlIDAgYW5kIDEgYXJlIHRoZSBwcmVkb21pbmFudCBjYXNlLiBsZXQncyBoYW5kbGUgdGhlbSBvdXRzaWRlIG9mIHRoZSBzd2l0Y2gvY2FzZVxuICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICBzdGF0ZSA9IHZhbHVlID8gMCA6IDE7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlID09PSAxKSB7XG4gICAgICAgIHN0YXRlID0gdmFsdWUgPyAwIDogMjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBoZXJlIHdlIGhhdmUgc3RhdGUgZWl0aGVyIGVxdWFsIHRvIDIgb3IgM1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICBzdGF0ZSA9IDM7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAxKSB7XG4gICAgICAgIG92ZXJmbG93ID0gaSAtIHN0YXRlIC0gMTtcbiAgICAgICAgaWYgKGxhc3RVbml0U3RhcnQgPj0gMCkge1xuICAgICAgICAgIGNvbnN0IHVuaXQgPSB7XG4gICAgICAgICAgICBkYXRhOiBhcnJheS5zdWJhcnJheShsYXN0VW5pdFN0YXJ0LCBvdmVyZmxvdyksXG4gICAgICAgICAgICB0eXBlOiBsYXN0VW5pdFR5cGVcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ3B1c2hpbmcgTkFMVSwgdHlwZS9zaXplOicgKyB1bml0LnR5cGUgKyAnLycgKyB1bml0LmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgdW5pdHMucHVzaCh1bml0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBsYXN0VW5pdFN0YXJ0IGlzIHVuZGVmaW5lZCA9PiB0aGlzIGlzIHRoZSBmaXJzdCBzdGFydCBjb2RlIGZvdW5kIGluIHRoaXMgUEVTIHBhY2tldFxuICAgICAgICAgIC8vIGZpcnN0IGNoZWNrIGlmIHN0YXJ0IGNvZGUgZGVsaW1pdGVyIGlzIG92ZXJsYXBwaW5nIGJldHdlZW4gMiBQRVMgcGFja2V0cyxcbiAgICAgICAgICAvLyBpZSBpdCBzdGFydGVkIGluIGxhc3QgcGFja2V0IChsYXN0U3RhdGUgbm90IHplcm8pXG4gICAgICAgICAgLy8gYW5kIGVuZGVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBQRVMgcGFja2V0IChpIDw9IDQgLSBsYXN0U3RhdGUpXG4gICAgICAgICAgY29uc3QgbGFzdFVuaXQgPSB0aGlzLmdldExhc3ROYWxVbml0KHRyYWNrLnNhbXBsZXMpO1xuICAgICAgICAgIGlmIChsYXN0VW5pdCkge1xuICAgICAgICAgICAgaWYgKGxhc3RTdGF0ZSAmJiBpIDw9IDQgLSBsYXN0U3RhdGUpIHtcbiAgICAgICAgICAgICAgLy8gc3RhcnQgZGVsaW1pdGVyIG92ZXJsYXBwaW5nIGJldHdlZW4gUEVTIHBhY2tldHNcbiAgICAgICAgICAgICAgLy8gc3RyaXAgc3RhcnQgZGVsaW1pdGVyIGJ5dGVzIGZyb20gdGhlIGVuZCBvZiBsYXN0IE5BTCB1bml0XG4gICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGxhc3RVbml0IGhhZCBhIHN0YXRlIGRpZmZlcmVudCBmcm9tIHplcm9cbiAgICAgICAgICAgICAgaWYgKGxhc3RVbml0LnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RyaXAgbGFzdCBieXRlc1xuICAgICAgICAgICAgICAgIGxhc3RVbml0LmRhdGEgPSBsYXN0VW5pdC5kYXRhLnN1YmFycmF5KDAsIGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCAtIGxhc3RTdGF0ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIE5BTCB1bml0cyBhcmUgbm90IHN0YXJ0aW5nIHJpZ2h0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIFBFUyBwYWNrZXQsIHB1c2ggcHJlY2VkaW5nIGRhdGEgaW50byBwcmV2aW91cyBOQUwgdW5pdC5cblxuICAgICAgICAgICAgaWYgKG92ZXJmbG93ID4gMCkge1xuICAgICAgICAgICAgICAvLyBsb2dnZXIubG9nKCdmaXJzdCBOQUxVIGZvdW5kIHdpdGggb3ZlcmZsb3c6JyArIG92ZXJmbG93KTtcbiAgICAgICAgICAgICAgbGFzdFVuaXQuZGF0YSA9IGFwcGVuZFVpbnQ4QXJyYXkobGFzdFVuaXQuZGF0YSwgYXJyYXkuc3ViYXJyYXkoMCwgb3ZlcmZsb3cpKTtcbiAgICAgICAgICAgICAgbGFzdFVuaXQuc3RhdGUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBpZiB3ZSBjYW4gcmVhZCB1bml0IHR5cGVcbiAgICAgICAgaWYgKGkgPCBsZW4pIHtcbiAgICAgICAgICB1bml0VHlwZSA9IGFycmF5W2ldICYgMHgxZjtcbiAgICAgICAgICAvLyBsb2dnZXIubG9nKCdmaW5kIE5BTFUgQCBvZmZzZXQ6JyArIGkgKyAnLHR5cGU6JyArIHVuaXRUeXBlKTtcbiAgICAgICAgICBsYXN0VW5pdFN0YXJ0ID0gaTtcbiAgICAgICAgICBsYXN0VW5pdFR5cGUgPSB1bml0VHlwZTtcbiAgICAgICAgICBzdGF0ZSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbm90IGVub3VnaCBieXRlIHRvIHJlYWQgdW5pdCB0eXBlLiBsZXQncyByZWFkIGl0IG9uIG5leHQgUEVTIHBhcnNpbmdcbiAgICAgICAgICBzdGF0ZSA9IC0xO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZSA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsYXN0VW5pdFN0YXJ0ID49IDAgJiYgc3RhdGUgPj0gMCkge1xuICAgICAgY29uc3QgdW5pdCA9IHtcbiAgICAgICAgZGF0YTogYXJyYXkuc3ViYXJyYXkobGFzdFVuaXRTdGFydCwgbGVuKSxcbiAgICAgICAgdHlwZTogbGFzdFVuaXRUeXBlLFxuICAgICAgICBzdGF0ZTogc3RhdGVcbiAgICAgIH07XG4gICAgICB1bml0cy5wdXNoKHVuaXQpO1xuICAgICAgLy8gbG9nZ2VyLmxvZygncHVzaGluZyBOQUxVLCB0eXBlL3NpemUvc3RhdGU6JyArIHVuaXQudHlwZSArICcvJyArIHVuaXQuZGF0YS5ieXRlTGVuZ3RoICsgJy8nICsgc3RhdGUpO1xuICAgIH1cbiAgICAvLyBubyBOQUx1IGZvdW5kXG4gICAgaWYgKHVuaXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gYXBwZW5kIHBlcy5kYXRhIHRvIHByZXZpb3VzIE5BTCB1bml0XG4gICAgICBjb25zdCBsYXN0VW5pdCA9IHRoaXMuZ2V0TGFzdE5hbFVuaXQodHJhY2suc2FtcGxlcyk7XG4gICAgICBpZiAobGFzdFVuaXQpIHtcbiAgICAgICAgbGFzdFVuaXQuZGF0YSA9IGFwcGVuZFVpbnQ4QXJyYXkobGFzdFVuaXQuZGF0YSwgYXJyYXkpO1xuICAgICAgfVxuICAgIH1cbiAgICB0cmFjay5uYWx1U3RhdGUgPSBzdGF0ZTtcbiAgICByZXR1cm4gdW5pdHM7XG4gIH1cbn1cblxuLyoqXG4gKiBTQU1QTEUtQUVTIGRlY3J5cHRlclxuICovXG5cbmNsYXNzIFNhbXBsZUFlc0RlY3J5cHRlciB7XG4gIGNvbnN0cnVjdG9yKG9ic2VydmVyLCBjb25maWcsIGtleURhdGEpIHtcbiAgICB0aGlzLmtleURhdGEgPSB2b2lkIDA7XG4gICAgdGhpcy5kZWNyeXB0ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXlEYXRhID0ga2V5RGF0YTtcbiAgICB0aGlzLmRlY3J5cHRlciA9IG5ldyBEZWNyeXB0ZXIoY29uZmlnLCB7XG4gICAgICByZW1vdmVQS0NTN1BhZGRpbmc6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgZGVjcnlwdEJ1ZmZlcihlbmNyeXB0ZWREYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVjcnlwdGVyLmRlY3J5cHQoZW5jcnlwdGVkRGF0YSwgdGhpcy5rZXlEYXRhLmtleS5idWZmZXIsIHRoaXMua2V5RGF0YS5pdi5idWZmZXIpO1xuICB9XG5cbiAgLy8gQUFDIC0gZW5jcnlwdCBhbGwgZnVsbCAxNiBieXRlcyBibG9ja3Mgc3RhcnRpbmcgZnJvbSBvZmZzZXQgMTZcbiAgZGVjcnlwdEFhY1NhbXBsZShzYW1wbGVzLCBzYW1wbGVJbmRleCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBjdXJVbml0ID0gc2FtcGxlc1tzYW1wbGVJbmRleF0udW5pdDtcbiAgICBpZiAoY3VyVW5pdC5sZW5ndGggPD0gMTYpIHtcbiAgICAgIC8vIE5vIGVuY3J5cHRlZCBwb3J0aW9uIGluIHRoaXMgc2FtcGxlIChmaXJzdCAxNiBieXRlcyBpcyBub3RcbiAgICAgIC8vIGVuY3J5cHRlZCwgc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9saWJyYXJ5L2FyY2hpdmUvZG9jdW1lbnRhdGlvbi9BdWRpb1ZpZGVvL0NvbmNlcHR1YWwvSExTX1NhbXBsZV9FbmNyeXB0aW9uL0VuY3J5cHRpb24vRW5jcnlwdGlvbi5odG1sKSxcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZW5jcnlwdGVkRGF0YSA9IGN1clVuaXQuc3ViYXJyYXkoMTYsIGN1clVuaXQubGVuZ3RoIC0gY3VyVW5pdC5sZW5ndGggJSAxNik7XG4gICAgY29uc3QgZW5jcnlwdGVkQnVmZmVyID0gZW5jcnlwdGVkRGF0YS5idWZmZXIuc2xpY2UoZW5jcnlwdGVkRGF0YS5ieXRlT2Zmc2V0LCBlbmNyeXB0ZWREYXRhLmJ5dGVPZmZzZXQgKyBlbmNyeXB0ZWREYXRhLmxlbmd0aCk7XG4gICAgdGhpcy5kZWNyeXB0QnVmZmVyKGVuY3J5cHRlZEJ1ZmZlcikudGhlbihkZWNyeXB0ZWRCdWZmZXIgPT4ge1xuICAgICAgY29uc3QgZGVjcnlwdGVkRGF0YSA9IG5ldyBVaW50OEFycmF5KGRlY3J5cHRlZEJ1ZmZlcik7XG4gICAgICBjdXJVbml0LnNldChkZWNyeXB0ZWREYXRhLCAxNik7XG4gICAgICBpZiAoIXRoaXMuZGVjcnlwdGVyLmlzU3luYygpKSB7XG4gICAgICAgIHRoaXMuZGVjcnlwdEFhY1NhbXBsZXMoc2FtcGxlcywgc2FtcGxlSW5kZXggKyAxLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZGVjcnlwdEFhY1NhbXBsZXMoc2FtcGxlcywgc2FtcGxlSW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgZm9yICg7OyBzYW1wbGVJbmRleCsrKSB7XG4gICAgICBpZiAoc2FtcGxlSW5kZXggPj0gc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHNhbXBsZXNbc2FtcGxlSW5kZXhdLnVuaXQubGVuZ3RoIDwgMzIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aGlzLmRlY3J5cHRBYWNTYW1wbGUoc2FtcGxlcywgc2FtcGxlSW5kZXgsIGNhbGxiYWNrKTtcbiAgICAgIGlmICghdGhpcy5kZWNyeXB0ZXIuaXNTeW5jKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEFWQyAtIGVuY3J5cHQgb25lIDE2IGJ5dGVzIGJsb2NrIG91dCBvZiB0ZW4sIHN0YXJ0aW5nIGZyb20gb2Zmc2V0IDMyXG4gIGdldEF2Y0VuY3J5cHRlZERhdGEoZGVjb2RlZERhdGEpIHtcbiAgICBjb25zdCBlbmNyeXB0ZWREYXRhTGVuID0gTWF0aC5mbG9vcigoZGVjb2RlZERhdGEubGVuZ3RoIC0gNDgpIC8gMTYwKSAqIDE2ICsgMTY7XG4gICAgY29uc3QgZW5jcnlwdGVkRGF0YSA9IG5ldyBJbnQ4QXJyYXkoZW5jcnlwdGVkRGF0YUxlbik7XG4gICAgbGV0IG91dHB1dFBvcyA9IDA7XG4gICAgZm9yIChsZXQgaW5wdXRQb3MgPSAzMjsgaW5wdXRQb3MgPCBkZWNvZGVkRGF0YS5sZW5ndGggLSAxNjsgaW5wdXRQb3MgKz0gMTYwLCBvdXRwdXRQb3MgKz0gMTYpIHtcbiAgICAgIGVuY3J5cHRlZERhdGEuc2V0KGRlY29kZWREYXRhLnN1YmFycmF5KGlucHV0UG9zLCBpbnB1dFBvcyArIDE2KSwgb3V0cHV0UG9zKTtcbiAgICB9XG4gICAgcmV0dXJuIGVuY3J5cHRlZERhdGE7XG4gIH1cbiAgZ2V0QXZjRGVjcnlwdGVkVW5pdChkZWNvZGVkRGF0YSwgZGVjcnlwdGVkRGF0YSkge1xuICAgIGNvbnN0IHVpbnQ4RGVjcnlwdGVkRGF0YSA9IG5ldyBVaW50OEFycmF5KGRlY3J5cHRlZERhdGEpO1xuICAgIGxldCBpbnB1dFBvcyA9IDA7XG4gICAgZm9yIChsZXQgb3V0cHV0UG9zID0gMzI7IG91dHB1dFBvcyA8IGRlY29kZWREYXRhLmxlbmd0aCAtIDE2OyBvdXRwdXRQb3MgKz0gMTYwLCBpbnB1dFBvcyArPSAxNikge1xuICAgICAgZGVjb2RlZERhdGEuc2V0KHVpbnQ4RGVjcnlwdGVkRGF0YS5zdWJhcnJheShpbnB1dFBvcywgaW5wdXRQb3MgKyAxNiksIG91dHB1dFBvcyk7XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVkRGF0YTtcbiAgfVxuICBkZWNyeXB0QXZjU2FtcGxlKHNhbXBsZXMsIHNhbXBsZUluZGV4LCB1bml0SW5kZXgsIGNhbGxiYWNrLCBjdXJVbml0KSB7XG4gICAgY29uc3QgZGVjb2RlZERhdGEgPSBkaXNjYXJkRVBCKGN1clVuaXQuZGF0YSk7XG4gICAgY29uc3QgZW5jcnlwdGVkRGF0YSA9IHRoaXMuZ2V0QXZjRW5jcnlwdGVkRGF0YShkZWNvZGVkRGF0YSk7XG4gICAgdGhpcy5kZWNyeXB0QnVmZmVyKGVuY3J5cHRlZERhdGEuYnVmZmVyKS50aGVuKGRlY3J5cHRlZEJ1ZmZlciA9PiB7XG4gICAgICBjdXJVbml0LmRhdGEgPSB0aGlzLmdldEF2Y0RlY3J5cHRlZFVuaXQoZGVjb2RlZERhdGEsIGRlY3J5cHRlZEJ1ZmZlcik7XG4gICAgICBpZiAoIXRoaXMuZGVjcnlwdGVyLmlzU3luYygpKSB7XG4gICAgICAgIHRoaXMuZGVjcnlwdEF2Y1NhbXBsZXMoc2FtcGxlcywgc2FtcGxlSW5kZXgsIHVuaXRJbmRleCArIDEsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBkZWNyeXB0QXZjU2FtcGxlcyhzYW1wbGVzLCBzYW1wbGVJbmRleCwgdW5pdEluZGV4LCBjYWxsYmFjaykge1xuICAgIGlmIChzYW1wbGVzIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZGVjcnlwdCBzYW1wbGVzIG9mIHR5cGUgVWludDhBcnJheScpO1xuICAgIH1cbiAgICBmb3IgKDs7IHNhbXBsZUluZGV4KyssIHVuaXRJbmRleCA9IDApIHtcbiAgICAgIGlmIChzYW1wbGVJbmRleCA+PSBzYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBjdXJVbml0cyA9IHNhbXBsZXNbc2FtcGxlSW5kZXhdLnVuaXRzO1xuICAgICAgZm9yICg7OyB1bml0SW5kZXgrKykge1xuICAgICAgICBpZiAodW5pdEluZGV4ID49IGN1clVuaXRzLmxlbmd0aCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1clVuaXQgPSBjdXJVbml0c1t1bml0SW5kZXhdO1xuICAgICAgICBpZiAoY3VyVW5pdC5kYXRhLmxlbmd0aCA8PSA0OCB8fCBjdXJVbml0LnR5cGUgIT09IDEgJiYgY3VyVW5pdC50eXBlICE9PSA1KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWNyeXB0QXZjU2FtcGxlKHNhbXBsZXMsIHNhbXBsZUluZGV4LCB1bml0SW5kZXgsIGNhbGxiYWNrLCBjdXJVbml0KTtcbiAgICAgICAgaWYgKCF0aGlzLmRlY3J5cHRlci5pc1N5bmMoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBQQUNLRVRfTEVOR1RIID0gMTg4O1xuY2xhc3MgVFNEZW11eGVyIHtcbiAgY29uc3RydWN0b3Iob2JzZXJ2ZXIsIGNvbmZpZywgdHlwZVN1cHBvcnRlZCkge1xuICAgIHRoaXMub2JzZXJ2ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy50eXBlU3VwcG9ydGVkID0gdm9pZCAwO1xuICAgIHRoaXMuc2FtcGxlQWVzID0gbnVsbDtcbiAgICB0aGlzLnBtdFBhcnNlZCA9IGZhbHNlO1xuICAgIHRoaXMuYXVkaW9Db2RlYyA9IHZvaWQgMDtcbiAgICB0aGlzLnZpZGVvQ29kZWMgPSB2b2lkIDA7XG4gICAgdGhpcy5fZHVyYXRpb24gPSAwO1xuICAgIHRoaXMuX3BtdElkID0gLTE7XG4gICAgdGhpcy5fdmlkZW9UcmFjayA9IHZvaWQgMDtcbiAgICB0aGlzLl9hdWRpb1RyYWNrID0gdm9pZCAwO1xuICAgIHRoaXMuX2lkM1RyYWNrID0gdm9pZCAwO1xuICAgIHRoaXMuX3R4dFRyYWNrID0gdm9pZCAwO1xuICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBudWxsO1xuICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgdGhpcy52aWRlb1BhcnNlciA9IHZvaWQgMDtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy50eXBlU3VwcG9ydGVkID0gdHlwZVN1cHBvcnRlZDtcbiAgICB0aGlzLnZpZGVvUGFyc2VyID0gbmV3IEF2Y1ZpZGVvUGFyc2VyKCk7XG4gIH1cbiAgc3RhdGljIHByb2JlKGRhdGEpIHtcbiAgICBjb25zdCBzeW5jT2Zmc2V0ID0gVFNEZW11eGVyLnN5bmNPZmZzZXQoZGF0YSk7XG4gICAgaWYgKHN5bmNPZmZzZXQgPiAwKSB7XG4gICAgICBsb2dnZXIud2FybihgTVBFRzItVFMgZGV0ZWN0ZWQgYnV0IGZpcnN0IHN5bmMgd29yZCBmb3VuZCBAIG9mZnNldCAke3N5bmNPZmZzZXR9YCk7XG4gICAgfVxuICAgIHJldHVybiBzeW5jT2Zmc2V0ICE9PSAtMTtcbiAgfVxuICBzdGF0aWMgc3luY09mZnNldChkYXRhKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgbGV0IHNjYW53aW5kb3cgPSBNYXRoLm1pbihQQUNLRVRfTEVOR1RIICogNSwgbGVuZ3RoIC0gUEFDS0VUX0xFTkdUSCkgKyAxO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHNjYW53aW5kb3cpIHtcbiAgICAgIC8vIGEgVFMgaW5pdCBzZWdtZW50IHNob3VsZCBjb250YWluIGF0IGxlYXN0IDIgVFMgcGFja2V0czogUEFUIGFuZCBQTVQsIGVhY2ggc3RhcnRpbmcgd2l0aCAweDQ3XG4gICAgICBsZXQgZm91bmRQYXQgPSBmYWxzZTtcbiAgICAgIGxldCBwYWNrZXRTdGFydCA9IC0xO1xuICAgICAgbGV0IHRzUGFja2V0cyA9IDA7XG4gICAgICBmb3IgKGxldCBqID0gaTsgaiA8IGxlbmd0aDsgaiArPSBQQUNLRVRfTEVOR1RIKSB7XG4gICAgICAgIGlmIChkYXRhW2pdID09PSAweDQ3ICYmIChsZW5ndGggLSBqID09PSBQQUNLRVRfTEVOR1RIIHx8IGRhdGFbaiArIFBBQ0tFVF9MRU5HVEhdID09PSAweDQ3KSkge1xuICAgICAgICAgIHRzUGFja2V0cysrO1xuICAgICAgICAgIGlmIChwYWNrZXRTdGFydCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHBhY2tldFN0YXJ0ID0gajtcbiAgICAgICAgICAgIC8vIEZpcnN0IHN5bmMgd29yZCBmb3VuZCBhdCBvZmZzZXQsIGluY3JlYXNlIHNjYW4gbGVuZ3RoICgjNTI1MSlcbiAgICAgICAgICAgIGlmIChwYWNrZXRTdGFydCAhPT0gMCkge1xuICAgICAgICAgICAgICBzY2Fud2luZG93ID0gTWF0aC5taW4ocGFja2V0U3RhcnQgKyBQQUNLRVRfTEVOR1RIICogOTksIGRhdGEubGVuZ3RoIC0gUEFDS0VUX0xFTkdUSCkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWZvdW5kUGF0KSB7XG4gICAgICAgICAgICBmb3VuZFBhdCA9IHBhcnNlUElEKGRhdGEsIGopID09PSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBTeW5jIHdvcmQgZm91bmQgYXQgMCB3aXRoIDMgcGFja2V0cywgb3IgZm91bmQgYXQgb2Zmc2V0IGxlYXN0IDIgcGFja2V0cyB1cCB0byBzY2Fud2luZG93ICgjNTUwMSlcbiAgICAgICAgICBpZiAoZm91bmRQYXQgJiYgdHNQYWNrZXRzID4gMSAmJiAocGFja2V0U3RhcnQgPT09IDAgJiYgdHNQYWNrZXRzID4gMiB8fCBqICsgUEFDS0VUX0xFTkdUSCA+IHNjYW53aW5kb3cpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFja2V0U3RhcnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRzUGFja2V0cykge1xuICAgICAgICAgIC8vIEV4aXQgaWYgc3luYyB3b3JkIGZvdW5kLCBidXQgZG9lcyBub3QgY29udGFpbiBjb250aWd1b3VzIHBhY2tldHNcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB0cmFjayBtb2RlbCBpbnRlcm5hbCB0byBkZW11eGVyIHVzZWQgdG8gZHJpdmUgcmVtdXhpbmcgaW5wdXRcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVUcmFjayh0eXBlLCBkdXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICBjb250YWluZXI6IHR5cGUgPT09ICd2aWRlbycgfHwgdHlwZSA9PT0gJ2F1ZGlvJyA/ICd2aWRlby9tcDJ0JyA6IHVuZGVmaW5lZCxcbiAgICAgIHR5cGUsXG4gICAgICBpZDogUmVtdXhlclRyYWNrSWRDb25maWdbdHlwZV0sXG4gICAgICBwaWQ6IC0xLFxuICAgICAgaW5wdXRUaW1lU2NhbGU6IDkwMDAwLFxuICAgICAgc2VxdWVuY2VOdW1iZXI6IDAsXG4gICAgICBzYW1wbGVzOiBbXSxcbiAgICAgIGRyb3BwZWQ6IDAsXG4gICAgICBkdXJhdGlvbjogdHlwZSA9PT0gJ2F1ZGlvJyA/IGR1cmF0aW9uIDogdW5kZWZpbmVkXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBhIG5ldyBpbml0IHNlZ21lbnQgb24gdGhlIGRlbXV4ZXIvcmVtdXhlciBpbnRlcmZhY2UuIE5lZWRlZCBmb3IgZGlzY29udGludWl0aWVzL3RyYWNrLXN3aXRjaGVzIChvciBhdCBzdHJlYW0gc3RhcnQpXG4gICAqIFJlc2V0cyBhbGwgaW50ZXJuYWwgdHJhY2sgaW5zdGFuY2VzIG9mIHRoZSBkZW11eGVyLlxuICAgKi9cbiAgcmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbikge1xuICAgIHRoaXMucG10UGFyc2VkID0gZmFsc2U7XG4gICAgdGhpcy5fcG10SWQgPSAtMTtcbiAgICB0aGlzLl92aWRlb1RyYWNrID0gVFNEZW11eGVyLmNyZWF0ZVRyYWNrKCd2aWRlbycpO1xuICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSBUU0RlbXV4ZXIuY3JlYXRlVHJhY2soJ2F1ZGlvJywgdHJhY2tEdXJhdGlvbik7XG4gICAgdGhpcy5faWQzVHJhY2sgPSBUU0RlbXV4ZXIuY3JlYXRlVHJhY2soJ2lkMycpO1xuICAgIHRoaXMuX3R4dFRyYWNrID0gVFNEZW11eGVyLmNyZWF0ZVRyYWNrKCd0ZXh0Jyk7XG4gICAgdGhpcy5fYXVkaW9UcmFjay5zZWdtZW50Q29kZWMgPSAnYWFjJztcblxuICAgIC8vIGZsdXNoIGFueSBwYXJ0aWFsIGNvbnRlbnRcbiAgICB0aGlzLmFhY092ZXJGbG93ID0gbnVsbDtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIHRoaXMuYXVkaW9Db2RlYyA9IGF1ZGlvQ29kZWM7XG4gICAgdGhpcy52aWRlb0NvZGVjID0gdmlkZW9Db2RlYztcbiAgICB0aGlzLl9kdXJhdGlvbiA9IHRyYWNrRHVyYXRpb247XG4gIH1cbiAgcmVzZXRUaW1lU3RhbXAoKSB7fVxuICByZXNldENvbnRpZ3VpdHkoKSB7XG4gICAgY29uc3Qge1xuICAgICAgX2F1ZGlvVHJhY2ssXG4gICAgICBfdmlkZW9UcmFjayxcbiAgICAgIF9pZDNUcmFja1xuICAgIH0gPSB0aGlzO1xuICAgIGlmIChfYXVkaW9UcmFjaykge1xuICAgICAgX2F1ZGlvVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChfdmlkZW9UcmFjaykge1xuICAgICAgX3ZpZGVvVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChfaWQzVHJhY2spIHtcbiAgICAgIF9pZDNUcmFjay5wZXNEYXRhID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5hYWNPdmVyRmxvdyA9IG51bGw7XG4gICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgfVxuICBkZW11eChkYXRhLCB0aW1lT2Zmc2V0LCBpc1NhbXBsZUFlcyA9IGZhbHNlLCBmbHVzaCA9IGZhbHNlKSB7XG4gICAgaWYgKCFpc1NhbXBsZUFlcykge1xuICAgICAgdGhpcy5zYW1wbGVBZXMgPSBudWxsO1xuICAgIH1cbiAgICBsZXQgcGVzO1xuICAgIGNvbnN0IHZpZGVvVHJhY2sgPSB0aGlzLl92aWRlb1RyYWNrO1xuICAgIGNvbnN0IGF1ZGlvVHJhY2sgPSB0aGlzLl9hdWRpb1RyYWNrO1xuICAgIGNvbnN0IGlkM1RyYWNrID0gdGhpcy5faWQzVHJhY2s7XG4gICAgY29uc3QgdGV4dFRyYWNrID0gdGhpcy5fdHh0VHJhY2s7XG4gICAgbGV0IHZpZGVvUGlkID0gdmlkZW9UcmFjay5waWQ7XG4gICAgbGV0IHZpZGVvRGF0YSA9IHZpZGVvVHJhY2sucGVzRGF0YTtcbiAgICBsZXQgYXVkaW9QaWQgPSBhdWRpb1RyYWNrLnBpZDtcbiAgICBsZXQgaWQzUGlkID0gaWQzVHJhY2sucGlkO1xuICAgIGxldCBhdWRpb0RhdGEgPSBhdWRpb1RyYWNrLnBlc0RhdGE7XG4gICAgbGV0IGlkM0RhdGEgPSBpZDNUcmFjay5wZXNEYXRhO1xuICAgIGxldCB1bmtub3duUElEID0gbnVsbDtcbiAgICBsZXQgcG10UGFyc2VkID0gdGhpcy5wbXRQYXJzZWQ7XG4gICAgbGV0IHBtdElkID0gdGhpcy5fcG10SWQ7XG4gICAgbGV0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgIGlmICh0aGlzLnJlbWFpbmRlckRhdGEpIHtcbiAgICAgIGRhdGEgPSBhcHBlbmRVaW50OEFycmF5KHRoaXMucmVtYWluZGVyRGF0YSwgZGF0YSk7XG4gICAgICBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChsZW4gPCBQQUNLRVRfTEVOR1RIICYmICFmbHVzaCkge1xuICAgICAgdGhpcy5yZW1haW5kZXJEYXRhID0gZGF0YTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1ZGlvVHJhY2ssXG4gICAgICAgIHZpZGVvVHJhY2ssXG4gICAgICAgIGlkM1RyYWNrLFxuICAgICAgICB0ZXh0VHJhY2tcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHN5bmNPZmZzZXQgPSBNYXRoLm1heCgwLCBUU0RlbXV4ZXIuc3luY09mZnNldChkYXRhKSk7XG4gICAgbGVuIC09IChsZW4gLSBzeW5jT2Zmc2V0KSAlIFBBQ0tFVF9MRU5HVEg7XG4gICAgaWYgKGxlbiA8IGRhdGEuYnl0ZUxlbmd0aCAmJiAhZmx1c2gpIHtcbiAgICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyLCBsZW4sIGRhdGEuYnVmZmVyLmJ5dGVMZW5ndGggLSBsZW4pO1xuICAgIH1cblxuICAgIC8vIGxvb3AgdGhyb3VnaCBUUyBwYWNrZXRzXG4gICAgbGV0IHRzUGFja2V0RXJyb3JzID0gMDtcbiAgICBmb3IgKGxldCBzdGFydCA9IHN5bmNPZmZzZXQ7IHN0YXJ0IDwgbGVuOyBzdGFydCArPSBQQUNLRVRfTEVOR1RIKSB7XG4gICAgICBpZiAoZGF0YVtzdGFydF0gPT09IDB4NDcpIHtcbiAgICAgICAgY29uc3Qgc3R0ID0gISEoZGF0YVtzdGFydCArIDFdICYgMHg0MCk7XG4gICAgICAgIGNvbnN0IHBpZCA9IHBhcnNlUElEKGRhdGEsIHN0YXJ0KTtcbiAgICAgICAgY29uc3QgYXRmID0gKGRhdGFbc3RhcnQgKyAzXSAmIDB4MzApID4+IDQ7XG5cbiAgICAgICAgLy8gaWYgYW4gYWRhcHRpb24gZmllbGQgaXMgcHJlc2VudCwgaXRzIGxlbmd0aCBpcyBzcGVjaWZpZWQgYnkgdGhlIGZpZnRoIGJ5dGUgb2YgdGhlIFRTIHBhY2tldCBoZWFkZXIuXG4gICAgICAgIGxldCBvZmZzZXQ7XG4gICAgICAgIGlmIChhdGYgPiAxKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gc3RhcnQgKyA1ICsgZGF0YVtzdGFydCArIDRdO1xuICAgICAgICAgIC8vIGNvbnRpbnVlIGlmIHRoZXJlIGlzIG9ubHkgYWRhcHRhdGlvbiBmaWVsZFxuICAgICAgICAgIGlmIChvZmZzZXQgPT09IHN0YXJ0ICsgUEFDS0VUX0xFTkdUSCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZnNldCA9IHN0YXJ0ICsgNDtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHBpZCkge1xuICAgICAgICAgIGNhc2UgdmlkZW9QaWQ6XG4gICAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICAgIGlmICh2aWRlb0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKHZpZGVvRGF0YSkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWRlb1BhcnNlci5wYXJzZUFWQ1BFUyh2aWRlb1RyYWNrLCB0ZXh0VHJhY2ssIHBlcywgZmFsc2UsIHRoaXMuX2R1cmF0aW9uKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2aWRlb0RhdGEgPSB7XG4gICAgICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICAgICAgc2l6ZTogMFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZpZGVvRGF0YSkge1xuICAgICAgICAgICAgICB2aWRlb0RhdGEuZGF0YS5wdXNoKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBzdGFydCArIFBBQ0tFVF9MRU5HVEgpKTtcbiAgICAgICAgICAgICAgdmlkZW9EYXRhLnNpemUgKz0gc3RhcnQgKyBQQUNLRVRfTEVOR1RIIC0gb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBhdWRpb1BpZDpcbiAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgaWYgKGF1ZGlvRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoYXVkaW9EYXRhKSkpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGF1ZGlvVHJhY2suc2VnbWVudENvZGVjKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlICdhYWMnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlQUFDUEVTKGF1ZGlvVHJhY2ssIHBlcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAnbXAzJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZU1QRUdQRVMoYXVkaW9UcmFjaywgcGVzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlICdhYzMnOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZUFDM1BFUyhhdWRpb1RyYWNrLCBwZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhdWRpb0RhdGEgPSB7XG4gICAgICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICAgICAgc2l6ZTogMFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF1ZGlvRGF0YSkge1xuICAgICAgICAgICAgICBhdWRpb0RhdGEuZGF0YS5wdXNoKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBzdGFydCArIFBBQ0tFVF9MRU5HVEgpKTtcbiAgICAgICAgICAgICAgYXVkaW9EYXRhLnNpemUgKz0gc3RhcnQgKyBQQUNLRVRfTEVOR1RIIC0gb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZDNQaWQ6XG4gICAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICAgIGlmIChpZDNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhpZDNEYXRhKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlSUQzUEVTKGlkM1RyYWNrLCBwZXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlkM0RhdGEgPSB7XG4gICAgICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICAgICAgc2l6ZTogMFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlkM0RhdGEpIHtcbiAgICAgICAgICAgICAgaWQzRGF0YS5kYXRhLnB1c2goZGF0YS5zdWJhcnJheShvZmZzZXQsIHN0YXJ0ICsgUEFDS0VUX0xFTkdUSCkpO1xuICAgICAgICAgICAgICBpZDNEYXRhLnNpemUgKz0gc3RhcnQgKyBQQUNLRVRfTEVOR1RIIC0gb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKHN0dCkge1xuICAgICAgICAgICAgICBvZmZzZXQgKz0gZGF0YVtvZmZzZXRdICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBtdElkID0gdGhpcy5fcG10SWQgPSBwYXJzZVBBVChkYXRhLCBvZmZzZXQpO1xuICAgICAgICAgICAgLy8gbG9nZ2VyLmxvZygnUE1UIFBJRDonICArIHRoaXMuX3BtdElkKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgcG10SWQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gZGF0YVtvZmZzZXRdICsgMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBwYXJzZWRQSURzID0gcGFyc2VQTVQoZGF0YSwgb2Zmc2V0LCB0aGlzLnR5cGVTdXBwb3J0ZWQsIGlzU2FtcGxlQWVzKTtcblxuICAgICAgICAgICAgICAvLyBvbmx5IHVwZGF0ZSB0cmFjayBpZCBpZiB0cmFjayBQSUQgZm91bmQgd2hpbGUgcGFyc2luZyBQTVRcbiAgICAgICAgICAgICAgLy8gdGhpcyBpcyB0byBhdm9pZCByZXNldHRpbmcgdGhlIFBJRCB0byAtMSBpbiBjYXNlXG4gICAgICAgICAgICAgIC8vIHRyYWNrIFBJRCB0cmFuc2llbnRseSBkaXNhcHBlYXJzIGZyb20gdGhlIHN0cmVhbVxuICAgICAgICAgICAgICAvLyB0aGlzIGNvdWxkIGhhcHBlbiBpbiBjYXNlIG9mIHRyYW5zaWVudCBtaXNzaW5nIGF1ZGlvIHNhbXBsZXMgZm9yIGV4YW1wbGVcbiAgICAgICAgICAgICAgLy8gTk9URSB0aGlzIGlzIG9ubHkgdGhlIFBJRCBvZiB0aGUgdHJhY2sgYXMgZm91bmQgaW4gVFMsXG4gICAgICAgICAgICAgIC8vIGJ1dCB3ZSBhcmUgbm90IHVzaW5nIHRoaXMgZm9yIE1QNCB0cmFjayBJRHMuXG4gICAgICAgICAgICAgIHZpZGVvUGlkID0gcGFyc2VkUElEcy52aWRlb1BpZDtcbiAgICAgICAgICAgICAgaWYgKHZpZGVvUGlkID4gMCkge1xuICAgICAgICAgICAgICAgIHZpZGVvVHJhY2sucGlkID0gdmlkZW9QaWQ7XG4gICAgICAgICAgICAgICAgdmlkZW9UcmFjay5zZWdtZW50Q29kZWMgPSBwYXJzZWRQSURzLnNlZ21lbnRWaWRlb0NvZGVjO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGF1ZGlvUGlkID0gcGFyc2VkUElEcy5hdWRpb1BpZDtcbiAgICAgICAgICAgICAgaWYgKGF1ZGlvUGlkID4gMCkge1xuICAgICAgICAgICAgICAgIGF1ZGlvVHJhY2sucGlkID0gYXVkaW9QaWQ7XG4gICAgICAgICAgICAgICAgYXVkaW9UcmFjay5zZWdtZW50Q29kZWMgPSBwYXJzZWRQSURzLnNlZ21lbnRBdWRpb0NvZGVjO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlkM1BpZCA9IHBhcnNlZFBJRHMuaWQzUGlkO1xuICAgICAgICAgICAgICBpZiAoaWQzUGlkID4gMCkge1xuICAgICAgICAgICAgICAgIGlkM1RyYWNrLnBpZCA9IGlkM1BpZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodW5rbm93blBJRCAhPT0gbnVsbCAmJiAhcG10UGFyc2VkKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYE1QRUctVFMgUE1UIGZvdW5kIGF0ICR7c3RhcnR9IGFmdGVyIHVua25vd24gUElEICcke3Vua25vd25QSUR9Jy4gQmFja3RyYWNraW5nIHRvIHN5bmMgYnl0ZSBAJHtzeW5jT2Zmc2V0fSB0byBwYXJzZSBhbGwgVFMgcGFja2V0cy5gKTtcbiAgICAgICAgICAgICAgICB1bmtub3duUElEID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyB3ZSBzZXQgaXQgdG8gLTE4OCwgdGhlICs9IDE4OCBpbiB0aGUgZm9yIGxvb3Agd2lsbCByZXNldCBzdGFydCB0byAwXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBzeW5jT2Zmc2V0IC0gMTg4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBtdFBhcnNlZCA9IHRoaXMucG10UGFyc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAweDExOlxuICAgICAgICAgIGNhc2UgMHgxZmZmOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHVua25vd25QSUQgPSBwaWQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHNQYWNrZXRFcnJvcnMrKztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRzUGFja2V0RXJyb3JzID4gMCkge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYEZvdW5kICR7dHNQYWNrZXRFcnJvcnN9IFRTIHBhY2tldC9zIHRoYXQgZG8gbm90IHN0YXJ0IHdpdGggMHg0N2ApO1xuICAgICAgdGhpcy5vYnNlcnZlci5lbWl0KEV2ZW50cy5FUlJPUiwgRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsXG4gICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHZpZGVvVHJhY2sucGVzRGF0YSA9IHZpZGVvRGF0YTtcbiAgICBhdWRpb1RyYWNrLnBlc0RhdGEgPSBhdWRpb0RhdGE7XG4gICAgaWQzVHJhY2sucGVzRGF0YSA9IGlkM0RhdGE7XG4gICAgY29uc3QgZGVtdXhSZXN1bHQgPSB7XG4gICAgICBhdWRpb1RyYWNrLFxuICAgICAgdmlkZW9UcmFjayxcbiAgICAgIGlkM1RyYWNrLFxuICAgICAgdGV4dFRyYWNrXG4gICAgfTtcbiAgICBpZiAoZmx1c2gpIHtcbiAgICAgIHRoaXMuZXh0cmFjdFJlbWFpbmluZ1NhbXBsZXMoZGVtdXhSZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gZGVtdXhSZXN1bHQ7XG4gIH1cbiAgZmx1c2goKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVtYWluZGVyRGF0YVxuICAgIH0gPSB0aGlzO1xuICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAocmVtYWluZGVyRGF0YSkge1xuICAgICAgcmVzdWx0ID0gdGhpcy5kZW11eChyZW1haW5kZXJEYXRhLCAtMSwgZmFsc2UsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIHZpZGVvVHJhY2s6IHRoaXMuX3ZpZGVvVHJhY2ssXG4gICAgICAgIGF1ZGlvVHJhY2s6IHRoaXMuX2F1ZGlvVHJhY2ssXG4gICAgICAgIGlkM1RyYWNrOiB0aGlzLl9pZDNUcmFjayxcbiAgICAgICAgdGV4dFRyYWNrOiB0aGlzLl90eHRUcmFja1xuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5leHRyYWN0UmVtYWluaW5nU2FtcGxlcyhyZXN1bHQpO1xuICAgIGlmICh0aGlzLnNhbXBsZUFlcykge1xuICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdChyZXN1bHQsIHRoaXMuc2FtcGxlQWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBleHRyYWN0UmVtYWluaW5nU2FtcGxlcyhkZW11eFJlc3VsdCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGF1ZGlvVHJhY2ssXG4gICAgICB2aWRlb1RyYWNrLFxuICAgICAgaWQzVHJhY2ssXG4gICAgICB0ZXh0VHJhY2tcbiAgICB9ID0gZGVtdXhSZXN1bHQ7XG4gICAgY29uc3QgdmlkZW9EYXRhID0gdmlkZW9UcmFjay5wZXNEYXRhO1xuICAgIGNvbnN0IGF1ZGlvRGF0YSA9IGF1ZGlvVHJhY2sucGVzRGF0YTtcbiAgICBjb25zdCBpZDNEYXRhID0gaWQzVHJhY2sucGVzRGF0YTtcbiAgICAvLyB0cnkgdG8gcGFyc2UgbGFzdCBQRVMgcGFja2V0c1xuICAgIGxldCBwZXM7XG4gICAgaWYgKHZpZGVvRGF0YSAmJiAocGVzID0gcGFyc2VQRVModmlkZW9EYXRhKSkpIHtcbiAgICAgIHRoaXMudmlkZW9QYXJzZXIucGFyc2VBVkNQRVModmlkZW9UcmFjaywgdGV4dFRyYWNrLCBwZXMsIHRydWUsIHRoaXMuX2R1cmF0aW9uKTtcbiAgICAgIHZpZGVvVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVpdGhlciBhdmNEYXRhIG51bGwgb3IgUEVTIHRydW5jYXRlZCwga2VlcCBpdCBmb3IgbmV4dCBmcmFnIHBhcnNpbmdcbiAgICAgIHZpZGVvVHJhY2sucGVzRGF0YSA9IHZpZGVvRGF0YTtcbiAgICB9XG4gICAgaWYgKGF1ZGlvRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoYXVkaW9EYXRhKSkpIHtcbiAgICAgIHN3aXRjaCAoYXVkaW9UcmFjay5zZWdtZW50Q29kZWMpIHtcbiAgICAgICAgY2FzZSAnYWFjJzpcbiAgICAgICAgICB0aGlzLnBhcnNlQUFDUEVTKGF1ZGlvVHJhY2ssIHBlcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ21wMyc6XG4gICAgICAgICAgdGhpcy5wYXJzZU1QRUdQRVMoYXVkaW9UcmFjaywgcGVzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYWMzJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlQUMzUEVTKGF1ZGlvVHJhY2ssIHBlcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYXVkaW9UcmFjay5wZXNEYXRhID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGF1ZGlvRGF0YSAhPSBudWxsICYmIGF1ZGlvRGF0YS5zaXplKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ2xhc3QgQUFDIFBFUyBwYWNrZXQgdHJ1bmNhdGVkLG1pZ2h0IG92ZXJsYXAgYmV0d2VlbiBmcmFnbWVudHMnKTtcbiAgICAgIH1cblxuICAgICAgLy8gZWl0aGVyIGF1ZGlvRGF0YSBudWxsIG9yIFBFUyB0cnVuY2F0ZWQsIGtlZXAgaXQgZm9yIG5leHQgZnJhZyBwYXJzaW5nXG4gICAgICBhdWRpb1RyYWNrLnBlc0RhdGEgPSBhdWRpb0RhdGE7XG4gICAgfVxuICAgIGlmIChpZDNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhpZDNEYXRhKSkpIHtcbiAgICAgIHRoaXMucGFyc2VJRDNQRVMoaWQzVHJhY2ssIHBlcyk7XG4gICAgICBpZDNUcmFjay5wZXNEYXRhID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZWl0aGVyIGlkM0RhdGEgbnVsbCBvciBQRVMgdHJ1bmNhdGVkLCBrZWVwIGl0IGZvciBuZXh0IGZyYWcgcGFyc2luZ1xuICAgICAgaWQzVHJhY2sucGVzRGF0YSA9IGlkM0RhdGE7XG4gICAgfVxuICB9XG4gIGRlbXV4U2FtcGxlQWVzKGRhdGEsIGtleURhdGEsIHRpbWVPZmZzZXQpIHtcbiAgICBjb25zdCBkZW11eFJlc3VsdCA9IHRoaXMuZGVtdXgoZGF0YSwgdGltZU9mZnNldCwgdHJ1ZSwgIXRoaXMuY29uZmlnLnByb2dyZXNzaXZlKTtcbiAgICBjb25zdCBzYW1wbGVBZXMgPSB0aGlzLnNhbXBsZUFlcyA9IG5ldyBTYW1wbGVBZXNEZWNyeXB0ZXIodGhpcy5vYnNlcnZlciwgdGhpcy5jb25maWcsIGtleURhdGEpO1xuICAgIHJldHVybiB0aGlzLmRlY3J5cHQoZGVtdXhSZXN1bHQsIHNhbXBsZUFlcyk7XG4gIH1cbiAgZGVjcnlwdChkZW11eFJlc3VsdCwgc2FtcGxlQWVzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBhdWRpb1RyYWNrLFxuICAgICAgICB2aWRlb1RyYWNrXG4gICAgICB9ID0gZGVtdXhSZXN1bHQ7XG4gICAgICBpZiAoYXVkaW9UcmFjay5zYW1wbGVzICYmIGF1ZGlvVHJhY2suc2VnbWVudENvZGVjID09PSAnYWFjJykge1xuICAgICAgICBzYW1wbGVBZXMuZGVjcnlwdEFhY1NhbXBsZXMoYXVkaW9UcmFjay5zYW1wbGVzLCAwLCAoKSA9PiB7XG4gICAgICAgICAgaWYgKHZpZGVvVHJhY2suc2FtcGxlcykge1xuICAgICAgICAgICAgc2FtcGxlQWVzLmRlY3J5cHRBdmNTYW1wbGVzKHZpZGVvVHJhY2suc2FtcGxlcywgMCwgMCwgKCkgPT4ge1xuICAgICAgICAgICAgICByZXNvbHZlKGRlbXV4UmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKGRlbXV4UmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICh2aWRlb1RyYWNrLnNhbXBsZXMpIHtcbiAgICAgICAgc2FtcGxlQWVzLmRlY3J5cHRBdmNTYW1wbGVzKHZpZGVvVHJhY2suc2FtcGxlcywgMCwgMCwgKCkgPT4ge1xuICAgICAgICAgIHJlc29sdmUoZGVtdXhSZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX2R1cmF0aW9uID0gMDtcbiAgfVxuICBwYXJzZUFBQ1BFUyh0cmFjaywgcGVzKSB7XG4gICAgbGV0IHN0YXJ0T2Zmc2V0ID0gMDtcbiAgICBjb25zdCBhYWNPdmVyRmxvdyA9IHRoaXMuYWFjT3ZlckZsb3c7XG4gICAgbGV0IGRhdGEgPSBwZXMuZGF0YTtcbiAgICBpZiAoYWFjT3ZlckZsb3cpIHtcbiAgICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBudWxsO1xuICAgICAgY29uc3QgZnJhbWVNaXNzaW5nQnl0ZXMgPSBhYWNPdmVyRmxvdy5taXNzaW5nO1xuICAgICAgY29uc3Qgc2FtcGxlTGVuZ3RoID0gYWFjT3ZlckZsb3cuc2FtcGxlLnVuaXQuYnl0ZUxlbmd0aDtcbiAgICAgIC8vIGxvZ2dlci5sb2coYEFBQzogYXBwZW5kIG92ZXJmbG93aW5nICR7c2FtcGxlTGVuZ3RofSBieXRlcyB0byBiZWdpbm5pbmcgb2YgbmV3IFBFU2ApO1xuICAgICAgaWYgKGZyYW1lTWlzc2luZ0J5dGVzID09PSAtMSkge1xuICAgICAgICBkYXRhID0gYXBwZW5kVWludDhBcnJheShhYWNPdmVyRmxvdy5zYW1wbGUudW5pdCwgZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBmcmFtZU92ZXJmbG93Qnl0ZXMgPSBzYW1wbGVMZW5ndGggLSBmcmFtZU1pc3NpbmdCeXRlcztcbiAgICAgICAgYWFjT3ZlckZsb3cuc2FtcGxlLnVuaXQuc2V0KGRhdGEuc3ViYXJyYXkoMCwgZnJhbWVNaXNzaW5nQnl0ZXMpLCBmcmFtZU92ZXJmbG93Qnl0ZXMpO1xuICAgICAgICB0cmFjay5zYW1wbGVzLnB1c2goYWFjT3ZlckZsb3cuc2FtcGxlKTtcbiAgICAgICAgc3RhcnRPZmZzZXQgPSBhYWNPdmVyRmxvdy5taXNzaW5nO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBsb29rIGZvciBBRFRTIGhlYWRlciAoMHhGRkZ4KVxuICAgIGxldCBvZmZzZXQ7XG4gICAgbGV0IGxlbjtcbiAgICBmb3IgKG9mZnNldCA9IHN0YXJ0T2Zmc2V0LCBsZW4gPSBkYXRhLmxlbmd0aDsgb2Zmc2V0IDwgbGVuIC0gMTsgb2Zmc2V0KyspIHtcbiAgICAgIGlmIChpc0hlYWRlciQxKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGlmIEFEVFMgaGVhZGVyIGRvZXMgbm90IHN0YXJ0IHN0cmFpZ2h0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgUEVTIHBheWxvYWQsIHJhaXNlIGFuIGVycm9yXG4gICAgaWYgKG9mZnNldCAhPT0gc3RhcnRPZmZzZXQpIHtcbiAgICAgIGxldCByZWFzb247XG4gICAgICBjb25zdCByZWNvdmVyYWJsZSA9IG9mZnNldCA8IGxlbiAtIDE7XG4gICAgICBpZiAocmVjb3ZlcmFibGUpIHtcbiAgICAgICAgcmVhc29uID0gYEFBQyBQRVMgZGlkIG5vdCBzdGFydCB3aXRoIEFEVFMgaGVhZGVyLG9mZnNldDoke29mZnNldH1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVhc29uID0gJ05vIEFEVFMgaGVhZGVyIGZvdW5kIGluIEFBQyBQRVMnO1xuICAgICAgfVxuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IocmVhc29uKTtcbiAgICAgIGxvZ2dlci53YXJuKGBwYXJzaW5nIGVycm9yOiAke3JlYXNvbn1gKTtcbiAgICAgIHRoaXMub2JzZXJ2ZXIuZW1pdChFdmVudHMuRVJST1IsIEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIGxldmVsUmV0cnk6IHJlY292ZXJhYmxlLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgcmVhc29uXG4gICAgICB9KTtcbiAgICAgIGlmICghcmVjb3ZlcmFibGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpbml0VHJhY2tDb25maWcodHJhY2ssIHRoaXMub2JzZXJ2ZXIsIGRhdGEsIG9mZnNldCwgdGhpcy5hdWRpb0NvZGVjKTtcbiAgICBsZXQgcHRzO1xuICAgIGlmIChwZXMucHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHB0cyA9IHBlcy5wdHM7XG4gICAgfSBlbHNlIGlmIChhYWNPdmVyRmxvdykge1xuICAgICAgLy8gaWYgbGFzdCBBQUMgZnJhbWUgaXMgb3ZlcmZsb3dpbmcsIHdlIHNob3VsZCBlbnN1cmUgdGltZXN0YW1wcyBhcmUgY29udGlndW91czpcbiAgICAgIC8vIGZpcnN0IHNhbXBsZSBQVFMgc2hvdWxkIGJlIGVxdWFsIHRvIGxhc3Qgc2FtcGxlIFBUUyArIGZyYW1lRHVyYXRpb25cbiAgICAgIGNvbnN0IGZyYW1lRHVyYXRpb24gPSBnZXRGcmFtZUR1cmF0aW9uKHRyYWNrLnNhbXBsZXJhdGUpO1xuICAgICAgcHRzID0gYWFjT3ZlckZsb3cuc2FtcGxlLnB0cyArIGZyYW1lRHVyYXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci53YXJuKCdbdHNkZW11eGVyXTogQUFDIFBFUyB1bmtub3duIFBUUycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHNjYW4gZm9yIGFhYyBzYW1wbGVzXG4gICAgbGV0IGZyYW1lSW5kZXggPSAwO1xuICAgIGxldCBmcmFtZTtcbiAgICB3aGlsZSAob2Zmc2V0IDwgbGVuKSB7XG4gICAgICBmcmFtZSA9IGFwcGVuZEZyYW1lJDIodHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KTtcbiAgICAgIG9mZnNldCArPSBmcmFtZS5sZW5ndGg7XG4gICAgICBpZiAoIWZyYW1lLm1pc3NpbmcpIHtcbiAgICAgICAgZnJhbWVJbmRleCsrO1xuICAgICAgICBmb3IgKDsgb2Zmc2V0IDwgbGVuIC0gMTsgb2Zmc2V0KyspIHtcbiAgICAgICAgICBpZiAoaXNIZWFkZXIkMShkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBmcmFtZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBhcnNlTVBFR1BFUyh0cmFjaywgcGVzKSB7XG4gICAgY29uc3QgZGF0YSA9IHBlcy5kYXRhO1xuICAgIGNvbnN0IGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgIGxldCBmcmFtZUluZGV4ID0gMDtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBjb25zdCBwdHMgPSBwZXMucHRzO1xuICAgIGlmIChwdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbG9nZ2VyLndhcm4oJ1t0c2RlbXV4ZXJdOiBNUEVHIFBFUyB1bmtub3duIFBUUycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3aGlsZSAob2Zmc2V0IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICBjb25zdCBmcmFtZSA9IGFwcGVuZEZyYW1lJDEodHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KTtcbiAgICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgICAgb2Zmc2V0ICs9IGZyYW1lLmxlbmd0aDtcbiAgICAgICAgICBmcmFtZUluZGV4Kys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbG9nZ2VyLmxvZygnVW5hYmxlIHRvIHBhcnNlIE1wZWcgYXVkaW8gZnJhbWUnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm90aGluZyBmb3VuZCwga2VlcCBsb29raW5nXG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwYXJzZUFDM1BFUyh0cmFjaywgcGVzKSB7XG4gICAge1xuICAgICAgY29uc3QgZGF0YSA9IHBlcy5kYXRhO1xuICAgICAgY29uc3QgcHRzID0gcGVzLnB0cztcbiAgICAgIGlmIChwdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsb2dnZXIud2FybignW3RzZGVtdXhlcl06IEFDMyBQRVMgdW5rbm93biBQVFMnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICBsZXQgZnJhbWVJbmRleCA9IDA7XG4gICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgIGxldCBwYXJzZWQ7XG4gICAgICB3aGlsZSAob2Zmc2V0IDwgbGVuZ3RoICYmIChwYXJzZWQgPSBhcHBlbmRGcmFtZSh0cmFjaywgZGF0YSwgb2Zmc2V0LCBwdHMsIGZyYW1lSW5kZXgrKykpID4gMCkge1xuICAgICAgICBvZmZzZXQgKz0gcGFyc2VkO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwYXJzZUlEM1BFUyhpZDNUcmFjaywgcGVzKSB7XG4gICAgaWYgKHBlcy5wdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbG9nZ2VyLndhcm4oJ1t0c2RlbXV4ZXJdOiBJRDMgUEVTIHVua25vd24gUFRTJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlkM1NhbXBsZSA9IF9leHRlbmRzKHt9LCBwZXMsIHtcbiAgICAgIHR5cGU6IHRoaXMuX3ZpZGVvVHJhY2sgPyBNZXRhZGF0YVNjaGVtYS5lbXNnIDogTWV0YWRhdGFTY2hlbWEuYXVkaW9JZDMsXG4gICAgICBkdXJhdGlvbjogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG4gICAgfSk7XG4gICAgaWQzVHJhY2suc2FtcGxlcy5wdXNoKGlkM1NhbXBsZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlUElEKGRhdGEsIG9mZnNldCkge1xuICAvLyBwaWQgaXMgYSAxMy1iaXQgZmllbGQgc3RhcnRpbmcgYXQgdGhlIGxhc3QgYml0IG9mIFRTWzFdXG4gIHJldHVybiAoKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDFmKSA8PCA4KSArIGRhdGFbb2Zmc2V0ICsgMl07XG59XG5mdW5jdGlvbiBwYXJzZVBBVChkYXRhLCBvZmZzZXQpIHtcbiAgLy8gc2tpcCB0aGUgUFNJIGhlYWRlciBhbmQgcGFyc2UgdGhlIGZpcnN0IFBNVCBlbnRyeVxuICByZXR1cm4gKGRhdGFbb2Zmc2V0ICsgMTBdICYgMHgxZikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgMTFdO1xufVxuZnVuY3Rpb24gcGFyc2VQTVQoZGF0YSwgb2Zmc2V0LCB0eXBlU3VwcG9ydGVkLCBpc1NhbXBsZUFlcykge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgYXVkaW9QaWQ6IC0xLFxuICAgIHZpZGVvUGlkOiAtMSxcbiAgICBpZDNQaWQ6IC0xLFxuICAgIHNlZ21lbnRWaWRlb0NvZGVjOiAnYXZjJyxcbiAgICBzZWdtZW50QXVkaW9Db2RlYzogJ2FhYydcbiAgfTtcbiAgY29uc3Qgc2VjdGlvbkxlbmd0aCA9IChkYXRhW29mZnNldCArIDFdICYgMHgwZikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgMl07XG4gIGNvbnN0IHRhYmxlRW5kID0gb2Zmc2V0ICsgMyArIHNlY3Rpb25MZW5ndGggLSA0O1xuICAvLyB0byBkZXRlcm1pbmUgd2hlcmUgdGhlIHRhYmxlIGlzLCB3ZSBoYXZlIHRvIGZpZ3VyZSBvdXQgaG93XG4gIC8vIGxvbmcgdGhlIHByb2dyYW0gaW5mbyBkZXNjcmlwdG9ycyBhcmVcbiAgY29uc3QgcHJvZ3JhbUluZm9MZW5ndGggPSAoZGF0YVtvZmZzZXQgKyAxMF0gJiAweDBmKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyAxMV07XG4gIC8vIGFkdmFuY2UgdGhlIG9mZnNldCB0byB0aGUgZmlyc3QgZW50cnkgaW4gdGhlIG1hcHBpbmcgdGFibGVcbiAgb2Zmc2V0ICs9IDEyICsgcHJvZ3JhbUluZm9MZW5ndGg7XG4gIHdoaWxlIChvZmZzZXQgPCB0YWJsZUVuZCkge1xuICAgIGNvbnN0IHBpZCA9IHBhcnNlUElEKGRhdGEsIG9mZnNldCk7XG4gICAgY29uc3QgZXNJbmZvTGVuZ3RoID0gKGRhdGFbb2Zmc2V0ICsgM10gJiAweDBmKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyA0XTtcbiAgICBzd2l0Y2ggKGRhdGFbb2Zmc2V0XSkge1xuICAgICAgY2FzZSAweGNmOlxuICAgICAgICAvLyBTQU1QTEUtQUVTIEFBQ1xuICAgICAgICBpZiAoIWlzU2FtcGxlQWVzKSB7XG4gICAgICAgICAgbG9nRW5jcnlwdGVkU2FtcGxlc0ZvdW5kSW5VbmVuY3J5cHRlZFN0cmVhbSgnQURUUyBBQUMnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSAweDBmOlxuICAgICAgICAvLyBJU08vSUVDIDEzODE4LTcgQURUUyBBQUMgKE1QRUctMiBsb3dlciBiaXQtcmF0ZSBhdWRpbylcbiAgICAgICAgLy8gbG9nZ2VyLmxvZygnQUFDIFBJRDonICArIHBpZCk7XG4gICAgICAgIGlmIChyZXN1bHQuYXVkaW9QaWQgPT09IC0xKSB7XG4gICAgICAgICAgcmVzdWx0LmF1ZGlvUGlkID0gcGlkO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBQYWNrZXRpemVkIG1ldGFkYXRhIChJRDMpXG4gICAgICBjYXNlIDB4MTU6XG4gICAgICAgIC8vIGxvZ2dlci5sb2coJ0lEMyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICBpZiAocmVzdWx0LmlkM1BpZCA9PT0gLTEpIHtcbiAgICAgICAgICByZXN1bHQuaWQzUGlkID0gcGlkO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAweGRiOlxuICAgICAgICAvLyBTQU1QTEUtQUVTIEFWQ1xuICAgICAgICBpZiAoIWlzU2FtcGxlQWVzKSB7XG4gICAgICAgICAgbG9nRW5jcnlwdGVkU2FtcGxlc0ZvdW5kSW5VbmVuY3J5cHRlZFN0cmVhbSgnSC4yNjQnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSAweDFiOlxuICAgICAgICAvLyBJVFUtVCBSZWMuIEguMjY0IGFuZCBJU08vSUVDIDE0NDk2LTEwIChsb3dlciBiaXQtcmF0ZSB2aWRlbylcbiAgICAgICAgLy8gbG9nZ2VyLmxvZygnQVZDIFBJRDonICArIHBpZCk7XG4gICAgICAgIGlmIChyZXN1bHQudmlkZW9QaWQgPT09IC0xKSB7XG4gICAgICAgICAgcmVzdWx0LnZpZGVvUGlkID0gcGlkO1xuICAgICAgICAgIHJlc3VsdC5zZWdtZW50VmlkZW9Db2RlYyA9ICdhdmMnO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBJU08vSUVDIDExMTcyLTMgKE1QRUctMSBhdWRpbylcbiAgICAgIC8vIG9yIElTTy9JRUMgMTM4MTgtMyAoTVBFRy0yIGhhbHZlZCBzYW1wbGUgcmF0ZSBhdWRpbylcbiAgICAgIGNhc2UgMHgwMzpcbiAgICAgIGNhc2UgMHgwNDpcbiAgICAgICAgLy8gbG9nZ2VyLmxvZygnTVBFRyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICBpZiAoIXR5cGVTdXBwb3J0ZWQubXBlZyAmJiAhdHlwZVN1cHBvcnRlZC5tcDMpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKCdNUEVHIGF1ZGlvIGZvdW5kLCBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5hdWRpb1BpZCA9PT0gLTEpIHtcbiAgICAgICAgICByZXN1bHQuYXVkaW9QaWQgPSBwaWQ7XG4gICAgICAgICAgcmVzdWx0LnNlZ21lbnRBdWRpb0NvZGVjID0gJ21wMyc7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDB4YzE6XG4gICAgICAgIC8vIFNBTVBMRS1BRVMgQUMzXG4gICAgICAgIGlmICghaXNTYW1wbGVBZXMpIHtcbiAgICAgICAgICBsb2dFbmNyeXB0ZWRTYW1wbGVzRm91bmRJblVuZW5jcnlwdGVkU3RyZWFtKCdBQy0zJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgMHg4MTpcbiAgICAgICAge1xuICAgICAgICAgIGlmICghdHlwZVN1cHBvcnRlZC5hYzMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0FDLTMgYXVkaW8gZm91bmQsIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQuYXVkaW9QaWQgPT09IC0xKSB7XG4gICAgICAgICAgICByZXN1bHQuYXVkaW9QaWQgPSBwaWQ7XG4gICAgICAgICAgICByZXN1bHQuc2VnbWVudEF1ZGlvQ29kZWMgPSAnYWMzJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDB4MDY6XG4gICAgICAgIC8vIHN0cmVhbV90eXBlIDYgY2FuIG1lYW4gYSBsb3Qgb2YgZGlmZmVyZW50IHRoaW5ncyBpbiBjYXNlIG9mIERWQi5cbiAgICAgICAgLy8gV2UgbmVlZCB0byBsb29rIGF0IHRoZSBkZXNjcmlwdG9ycy4gUmlnaHQgbm93LCB3ZSdyZSBvbmx5IGludGVyZXN0ZWRcbiAgICAgICAgLy8gaW4gQUMtMyBhdWRpbywgc28gd2UgZG8gdGhlIGRlc2NyaXB0b3IgcGFyc2luZyBvbmx5IHdoZW4gd2UgZG9uJ3QgaGF2ZVxuICAgICAgICAvLyBhbiBhdWRpbyBQSUQgeWV0LlxuICAgICAgICBpZiAocmVzdWx0LmF1ZGlvUGlkID09PSAtMSAmJiBlc0luZm9MZW5ndGggPiAwKSB7XG4gICAgICAgICAgbGV0IHBhcnNlUG9zID0gb2Zmc2V0ICsgNTtcbiAgICAgICAgICBsZXQgcmVtYWluaW5nID0gZXNJbmZvTGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChyZW1haW5pbmcgPiAyKSB7XG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdG9ySWQgPSBkYXRhW3BhcnNlUG9zXTtcbiAgICAgICAgICAgIHN3aXRjaCAoZGVzY3JpcHRvcklkKSB7XG4gICAgICAgICAgICAgIGNhc2UgMHg2YTpcbiAgICAgICAgICAgICAgICAvLyBEVkIgRGVzY3JpcHRvciBmb3IgQUMtM1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlU3VwcG9ydGVkLmFjMyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKCdBQy0zIGF1ZGlvIGZvdW5kLCBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlciBmb3Igbm93Jyk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXVkaW9QaWQgPSBwaWQ7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZWdtZW50QXVkaW9Db2RlYyA9ICdhYzMnO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0b3JMZW4gPSBkYXRhW3BhcnNlUG9zICsgMV0gKyAyO1xuICAgICAgICAgICAgcGFyc2VQb3MgKz0gZGVzY3JpcHRvckxlbjtcbiAgICAgICAgICAgIHJlbWFpbmluZyAtPSBkZXNjcmlwdG9yTGVuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMHhjMjogLy8gU0FNUExFLUFFUyBFQzNcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgMHg4NzpcbiAgICAgICAgbG9nZ2VyLndhcm4oJ1Vuc3VwcG9ydGVkIEVDLTMgaW4gTTJUUyBmb3VuZCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMHgyNDpcbiAgICAgICAgbG9nZ2VyLndhcm4oJ1Vuc3VwcG9ydGVkIEhFVkMgaW4gTTJUUyBmb3VuZCcpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gbW92ZSB0byB0aGUgbmV4dCB0YWJsZSBlbnRyeVxuICAgIC8vIHNraXAgcGFzdCB0aGUgZWxlbWVudGFyeSBzdHJlYW0gZGVzY3JpcHRvcnMsIGlmIHByZXNlbnRcbiAgICBvZmZzZXQgKz0gZXNJbmZvTGVuZ3RoICsgNTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbG9nRW5jcnlwdGVkU2FtcGxlc0ZvdW5kSW5VbmVuY3J5cHRlZFN0cmVhbSh0eXBlKSB7XG4gIGxvZ2dlci5sb2coYCR7dHlwZX0gd2l0aCBBRVMtMTI4LUNCQyBlbmNyeXB0aW9uIGZvdW5kIGluIHVuZW5jcnlwdGVkIHN0cmVhbWApO1xufVxuZnVuY3Rpb24gcGFyc2VQRVMoc3RyZWFtKSB7XG4gIGxldCBpID0gMDtcbiAgbGV0IGZyYWc7XG4gIGxldCBwZXNMZW47XG4gIGxldCBwZXNIZHJMZW47XG4gIGxldCBwZXNQdHM7XG4gIGxldCBwZXNEdHM7XG4gIGNvbnN0IGRhdGEgPSBzdHJlYW0uZGF0YTtcbiAgLy8gc2FmZXR5IGNoZWNrXG4gIGlmICghc3RyZWFtIHx8IHN0cmVhbS5zaXplID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyB3ZSBtaWdodCBuZWVkIHVwIHRvIDE5IGJ5dGVzIHRvIHJlYWQgUEVTIGhlYWRlclxuICAvLyBpZiBmaXJzdCBjaHVuayBvZiBkYXRhIGlzIGxlc3MgdGhhbiAxOSBieXRlcywgbGV0J3MgbWVyZ2UgaXQgd2l0aCBmb2xsb3dpbmcgb25lcyB1bnRpbCB3ZSBnZXQgMTkgYnl0ZXNcbiAgLy8gdXN1YWxseSBvbmx5IG9uZSBtZXJnZSBpcyBuZWVkZWQgKGFuZCB0aGlzIGlzIHJhcmUgLi4uKVxuICB3aGlsZSAoZGF0YVswXS5sZW5ndGggPCAxOSAmJiBkYXRhLmxlbmd0aCA+IDEpIHtcbiAgICBkYXRhWzBdID0gYXBwZW5kVWludDhBcnJheShkYXRhWzBdLCBkYXRhWzFdKTtcbiAgICBkYXRhLnNwbGljZSgxLCAxKTtcbiAgfVxuICAvLyByZXRyaWV2ZSBQVFMvRFRTIGZyb20gZmlyc3QgZnJhZ21lbnRcbiAgZnJhZyA9IGRhdGFbMF07XG4gIGNvbnN0IHBlc1ByZWZpeCA9IChmcmFnWzBdIDw8IDE2KSArIChmcmFnWzFdIDw8IDgpICsgZnJhZ1syXTtcbiAgaWYgKHBlc1ByZWZpeCA9PT0gMSkge1xuICAgIHBlc0xlbiA9IChmcmFnWzRdIDw8IDgpICsgZnJhZ1s1XTtcbiAgICAvLyBpZiBQRVMgcGFyc2VkIGxlbmd0aCBpcyBub3QgemVybyBhbmQgZ3JlYXRlciB0aGFuIHRvdGFsIHJlY2VpdmVkIGxlbmd0aCwgc3RvcCBwYXJzaW5nLiBQRVMgbWlnaHQgYmUgdHJ1bmNhdGVkXG4gICAgLy8gbWludXMgNiA6IFBFUyBoZWFkZXIgc2l6ZVxuICAgIGlmIChwZXNMZW4gJiYgcGVzTGVuID4gc3RyZWFtLnNpemUgLSA2KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcGVzRmxhZ3MgPSBmcmFnWzddO1xuICAgIGlmIChwZXNGbGFncyAmIDB4YzApIHtcbiAgICAgIC8qIFBFUyBoZWFkZXIgZGVzY3JpYmVkIGhlcmUgOiBodHRwOi8vZHZkLnNvdXJjZWZvcmdlLm5ldC9kdmRpbmZvL3Blcy1oZHIuaHRtbFxuICAgICAgICAgIGFzIFBUUyAvIERUUyBpcyAzMyBiaXQgd2UgY2Fubm90IHVzZSBiaXR3aXNlIG9wZXJhdG9yIGluIEpTLFxuICAgICAgICAgIGFzIEJpdHdpc2Ugb3BlcmF0b3JzIHRyZWF0IHRoZWlyIG9wZXJhbmRzIGFzIGEgc2VxdWVuY2Ugb2YgMzIgYml0cyAqL1xuICAgICAgcGVzUHRzID0gKGZyYWdbOV0gJiAweDBlKSAqIDUzNjg3MDkxMiArXG4gICAgICAvLyAxIDw8IDI5XG4gICAgICAoZnJhZ1sxMF0gJiAweGZmKSAqIDQxOTQzMDQgK1xuICAgICAgLy8gMSA8PCAyMlxuICAgICAgKGZyYWdbMTFdICYgMHhmZSkgKiAxNjM4NCArXG4gICAgICAvLyAxIDw8IDE0XG4gICAgICAoZnJhZ1sxMl0gJiAweGZmKSAqIDEyOCArXG4gICAgICAvLyAxIDw8IDdcbiAgICAgIChmcmFnWzEzXSAmIDB4ZmUpIC8gMjtcbiAgICAgIGlmIChwZXNGbGFncyAmIDB4NDApIHtcbiAgICAgICAgcGVzRHRzID0gKGZyYWdbMTRdICYgMHgwZSkgKiA1MzY4NzA5MTIgK1xuICAgICAgICAvLyAxIDw8IDI5XG4gICAgICAgIChmcmFnWzE1XSAmIDB4ZmYpICogNDE5NDMwNCArXG4gICAgICAgIC8vIDEgPDwgMjJcbiAgICAgICAgKGZyYWdbMTZdICYgMHhmZSkgKiAxNjM4NCArXG4gICAgICAgIC8vIDEgPDwgMTRcbiAgICAgICAgKGZyYWdbMTddICYgMHhmZikgKiAxMjggK1xuICAgICAgICAvLyAxIDw8IDdcbiAgICAgICAgKGZyYWdbMThdICYgMHhmZSkgLyAyO1xuICAgICAgICBpZiAocGVzUHRzIC0gcGVzRHRzID4gNjAgKiA5MDAwMCkge1xuICAgICAgICAgIGxvZ2dlci53YXJuKGAke01hdGgucm91bmQoKHBlc1B0cyAtIHBlc0R0cykgLyA5MDAwMCl9cyBkZWx0YSBiZXR3ZWVuIFBUUyBhbmQgRFRTLCBhbGlnbiB0aGVtYCk7XG4gICAgICAgICAgcGVzUHRzID0gcGVzRHRzO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZXNEdHMgPSBwZXNQdHM7XG4gICAgICB9XG4gICAgfVxuICAgIHBlc0hkckxlbiA9IGZyYWdbOF07XG4gICAgLy8gOSBieXRlcyA6IDYgYnl0ZXMgZm9yIFBFUyBoZWFkZXIgKyAzIGJ5dGVzIGZvciBQRVMgZXh0ZW5zaW9uXG4gICAgbGV0IHBheWxvYWRTdGFydE9mZnNldCA9IHBlc0hkckxlbiArIDk7XG4gICAgaWYgKHN0cmVhbS5zaXplIDw9IHBheWxvYWRTdGFydE9mZnNldCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHN0cmVhbS5zaXplIC09IHBheWxvYWRTdGFydE9mZnNldDtcbiAgICAvLyByZWFzc2VtYmxlIFBFUyBwYWNrZXRcbiAgICBjb25zdCBwZXNEYXRhID0gbmV3IFVpbnQ4QXJyYXkoc3RyZWFtLnNpemUpO1xuICAgIGZvciAobGV0IGogPSAwLCBkYXRhTGVuID0gZGF0YS5sZW5ndGg7IGogPCBkYXRhTGVuOyBqKyspIHtcbiAgICAgIGZyYWcgPSBkYXRhW2pdO1xuICAgICAgbGV0IGxlbiA9IGZyYWcuYnl0ZUxlbmd0aDtcbiAgICAgIGlmIChwYXlsb2FkU3RhcnRPZmZzZXQpIHtcbiAgICAgICAgaWYgKHBheWxvYWRTdGFydE9mZnNldCA+IGxlbikge1xuICAgICAgICAgIC8vIHRyaW0gZnVsbCBmcmFnIGlmIFBFUyBoZWFkZXIgYmlnZ2VyIHRoYW4gZnJhZ1xuICAgICAgICAgIHBheWxvYWRTdGFydE9mZnNldCAtPSBsZW47XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdHJpbSBwYXJ0aWFsIGZyYWcgaWYgUEVTIGhlYWRlciBzbWFsbGVyIHRoYW4gZnJhZ1xuICAgICAgICAgIGZyYWcgPSBmcmFnLnN1YmFycmF5KHBheWxvYWRTdGFydE9mZnNldCk7XG4gICAgICAgICAgbGVuIC09IHBheWxvYWRTdGFydE9mZnNldDtcbiAgICAgICAgICBwYXlsb2FkU3RhcnRPZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwZXNEYXRhLnNldChmcmFnLCBpKTtcbiAgICAgIGkgKz0gbGVuO1xuICAgIH1cbiAgICBpZiAocGVzTGVuKSB7XG4gICAgICAvLyBwYXlsb2FkIHNpemUgOiByZW1vdmUgUEVTIGhlYWRlciArIFBFUyBleHRlbnNpb25cbiAgICAgIHBlc0xlbiAtPSBwZXNIZHJMZW4gKyAzO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogcGVzRGF0YSxcbiAgICAgIHB0czogcGVzUHRzLFxuICAgICAgZHRzOiBwZXNEdHMsXG4gICAgICBsZW46IHBlc0xlblxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogTVAzIGRlbXV4ZXJcbiAqL1xuY2xhc3MgTVAzRGVtdXhlciBleHRlbmRzIEJhc2VBdWRpb0RlbXV4ZXIge1xuICByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0cmFja0R1cmF0aW9uKSB7XG4gICAgc3VwZXIucmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbik7XG4gICAgdGhpcy5fYXVkaW9UcmFjayA9IHtcbiAgICAgIGNvbnRhaW5lcjogJ2F1ZGlvL21wZWcnLFxuICAgICAgdHlwZTogJ2F1ZGlvJyxcbiAgICAgIGlkOiAyLFxuICAgICAgcGlkOiAtMSxcbiAgICAgIHNlcXVlbmNlTnVtYmVyOiAwLFxuICAgICAgc2VnbWVudENvZGVjOiAnbXAzJyxcbiAgICAgIHNhbXBsZXM6IFtdLFxuICAgICAgbWFuaWZlc3RDb2RlYzogYXVkaW9Db2RlYyxcbiAgICAgIGR1cmF0aW9uOiB0cmFja0R1cmF0aW9uLFxuICAgICAgaW5wdXRUaW1lU2NhbGU6IDkwMDAwLFxuICAgICAgZHJvcHBlZDogMFxuICAgIH07XG4gIH1cbiAgc3RhdGljIHByb2JlKGRhdGEpIHtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiBkYXRhIGNvbnRhaW5zIElEMyB0aW1lc3RhbXAgYW5kIE1QRUcgc3luYyB3b3JkXG4gICAgLy8gTG9vayBmb3IgTVBFRyBoZWFkZXIgfCAxMTExIDExMTEgfCAxMTFYIFhZWlggfCB3aGVyZSBYIGNhbiBiZSBlaXRoZXIgMCBvciAxIGFuZCBZIG9yIFogc2hvdWxkIGJlIDFcbiAgICAvLyBMYXllciBiaXRzIChwb3NpdGlvbiAxNCBhbmQgMTUpIGluIGhlYWRlciBzaG91bGQgYmUgYWx3YXlzIGRpZmZlcmVudCBmcm9tIDAgKExheWVyIEkgb3IgTGF5ZXIgSUkgb3IgTGF5ZXIgSUlJKVxuICAgIC8vIE1vcmUgaW5mbyBodHRwOi8vd3d3Lm1wMy10ZWNoLm9yZy9wcm9ncmFtbWVyL2ZyYW1lX2hlYWRlci5odG1sXG4gICAgY29uc3QgaWQzRGF0YSA9IGdldElEM0RhdGEoZGF0YSwgMCk7XG4gICAgbGV0IG9mZnNldCA9IChpZDNEYXRhID09IG51bGwgPyB2b2lkIDAgOiBpZDNEYXRhLmxlbmd0aCkgfHwgMDtcblxuICAgIC8vIENoZWNrIGZvciBhYy0zfGVjLTMgc3luYyBieXRlcyBhbmQgcmV0dXJuIGZhbHNlIGlmIHByZXNlbnRcbiAgICBpZiAoaWQzRGF0YSAmJiBkYXRhW29mZnNldF0gPT09IDB4MGIgJiYgZGF0YVtvZmZzZXQgKyAxXSA9PT0gMHg3NyAmJiBnZXRUaW1lU3RhbXAoaWQzRGF0YSkgIT09IHVuZGVmaW5lZCAmJlxuICAgIC8vIGNoZWNrIHRoZSBic2lkIHRvIGNvbmZpcm0gYWMtMyBvciBlYy0zIChub3QgbXAzKVxuICAgIGdldEF1ZGlvQlNJRChkYXRhLCBvZmZzZXQpIDw9IDE2KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGxlbmd0aCA9IGRhdGEubGVuZ3RoOyBvZmZzZXQgPCBsZW5ndGg7IG9mZnNldCsrKSB7XG4gICAgICBpZiAocHJvYmUoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICBsb2dnZXIubG9nKCdNUEVHIEF1ZGlvIHN5bmMgd29yZCBmb3VuZCAhJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY2FuUGFyc2UoZGF0YSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGNhblBhcnNlKGRhdGEsIG9mZnNldCk7XG4gIH1cbiAgYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCkge1xuICAgIGlmICh0aGlzLmJhc2VQVFMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGFwcGVuZEZyYW1lJDEodHJhY2ssIGRhdGEsIG9mZnNldCwgdGhpcy5iYXNlUFRTLCB0aGlzLmZyYW1lSW5kZXgpO1xuICB9XG59XG5cbi8qKlxuICogIEFBQyBoZWxwZXJcbiAqL1xuXG5jbGFzcyBBQUMge1xuICBzdGF0aWMgZ2V0U2lsZW50RnJhbWUoY29kZWMsIGNoYW5uZWxDb3VudCkge1xuICAgIHN3aXRjaCAoY29kZWMpIHtcbiAgICAgIGNhc2UgJ21wNGEuNDAuMic6XG4gICAgICAgIGlmIChjaGFubmVsQ291bnQgPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjMsIDB4ODBdKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MjEsIDB4MDAsIDB4NDksIDB4OTAsIDB4MDIsIDB4MTksIDB4MDAsIDB4MjMsIDB4ODBdKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsIDB4MDAsIDB4OGVdKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsIDB4MDAsIDB4ODAsIDB4MmMsIDB4ODAsIDB4MDgsIDB4MDIsIDB4MzhdKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDUpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsIDB4MDAsIDB4ODIsIDB4MzAsIDB4MDQsIDB4OTksIDB4MDAsIDB4MjEsIDB4OTAsIDB4MDIsIDB4MzhdKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDYpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsIDB4MDAsIDB4ODIsIDB4MzAsIDB4MDQsIDB4OTksIDB4MDAsIDB4MjEsIDB4OTAsIDB4MDIsIDB4MDAsIDB4YjIsIDB4MDAsIDB4MjAsIDB4MDgsIDB4ZTBdKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIC8vIGhhbmRsZSBIRS1BQUMgYmVsb3cgKG1wNGEuNDAuNSAvIG1wNGEuNDAuMjkpXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoY2hhbm5lbENvdW50ID09PSAxKSB7XG4gICAgICAgICAgLy8gZmZtcGVnIC15IC1mIGxhdmZpIC1pIFwiYWV2YWxzcmM9MDpkPTAuMDVcIiAtYzphIGxpYmZka19hYWMgLXByb2ZpbGU6YSBhYWNfaGUgLWI6YSA0ayBvdXRwdXQuYWFjICYmIGhleGR1bXAgLXYgLWUgJzE2LzEgXCIweCV4LFwiIFwiXFxuXCInIC12IG91dHB1dC5hYWNcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MSwgMHg0MCwgMHgyMiwgMHg4MCwgMHhhMywgMHg0ZSwgMHhlNiwgMHg4MCwgMHhiYSwgMHg4LCAweDAsIDB4MCwgMHgwLCAweDFjLCAweDYsIDB4ZjEsIDB4YzEsIDB4YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1ZV0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMikge1xuICAgICAgICAgIC8vIGZmbXBlZyAteSAtZiBsYXZmaSAtaSBcImFldmFsc3JjPTB8MDpkPTAuMDVcIiAtYzphIGxpYmZka19hYWMgLXByb2ZpbGU6YSBhYWNfaGVfdjIgLWI6YSA0ayBvdXRwdXQuYWFjICYmIGhleGR1bXAgLXYgLWUgJzE2LzEgXCIweCV4LFwiIFwiXFxuXCInIC12IG91dHB1dC5hYWNcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MSwgMHg0MCwgMHgyMiwgMHg4MCwgMHhhMywgMHg1ZSwgMHhlNiwgMHg4MCwgMHhiYSwgMHg4LCAweDAsIDB4MCwgMHgwLCAweDAsIDB4OTUsIDB4MCwgMHg2LCAweGYxLCAweGExLCAweGEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWVdKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDMpIHtcbiAgICAgICAgICAvLyBmZm1wZWcgLXkgLWYgbGF2ZmkgLWkgXCJhZXZhbHNyYz0wfDB8MDpkPTAuMDVcIiAtYzphIGxpYmZka19hYWMgLXByb2ZpbGU6YSBhYWNfaGVfdjIgLWI6YSA0ayBvdXRwdXQuYWFjICYmIGhleGR1bXAgLXYgLWUgJzE2LzEgXCIweCV4LFwiIFwiXFxuXCInIC12IG91dHB1dC5hYWNcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MSwgMHg0MCwgMHgyMiwgMHg4MCwgMHhhMywgMHg1ZSwgMHhlNiwgMHg4MCwgMHhiYSwgMHg4LCAweDAsIDB4MCwgMHgwLCAweDAsIDB4OTUsIDB4MCwgMHg2LCAweGYxLCAweGExLCAweGEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWVdKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIEdlbmVyYXRlIE1QNCBCb3hcbiAqL1xuXG5jb25zdCBVSU5UMzJfTUFYID0gTWF0aC5wb3coMiwgMzIpIC0gMTtcbmNsYXNzIE1QNCB7XG4gIHN0YXRpYyBpbml0KCkge1xuICAgIE1QNC50eXBlcyA9IHtcbiAgICAgIGF2YzE6IFtdLFxuICAgICAgLy8gY29kaW5nbmFtZVxuICAgICAgYXZjQzogW10sXG4gICAgICBidHJ0OiBbXSxcbiAgICAgIGRpbmY6IFtdLFxuICAgICAgZHJlZjogW10sXG4gICAgICBlc2RzOiBbXSxcbiAgICAgIGZ0eXA6IFtdLFxuICAgICAgaGRscjogW10sXG4gICAgICBtZGF0OiBbXSxcbiAgICAgIG1kaGQ6IFtdLFxuICAgICAgbWRpYTogW10sXG4gICAgICBtZmhkOiBbXSxcbiAgICAgIG1pbmY6IFtdLFxuICAgICAgbW9vZjogW10sXG4gICAgICBtb292OiBbXSxcbiAgICAgIG1wNGE6IFtdLFxuICAgICAgJy5tcDMnOiBbXSxcbiAgICAgIGRhYzM6IFtdLFxuICAgICAgJ2FjLTMnOiBbXSxcbiAgICAgIG12ZXg6IFtdLFxuICAgICAgbXZoZDogW10sXG4gICAgICBwYXNwOiBbXSxcbiAgICAgIHNkdHA6IFtdLFxuICAgICAgc3RibDogW10sXG4gICAgICBzdGNvOiBbXSxcbiAgICAgIHN0c2M6IFtdLFxuICAgICAgc3RzZDogW10sXG4gICAgICBzdHN6OiBbXSxcbiAgICAgIHN0dHM6IFtdLFxuICAgICAgdGZkdDogW10sXG4gICAgICB0ZmhkOiBbXSxcbiAgICAgIHRyYWY6IFtdLFxuICAgICAgdHJhazogW10sXG4gICAgICB0cnVuOiBbXSxcbiAgICAgIHRyZXg6IFtdLFxuICAgICAgdGtoZDogW10sXG4gICAgICB2bWhkOiBbXSxcbiAgICAgIHNtaGQ6IFtdXG4gICAgfTtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgaW4gTVA0LnR5cGVzKSB7XG4gICAgICBpZiAoTVA0LnR5cGVzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgIE1QNC50eXBlc1tpXSA9IFtpLmNoYXJDb2RlQXQoMCksIGkuY2hhckNvZGVBdCgxKSwgaS5jaGFyQ29kZUF0KDIpLCBpLmNoYXJDb2RlQXQoMyldO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB2aWRlb0hkbHIgPSBuZXcgVWludDhBcnJheShbMHgwMCxcbiAgICAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGZsYWdzXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBwcmVfZGVmaW5lZFxuICAgIDB4NzYsIDB4NjksIDB4NjQsIDB4NjUsXG4gICAgLy8gaGFuZGxlcl90eXBlOiAndmlkZSdcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDU2LCAweDY5LCAweDY0LCAweDY1LCAweDZmLCAweDQ4LCAweDYxLCAweDZlLCAweDY0LCAweDZjLCAweDY1LCAweDcyLCAweDAwIC8vIG5hbWU6ICdWaWRlb0hhbmRsZXInXG4gICAgXSk7XG4gICAgY29uc3QgYXVkaW9IZGxyID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcHJlX2RlZmluZWRcbiAgICAweDczLCAweDZmLCAweDc1LCAweDZlLFxuICAgIC8vIGhhbmRsZXJfdHlwZTogJ3NvdW4nXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHg1MywgMHg2ZiwgMHg3NSwgMHg2ZSwgMHg2NCwgMHg0OCwgMHg2MSwgMHg2ZSwgMHg2NCwgMHg2YywgMHg2NSwgMHg3MiwgMHgwMCAvLyBuYW1lOiAnU291bmRIYW5kbGVyJ1xuICAgIF0pO1xuICAgIE1QNC5IRExSX1RZUEVTID0ge1xuICAgICAgdmlkZW86IHZpZGVvSGRscixcbiAgICAgIGF1ZGlvOiBhdWRpb0hkbHJcbiAgICB9O1xuICAgIGNvbnN0IGRyZWYgPSBuZXcgVWludDhBcnJheShbMHgwMCxcbiAgICAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGZsYWdzXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSxcbiAgICAvLyBlbnRyeV9jb3VudFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MGMsXG4gICAgLy8gZW50cnlfc2l6ZVxuICAgIDB4NzUsIDB4NzIsIDB4NmMsIDB4MjAsXG4gICAgLy8gJ3VybCcgdHlwZVxuICAgIDB4MDAsXG4gICAgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwMCwgMHgwMSAvLyBlbnRyeV9mbGFnc1xuICAgIF0pO1xuICAgIGNvbnN0IHN0Y28gPSBuZXcgVWludDhBcnJheShbMHgwMCxcbiAgICAvLyB2ZXJzaW9uXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAgLy8gZW50cnlfY291bnRcbiAgICBdKTtcbiAgICBNUDQuU1RUUyA9IE1QNC5TVFNDID0gTVA0LlNUQ08gPSBzdGNvO1xuICAgIE1QNC5TVFNaID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgLy8gdmVyc2lvblxuICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gZmxhZ3NcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHNhbXBsZV9zaXplXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCAvLyBzYW1wbGVfY291bnRcbiAgICBdKTtcbiAgICBNUDQuVk1IRCA9IG5ldyBVaW50OEFycmF5KFsweDAwLFxuICAgIC8vIHZlcnNpb25cbiAgICAweDAwLCAweDAwLCAweDAxLFxuICAgIC8vIGZsYWdzXG4gICAgMHgwMCwgMHgwMCxcbiAgICAvLyBncmFwaGljc21vZGVcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwIC8vIG9wY29sb3JcbiAgICBdKTtcbiAgICBNUDQuU01IRCA9IG5ldyBVaW50OEFycmF5KFsweDAwLFxuICAgIC8vIHZlcnNpb25cbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGZsYWdzXG4gICAgMHgwMCwgMHgwMCxcbiAgICAvLyBiYWxhbmNlXG4gICAgMHgwMCwgMHgwMCAvLyByZXNlcnZlZFxuICAgIF0pO1xuICAgIE1QNC5TVFNEID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDFdKTsgLy8gZW50cnlfY291bnRcblxuICAgIGNvbnN0IG1ham9yQnJhbmQgPSBuZXcgVWludDhBcnJheShbMTA1LCAxMTUsIDExMSwgMTA5XSk7IC8vIGlzb21cbiAgICBjb25zdCBhdmMxQnJhbmQgPSBuZXcgVWludDhBcnJheShbOTcsIDExOCwgOTksIDQ5XSk7IC8vIGF2YzFcbiAgICBjb25zdCBtaW5vclZlcnNpb24gPSBuZXcgVWludDhBcnJheShbMCwgMCwgMCwgMV0pO1xuICAgIE1QNC5GVFlQID0gTVA0LmJveChNUDQudHlwZXMuZnR5cCwgbWFqb3JCcmFuZCwgbWlub3JWZXJzaW9uLCBtYWpvckJyYW5kLCBhdmMxQnJhbmQpO1xuICAgIE1QNC5ESU5GID0gTVA0LmJveChNUDQudHlwZXMuZGluZiwgTVA0LmJveChNUDQudHlwZXMuZHJlZiwgZHJlZikpO1xuICB9XG4gIHN0YXRpYyBib3godHlwZSwgLi4ucGF5bG9hZCkge1xuICAgIGxldCBzaXplID0gODtcbiAgICBsZXQgaSA9IHBheWxvYWQubGVuZ3RoO1xuICAgIGNvbnN0IGxlbiA9IGk7XG4gICAgLy8gY2FsY3VsYXRlIHRoZSB0b3RhbCBzaXplIHdlIG5lZWQgdG8gYWxsb2NhdGVcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBzaXplICs9IHBheWxvYWRbaV0uYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgcmVzdWx0WzBdID0gc2l6ZSA+PiAyNCAmIDB4ZmY7XG4gICAgcmVzdWx0WzFdID0gc2l6ZSA+PiAxNiAmIDB4ZmY7XG4gICAgcmVzdWx0WzJdID0gc2l6ZSA+PiA4ICYgMHhmZjtcbiAgICByZXN1bHRbM10gPSBzaXplICYgMHhmZjtcbiAgICByZXN1bHQuc2V0KHR5cGUsIDQpO1xuICAgIC8vIGNvcHkgdGhlIHBheWxvYWQgaW50byB0aGUgcmVzdWx0XG4gICAgZm9yIChpID0gMCwgc2l6ZSA9IDg7IGkgPCBsZW47IGkrKykge1xuICAgICAgLy8gY29weSBwYXlsb2FkW2ldIGFycmF5IEAgb2Zmc2V0IHNpemVcbiAgICAgIHJlc3VsdC5zZXQocGF5bG9hZFtpXSwgc2l6ZSk7XG4gICAgICBzaXplICs9IHBheWxvYWRbaV0uYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBzdGF0aWMgaGRscih0eXBlKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLmhkbHIsIE1QNC5IRExSX1RZUEVTW3R5cGVdKTtcbiAgfVxuICBzdGF0aWMgbWRhdChkYXRhKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1kYXQsIGRhdGEpO1xuICB9XG4gIHN0YXRpYyBtZGhkKHRpbWVzY2FsZSwgZHVyYXRpb24pIHtcbiAgICBkdXJhdGlvbiAqPSB0aW1lc2NhbGU7XG4gICAgY29uc3QgdXBwZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uIC8gKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgY29uc3QgbG93ZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uICUgKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1kaGQsIG5ldyBVaW50OEFycmF5KFsweDAxLFxuICAgIC8vIHZlcnNpb24gMVxuICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gZmxhZ3NcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAyLFxuICAgIC8vIGNyZWF0aW9uX3RpbWVcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAzLFxuICAgIC8vIG1vZGlmaWNhdGlvbl90aW1lXG4gICAgdGltZXNjYWxlID4+IDI0ICYgMHhmZiwgdGltZXNjYWxlID4+IDE2ICYgMHhmZiwgdGltZXNjYWxlID4+IDggJiAweGZmLCB0aW1lc2NhbGUgJiAweGZmLFxuICAgIC8vIHRpbWVzY2FsZVxuICAgIHVwcGVyV29yZER1cmF0aW9uID4+IDI0LCB1cHBlcldvcmREdXJhdGlvbiA+PiAxNiAmIDB4ZmYsIHVwcGVyV29yZER1cmF0aW9uID4+IDggJiAweGZmLCB1cHBlcldvcmREdXJhdGlvbiAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uID4+IDI0LCBsb3dlcldvcmREdXJhdGlvbiA+PiAxNiAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uID4+IDggJiAweGZmLCBsb3dlcldvcmREdXJhdGlvbiAmIDB4ZmYsIDB4NTUsIDB4YzQsXG4gICAgLy8gJ3VuZCcgbGFuZ3VhZ2UgKHVuZGV0ZXJtaW5lZClcbiAgICAweDAwLCAweDAwXSkpO1xuICB9XG4gIHN0YXRpYyBtZGlhKHRyYWNrKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1kaWEsIE1QNC5tZGhkKHRyYWNrLnRpbWVzY2FsZSwgdHJhY2suZHVyYXRpb24pLCBNUDQuaGRscih0cmFjay50eXBlKSwgTVA0Lm1pbmYodHJhY2spKTtcbiAgfVxuICBzdGF0aWMgbWZoZChzZXF1ZW5jZU51bWJlcikge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZmhkLCBuZXcgVWludDhBcnJheShbMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIHNlcXVlbmNlTnVtYmVyID4+IDI0LCBzZXF1ZW5jZU51bWJlciA+PiAxNiAmIDB4ZmYsIHNlcXVlbmNlTnVtYmVyID4+IDggJiAweGZmLCBzZXF1ZW5jZU51bWJlciAmIDB4ZmYgLy8gc2VxdWVuY2VfbnVtYmVyXG4gICAgXSkpO1xuICB9XG4gIHN0YXRpYyBtaW5mKHRyYWNrKSB7XG4gICAgaWYgKHRyYWNrLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5taW5mLCBNUDQuYm94KE1QNC50eXBlcy5zbWhkLCBNUDQuU01IRCksIE1QNC5ESU5GLCBNUDQuc3RibCh0cmFjaykpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWluZiwgTVA0LmJveChNUDQudHlwZXMudm1oZCwgTVA0LlZNSEQpLCBNUDQuRElORiwgTVA0LnN0YmwodHJhY2spKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIG1vb2Yoc24sIGJhc2VNZWRpYURlY29kZVRpbWUsIHRyYWNrKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1vb2YsIE1QNC5tZmhkKHNuKSwgTVA0LnRyYWYodHJhY2ssIGJhc2VNZWRpYURlY29kZVRpbWUpKTtcbiAgfVxuICBzdGF0aWMgbW9vdih0cmFja3MpIHtcbiAgICBsZXQgaSA9IHRyYWNrcy5sZW5ndGg7XG4gICAgY29uc3QgYm94ZXMgPSBbXTtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBib3hlc1tpXSA9IE1QNC50cmFrKHRyYWNrc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBNUDQuYm94LmFwcGx5KG51bGwsIFtNUDQudHlwZXMubW9vdiwgTVA0Lm12aGQodHJhY2tzWzBdLnRpbWVzY2FsZSwgdHJhY2tzWzBdLmR1cmF0aW9uKV0uY29uY2F0KGJveGVzKS5jb25jYXQoTVA0Lm12ZXgodHJhY2tzKSkpO1xuICB9XG4gIHN0YXRpYyBtdmV4KHRyYWNrcykge1xuICAgIGxldCBpID0gdHJhY2tzLmxlbmd0aDtcbiAgICBjb25zdCBib3hlcyA9IFtdO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGJveGVzW2ldID0gTVA0LnRyZXgodHJhY2tzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIE1QNC5ib3guYXBwbHkobnVsbCwgW01QNC50eXBlcy5tdmV4LCAuLi5ib3hlc10pO1xuICB9XG4gIHN0YXRpYyBtdmhkKHRpbWVzY2FsZSwgZHVyYXRpb24pIHtcbiAgICBkdXJhdGlvbiAqPSB0aW1lc2NhbGU7XG4gICAgY29uc3QgdXBwZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uIC8gKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgY29uc3QgbG93ZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uICUgKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShbMHgwMSxcbiAgICAvLyB2ZXJzaW9uIDFcbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGZsYWdzXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMixcbiAgICAvLyBjcmVhdGlvbl90aW1lXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMyxcbiAgICAvLyBtb2RpZmljYXRpb25fdGltZVxuICAgIHRpbWVzY2FsZSA+PiAyNCAmIDB4ZmYsIHRpbWVzY2FsZSA+PiAxNiAmIDB4ZmYsIHRpbWVzY2FsZSA+PiA4ICYgMHhmZiwgdGltZXNjYWxlICYgMHhmZixcbiAgICAvLyB0aW1lc2NhbGVcbiAgICB1cHBlcldvcmREdXJhdGlvbiA+PiAyNCwgdXBwZXJXb3JkRHVyYXRpb24gPj4gMTYgJiAweGZmLCB1cHBlcldvcmREdXJhdGlvbiA+PiA4ICYgMHhmZiwgdXBwZXJXb3JkRHVyYXRpb24gJiAweGZmLCBsb3dlcldvcmREdXJhdGlvbiA+PiAyNCwgbG93ZXJXb3JkRHVyYXRpb24gPj4gMTYgJiAweGZmLCBsb3dlcldvcmREdXJhdGlvbiA+PiA4ICYgMHhmZiwgbG93ZXJXb3JkRHVyYXRpb24gJiAweGZmLCAweDAwLCAweDAxLCAweDAwLCAweDAwLFxuICAgIC8vIDEuMCByYXRlXG4gICAgMHgwMSwgMHgwMCxcbiAgICAvLyAxLjAgdm9sdW1lXG4gICAgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHg0MCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyB0cmFuc2Zvcm1hdGlvbjogdW5pdHkgbWF0cml4XG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBwcmVfZGVmaW5lZFxuICAgIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYgLy8gbmV4dF90cmFja19JRFxuICAgIF0pO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tdmhkLCBieXRlcyk7XG4gIH1cbiAgc3RhdGljIHNkdHAodHJhY2spIHtcbiAgICBjb25zdCBzYW1wbGVzID0gdHJhY2suc2FtcGxlcyB8fCBbXTtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KDQgKyBzYW1wbGVzLmxlbmd0aCk7XG4gICAgbGV0IGk7XG4gICAgbGV0IGZsYWdzO1xuICAgIC8vIGxlYXZlIHRoZSBmdWxsIGJveCBoZWFkZXIgKDQgYnl0ZXMpIGFsbCB6ZXJvXG4gICAgLy8gd3JpdGUgdGhlIHNhbXBsZSB0YWJsZVxuICAgIGZvciAoaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmbGFncyA9IHNhbXBsZXNbaV0uZmxhZ3M7XG4gICAgICBieXRlc1tpICsgNF0gPSBmbGFncy5kZXBlbmRzT24gPDwgNCB8IGZsYWdzLmlzRGVwZW5kZWRPbiA8PCAyIHwgZmxhZ3MuaGFzUmVkdW5kYW5jeTtcbiAgICB9XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnNkdHAsIGJ5dGVzKTtcbiAgfVxuICBzdGF0aWMgc3RibCh0cmFjaykge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdGJsLCBNUDQuc3RzZCh0cmFjayksIE1QNC5ib3goTVA0LnR5cGVzLnN0dHMsIE1QNC5TVFRTKSwgTVA0LmJveChNUDQudHlwZXMuc3RzYywgTVA0LlNUU0MpLCBNUDQuYm94KE1QNC50eXBlcy5zdHN6LCBNUDQuU1RTWiksIE1QNC5ib3goTVA0LnR5cGVzLnN0Y28sIE1QNC5TVENPKSk7XG4gIH1cbiAgc3RhdGljIGF2YzEodHJhY2spIHtcbiAgICBsZXQgc3BzID0gW107XG4gICAgbGV0IHBwcyA9IFtdO1xuICAgIGxldCBpO1xuICAgIGxldCBkYXRhO1xuICAgIGxldCBsZW47XG4gICAgLy8gYXNzZW1ibGUgdGhlIFNQU3NcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0cmFjay5zcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGEgPSB0cmFjay5zcHNbaV07XG4gICAgICBsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICBzcHMucHVzaChsZW4gPj4+IDggJiAweGZmKTtcbiAgICAgIHNwcy5wdXNoKGxlbiAmIDB4ZmYpO1xuXG4gICAgICAvLyBTUFNcbiAgICAgIHNwcyA9IHNwcy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGF0YSkpO1xuICAgIH1cblxuICAgIC8vIGFzc2VtYmxlIHRoZSBQUFNzXG4gICAgZm9yIChpID0gMDsgaSA8IHRyYWNrLnBwcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGF0YSA9IHRyYWNrLnBwc1tpXTtcbiAgICAgIGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgIHBwcy5wdXNoKGxlbiA+Pj4gOCAmIDB4ZmYpO1xuICAgICAgcHBzLnB1c2gobGVuICYgMHhmZik7XG4gICAgICBwcHMgPSBwcHMuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgYXZjYyA9IE1QNC5ib3goTVA0LnR5cGVzLmF2Y0MsIG5ldyBVaW50OEFycmF5KFsweDAxLFxuICAgIC8vIHZlcnNpb25cbiAgICBzcHNbM10sXG4gICAgLy8gcHJvZmlsZVxuICAgIHNwc1s0XSxcbiAgICAvLyBwcm9maWxlIGNvbXBhdFxuICAgIHNwc1s1XSxcbiAgICAvLyBsZXZlbFxuICAgIDB4ZmMgfCAzLFxuICAgIC8vIGxlbmd0aFNpemVNaW51c09uZSwgaGFyZC1jb2RlZCB0byA0IGJ5dGVzXG4gICAgMHhlMCB8IHRyYWNrLnNwcy5sZW5ndGggLy8gM2JpdCByZXNlcnZlZCAoMTExKSArIG51bU9mU2VxdWVuY2VQYXJhbWV0ZXJTZXRzXG4gICAgXS5jb25jYXQoc3BzKS5jb25jYXQoW3RyYWNrLnBwcy5sZW5ndGggLy8gbnVtT2ZQaWN0dXJlUGFyYW1ldGVyU2V0c1xuICAgIF0pLmNvbmNhdChwcHMpKSk7IC8vIFwiUFBTXCJcbiAgICBjb25zdCB3aWR0aCA9IHRyYWNrLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHRyYWNrLmhlaWdodDtcbiAgICBjb25zdCBoU3BhY2luZyA9IHRyYWNrLnBpeGVsUmF0aW9bMF07XG4gICAgY29uc3QgdlNwYWNpbmcgPSB0cmFjay5waXhlbFJhdGlvWzFdO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5hdmMxLCBuZXcgVWludDhBcnJheShbMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAxLFxuICAgIC8vIGRhdGFfcmVmZXJlbmNlX2luZGV4XG4gICAgMHgwMCwgMHgwMCxcbiAgICAvLyBwcmVfZGVmaW5lZFxuICAgIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHByZV9kZWZpbmVkXG4gICAgd2lkdGggPj4gOCAmIDB4ZmYsIHdpZHRoICYgMHhmZixcbiAgICAvLyB3aWR0aFxuICAgIGhlaWdodCA+PiA4ICYgMHhmZiwgaGVpZ2h0ICYgMHhmZixcbiAgICAvLyBoZWlnaHRcbiAgICAweDAwLCAweDQ4LCAweDAwLCAweDAwLFxuICAgIC8vIGhvcml6cmVzb2x1dGlvblxuICAgIDB4MDAsIDB4NDgsIDB4MDAsIDB4MDAsXG4gICAgLy8gdmVydHJlc29sdXRpb25cbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMSxcbiAgICAvLyBmcmFtZV9jb3VudFxuICAgIDB4MTIsIDB4NjQsIDB4NjEsIDB4NjksIDB4NmMsXG4gICAgLy8gZGFpbHltb3Rpb24vaGxzLmpzXG4gICAgMHg3OSwgMHg2ZCwgMHg2ZiwgMHg3NCwgMHg2OSwgMHg2ZiwgMHg2ZSwgMHgyZiwgMHg2OCwgMHg2YywgMHg3MywgMHgyZSwgMHg2YSwgMHg3MywgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBjb21wcmVzc29ybmFtZVxuICAgIDB4MDAsIDB4MTgsXG4gICAgLy8gZGVwdGggPSAyNFxuICAgIDB4MTEsIDB4MTFdKSxcbiAgICAvLyBwcmVfZGVmaW5lZCA9IC0xXG4gICAgYXZjYywgTVA0LmJveChNUDQudHlwZXMuYnRydCwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4MWMsIDB4OWMsIDB4ODAsXG4gICAgLy8gYnVmZmVyU2l6ZURCXG4gICAgMHgwMCwgMHgyZCwgMHhjNiwgMHhjMCxcbiAgICAvLyBtYXhCaXRyYXRlXG4gICAgMHgwMCwgMHgyZCwgMHhjNiwgMHhjMF0pKSxcbiAgICAvLyBhdmdCaXRyYXRlXG4gICAgTVA0LmJveChNUDQudHlwZXMucGFzcCwgbmV3IFVpbnQ4QXJyYXkoW2hTcGFjaW5nID4+IDI0LFxuICAgIC8vIGhTcGFjaW5nXG4gICAgaFNwYWNpbmcgPj4gMTYgJiAweGZmLCBoU3BhY2luZyA+PiA4ICYgMHhmZiwgaFNwYWNpbmcgJiAweGZmLCB2U3BhY2luZyA+PiAyNCxcbiAgICAvLyB2U3BhY2luZ1xuICAgIHZTcGFjaW5nID4+IDE2ICYgMHhmZiwgdlNwYWNpbmcgPj4gOCAmIDB4ZmYsIHZTcGFjaW5nICYgMHhmZl0pKSk7XG4gIH1cbiAgc3RhdGljIGVzZHModHJhY2spIHtcbiAgICBjb25zdCBjb25maWdsZW4gPSB0cmFjay5jb25maWcubGVuZ3RoO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCxcbiAgICAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGZsYWdzXG5cbiAgICAweDAzLFxuICAgIC8vIGRlc2NyaXB0b3JfdHlwZVxuICAgIDB4MTcgKyBjb25maWdsZW4sXG4gICAgLy8gbGVuZ3RoXG4gICAgMHgwMCwgMHgwMSxcbiAgICAvLyBlc19pZFxuICAgIDB4MDAsXG4gICAgLy8gc3RyZWFtX3ByaW9yaXR5XG5cbiAgICAweDA0LFxuICAgIC8vIGRlc2NyaXB0b3JfdHlwZVxuICAgIDB4MGYgKyBjb25maWdsZW4sXG4gICAgLy8gbGVuZ3RoXG4gICAgMHg0MCxcbiAgICAvLyBjb2RlYyA6IG1wZWc0X2F1ZGlvXG4gICAgMHgxNSxcbiAgICAvLyBzdHJlYW1fdHlwZVxuICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gYnVmZmVyX3NpemVcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIG1heEJpdHJhdGVcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGF2Z0JpdHJhdGVcblxuICAgIDB4MDUgLy8gZGVzY3JpcHRvcl90eXBlXG4gICAgXS5jb25jYXQoW2NvbmZpZ2xlbl0pLmNvbmNhdCh0cmFjay5jb25maWcpLmNvbmNhdChbMHgwNiwgMHgwMSwgMHgwMl0pKTsgLy8gR0FTcGVjaWZpY0NvbmZpZykpOyAvLyBsZW5ndGggKyBhdWRpbyBjb25maWcgZGVzY3JpcHRvclxuICB9XG4gIHN0YXRpYyBhdWRpb1N0c2QodHJhY2spIHtcbiAgICBjb25zdCBzYW1wbGVyYXRlID0gdHJhY2suc2FtcGxlcmF0ZTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMSxcbiAgICAvLyBkYXRhX3JlZmVyZW5jZV9pbmRleFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCB0cmFjay5jaGFubmVsQ291bnQsXG4gICAgLy8gY2hhbm5lbGNvdW50XG4gICAgMHgwMCwgMHgxMCxcbiAgICAvLyBzYW1wbGVTaXplOjE2Yml0c1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWQyXG4gICAgc2FtcGxlcmF0ZSA+PiA4ICYgMHhmZiwgc2FtcGxlcmF0ZSAmIDB4ZmYsXG4gICAgLy9cbiAgICAweDAwLCAweDAwXSk7XG4gIH1cbiAgc3RhdGljIG1wNGEodHJhY2spIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubXA0YSwgTVA0LmF1ZGlvU3RzZCh0cmFjayksIE1QNC5ib3goTVA0LnR5cGVzLmVzZHMsIE1QNC5lc2RzKHRyYWNrKSkpO1xuICB9XG4gIHN0YXRpYyBtcDModHJhY2spIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXNbJy5tcDMnXSwgTVA0LmF1ZGlvU3RzZCh0cmFjaykpO1xuICB9XG4gIHN0YXRpYyBhYzModHJhY2spIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXNbJ2FjLTMnXSwgTVA0LmF1ZGlvU3RzZCh0cmFjayksIE1QNC5ib3goTVA0LnR5cGVzLmRhYzMsIHRyYWNrLmNvbmZpZykpO1xuICB9XG4gIHN0YXRpYyBzdHNkKHRyYWNrKSB7XG4gICAgaWYgKHRyYWNrLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgIGlmICh0cmFjay5zZWdtZW50Q29kZWMgPT09ICdtcDMnICYmIHRyYWNrLmNvZGVjID09PSAnbXAzJykge1xuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RzZCwgTVA0LlNUU0QsIE1QNC5tcDModHJhY2spKTtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFjay5zZWdtZW50Q29kZWMgPT09ICdhYzMnKSB7XG4gICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdHNkLCBNUDQuU1RTRCwgTVA0LmFjMyh0cmFjaykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnN0c2QsIE1QNC5TVFNELCBNUDQubXA0YSh0cmFjaykpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RzZCwgTVA0LlNUU0QsIE1QNC5hdmMxKHRyYWNrKSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyB0a2hkKHRyYWNrKSB7XG4gICAgY29uc3QgaWQgPSB0cmFjay5pZDtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHRyYWNrLmR1cmF0aW9uICogdHJhY2sudGltZXNjYWxlO1xuICAgIGNvbnN0IHdpZHRoID0gdHJhY2sud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gdHJhY2suaGVpZ2h0O1xuICAgIGNvbnN0IHVwcGVyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAvIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIGNvbnN0IGxvd2VyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAlIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50a2hkLCBuZXcgVWludDhBcnJheShbMHgwMSxcbiAgICAvLyB2ZXJzaW9uIDFcbiAgICAweDAwLCAweDAwLCAweDA3LFxuICAgIC8vIGZsYWdzXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMixcbiAgICAvLyBjcmVhdGlvbl90aW1lXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMyxcbiAgICAvLyBtb2RpZmljYXRpb25fdGltZVxuICAgIGlkID4+IDI0ICYgMHhmZiwgaWQgPj4gMTYgJiAweGZmLCBpZCA+PiA4ICYgMHhmZiwgaWQgJiAweGZmLFxuICAgIC8vIHRyYWNrX0lEXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIHVwcGVyV29yZER1cmF0aW9uID4+IDI0LCB1cHBlcldvcmREdXJhdGlvbiA+PiAxNiAmIDB4ZmYsIHVwcGVyV29yZER1cmF0aW9uID4+IDggJiAweGZmLCB1cHBlcldvcmREdXJhdGlvbiAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uID4+IDI0LCBsb3dlcldvcmREdXJhdGlvbiA+PiAxNiAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uID4+IDggJiAweGZmLCBsb3dlcldvcmREdXJhdGlvbiAmIDB4ZmYsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLFxuICAgIC8vIGxheWVyXG4gICAgMHgwMCwgMHgwMCxcbiAgICAvLyBhbHRlcm5hdGVfZ3JvdXBcbiAgICAweDAwLCAweDAwLFxuICAgIC8vIG5vbi1hdWRpbyB0cmFjayB2b2x1bWVcbiAgICAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHg0MCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyB0cmFuc2Zvcm1hdGlvbjogdW5pdHkgbWF0cml4XG4gICAgd2lkdGggPj4gOCAmIDB4ZmYsIHdpZHRoICYgMHhmZiwgMHgwMCwgMHgwMCxcbiAgICAvLyB3aWR0aFxuICAgIGhlaWdodCA+PiA4ICYgMHhmZiwgaGVpZ2h0ICYgMHhmZiwgMHgwMCwgMHgwMCAvLyBoZWlnaHRcbiAgICBdKSk7XG4gIH1cbiAgc3RhdGljIHRyYWYodHJhY2ssIGJhc2VNZWRpYURlY29kZVRpbWUpIHtcbiAgICBjb25zdCBzYW1wbGVEZXBlbmRlbmN5VGFibGUgPSBNUDQuc2R0cCh0cmFjayk7XG4gICAgY29uc3QgaWQgPSB0cmFjay5pZDtcbiAgICBjb25zdCB1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID0gTWF0aC5mbG9vcihiYXNlTWVkaWFEZWNvZGVUaW1lIC8gKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgY29uc3QgbG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA9IE1hdGguZmxvb3IoYmFzZU1lZGlhRGVjb2RlVGltZSAlIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cmFmLCBNUDQuYm94KE1QNC50eXBlcy50ZmhkLCBuZXcgVWludDhBcnJheShbMHgwMCxcbiAgICAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGZsYWdzXG4gICAgaWQgPj4gMjQsIGlkID4+IDE2ICYgMHhmZiwgaWQgPj4gOCAmIDB4ZmYsIGlkICYgMHhmZiAvLyB0cmFja19JRFxuICAgIF0pKSwgTVA0LmJveChNUDQudHlwZXMudGZkdCwgbmV3IFVpbnQ4QXJyYXkoWzB4MDEsXG4gICAgLy8gdmVyc2lvbiAxXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gMjQsIHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gMTYgJiAweGZmLCB1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDggJiAweGZmLCB1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lICYgMHhmZiwgbG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiAyNCwgbG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiAxNiAmIDB4ZmYsIGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gOCAmIDB4ZmYsIGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgJiAweGZmXSkpLCBNUDQudHJ1bih0cmFjaywgc2FtcGxlRGVwZW5kZW5jeVRhYmxlLmxlbmd0aCArIDE2ICtcbiAgICAvLyB0ZmhkXG4gICAgMjAgK1xuICAgIC8vIHRmZHRcbiAgICA4ICtcbiAgICAvLyB0cmFmIGhlYWRlclxuICAgIDE2ICtcbiAgICAvLyBtZmhkXG4gICAgOCArXG4gICAgLy8gbW9vZiBoZWFkZXJcbiAgICA4KSxcbiAgICAvLyBtZGF0IGhlYWRlclxuICAgIHNhbXBsZURlcGVuZGVuY3lUYWJsZSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFjayBib3guXG4gICAqIEBwYXJhbSB0cmFjayBhIHRyYWNrIGRlZmluaXRpb25cbiAgICovXG4gIHN0YXRpYyB0cmFrKHRyYWNrKSB7XG4gICAgdHJhY2suZHVyYXRpb24gPSB0cmFjay5kdXJhdGlvbiB8fCAweGZmZmZmZmZmO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cmFrLCBNUDQudGtoZCh0cmFjayksIE1QNC5tZGlhKHRyYWNrKSk7XG4gIH1cbiAgc3RhdGljIHRyZXgodHJhY2spIHtcbiAgICBjb25zdCBpZCA9IHRyYWNrLmlkO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cmV4LCBuZXcgVWludDhBcnJheShbMHgwMCxcbiAgICAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGZsYWdzXG4gICAgaWQgPj4gMjQsIGlkID4+IDE2ICYgMHhmZiwgaWQgPj4gOCAmIDB4ZmYsIGlkICYgMHhmZixcbiAgICAvLyB0cmFja19JRFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsXG4gICAgLy8gZGVmYXVsdF9zYW1wbGVfZGVzY3JpcHRpb25faW5kZXhcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBkZWZhdWx0X3NhbXBsZV9zaXplXG4gICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMSAvLyBkZWZhdWx0X3NhbXBsZV9mbGFnc1xuICAgIF0pKTtcbiAgfVxuICBzdGF0aWMgdHJ1bih0cmFjaywgb2Zmc2V0KSB7XG4gICAgY29uc3Qgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXMgfHwgW107XG4gICAgY29uc3QgbGVuID0gc2FtcGxlcy5sZW5ndGg7XG4gICAgY29uc3QgYXJyYXlsZW4gPSAxMiArIDE2ICogbGVuO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlsZW4pO1xuICAgIGxldCBpO1xuICAgIGxldCBzYW1wbGU7XG4gICAgbGV0IGR1cmF0aW9uO1xuICAgIGxldCBzaXplO1xuICAgIGxldCBmbGFncztcbiAgICBsZXQgY3RzO1xuICAgIG9mZnNldCArPSA4ICsgYXJyYXlsZW47XG4gICAgYXJyYXkuc2V0KFt0cmFjay50eXBlID09PSAndmlkZW8nID8gMHgwMSA6IDB4MDAsXG4gICAgLy8gdmVyc2lvbiAxIGZvciB2aWRlbyB3aXRoIHNpZ25lZC1pbnQgc2FtcGxlX2NvbXBvc2l0aW9uX3RpbWVfb2Zmc2V0XG4gICAgMHgwMCwgMHgwZiwgMHgwMSxcbiAgICAvLyBmbGFnc1xuICAgIGxlbiA+Pj4gMjQgJiAweGZmLCBsZW4gPj4+IDE2ICYgMHhmZiwgbGVuID4+PiA4ICYgMHhmZiwgbGVuICYgMHhmZixcbiAgICAvLyBzYW1wbGVfY291bnRcbiAgICBvZmZzZXQgPj4+IDI0ICYgMHhmZiwgb2Zmc2V0ID4+PiAxNiAmIDB4ZmYsIG9mZnNldCA+Pj4gOCAmIDB4ZmYsIG9mZnNldCAmIDB4ZmYgLy8gZGF0YV9vZmZzZXRcbiAgICBdLCAwKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHNhbXBsZSA9IHNhbXBsZXNbaV07XG4gICAgICBkdXJhdGlvbiA9IHNhbXBsZS5kdXJhdGlvbjtcbiAgICAgIHNpemUgPSBzYW1wbGUuc2l6ZTtcbiAgICAgIGZsYWdzID0gc2FtcGxlLmZsYWdzO1xuICAgICAgY3RzID0gc2FtcGxlLmN0cztcbiAgICAgIGFycmF5LnNldChbZHVyYXRpb24gPj4+IDI0ICYgMHhmZiwgZHVyYXRpb24gPj4+IDE2ICYgMHhmZiwgZHVyYXRpb24gPj4+IDggJiAweGZmLCBkdXJhdGlvbiAmIDB4ZmYsXG4gICAgICAvLyBzYW1wbGVfZHVyYXRpb25cbiAgICAgIHNpemUgPj4+IDI0ICYgMHhmZiwgc2l6ZSA+Pj4gMTYgJiAweGZmLCBzaXplID4+PiA4ICYgMHhmZiwgc2l6ZSAmIDB4ZmYsXG4gICAgICAvLyBzYW1wbGVfc2l6ZVxuICAgICAgZmxhZ3MuaXNMZWFkaW5nIDw8IDIgfCBmbGFncy5kZXBlbmRzT24sIGZsYWdzLmlzRGVwZW5kZWRPbiA8PCA2IHwgZmxhZ3MuaGFzUmVkdW5kYW5jeSA8PCA0IHwgZmxhZ3MucGFkZGluZ1ZhbHVlIDw8IDEgfCBmbGFncy5pc05vblN5bmMsIGZsYWdzLmRlZ3JhZFByaW8gJiAweGYwIDw8IDgsIGZsYWdzLmRlZ3JhZFByaW8gJiAweDBmLFxuICAgICAgLy8gc2FtcGxlX2ZsYWdzXG4gICAgICBjdHMgPj4+IDI0ICYgMHhmZiwgY3RzID4+PiAxNiAmIDB4ZmYsIGN0cyA+Pj4gOCAmIDB4ZmYsIGN0cyAmIDB4ZmYgLy8gc2FtcGxlX2NvbXBvc2l0aW9uX3RpbWVfb2Zmc2V0XG4gICAgICBdLCAxMiArIDE2ICogaSk7XG4gICAgfVxuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cnVuLCBhcnJheSk7XG4gIH1cbiAgc3RhdGljIGluaXRTZWdtZW50KHRyYWNrcykge1xuICAgIGlmICghTVA0LnR5cGVzKSB7XG4gICAgICBNUDQuaW5pdCgpO1xuICAgIH1cbiAgICBjb25zdCBtb3ZpZSA9IE1QNC5tb292KHRyYWNrcyk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXBwZW5kVWludDhBcnJheShNUDQuRlRZUCwgbW92aWUpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbk1QNC50eXBlcyA9IHZvaWQgMDtcbk1QNC5IRExSX1RZUEVTID0gdm9pZCAwO1xuTVA0LlNUVFMgPSB2b2lkIDA7XG5NUDQuU1RTQyA9IHZvaWQgMDtcbk1QNC5TVENPID0gdm9pZCAwO1xuTVA0LlNUU1ogPSB2b2lkIDA7XG5NUDQuVk1IRCA9IHZvaWQgMDtcbk1QNC5TTUhEID0gdm9pZCAwO1xuTVA0LlNUU0QgPSB2b2lkIDA7XG5NUDQuRlRZUCA9IHZvaWQgMDtcbk1QNC5ESU5GID0gdm9pZCAwO1xuXG5jb25zdCBNUEVHX1RTX0NMT0NLX0ZSRVFfSFogPSA5MDAwMDtcbmZ1bmN0aW9uIHRvVGltZXNjYWxlRnJvbUJhc2UoYmFzZVRpbWUsIGRlc3RTY2FsZSwgc3JjQmFzZSA9IDEsIHJvdW5kID0gZmFsc2UpIHtcbiAgY29uc3QgcmVzdWx0ID0gYmFzZVRpbWUgKiBkZXN0U2NhbGUgKiBzcmNCYXNlOyAvLyBlcXVpdmFsZW50IHRvIGAodmFsdWUgKiBzY2FsZSkgLyAoMSAvIGJhc2UpYFxuICByZXR1cm4gcm91bmQgPyBNYXRoLnJvdW5kKHJlc3VsdCkgOiByZXN1bHQ7XG59XG5mdW5jdGlvbiB0b1RpbWVzY2FsZUZyb21TY2FsZShiYXNlVGltZSwgZGVzdFNjYWxlLCBzcmNTY2FsZSA9IDEsIHJvdW5kID0gZmFsc2UpIHtcbiAgcmV0dXJuIHRvVGltZXNjYWxlRnJvbUJhc2UoYmFzZVRpbWUsIGRlc3RTY2FsZSwgMSAvIHNyY1NjYWxlLCByb3VuZCk7XG59XG5mdW5jdGlvbiB0b01zRnJvbU1wZWdUc0Nsb2NrKGJhc2VUaW1lLCByb3VuZCA9IGZhbHNlKSB7XG4gIHJldHVybiB0b1RpbWVzY2FsZUZyb21CYXNlKGJhc2VUaW1lLCAxMDAwLCAxIC8gTVBFR19UU19DTE9DS19GUkVRX0haLCByb3VuZCk7XG59XG5mdW5jdGlvbiB0b01wZWdUc0Nsb2NrRnJvbVRpbWVzY2FsZShiYXNlVGltZSwgc3JjU2NhbGUgPSAxKSB7XG4gIHJldHVybiB0b1RpbWVzY2FsZUZyb21CYXNlKGJhc2VUaW1lLCBNUEVHX1RTX0NMT0NLX0ZSRVFfSFosIDEgLyBzcmNTY2FsZSk7XG59XG5cbmNvbnN0IE1BWF9TSUxFTlRfRlJBTUVfRFVSQVRJT04gPSAxMCAqIDEwMDA7IC8vIDEwIHNlY29uZHNcbmNvbnN0IEFBQ19TQU1QTEVTX1BFUl9GUkFNRSA9IDEwMjQ7XG5jb25zdCBNUEVHX0FVRElPX1NBTVBMRV9QRVJfRlJBTUUgPSAxMTUyO1xuY29uc3QgQUMzX1NBTVBMRVNfUEVSX0ZSQU1FID0gMTUzNjtcbmxldCBjaHJvbWVWZXJzaW9uID0gbnVsbDtcbmxldCBzYWZhcmlXZWJraXRWZXJzaW9uID0gbnVsbDtcbmNsYXNzIE1QNFJlbXV4ZXIge1xuICBjb25zdHJ1Y3RvcihvYnNlcnZlciwgY29uZmlnLCB0eXBlU3VwcG9ydGVkLCB2ZW5kb3IgPSAnJykge1xuICAgIHRoaXMub2JzZXJ2ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy50eXBlU3VwcG9ydGVkID0gdm9pZCAwO1xuICAgIHRoaXMuSVNHZW5lcmF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9pbml0UFRTID0gbnVsbDtcbiAgICB0aGlzLl9pbml0RFRTID0gbnVsbDtcbiAgICB0aGlzLm5leHRBdmNEdHMgPSBudWxsO1xuICAgIHRoaXMubmV4dEF1ZGlvUHRzID0gbnVsbDtcbiAgICB0aGlzLnZpZGVvU2FtcGxlRHVyYXRpb24gPSBudWxsO1xuICAgIHRoaXMuaXNBdWRpb0NvbnRpZ3VvdXMgPSBmYWxzZTtcbiAgICB0aGlzLmlzVmlkZW9Db250aWd1b3VzID0gZmFsc2U7XG4gICAgdGhpcy52aWRlb1RyYWNrQ29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB0eXBlU3VwcG9ydGVkO1xuICAgIHRoaXMuSVNHZW5lcmF0ZWQgPSBmYWxzZTtcbiAgICBpZiAoY2hyb21lVmVyc2lvbiA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJztcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspL2kpO1xuICAgICAgY2hyb21lVmVyc2lvbiA9IHJlc3VsdCA/IHBhcnNlSW50KHJlc3VsdFsxXSkgOiAwO1xuICAgIH1cbiAgICBpZiAoc2FmYXJpV2Via2l0VmVyc2lvbiA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvU2FmYXJpXFwvKFxcZCspL2kpO1xuICAgICAgc2FmYXJpV2Via2l0VmVyc2lvbiA9IHJlc3VsdCA/IHBhcnNlSW50KHJlc3VsdFsxXSkgOiAwO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmNvbmZpZyA9IHRoaXMudmlkZW9UcmFja0NvbmZpZyA9IHRoaXMuX2luaXRQVFMgPSB0aGlzLl9pbml0RFRTID0gbnVsbDtcbiAgfVxuICByZXNldFRpbWVTdGFtcChkZWZhdWx0VGltZVN0YW1wKSB7XG4gICAgbG9nZ2VyLmxvZygnW21wNC1yZW11eGVyXTogaW5pdFBUUyAmIGluaXREVFMgcmVzZXQnKTtcbiAgICB0aGlzLl9pbml0UFRTID0gdGhpcy5faW5pdERUUyA9IGRlZmF1bHRUaW1lU3RhbXA7XG4gIH1cbiAgcmVzZXROZXh0VGltZXN0YW1wKCkge1xuICAgIGxvZ2dlci5sb2coJ1ttcDQtcmVtdXhlcl06IHJlc2V0IG5leHQgdGltZXN0YW1wJyk7XG4gICAgdGhpcy5pc1ZpZGVvQ29udGlndW91cyA9IGZhbHNlO1xuICAgIHRoaXMuaXNBdWRpb0NvbnRpZ3VvdXMgPSBmYWxzZTtcbiAgfVxuICByZXNldEluaXRTZWdtZW50KCkge1xuICAgIGxvZ2dlci5sb2coJ1ttcDQtcmVtdXhlcl06IElTR2VuZXJhdGVkIGZsYWcgcmVzZXQnKTtcbiAgICB0aGlzLklTR2VuZXJhdGVkID0gZmFsc2U7XG4gICAgdGhpcy52aWRlb1RyYWNrQ29uZmlnID0gdW5kZWZpbmVkO1xuICB9XG4gIGdldFZpZGVvU3RhcnRQdHModmlkZW9TYW1wbGVzKSB7XG4gICAgbGV0IHJvbGxvdmVyRGV0ZWN0ZWQgPSBmYWxzZTtcbiAgICBjb25zdCBzdGFydFBUUyA9IHZpZGVvU2FtcGxlcy5yZWR1Y2UoKG1pblBUUywgc2FtcGxlKSA9PiB7XG4gICAgICBjb25zdCBkZWx0YSA9IHNhbXBsZS5wdHMgLSBtaW5QVFM7XG4gICAgICBpZiAoZGVsdGEgPCAtNDI5NDk2NzI5Nikge1xuICAgICAgICAvLyAyXjMyLCBzZWUgUFRTTm9ybWFsaXplIGZvciByZWFzb25pbmcsIGJ1dCB3ZSdyZSBoaXR0aW5nIGEgcm9sbG92ZXIgaGVyZSwgYW5kIHdlIGRvbid0IHdhbnQgdGhhdCB0byBpbXBhY3QgdGhlIHRpbWVPZmZzZXQgY2FsY3VsYXRpb25cbiAgICAgICAgcm9sbG92ZXJEZXRlY3RlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBub3JtYWxpemVQdHMobWluUFRTLCBzYW1wbGUucHRzKTtcbiAgICAgIH0gZWxzZSBpZiAoZGVsdGEgPiAwKSB7XG4gICAgICAgIHJldHVybiBtaW5QVFM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2FtcGxlLnB0cztcbiAgICAgIH1cbiAgICB9LCB2aWRlb1NhbXBsZXNbMF0ucHRzKTtcbiAgICBpZiAocm9sbG92ZXJEZXRlY3RlZCkge1xuICAgICAgbG9nZ2VyLmRlYnVnKCdQVFMgcm9sbG92ZXIgZGV0ZWN0ZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXJ0UFRTO1xuICB9XG4gIHJlbXV4KGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgZmx1c2gsIHBsYXlsaXN0VHlwZSkge1xuICAgIGxldCB2aWRlbztcbiAgICBsZXQgYXVkaW87XG4gICAgbGV0IGluaXRTZWdtZW50O1xuICAgIGxldCB0ZXh0O1xuICAgIGxldCBpZDM7XG4gICAgbGV0IGluZGVwZW5kZW50O1xuICAgIGxldCBhdWRpb1RpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0O1xuICAgIGxldCB2aWRlb1RpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0O1xuXG4gICAgLy8gSWYgd2UncmUgcmVtdXhpbmcgYXVkaW8gYW5kIHZpZGVvIHByb2dyZXNzaXZlbHksIHdhaXQgdW50aWwgd2UndmUgcmVjZWl2ZWQgZW5vdWdoIHNhbXBsZXMgZm9yIGVhY2ggdHJhY2sgYmVmb3JlIHByb2NlZWRpbmcuXG4gICAgLy8gVGhpcyBpcyBkb25lIHRvIHN5bmNocm9uaXplIHRoZSBhdWRpbyBhbmQgdmlkZW8gc3RyZWFtcy4gV2Uga25vdyBpZiB0aGUgY3VycmVudCBzZWdtZW50IHdpbGwgaGF2ZSBzYW1wbGVzIGlmIHRoZSBcInBpZFwiXG4gICAgLy8gcGFyYW1ldGVyIGlzIGdyZWF0ZXIgdGhhbiAtMS4gVGhlIHBpZCBpcyBzZXQgd2hlbiB0aGUgUE1UIGlzIHBhcnNlZCwgd2hpY2ggY29udGFpbnMgdGhlIHRyYWNrcyBsaXN0LlxuICAgIC8vIEhvd2V2ZXIsIGlmIHRoZSBpbml0U2VnbWVudCBoYXMgYWxyZWFkeSBiZWVuIGdlbmVyYXRlZCwgb3Igd2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIGEgc2VnbWVudCAoZmx1c2gpLFxuICAgIC8vIHRoZW4gd2UgY2FuIHJlbXV4IG9uZSB0cmFjayB3aXRob3V0IHdhaXRpbmcgZm9yIHRoZSBvdGhlci5cbiAgICBjb25zdCBoYXNBdWRpbyA9IGF1ZGlvVHJhY2sucGlkID4gLTE7XG4gICAgY29uc3QgaGFzVmlkZW8gPSB2aWRlb1RyYWNrLnBpZCA+IC0xO1xuICAgIGNvbnN0IGxlbmd0aCA9IHZpZGVvVHJhY2suc2FtcGxlcy5sZW5ndGg7XG4gICAgY29uc3QgZW5vdWdoQXVkaW9TYW1wbGVzID0gYXVkaW9UcmFjay5zYW1wbGVzLmxlbmd0aCA+IDA7XG4gICAgY29uc3QgZW5vdWdoVmlkZW9TYW1wbGVzID0gZmx1c2ggJiYgbGVuZ3RoID4gMCB8fCBsZW5ndGggPiAxO1xuICAgIGNvbnN0IGNhblJlbXV4QXZjID0gKCFoYXNBdWRpbyB8fCBlbm91Z2hBdWRpb1NhbXBsZXMpICYmICghaGFzVmlkZW8gfHwgZW5vdWdoVmlkZW9TYW1wbGVzKSB8fCB0aGlzLklTR2VuZXJhdGVkIHx8IGZsdXNoO1xuICAgIGlmIChjYW5SZW11eEF2Yykge1xuICAgICAgaWYgKHRoaXMuSVNHZW5lcmF0ZWQpIHtcbiAgICAgICAgdmFyIF92aWRlb1RyYWNrJHBpeGVsUmF0aSwgX2NvbmZpZyRwaXhlbFJhdGlvLCBfdmlkZW9UcmFjayRwaXhlbFJhdGkyLCBfY29uZmlnJHBpeGVsUmF0aW8yO1xuICAgICAgICBjb25zdCBjb25maWcgPSB0aGlzLnZpZGVvVHJhY2tDb25maWc7XG4gICAgICAgIGlmIChjb25maWcgJiYgKHZpZGVvVHJhY2sud2lkdGggIT09IGNvbmZpZy53aWR0aCB8fCB2aWRlb1RyYWNrLmhlaWdodCAhPT0gY29uZmlnLmhlaWdodCB8fCAoKF92aWRlb1RyYWNrJHBpeGVsUmF0aSA9IHZpZGVvVHJhY2sucGl4ZWxSYXRpbykgPT0gbnVsbCA/IHZvaWQgMCA6IF92aWRlb1RyYWNrJHBpeGVsUmF0aVswXSkgIT09ICgoX2NvbmZpZyRwaXhlbFJhdGlvID0gY29uZmlnLnBpeGVsUmF0aW8pID09IG51bGwgPyB2b2lkIDAgOiBfY29uZmlnJHBpeGVsUmF0aW9bMF0pIHx8ICgoX3ZpZGVvVHJhY2skcGl4ZWxSYXRpMiA9IHZpZGVvVHJhY2sucGl4ZWxSYXRpbykgPT0gbnVsbCA/IHZvaWQgMCA6IF92aWRlb1RyYWNrJHBpeGVsUmF0aTJbMV0pICE9PSAoKF9jb25maWckcGl4ZWxSYXRpbzIgPSBjb25maWcucGl4ZWxSYXRpbykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jb25maWckcGl4ZWxSYXRpbzJbMV0pKSkge1xuICAgICAgICAgIHRoaXMucmVzZXRJbml0U2VnbWVudCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbml0U2VnbWVudCA9IHRoaXMuZ2VuZXJhdGVJUyhhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNWaWRlb0NvbnRpZ3VvdXMgPSB0aGlzLmlzVmlkZW9Db250aWd1b3VzO1xuICAgICAgbGV0IGZpcnN0S2V5RnJhbWVJbmRleCA9IC0xO1xuICAgICAgbGV0IGZpcnN0S2V5RnJhbWVQVFM7XG4gICAgICBpZiAoZW5vdWdoVmlkZW9TYW1wbGVzKSB7XG4gICAgICAgIGZpcnN0S2V5RnJhbWVJbmRleCA9IGZpbmRLZXlmcmFtZUluZGV4KHZpZGVvVHJhY2suc2FtcGxlcyk7XG4gICAgICAgIGlmICghaXNWaWRlb0NvbnRpZ3VvdXMgJiYgdGhpcy5jb25maWcuZm9yY2VLZXlGcmFtZU9uRGlzY29udGludWl0eSkge1xuICAgICAgICAgIGluZGVwZW5kZW50ID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoZmlyc3RLZXlGcmFtZUluZGV4ID4gMCkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYFttcDQtcmVtdXhlcl06IERyb3BwZWQgJHtmaXJzdEtleUZyYW1lSW5kZXh9IG91dCBvZiAke2xlbmd0aH0gdmlkZW8gc2FtcGxlcyBkdWUgdG8gYSBtaXNzaW5nIGtleWZyYW1lYCk7XG4gICAgICAgICAgICBjb25zdCBzdGFydFBUUyA9IHRoaXMuZ2V0VmlkZW9TdGFydFB0cyh2aWRlb1RyYWNrLnNhbXBsZXMpO1xuICAgICAgICAgICAgdmlkZW9UcmFjay5zYW1wbGVzID0gdmlkZW9UcmFjay5zYW1wbGVzLnNsaWNlKGZpcnN0S2V5RnJhbWVJbmRleCk7XG4gICAgICAgICAgICB2aWRlb1RyYWNrLmRyb3BwZWQgKz0gZmlyc3RLZXlGcmFtZUluZGV4O1xuICAgICAgICAgICAgdmlkZW9UaW1lT2Zmc2V0ICs9ICh2aWRlb1RyYWNrLnNhbXBsZXNbMF0ucHRzIC0gc3RhcnRQVFMpIC8gdmlkZW9UcmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICAgICAgICAgIGZpcnN0S2V5RnJhbWVQVFMgPSB2aWRlb1RpbWVPZmZzZXQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChmaXJzdEtleUZyYW1lSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihgW21wNC1yZW11eGVyXTogTm8ga2V5ZnJhbWUgZm91bmQgb3V0IG9mICR7bGVuZ3RofSB2aWRlbyBzYW1wbGVzYCk7XG4gICAgICAgICAgICBpbmRlcGVuZGVudCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuSVNHZW5lcmF0ZWQpIHtcbiAgICAgICAgaWYgKGVub3VnaEF1ZGlvU2FtcGxlcyAmJiBlbm91Z2hWaWRlb1NhbXBsZXMpIHtcbiAgICAgICAgICAvLyB0aW1lT2Zmc2V0IGlzIGV4cGVjdGVkIHRvIGJlIHRoZSBvZmZzZXQgb2YgdGhlIGZpcnN0IHRpbWVzdGFtcCBvZiB0aGlzIGZyYWdtZW50IChmaXJzdCBEVFMpXG4gICAgICAgICAgLy8gaWYgZmlyc3QgYXVkaW8gRFRTIGlzIG5vdCBhbGlnbmVkIHdpdGggZmlyc3QgdmlkZW8gRFRTIHRoZW4gd2UgbmVlZCB0byB0YWtlIHRoYXQgaW50byBhY2NvdW50XG4gICAgICAgICAgLy8gd2hlbiBwcm92aWRpbmcgdGltZU9mZnNldCB0byByZW11eEF1ZGlvIC8gcmVtdXhWaWRlby4gaWYgd2UgZG9uJ3QgZG8gdGhhdCwgdGhlcmUgbWlnaHQgYmUgYSBwZXJtYW5lbnQgLyBzbWFsbFxuICAgICAgICAgIC8vIGRyaWZ0IGJldHdlZW4gYXVkaW8gYW5kIHZpZGVvIHN0cmVhbXNcbiAgICAgICAgICBjb25zdCBzdGFydFBUUyA9IHRoaXMuZ2V0VmlkZW9TdGFydFB0cyh2aWRlb1RyYWNrLnNhbXBsZXMpO1xuICAgICAgICAgIGNvbnN0IHRzRGVsdGEgPSBub3JtYWxpemVQdHMoYXVkaW9UcmFjay5zYW1wbGVzWzBdLnB0cywgc3RhcnRQVFMpIC0gc3RhcnRQVFM7XG4gICAgICAgICAgY29uc3QgYXVkaW92aWRlb1RpbWVzdGFtcERlbHRhID0gdHNEZWx0YSAvIHZpZGVvVHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgICAgICAgYXVkaW9UaW1lT2Zmc2V0ICs9IE1hdGgubWF4KDAsIGF1ZGlvdmlkZW9UaW1lc3RhbXBEZWx0YSk7XG4gICAgICAgICAgdmlkZW9UaW1lT2Zmc2V0ICs9IE1hdGgubWF4KDAsIC1hdWRpb3ZpZGVvVGltZXN0YW1wRGVsdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHVycG9zZWZ1bGx5IHJlbXV4aW5nIGF1ZGlvIGJlZm9yZSB2aWRlbywgc28gdGhhdCByZW11eFZpZGVvIGNhbiB1c2UgbmV4dEF1ZGlvUHRzLCB3aGljaCBpcyBjYWxjdWxhdGVkIGluIHJlbXV4QXVkaW8uXG4gICAgICAgIGlmIChlbm91Z2hBdWRpb1NhbXBsZXMpIHtcbiAgICAgICAgICAvLyBpZiBpbml0U2VnbWVudCB3YXMgZ2VuZXJhdGVkIHdpdGhvdXQgYXVkaW8gc2FtcGxlcywgcmVnZW5lcmF0ZSBpdCBhZ2FpblxuICAgICAgICAgIGlmICghYXVkaW9UcmFjay5zYW1wbGVyYXRlKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybignW21wNC1yZW11eGVyXTogcmVnZW5lcmF0ZSBJbml0U2VnbWVudCBhcyBhdWRpbyBkZXRlY3RlZCcpO1xuICAgICAgICAgICAgaW5pdFNlZ21lbnQgPSB0aGlzLmdlbmVyYXRlSVMoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXVkaW8gPSB0aGlzLnJlbXV4QXVkaW8oYXVkaW9UcmFjaywgYXVkaW9UaW1lT2Zmc2V0LCB0aGlzLmlzQXVkaW9Db250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGhhc1ZpZGVvIHx8IGVub3VnaFZpZGVvU2FtcGxlcyB8fCBwbGF5bGlzdFR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLkFVRElPID8gdmlkZW9UaW1lT2Zmc2V0IDogdW5kZWZpbmVkKTtcbiAgICAgICAgICBpZiAoZW5vdWdoVmlkZW9TYW1wbGVzKSB7XG4gICAgICAgICAgICBjb25zdCBhdWRpb1RyYWNrTGVuZ3RoID0gYXVkaW8gPyBhdWRpby5lbmRQVFMgLSBhdWRpby5zdGFydFBUUyA6IDA7XG4gICAgICAgICAgICAvLyBpZiBpbml0U2VnbWVudCB3YXMgZ2VuZXJhdGVkIHdpdGhvdXQgdmlkZW8gc2FtcGxlcywgcmVnZW5lcmF0ZSBpdCBhZ2FpblxuICAgICAgICAgICAgaWYgKCF2aWRlb1RyYWNrLmlucHV0VGltZVNjYWxlKSB7XG4gICAgICAgICAgICAgIGxvZ2dlci53YXJuKCdbbXA0LXJlbXV4ZXJdOiByZWdlbmVyYXRlIEluaXRTZWdtZW50IGFzIHZpZGVvIGRldGVjdGVkJyk7XG4gICAgICAgICAgICAgIGluaXRTZWdtZW50ID0gdGhpcy5nZW5lcmF0ZUlTKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2aWRlbyA9IHRoaXMucmVtdXhWaWRlbyh2aWRlb1RyYWNrLCB2aWRlb1RpbWVPZmZzZXQsIGlzVmlkZW9Db250aWd1b3VzLCBhdWRpb1RyYWNrTGVuZ3RoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZW5vdWdoVmlkZW9TYW1wbGVzKSB7XG4gICAgICAgICAgdmlkZW8gPSB0aGlzLnJlbXV4VmlkZW8odmlkZW9UcmFjaywgdmlkZW9UaW1lT2Zmc2V0LCBpc1ZpZGVvQ29udGlndW91cywgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpZGVvKSB7XG4gICAgICAgICAgdmlkZW8uZmlyc3RLZXlGcmFtZSA9IGZpcnN0S2V5RnJhbWVJbmRleDtcbiAgICAgICAgICB2aWRlby5pbmRlcGVuZGVudCA9IGZpcnN0S2V5RnJhbWVJbmRleCAhPT0gLTE7XG4gICAgICAgICAgdmlkZW8uZmlyc3RLZXlGcmFtZVBUUyA9IGZpcnN0S2V5RnJhbWVQVFM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbGxvdyBJRDMgYW5kIHRleHQgdG8gcmVtdXgsIGV2ZW4gaWYgbW9yZSBhdWRpby92aWRlbyBzYW1wbGVzIGFyZSByZXF1aXJlZFxuICAgIGlmICh0aGlzLklTR2VuZXJhdGVkICYmIHRoaXMuX2luaXRQVFMgJiYgdGhpcy5faW5pdERUUykge1xuICAgICAgaWYgKGlkM1RyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgIGlkMyA9IGZsdXNoVGV4dFRyYWNrTWV0YWRhdGFDdWVTYW1wbGVzKGlkM1RyYWNrLCB0aW1lT2Zmc2V0LCB0aGlzLl9pbml0UFRTLCB0aGlzLl9pbml0RFRTKTtcbiAgICAgIH1cbiAgICAgIGlmICh0ZXh0VHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgdGV4dCA9IGZsdXNoVGV4dFRyYWNrVXNlcmRhdGFDdWVTYW1wbGVzKHRleHRUcmFjaywgdGltZU9mZnNldCwgdGhpcy5faW5pdFBUUyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBhdWRpbyxcbiAgICAgIHZpZGVvLFxuICAgICAgaW5pdFNlZ21lbnQsXG4gICAgICBpbmRlcGVuZGVudCxcbiAgICAgIHRleHQsXG4gICAgICBpZDNcbiAgICB9O1xuICB9XG4gIGdlbmVyYXRlSVMoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgY29uc3QgYXVkaW9TYW1wbGVzID0gYXVkaW9UcmFjay5zYW1wbGVzO1xuICAgIGNvbnN0IHZpZGVvU2FtcGxlcyA9IHZpZGVvVHJhY2suc2FtcGxlcztcbiAgICBjb25zdCB0eXBlU3VwcG9ydGVkID0gdGhpcy50eXBlU3VwcG9ydGVkO1xuICAgIGNvbnN0IHRyYWNrcyA9IHt9O1xuICAgIGNvbnN0IF9pbml0UFRTID0gdGhpcy5faW5pdFBUUztcbiAgICBsZXQgY29tcHV0ZVBUU0RUUyA9ICFfaW5pdFBUUyB8fCBhY2N1cmF0ZVRpbWVPZmZzZXQ7XG4gICAgbGV0IGNvbnRhaW5lciA9ICdhdWRpby9tcDQnO1xuICAgIGxldCBpbml0UFRTO1xuICAgIGxldCBpbml0RFRTO1xuICAgIGxldCB0aW1lc2NhbGU7XG4gICAgaWYgKGNvbXB1dGVQVFNEVFMpIHtcbiAgICAgIGluaXRQVFMgPSBpbml0RFRTID0gSW5maW5pdHk7XG4gICAgfVxuICAgIGlmIChhdWRpb1RyYWNrLmNvbmZpZyAmJiBhdWRpb1NhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAvLyBsZXQncyB1c2UgYXVkaW8gc2FtcGxpbmcgcmF0ZSBhcyBNUDQgdGltZSBzY2FsZS5cbiAgICAgIC8vIHJhdGlvbmFsZSBpcyB0aGF0IHRoZXJlIGlzIGEgaW50ZWdlciBuYiBvZiBhdWRpbyBmcmFtZXMgcGVyIGF1ZGlvIHNhbXBsZSAoMTAyNCBmb3IgQUFDKVxuICAgICAgLy8gdXNpbmcgYXVkaW8gc2FtcGxpbmcgcmF0ZSBoZXJlIGhlbHBzIGhhdmluZyBhbiBpbnRlZ2VyIE1QNCBmcmFtZSBkdXJhdGlvblxuICAgICAgLy8gdGhpcyBhdm9pZHMgcG90ZW50aWFsIHJvdW5kaW5nIGlzc3VlIGFuZCBBViBzeW5jIGlzc3VlXG4gICAgICBhdWRpb1RyYWNrLnRpbWVzY2FsZSA9IGF1ZGlvVHJhY2suc2FtcGxlcmF0ZTtcbiAgICAgIHN3aXRjaCAoYXVkaW9UcmFjay5zZWdtZW50Q29kZWMpIHtcbiAgICAgICAgY2FzZSAnbXAzJzpcbiAgICAgICAgICBpZiAodHlwZVN1cHBvcnRlZC5tcGVnKSB7XG4gICAgICAgICAgICAvLyBDaHJvbWUgYW5kIFNhZmFyaVxuICAgICAgICAgICAgY29udGFpbmVyID0gJ2F1ZGlvL21wZWcnO1xuICAgICAgICAgICAgYXVkaW9UcmFjay5jb2RlYyA9ICcnO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZVN1cHBvcnRlZC5tcDMpIHtcbiAgICAgICAgICAgIC8vIEZpcmVmb3hcbiAgICAgICAgICAgIGF1ZGlvVHJhY2suY29kZWMgPSAnbXAzJztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2FjMyc6XG4gICAgICAgICAgYXVkaW9UcmFjay5jb2RlYyA9ICdhYy0zJztcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRyYWNrcy5hdWRpbyA9IHtcbiAgICAgICAgaWQ6ICdhdWRpbycsXG4gICAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgICBjb2RlYzogYXVkaW9UcmFjay5jb2RlYyxcbiAgICAgICAgaW5pdFNlZ21lbnQ6IGF1ZGlvVHJhY2suc2VnbWVudENvZGVjID09PSAnbXAzJyAmJiB0eXBlU3VwcG9ydGVkLm1wZWcgPyBuZXcgVWludDhBcnJheSgwKSA6IE1QNC5pbml0U2VnbWVudChbYXVkaW9UcmFja10pLFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIGNoYW5uZWxDb3VudDogYXVkaW9UcmFjay5jaGFubmVsQ291bnRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XG4gICAgICAgIHRpbWVzY2FsZSA9IGF1ZGlvVHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgICAgIGlmICghX2luaXRQVFMgfHwgdGltZXNjYWxlICE9PSBfaW5pdFBUUy50aW1lc2NhbGUpIHtcbiAgICAgICAgICAvLyByZW1lbWJlciBmaXJzdCBQVFMgb2YgdGhpcyBkZW11eGluZyBjb250ZXh0LiBmb3IgYXVkaW8sIFBUUyA9IERUU1xuICAgICAgICAgIGluaXRQVFMgPSBpbml0RFRTID0gYXVkaW9TYW1wbGVzWzBdLnB0cyAtIE1hdGgucm91bmQodGltZXNjYWxlICogdGltZU9mZnNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29tcHV0ZVBUU0RUUyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2aWRlb1RyYWNrLnNwcyAmJiB2aWRlb1RyYWNrLnBwcyAmJiB2aWRlb1NhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAvLyBsZXQncyB1c2UgaW5wdXQgdGltZSBzY2FsZSBhcyBNUDQgdmlkZW8gdGltZXNjYWxlXG4gICAgICAvLyB3ZSB1c2UgaW5wdXQgdGltZSBzY2FsZSBzdHJhaWdodCBhd2F5IHRvIGF2b2lkIHJvdW5kaW5nIGlzc3VlcyBvbiBmcmFtZSBkdXJhdGlvbiAvIGN0cyBjb21wdXRhdGlvblxuICAgICAgdmlkZW9UcmFjay50aW1lc2NhbGUgPSB2aWRlb1RyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgICAgdHJhY2tzLnZpZGVvID0ge1xuICAgICAgICBpZDogJ21haW4nLFxuICAgICAgICBjb250YWluZXI6ICd2aWRlby9tcDQnLFxuICAgICAgICBjb2RlYzogdmlkZW9UcmFjay5jb2RlYyxcbiAgICAgICAgaW5pdFNlZ21lbnQ6IE1QNC5pbml0U2VnbWVudChbdmlkZW9UcmFja10pLFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIHdpZHRoOiB2aWRlb1RyYWNrLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogdmlkZW9UcmFjay5oZWlnaHRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XG4gICAgICAgIHRpbWVzY2FsZSA9IHZpZGVvVHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgICAgIGlmICghX2luaXRQVFMgfHwgdGltZXNjYWxlICE9PSBfaW5pdFBUUy50aW1lc2NhbGUpIHtcbiAgICAgICAgICBjb25zdCBzdGFydFBUUyA9IHRoaXMuZ2V0VmlkZW9TdGFydFB0cyh2aWRlb1NhbXBsZXMpO1xuICAgICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gTWF0aC5yb3VuZCh0aW1lc2NhbGUgKiB0aW1lT2Zmc2V0KTtcbiAgICAgICAgICBpbml0RFRTID0gTWF0aC5taW4oaW5pdERUUywgbm9ybWFsaXplUHRzKHZpZGVvU2FtcGxlc1swXS5kdHMsIHN0YXJ0UFRTKSAtIHN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICBpbml0UFRTID0gTWF0aC5taW4oaW5pdFBUUywgc3RhcnRQVFMgLSBzdGFydE9mZnNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29tcHV0ZVBUU0RUUyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnZpZGVvVHJhY2tDb25maWcgPSB7XG4gICAgICAgIHdpZHRoOiB2aWRlb1RyYWNrLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHZpZGVvVHJhY2suaGVpZ2h0LFxuICAgICAgICBwaXhlbFJhdGlvOiB2aWRlb1RyYWNrLnBpeGVsUmF0aW9cbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyh0cmFja3MpLmxlbmd0aCkge1xuICAgICAgdGhpcy5JU0dlbmVyYXRlZCA9IHRydWU7XG4gICAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgICB0aGlzLl9pbml0UFRTID0ge1xuICAgICAgICAgIGJhc2VUaW1lOiBpbml0UFRTLFxuICAgICAgICAgIHRpbWVzY2FsZTogdGltZXNjYWxlXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2luaXREVFMgPSB7XG4gICAgICAgICAgYmFzZVRpbWU6IGluaXREVFMsXG4gICAgICAgICAgdGltZXNjYWxlOiB0aW1lc2NhbGVcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluaXRQVFMgPSB0aW1lc2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0cmFja3MsXG4gICAgICAgIGluaXRQVFMsXG4gICAgICAgIHRpbWVzY2FsZVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmVtdXhWaWRlbyh0cmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYXVkaW9UcmFja0xlbmd0aCkge1xuICAgIGNvbnN0IHRpbWVTY2FsZSA9IHRyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgIGNvbnN0IGlucHV0U2FtcGxlcyA9IHRyYWNrLnNhbXBsZXM7XG4gICAgY29uc3Qgb3V0cHV0U2FtcGxlcyA9IFtdO1xuICAgIGNvbnN0IG5iU2FtcGxlcyA9IGlucHV0U2FtcGxlcy5sZW5ndGg7XG4gICAgY29uc3QgaW5pdFBUUyA9IHRoaXMuX2luaXRQVFM7XG4gICAgbGV0IG5leHRBdmNEdHMgPSB0aGlzLm5leHRBdmNEdHM7XG4gICAgbGV0IG9mZnNldCA9IDg7XG4gICAgbGV0IG1wNFNhbXBsZUR1cmF0aW9uID0gdGhpcy52aWRlb1NhbXBsZUR1cmF0aW9uO1xuICAgIGxldCBmaXJzdERUUztcbiAgICBsZXQgbGFzdERUUztcbiAgICBsZXQgbWluUFRTID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGxldCBtYXhQVFMgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IHNvcnRTYW1wbGVzID0gZmFsc2U7XG5cbiAgICAvLyBpZiBwYXJzZWQgZnJhZ21lbnQgaXMgY29udGlndW91cyB3aXRoIGxhc3Qgb25lLCBsZXQncyB1c2UgbGFzdCBEVFMgdmFsdWUgYXMgcmVmZXJlbmNlXG4gICAgaWYgKCFjb250aWd1b3VzIHx8IG5leHRBdmNEdHMgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHB0cyA9IHRpbWVPZmZzZXQgKiB0aW1lU2NhbGU7XG4gICAgICBjb25zdCBjdHMgPSBpbnB1dFNhbXBsZXNbMF0ucHRzIC0gbm9ybWFsaXplUHRzKGlucHV0U2FtcGxlc1swXS5kdHMsIGlucHV0U2FtcGxlc1swXS5wdHMpO1xuICAgICAgaWYgKGNocm9tZVZlcnNpb24gJiYgbmV4dEF2Y0R0cyAhPT0gbnVsbCAmJiBNYXRoLmFicyhwdHMgLSBjdHMgLSBuZXh0QXZjRHRzKSA8IDE1MDAwKSB7XG4gICAgICAgIC8vIHRyZWF0IGFzIGNvbnRpZ291cyB0byBhZGp1c3Qgc2FtcGxlcyB0aGF0IHdvdWxkIG90aGVyd2lzZSBwcm9kdWNlIHZpZGVvIGJ1ZmZlciBnYXBzIGluIENocm9tZVxuICAgICAgICBjb250aWd1b3VzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIG5vdCBjb250aWd1b3VzLCBsZXQncyB1c2UgdGFyZ2V0IHRpbWVPZmZzZXRcbiAgICAgICAgbmV4dEF2Y0R0cyA9IHB0cyAtIGN0cztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQVFMgaXMgY29kZWQgb24gMzNiaXRzLCBhbmQgY2FuIGxvb3AgZnJvbSAtMl4zMiB0byAyXjMyXG4gICAgLy8gUFRTTm9ybWFsaXplIHdpbGwgbWFrZSBQVFMvRFRTIHZhbHVlIG1vbm90b25pYywgd2UgdXNlIGxhc3Qga25vd24gRFRTIHZhbHVlIGFzIHJlZmVyZW5jZSB2YWx1ZVxuICAgIGNvbnN0IGluaXRUaW1lID0gaW5pdFBUUy5iYXNlVGltZSAqIHRpbWVTY2FsZSAvIGluaXRQVFMudGltZXNjYWxlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmJTYW1wbGVzOyBpKyspIHtcbiAgICAgIGNvbnN0IHNhbXBsZSA9IGlucHV0U2FtcGxlc1tpXTtcbiAgICAgIHNhbXBsZS5wdHMgPSBub3JtYWxpemVQdHMoc2FtcGxlLnB0cyAtIGluaXRUaW1lLCBuZXh0QXZjRHRzKTtcbiAgICAgIHNhbXBsZS5kdHMgPSBub3JtYWxpemVQdHMoc2FtcGxlLmR0cyAtIGluaXRUaW1lLCBuZXh0QXZjRHRzKTtcbiAgICAgIGlmIChzYW1wbGUuZHRzIDwgaW5wdXRTYW1wbGVzW2kgPiAwID8gaSAtIDEgOiBpXS5kdHMpIHtcbiAgICAgICAgc29ydFNhbXBsZXMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNvcnQgdmlkZW8gc2FtcGxlcyBieSBEVFMgdGhlbiBQVFMgdGhlbiBkZW11eCBpZCBvcmRlclxuICAgIGlmIChzb3J0U2FtcGxlcykge1xuICAgICAgaW5wdXRTYW1wbGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgY29uc3QgZGVsdGFkdHMgPSBhLmR0cyAtIGIuZHRzO1xuICAgICAgICBjb25zdCBkZWx0YXB0cyA9IGEucHRzIC0gYi5wdHM7XG4gICAgICAgIHJldHVybiBkZWx0YWR0cyB8fCBkZWx0YXB0cztcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEdldCBmaXJzdC9sYXN0IERUU1xuICAgIGZpcnN0RFRTID0gaW5wdXRTYW1wbGVzWzBdLmR0cztcbiAgICBsYXN0RFRTID0gaW5wdXRTYW1wbGVzW2lucHV0U2FtcGxlcy5sZW5ndGggLSAxXS5kdHM7XG5cbiAgICAvLyBTYW1wbGUgZHVyYXRpb24gKGFzIGV4cGVjdGVkIGJ5IHRydW4gTVA0IGJveGVzKSwgc2hvdWxkIGJlIHRoZSBkZWx0YSBiZXR3ZWVuIHNhbXBsZSBEVFNcbiAgICAvLyBzZXQgdGhpcyBjb25zdGFudCBkdXJhdGlvbiBhcyBiZWluZyB0aGUgYXZnIGRlbHRhIGJldHdlZW4gY29uc2VjdXRpdmUgRFRTLlxuICAgIGNvbnN0IGlucHV0RHVyYXRpb24gPSBsYXN0RFRTIC0gZmlyc3REVFM7XG4gICAgY29uc3QgYXZlcmFnZVNhbXBsZUR1cmF0aW9uID0gaW5wdXREdXJhdGlvbiA/IE1hdGgucm91bmQoaW5wdXREdXJhdGlvbiAvIChuYlNhbXBsZXMgLSAxKSkgOiBtcDRTYW1wbGVEdXJhdGlvbiB8fCB0cmFjay5pbnB1dFRpbWVTY2FsZSAvIDMwO1xuXG4gICAgLy8gaWYgZnJhZ21lbnQgYXJlIGNvbnRpZ3VvdXMsIGRldGVjdCBob2xlL292ZXJsYXBwaW5nIGJldHdlZW4gZnJhZ21lbnRzXG4gICAgaWYgKGNvbnRpZ3VvdXMpIHtcbiAgICAgIC8vIGNoZWNrIHRpbWVzdGFtcCBjb250aW51aXR5IGFjcm9zcyBjb25zZWN1dGl2ZSBmcmFnbWVudHMgKHRoaXMgaXMgdG8gcmVtb3ZlIGludGVyLWZyYWdtZW50IGdhcC9ob2xlKVxuICAgICAgY29uc3QgZGVsdGEgPSBmaXJzdERUUyAtIG5leHRBdmNEdHM7XG4gICAgICBjb25zdCBmb3VuZEhvbGUgPSBkZWx0YSA+IGF2ZXJhZ2VTYW1wbGVEdXJhdGlvbjtcbiAgICAgIGNvbnN0IGZvdW5kT3ZlcmxhcCA9IGRlbHRhIDwgLTE7XG4gICAgICBpZiAoZm91bmRIb2xlIHx8IGZvdW5kT3ZlcmxhcCkge1xuICAgICAgICBpZiAoZm91bmRIb2xlKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYEFWQzogJHt0b01zRnJvbU1wZWdUc0Nsb2NrKGRlbHRhLCB0cnVlKX0gbXMgKCR7ZGVsdGF9ZHRzKSBob2xlIGJldHdlZW4gZnJhZ21lbnRzIGRldGVjdGVkIGF0ICR7dGltZU9mZnNldC50b0ZpeGVkKDMpfWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci53YXJuKGBBVkM6ICR7dG9Nc0Zyb21NcGVnVHNDbG9jaygtZGVsdGEsIHRydWUpfSBtcyAoJHtkZWx0YX1kdHMpIG92ZXJsYXBwaW5nIGJldHdlZW4gZnJhZ21lbnRzIGRldGVjdGVkIGF0ICR7dGltZU9mZnNldC50b0ZpeGVkKDMpfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZm91bmRPdmVybGFwIHx8IG5leHRBdmNEdHMgPj0gaW5wdXRTYW1wbGVzWzBdLnB0cyB8fCBjaHJvbWVWZXJzaW9uKSB7XG4gICAgICAgICAgZmlyc3REVFMgPSBuZXh0QXZjRHRzO1xuICAgICAgICAgIGNvbnN0IGZpcnN0UFRTID0gaW5wdXRTYW1wbGVzWzBdLnB0cyAtIGRlbHRhO1xuICAgICAgICAgIGlmIChmb3VuZEhvbGUpIHtcbiAgICAgICAgICAgIGlucHV0U2FtcGxlc1swXS5kdHMgPSBmaXJzdERUUztcbiAgICAgICAgICAgIGlucHV0U2FtcGxlc1swXS5wdHMgPSBmaXJzdFBUUztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dFNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKGlucHV0U2FtcGxlc1tpXS5kdHMgPiBmaXJzdFBUUykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlucHV0U2FtcGxlc1tpXS5kdHMgLT0gZGVsdGE7XG4gICAgICAgICAgICAgIGlucHV0U2FtcGxlc1tpXS5wdHMgLT0gZGVsdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvZ2dlci5sb2coYFZpZGVvOiBJbml0aWFsIFBUUy9EVFMgYWRqdXN0ZWQ6ICR7dG9Nc0Zyb21NcGVnVHNDbG9jayhmaXJzdFBUUywgdHJ1ZSl9LyR7dG9Nc0Zyb21NcGVnVHNDbG9jayhmaXJzdERUUywgdHJ1ZSl9LCBkZWx0YTogJHt0b01zRnJvbU1wZWdUc0Nsb2NrKGRlbHRhLCB0cnVlKX0gbXNgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmaXJzdERUUyA9IE1hdGgubWF4KDAsIGZpcnN0RFRTKTtcbiAgICBsZXQgbmJOYWx1ID0gMDtcbiAgICBsZXQgbmFsdUxlbiA9IDA7XG4gICAgbGV0IGR0c1N0ZXAgPSBmaXJzdERUUztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5iU2FtcGxlczsgaSsrKSB7XG4gICAgICAvLyBjb21wdXRlIHRvdGFsL2F2YyBzYW1wbGUgbGVuZ3RoIGFuZCBuYiBvZiBOQUwgdW5pdHNcbiAgICAgIGNvbnN0IHNhbXBsZSA9IGlucHV0U2FtcGxlc1tpXTtcbiAgICAgIGNvbnN0IHVuaXRzID0gc2FtcGxlLnVuaXRzO1xuICAgICAgY29uc3QgbmJVbml0cyA9IHVuaXRzLmxlbmd0aDtcbiAgICAgIGxldCBzYW1wbGVMZW4gPSAwO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBuYlVuaXRzOyBqKyspIHtcbiAgICAgICAgc2FtcGxlTGVuICs9IHVuaXRzW2pdLmRhdGEubGVuZ3RoO1xuICAgICAgfVxuICAgICAgbmFsdUxlbiArPSBzYW1wbGVMZW47XG4gICAgICBuYk5hbHUgKz0gbmJVbml0cztcbiAgICAgIHNhbXBsZS5sZW5ndGggPSBzYW1wbGVMZW47XG5cbiAgICAgIC8vIGVuc3VyZSBzYW1wbGUgbW9ub3RvbmljIERUU1xuICAgICAgaWYgKHNhbXBsZS5kdHMgPCBkdHNTdGVwKSB7XG4gICAgICAgIHNhbXBsZS5kdHMgPSBkdHNTdGVwO1xuICAgICAgICBkdHNTdGVwICs9IGF2ZXJhZ2VTYW1wbGVEdXJhdGlvbiAvIDQgfCAwIHx8IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkdHNTdGVwID0gc2FtcGxlLmR0cztcbiAgICAgIH1cbiAgICAgIG1pblBUUyA9IE1hdGgubWluKHNhbXBsZS5wdHMsIG1pblBUUyk7XG4gICAgICBtYXhQVFMgPSBNYXRoLm1heChzYW1wbGUucHRzLCBtYXhQVFMpO1xuICAgIH1cbiAgICBsYXN0RFRTID0gaW5wdXRTYW1wbGVzW25iU2FtcGxlcyAtIDFdLmR0cztcblxuICAgIC8qIGNvbmNhdGVuYXRlIHRoZSB2aWRlbyBkYXRhIGFuZCBjb25zdHJ1Y3QgdGhlIG1kYXQgaW4gcGxhY2VcbiAgICAgIChuZWVkIDggbW9yZSBieXRlcyB0byBmaWxsIGxlbmd0aCBhbmQgbXBkYXQgdHlwZSkgKi9cbiAgICBjb25zdCBtZGF0U2l6ZSA9IG5hbHVMZW4gKyA0ICogbmJOYWx1ICsgODtcbiAgICBsZXQgbWRhdDtcbiAgICB0cnkge1xuICAgICAgbWRhdCA9IG5ldyBVaW50OEFycmF5KG1kYXRTaXplKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMub2JzZXJ2ZXIuZW1pdChFdmVudHMuRVJST1IsIEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1VWF9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLlJFTVVYX0FMTE9DX0VSUk9SLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgIGJ5dGVzOiBtZGF0U2l6ZSxcbiAgICAgICAgcmVhc29uOiBgZmFpbCBhbGxvY2F0aW5nIHZpZGVvIG1kYXQgJHttZGF0U2l6ZX1gXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhtZGF0LmJ1ZmZlcik7XG4gICAgdmlldy5zZXRVaW50MzIoMCwgbWRhdFNpemUpO1xuICAgIG1kYXQuc2V0KE1QNC50eXBlcy5tZGF0LCA0KTtcbiAgICBsZXQgc3RyZXRjaGVkTGFzdEZyYW1lID0gZmFsc2U7XG4gICAgbGV0IG1pbkR0c0RlbHRhID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGxldCBtaW5QdHNEZWx0YSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgbWF4RHRzRGVsdGEgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IG1heFB0c0RlbHRhID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmJTYW1wbGVzOyBpKyspIHtcbiAgICAgIGNvbnN0IFZpZGVvU2FtcGxlID0gaW5wdXRTYW1wbGVzW2ldO1xuICAgICAgY29uc3QgVmlkZW9TYW1wbGVVbml0cyA9IFZpZGVvU2FtcGxlLnVuaXRzO1xuICAgICAgbGV0IG1wNFNhbXBsZUxlbmd0aCA9IDA7XG4gICAgICAvLyBjb252ZXJ0IE5BTFUgYml0c3RyZWFtIHRvIE1QNCBmb3JtYXQgKHByZXBlbmQgTkFMVSB3aXRoIHNpemUgZmllbGQpXG4gICAgICBmb3IgKGxldCBqID0gMCwgbmJVbml0cyA9IFZpZGVvU2FtcGxlVW5pdHMubGVuZ3RoOyBqIDwgbmJVbml0czsgaisrKSB7XG4gICAgICAgIGNvbnN0IHVuaXQgPSBWaWRlb1NhbXBsZVVuaXRzW2pdO1xuICAgICAgICBjb25zdCB1bml0RGF0YSA9IHVuaXQuZGF0YTtcbiAgICAgICAgY29uc3QgdW5pdERhdGFMZW4gPSB1bml0LmRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCB1bml0RGF0YUxlbik7XG4gICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICBtZGF0LnNldCh1bml0RGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IHVuaXREYXRhTGVuO1xuICAgICAgICBtcDRTYW1wbGVMZW5ndGggKz0gNCArIHVuaXREYXRhTGVuO1xuICAgICAgfVxuXG4gICAgICAvLyBleHBlY3RlZCBzYW1wbGUgZHVyYXRpb24gaXMgdGhlIERlY29kaW5nIFRpbWVzdGFtcCBkaWZmIG9mIGNvbnNlY3V0aXZlIHNhbXBsZXNcbiAgICAgIGxldCBwdHNEZWx0YTtcbiAgICAgIGlmIChpIDwgbmJTYW1wbGVzIC0gMSkge1xuICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGlucHV0U2FtcGxlc1tpICsgMV0uZHRzIC0gVmlkZW9TYW1wbGUuZHRzO1xuICAgICAgICBwdHNEZWx0YSA9IGlucHV0U2FtcGxlc1tpICsgMV0ucHRzIC0gVmlkZW9TYW1wbGUucHRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICAgIGNvbnN0IGxhc3RGcmFtZUR1cmF0aW9uID0gaSA+IDAgPyBWaWRlb1NhbXBsZS5kdHMgLSBpbnB1dFNhbXBsZXNbaSAtIDFdLmR0cyA6IGF2ZXJhZ2VTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgcHRzRGVsdGEgPSBpID4gMCA/IFZpZGVvU2FtcGxlLnB0cyAtIGlucHV0U2FtcGxlc1tpIC0gMV0ucHRzIDogYXZlcmFnZVNhbXBsZUR1cmF0aW9uO1xuICAgICAgICBpZiAoY29uZmlnLnN0cmV0Y2hTaG9ydFZpZGVvVHJhY2sgJiYgdGhpcy5uZXh0QXVkaW9QdHMgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBJbiBzb21lIGNhc2VzLCBhIHNlZ21lbnQncyBhdWRpbyB0cmFjayBkdXJhdGlvbiBtYXkgZXhjZWVkIHRoZSB2aWRlbyB0cmFjayBkdXJhdGlvbi5cbiAgICAgICAgICAvLyBTaW5jZSB3ZSd2ZSBhbHJlYWR5IHJlbXV4ZWQgYXVkaW8sIGFuZCB3ZSBrbm93IGhvdyBsb25nIHRoZSBhdWRpbyB0cmFjayBpcywgd2UgbG9vayB0b1xuICAgICAgICAgIC8vIHNlZSBpZiB0aGUgZGVsdGEgdG8gdGhlIG5leHQgc2VnbWVudCBpcyBsb25nZXIgdGhhbiBtYXhCdWZmZXJIb2xlLlxuICAgICAgICAgIC8vIElmIHNvLCBwbGF5YmFjayB3b3VsZCBwb3RlbnRpYWxseSBnZXQgc3R1Y2ssIHNvIHdlIGFydGlmaWNpYWxseSBpbmZsYXRlXG4gICAgICAgICAgLy8gdGhlIGR1cmF0aW9uIG9mIHRoZSBsYXN0IGZyYW1lIHRvIG1pbmltaXplIGFueSBwb3RlbnRpYWwgZ2FwIGJldHdlZW4gc2VnbWVudHMuXG4gICAgICAgICAgY29uc3QgZ2FwVG9sZXJhbmNlID0gTWF0aC5mbG9vcihjb25maWcubWF4QnVmZmVySG9sZSAqIHRpbWVTY2FsZSk7XG4gICAgICAgICAgY29uc3QgZGVsdGFUb0ZyYW1lRW5kID0gKGF1ZGlvVHJhY2tMZW5ndGggPyBtaW5QVFMgKyBhdWRpb1RyYWNrTGVuZ3RoICogdGltZVNjYWxlIDogdGhpcy5uZXh0QXVkaW9QdHMpIC0gVmlkZW9TYW1wbGUucHRzO1xuICAgICAgICAgIGlmIChkZWx0YVRvRnJhbWVFbmQgPiBnYXBUb2xlcmFuY2UpIHtcbiAgICAgICAgICAgIC8vIFdlIHN1YnRyYWN0IGxhc3RGcmFtZUR1cmF0aW9uIGZyb20gZGVsdGFUb0ZyYW1lRW5kIHRvIHRyeSB0byBwcmV2ZW50IGFueSB2aWRlb1xuICAgICAgICAgICAgLy8gZnJhbWUgb3ZlcmxhcC4gbWF4QnVmZmVySG9sZSBzaG91bGQgYmUgPj4gbGFzdEZyYW1lRHVyYXRpb24gYW55d2F5LlxuICAgICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBkZWx0YVRvRnJhbWVFbmQgLSBsYXN0RnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICAgIGlmIChtcDRTYW1wbGVEdXJhdGlvbiA8IDApIHtcbiAgICAgICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBsYXN0RnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0cmV0Y2hlZExhc3RGcmFtZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIubG9nKGBbbXA0LXJlbXV4ZXJdOiBJdCBpcyBhcHByb3hpbWF0ZWx5ICR7ZGVsdGFUb0ZyYW1lRW5kIC8gOTB9IG1zIHRvIHRoZSBuZXh0IHNlZ21lbnQ7IHVzaW5nIGR1cmF0aW9uICR7bXA0U2FtcGxlRHVyYXRpb24gLyA5MH0gbXMgZm9yIHRoZSBsYXN0IHZpZGVvIGZyYW1lLmApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGxhc3RGcmFtZUR1cmF0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGxhc3RGcmFtZUR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBjb21wb3NpdGlvblRpbWVPZmZzZXQgPSBNYXRoLnJvdW5kKFZpZGVvU2FtcGxlLnB0cyAtIFZpZGVvU2FtcGxlLmR0cyk7XG4gICAgICBtaW5EdHNEZWx0YSA9IE1hdGgubWluKG1pbkR0c0RlbHRhLCBtcDRTYW1wbGVEdXJhdGlvbik7XG4gICAgICBtYXhEdHNEZWx0YSA9IE1hdGgubWF4KG1heER0c0RlbHRhLCBtcDRTYW1wbGVEdXJhdGlvbik7XG4gICAgICBtaW5QdHNEZWx0YSA9IE1hdGgubWluKG1pblB0c0RlbHRhLCBwdHNEZWx0YSk7XG4gICAgICBtYXhQdHNEZWx0YSA9IE1hdGgubWF4KG1heFB0c0RlbHRhLCBwdHNEZWx0YSk7XG4gICAgICBvdXRwdXRTYW1wbGVzLnB1c2gobmV3IE1wNFNhbXBsZShWaWRlb1NhbXBsZS5rZXksIG1wNFNhbXBsZUR1cmF0aW9uLCBtcDRTYW1wbGVMZW5ndGgsIGNvbXBvc2l0aW9uVGltZU9mZnNldCkpO1xuICAgIH1cbiAgICBpZiAob3V0cHV0U2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIGlmIChjaHJvbWVWZXJzaW9uKSB7XG4gICAgICAgIGlmIChjaHJvbWVWZXJzaW9uIDwgNzApIHtcbiAgICAgICAgICAvLyBDaHJvbWUgd29ya2Fyb3VuZCwgbWFyayBmaXJzdCBzYW1wbGUgYXMgYmVpbmcgYSBSYW5kb20gQWNjZXNzIFBvaW50IChrZXlmcmFtZSkgdG8gYXZvaWQgc291cmNlYnVmZmVyIGFwcGVuZCBpc3N1ZVxuICAgICAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yMjk0MTJcbiAgICAgICAgICBjb25zdCBmbGFncyA9IG91dHB1dFNhbXBsZXNbMF0uZmxhZ3M7XG4gICAgICAgICAgZmxhZ3MuZGVwZW5kc09uID0gMjtcbiAgICAgICAgICBmbGFncy5pc05vblN5bmMgPSAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNhZmFyaVdlYmtpdFZlcnNpb24pIHtcbiAgICAgICAgLy8gRml4IGZvciBcIkNOTiBzcGVjaWFsIHJlcG9ydCwgd2l0aCBDQ1wiIGluIHRlc3Qtc3RyZWFtcyAoU2FmYXJpIGJyb3dzZXIgb25seSlcbiAgICAgICAgLy8gSWdub3JlIERUUyB3aGVuIGZyYW1lIGR1cmF0aW9ucyBhcmUgaXJyZWd1bGFyLiBTYWZhcmkgTVNFIGRvZXMgbm90IGhhbmRsZSB0aGlzIGxlYWRpbmcgdG8gZ2Fwcy5cbiAgICAgICAgaWYgKG1heFB0c0RlbHRhIC0gbWluUHRzRGVsdGEgPCBtYXhEdHNEZWx0YSAtIG1pbkR0c0RlbHRhICYmIGF2ZXJhZ2VTYW1wbGVEdXJhdGlvbiAvIG1heER0c0RlbHRhIDwgMC4wMjUgJiYgb3V0cHV0U2FtcGxlc1swXS5jdHMgPT09IDApIHtcbiAgICAgICAgICBsb2dnZXIud2FybignRm91bmQgaXJyZWd1bGFyIGdhcHMgaW4gc2FtcGxlIGR1cmF0aW9uLiBVc2luZyBQVFMgaW5zdGVhZCBvZiBEVFMgdG8gZGV0ZXJtaW5lIE1QNCBzYW1wbGUgZHVyYXRpb24uJyk7XG4gICAgICAgICAgbGV0IGR0cyA9IGZpcnN0RFRTO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBvdXRwdXRTYW1wbGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0RHRzID0gZHRzICsgb3V0cHV0U2FtcGxlc1tpXS5kdXJhdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IHB0cyA9IGR0cyArIG91dHB1dFNhbXBsZXNbaV0uY3RzO1xuICAgICAgICAgICAgaWYgKGkgPCBsZW4gLSAxKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5leHRQdHMgPSBuZXh0RHRzICsgb3V0cHV0U2FtcGxlc1tpICsgMV0uY3RzO1xuICAgICAgICAgICAgICBvdXRwdXRTYW1wbGVzW2ldLmR1cmF0aW9uID0gbmV4dFB0cyAtIHB0cztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG91dHB1dFNhbXBsZXNbaV0uZHVyYXRpb24gPSBpID8gb3V0cHV0U2FtcGxlc1tpIC0gMV0uZHVyYXRpb24gOiBhdmVyYWdlU2FtcGxlRHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXRTYW1wbGVzW2ldLmN0cyA9IDA7XG4gICAgICAgICAgICBkdHMgPSBuZXh0RHRzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBuZXh0IEFWQyBzYW1wbGUgRFRTIHNob3VsZCBiZSBlcXVhbCB0byBsYXN0IHNhbXBsZSBEVFMgKyBsYXN0IHNhbXBsZSBkdXJhdGlvbiAoaW4gUEVTIHRpbWVzY2FsZSlcbiAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IHN0cmV0Y2hlZExhc3RGcmFtZSB8fCAhbXA0U2FtcGxlRHVyYXRpb24gPyBhdmVyYWdlU2FtcGxlRHVyYXRpb24gOiBtcDRTYW1wbGVEdXJhdGlvbjtcbiAgICB0aGlzLm5leHRBdmNEdHMgPSBuZXh0QXZjRHRzID0gbGFzdERUUyArIG1wNFNhbXBsZUR1cmF0aW9uO1xuICAgIHRoaXMudmlkZW9TYW1wbGVEdXJhdGlvbiA9IG1wNFNhbXBsZUR1cmF0aW9uO1xuICAgIHRoaXMuaXNWaWRlb0NvbnRpZ3VvdXMgPSB0cnVlO1xuICAgIGNvbnN0IG1vb2YgPSBNUDQubW9vZih0cmFjay5zZXF1ZW5jZU51bWJlcisrLCBmaXJzdERUUywgX2V4dGVuZHMoe30sIHRyYWNrLCB7XG4gICAgICBzYW1wbGVzOiBvdXRwdXRTYW1wbGVzXG4gICAgfSkpO1xuICAgIGNvbnN0IHR5cGUgPSAndmlkZW8nO1xuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICBkYXRhMTogbW9vZixcbiAgICAgIGRhdGEyOiBtZGF0LFxuICAgICAgc3RhcnRQVFM6IG1pblBUUyAvIHRpbWVTY2FsZSxcbiAgICAgIGVuZFBUUzogKG1heFBUUyArIG1wNFNhbXBsZUR1cmF0aW9uKSAvIHRpbWVTY2FsZSxcbiAgICAgIHN0YXJ0RFRTOiBmaXJzdERUUyAvIHRpbWVTY2FsZSxcbiAgICAgIGVuZERUUzogbmV4dEF2Y0R0cyAvIHRpbWVTY2FsZSxcbiAgICAgIHR5cGUsXG4gICAgICBoYXNBdWRpbzogZmFsc2UsXG4gICAgICBoYXNWaWRlbzogdHJ1ZSxcbiAgICAgIG5iOiBvdXRwdXRTYW1wbGVzLmxlbmd0aCxcbiAgICAgIGRyb3BwZWQ6IHRyYWNrLmRyb3BwZWRcbiAgICB9O1xuICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgICB0cmFjay5kcm9wcGVkID0gMDtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBnZXRTYW1wbGVzUGVyRnJhbWUodHJhY2spIHtcbiAgICBzd2l0Y2ggKHRyYWNrLnNlZ21lbnRDb2RlYykge1xuICAgICAgY2FzZSAnbXAzJzpcbiAgICAgICAgcmV0dXJuIE1QRUdfQVVESU9fU0FNUExFX1BFUl9GUkFNRTtcbiAgICAgIGNhc2UgJ2FjMyc6XG4gICAgICAgIHJldHVybiBBQzNfU0FNUExFU19QRVJfRlJBTUU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gQUFDX1NBTVBMRVNfUEVSX0ZSQU1FO1xuICAgIH1cbiAgfVxuICByZW11eEF1ZGlvKHRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIHZpZGVvVGltZU9mZnNldCkge1xuICAgIGNvbnN0IGlucHV0VGltZVNjYWxlID0gdHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgY29uc3QgbXA0dGltZVNjYWxlID0gdHJhY2suc2FtcGxlcmF0ZSA/IHRyYWNrLnNhbXBsZXJhdGUgOiBpbnB1dFRpbWVTY2FsZTtcbiAgICBjb25zdCBzY2FsZUZhY3RvciA9IGlucHV0VGltZVNjYWxlIC8gbXA0dGltZVNjYWxlO1xuICAgIGNvbnN0IG1wNFNhbXBsZUR1cmF0aW9uID0gdGhpcy5nZXRTYW1wbGVzUGVyRnJhbWUodHJhY2spO1xuICAgIGNvbnN0IGlucHV0U2FtcGxlRHVyYXRpb24gPSBtcDRTYW1wbGVEdXJhdGlvbiAqIHNjYWxlRmFjdG9yO1xuICAgIGNvbnN0IGluaXRQVFMgPSB0aGlzLl9pbml0UFRTO1xuICAgIGNvbnN0IHJhd01QRUcgPSB0cmFjay5zZWdtZW50Q29kZWMgPT09ICdtcDMnICYmIHRoaXMudHlwZVN1cHBvcnRlZC5tcGVnO1xuICAgIGNvbnN0IG91dHB1dFNhbXBsZXMgPSBbXTtcbiAgICBjb25zdCBhbGlnbmVkV2l0aFZpZGVvID0gdmlkZW9UaW1lT2Zmc2V0ICE9PSB1bmRlZmluZWQ7XG4gICAgbGV0IGlucHV0U2FtcGxlcyA9IHRyYWNrLnNhbXBsZXM7XG4gICAgbGV0IG9mZnNldCA9IHJhd01QRUcgPyAwIDogODtcbiAgICBsZXQgbmV4dEF1ZGlvUHRzID0gdGhpcy5uZXh0QXVkaW9QdHMgfHwgLTE7XG5cbiAgICAvLyB3aW5kb3cuYXVkaW9TYW1wbGVzID8gd2luZG93LmF1ZGlvU2FtcGxlcy5wdXNoKGlucHV0U2FtcGxlcy5tYXAocyA9PiBzLnB0cykpIDogKHdpbmRvdy5hdWRpb1NhbXBsZXMgPSBbaW5wdXRTYW1wbGVzLm1hcChzID0+IHMucHRzKV0pO1xuXG4gICAgLy8gZm9yIGF1ZGlvIHNhbXBsZXMsIGFsc28gY29uc2lkZXIgY29uc2VjdXRpdmUgZnJhZ21lbnRzIGFzIGJlaW5nIGNvbnRpZ3VvdXMgKGV2ZW4gaWYgYSBsZXZlbCBzd2l0Y2ggb2NjdXJzKSxcbiAgICAvLyBmb3Igc2FrZSBvZiBjbGFyaXR5OlxuICAgIC8vIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBhcmUgZnJhZ3Mgd2l0aFxuICAgIC8vICAtIGxlc3MgdGhhbiAxMDBtcyBnYXBzIGJldHdlZW4gbmV3IHRpbWUgb2Zmc2V0IChpZiBhY2N1cmF0ZSkgYW5kIG5leHQgZXhwZWN0ZWQgUFRTIE9SXG4gICAgLy8gIC0gbGVzcyB0aGFuIDIwIGF1ZGlvIGZyYW1lcyBkaXN0YW5jZVxuICAgIC8vIGNvbnRpZ3VvdXMgZnJhZ21lbnRzIGFyZSBjb25zZWN1dGl2ZSBmcmFnbWVudHMgZnJvbSBzYW1lIHF1YWxpdHkgbGV2ZWwgKHNhbWUgbGV2ZWwsIG5ldyBTTiA9IG9sZCBTTiArIDEpXG4gICAgLy8gdGhpcyBoZWxwcyBlbnN1cmluZyBhdWRpbyBjb250aW51aXR5XG4gICAgLy8gYW5kIHRoaXMgYWxzbyBhdm9pZHMgYXVkaW8gZ2xpdGNoZXMvY3V0IHdoZW4gc3dpdGNoaW5nIHF1YWxpdHksIG9yIHJlcG9ydGluZyB3cm9uZyBkdXJhdGlvbiBvbiBmaXJzdCBhdWRpbyBmcmFtZVxuICAgIGNvbnN0IHRpbWVPZmZzZXRNcGVnVFMgPSB0aW1lT2Zmc2V0ICogaW5wdXRUaW1lU2NhbGU7XG4gICAgY29uc3QgaW5pdFRpbWUgPSBpbml0UFRTLmJhc2VUaW1lICogaW5wdXRUaW1lU2NhbGUgLyBpbml0UFRTLnRpbWVzY2FsZTtcbiAgICB0aGlzLmlzQXVkaW9Db250aWd1b3VzID0gY29udGlndW91cyA9IGNvbnRpZ3VvdXMgfHwgaW5wdXRTYW1wbGVzLmxlbmd0aCAmJiBuZXh0QXVkaW9QdHMgPiAwICYmIChhY2N1cmF0ZVRpbWVPZmZzZXQgJiYgTWF0aC5hYnModGltZU9mZnNldE1wZWdUUyAtIG5leHRBdWRpb1B0cykgPCA5MDAwIHx8IE1hdGguYWJzKG5vcm1hbGl6ZVB0cyhpbnB1dFNhbXBsZXNbMF0ucHRzIC0gaW5pdFRpbWUsIHRpbWVPZmZzZXRNcGVnVFMpIC0gbmV4dEF1ZGlvUHRzKSA8IDIwICogaW5wdXRTYW1wbGVEdXJhdGlvbik7XG5cbiAgICAvLyBjb21wdXRlIG5vcm1hbGl6ZWQgUFRTXG4gICAgaW5wdXRTYW1wbGVzLmZvckVhY2goZnVuY3Rpb24gKHNhbXBsZSkge1xuICAgICAgc2FtcGxlLnB0cyA9IG5vcm1hbGl6ZVB0cyhzYW1wbGUucHRzIC0gaW5pdFRpbWUsIHRpbWVPZmZzZXRNcGVnVFMpO1xuICAgIH0pO1xuICAgIGlmICghY29udGlndW91cyB8fCBuZXh0QXVkaW9QdHMgPCAwKSB7XG4gICAgICAvLyBmaWx0ZXIgb3V0IHNhbXBsZSB3aXRoIG5lZ2F0aXZlIFBUUyB0aGF0IGFyZSBub3QgcGxheWFibGUgYW55d2F5XG4gICAgICAvLyBpZiB3ZSBkb24ndCByZW1vdmUgdGhlc2UgbmVnYXRpdmUgc2FtcGxlcywgdGhleSB3aWxsIHNoaWZ0IGFsbCBhdWRpbyBzYW1wbGVzIGZvcndhcmQuXG4gICAgICAvLyBsZWFkaW5nIHRvIGF1ZGlvIG92ZXJsYXAgYmV0d2VlbiBjdXJyZW50IC8gbmV4dCBmcmFnbWVudFxuICAgICAgaW5wdXRTYW1wbGVzID0gaW5wdXRTYW1wbGVzLmZpbHRlcihzYW1wbGUgPT4gc2FtcGxlLnB0cyA+PSAwKTtcblxuICAgICAgLy8gaW4gY2FzZSBhbGwgc2FtcGxlcyBoYXZlIG5lZ2F0aXZlIFBUUywgYW5kIGhhdmUgYmVlbiBmaWx0ZXJlZCBvdXQsIHJldHVybiBub3dcbiAgICAgIGlmICghaW5wdXRTYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodmlkZW9UaW1lT2Zmc2V0ID09PSAwKSB7XG4gICAgICAgIC8vIFNldCB0aGUgc3RhcnQgdG8gMCB0byBtYXRjaCB2aWRlbyBzbyB0aGF0IHN0YXJ0IGdhcHMgbGFyZ2VyIHRoYW4gaW5wdXRTYW1wbGVEdXJhdGlvbiBhcmUgZmlsbGVkIHdpdGggc2lsZW5jZVxuICAgICAgICBuZXh0QXVkaW9QdHMgPSAwO1xuICAgICAgfSBlbHNlIGlmIChhY2N1cmF0ZVRpbWVPZmZzZXQgJiYgIWFsaWduZWRXaXRoVmlkZW8pIHtcbiAgICAgICAgLy8gV2hlbiBub3Qgc2Vla2luZywgbm90IGxpdmUsIGFuZCBMZXZlbERldGFpbHMuUFRTS25vd24sIHVzZSBmcmFnbWVudCBzdGFydCBhcyBwcmVkaWN0ZWQgbmV4dCBhdWRpbyBQVFNcbiAgICAgICAgbmV4dEF1ZGlvUHRzID0gTWF0aC5tYXgoMCwgdGltZU9mZnNldE1wZWdUUyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiBmcmFncyBhcmUgbm90IGNvbnRpZ3VvdXMgYW5kIGlmIHdlIGNhbnQgdHJ1c3QgdGltZSBvZmZzZXQsIGxldCdzIHVzZSBmaXJzdCBzYW1wbGUgUFRTIGFzIG5leHQgYXVkaW8gUFRTXG4gICAgICAgIG5leHRBdWRpb1B0cyA9IGlucHV0U2FtcGxlc1swXS5wdHM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGF1ZGlvIHRyYWNrIGlzIG1pc3Npbmcgc2FtcGxlcywgdGhlIGZyYW1lcyBzZWVtIHRvIGdldCBcImxlZnQtc2hpZnRlZFwiIHdpdGhpbiB0aGVcbiAgICAvLyByZXN1bHRpbmcgbXA0IHNlZ21lbnQsIGNhdXNpbmcgc3luYyBpc3N1ZXMgYW5kIGxlYXZpbmcgZ2FwcyBhdCB0aGUgZW5kIG9mIHRoZSBhdWRpbyBzZWdtZW50LlxuICAgIC8vIEluIGFuIGVmZm9ydCB0byBwcmV2ZW50IHRoaXMgZnJvbSBoYXBwZW5pbmcsIHdlIGluamVjdCBmcmFtZXMgaGVyZSB3aGVyZSB0aGVyZSBhcmUgZ2Fwcy5cbiAgICAvLyBXaGVuIHBvc3NpYmxlLCB3ZSBpbmplY3QgYSBzaWxlbnQgZnJhbWU7IHdoZW4gdGhhdCdzIG5vdCBwb3NzaWJsZSwgd2UgZHVwbGljYXRlIHRoZSBsYXN0XG4gICAgLy8gZnJhbWUuXG5cbiAgICBpZiAodHJhY2suc2VnbWVudENvZGVjID09PSAnYWFjJykge1xuICAgICAgY29uc3QgbWF4QXVkaW9GcmFtZXNEcmlmdCA9IHRoaXMuY29uZmlnLm1heEF1ZGlvRnJhbWVzRHJpZnQ7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbmV4dFB0cyA9IG5leHRBdWRpb1B0czsgaSA8IGlucHV0U2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBGaXJzdCwgbGV0J3Mgc2VlIGhvdyBmYXIgb2ZmIHRoaXMgZnJhbWUgaXMgZnJvbSB3aGVyZSB3ZSBleHBlY3QgaXQgdG8gYmVcbiAgICAgICAgY29uc3Qgc2FtcGxlID0gaW5wdXRTYW1wbGVzW2ldO1xuICAgICAgICBjb25zdCBwdHMgPSBzYW1wbGUucHRzO1xuICAgICAgICBjb25zdCBkZWx0YSA9IHB0cyAtIG5leHRQdHM7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gTWF0aC5hYnMoMTAwMCAqIGRlbHRhIC8gaW5wdXRUaW1lU2NhbGUpO1xuXG4gICAgICAgIC8vIFdoZW4gcmVtdXhpbmcgd2l0aCB2aWRlbywgaWYgd2UncmUgb3ZlcmxhcHBpbmcgYnkgbW9yZSB0aGFuIGEgZHVyYXRpb24sIGRyb3AgdGhpcyBzYW1wbGUgdG8gc3RheSBpbiBzeW5jXG4gICAgICAgIGlmIChkZWx0YSA8PSAtbWF4QXVkaW9GcmFtZXNEcmlmdCAqIGlucHV0U2FtcGxlRHVyYXRpb24gJiYgYWxpZ25lZFdpdGhWaWRlbykge1xuICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihgQXVkaW8gZnJhbWUgQCAkeyhwdHMgLyBpbnB1dFRpbWVTY2FsZSkudG9GaXhlZCgzKX1zIG92ZXJsYXBzIG5leHRBdWRpb1B0cyBieSAke01hdGgucm91bmQoMTAwMCAqIGRlbHRhIC8gaW5wdXRUaW1lU2NhbGUpfSBtcy5gKTtcbiAgICAgICAgICAgIHRoaXMubmV4dEF1ZGlvUHRzID0gbmV4dEF1ZGlvUHRzID0gbmV4dFB0cyA9IHB0cztcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBicmFjZS1zdHlsZVxuXG4gICAgICAgIC8vIEluc2VydCBtaXNzaW5nIGZyYW1lcyBpZjpcbiAgICAgICAgLy8gMTogV2UncmUgbW9yZSB0aGFuIG1heEF1ZGlvRnJhbWVzRHJpZnQgZnJhbWUgYXdheVxuICAgICAgICAvLyAyOiBOb3QgbW9yZSB0aGFuIE1BWF9TSUxFTlRfRlJBTUVfRFVSQVRJT04gYXdheVxuICAgICAgICAvLyAzOiBjdXJyZW50VGltZSAoYWthIG5leHRQdHNOb3JtKSBpcyBub3QgMFxuICAgICAgICAvLyA0OiByZW11eGluZyB3aXRoIHZpZGVvICh2aWRlb1RpbWVPZmZzZXQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgZWxzZSBpZiAoZGVsdGEgPj0gbWF4QXVkaW9GcmFtZXNEcmlmdCAqIGlucHV0U2FtcGxlRHVyYXRpb24gJiYgZHVyYXRpb24gPCBNQVhfU0lMRU5UX0ZSQU1FX0RVUkFUSU9OICYmIGFsaWduZWRXaXRoVmlkZW8pIHtcbiAgICAgICAgICBsZXQgbWlzc2luZyA9IE1hdGgucm91bmQoZGVsdGEgLyBpbnB1dFNhbXBsZUR1cmF0aW9uKTtcbiAgICAgICAgICAvLyBBZGp1c3QgbmV4dFB0cyBzbyB0aGF0IHNpbGVudCBzYW1wbGVzIGFyZSBhbGlnbmVkIHdpdGggbWVkaWEgcHRzLiBUaGlzIHdpbGwgcHJldmVudCBtZWRpYSBzYW1wbGVzIGZyb21cbiAgICAgICAgICAvLyBsYXRlciBiZWluZyBzaGlmdGVkIGlmIG5leHRQdHMgaXMgYmFzZWQgb24gdGltZU9mZnNldCBhbmQgZGVsdGEgaXMgbm90IGEgbXVsdGlwbGUgb2YgaW5wdXRTYW1wbGVEdXJhdGlvbi5cbiAgICAgICAgICBuZXh0UHRzID0gcHRzIC0gbWlzc2luZyAqIGlucHV0U2FtcGxlRHVyYXRpb247XG4gICAgICAgICAgaWYgKG5leHRQdHMgPCAwKSB7XG4gICAgICAgICAgICBtaXNzaW5nLS07XG4gICAgICAgICAgICBuZXh0UHRzICs9IGlucHV0U2FtcGxlRHVyYXRpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLm5leHRBdWRpb1B0cyA9IG5leHRBdWRpb1B0cyA9IG5leHRQdHM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvZ2dlci53YXJuKGBbbXA0LXJlbXV4ZXJdOiBJbmplY3RpbmcgJHttaXNzaW5nfSBhdWRpbyBmcmFtZSBAICR7KG5leHRQdHMgLyBpbnB1dFRpbWVTY2FsZSkudG9GaXhlZCgzKX1zIGR1ZSB0byAke01hdGgucm91bmQoMTAwMCAqIGRlbHRhIC8gaW5wdXRUaW1lU2NhbGUpfSBtcyBnYXAuYCk7XG4gICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtaXNzaW5nOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1N0YW1wID0gTWF0aC5tYXgobmV4dFB0cywgMCk7XG4gICAgICAgICAgICBsZXQgZmlsbEZyYW1lID0gQUFDLmdldFNpbGVudEZyYW1lKHRyYWNrLm1hbmlmZXN0Q29kZWMgfHwgdHJhY2suY29kZWMsIHRyYWNrLmNoYW5uZWxDb3VudCk7XG4gICAgICAgICAgICBpZiAoIWZpbGxGcmFtZSkge1xuICAgICAgICAgICAgICBsb2dnZXIubG9nKCdbbXA0LXJlbXV4ZXJdOiBVbmFibGUgdG8gZ2V0IHNpbGVudCBmcmFtZSBmb3IgZ2l2ZW4gYXVkaW8gY29kZWM7IGR1cGxpY2F0aW5nIGxhc3QgZnJhbWUgaW5zdGVhZC4nKTtcbiAgICAgICAgICAgICAgZmlsbEZyYW1lID0gc2FtcGxlLnVuaXQuc3ViYXJyYXkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlucHV0U2FtcGxlcy5zcGxpY2UoaSwgMCwge1xuICAgICAgICAgICAgICB1bml0OiBmaWxsRnJhbWUsXG4gICAgICAgICAgICAgIHB0czogbmV3U3RhbXBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmV4dFB0cyArPSBpbnB1dFNhbXBsZUR1cmF0aW9uO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzYW1wbGUucHRzID0gbmV4dFB0cztcbiAgICAgICAgbmV4dFB0cyArPSBpbnB1dFNhbXBsZUR1cmF0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgZmlyc3RQVFMgPSBudWxsO1xuICAgIGxldCBsYXN0UFRTID0gbnVsbDtcbiAgICBsZXQgbWRhdDtcbiAgICBsZXQgbWRhdFNpemUgPSAwO1xuICAgIGxldCBzYW1wbGVMZW5ndGggPSBpbnB1dFNhbXBsZXMubGVuZ3RoO1xuICAgIHdoaWxlIChzYW1wbGVMZW5ndGgtLSkge1xuICAgICAgbWRhdFNpemUgKz0gaW5wdXRTYW1wbGVzW3NhbXBsZUxlbmd0aF0udW5pdC5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gMCwgX25iU2FtcGxlcyA9IGlucHV0U2FtcGxlcy5sZW5ndGg7IGogPCBfbmJTYW1wbGVzOyBqKyspIHtcbiAgICAgIGNvbnN0IGF1ZGlvU2FtcGxlID0gaW5wdXRTYW1wbGVzW2pdO1xuICAgICAgY29uc3QgdW5pdCA9IGF1ZGlvU2FtcGxlLnVuaXQ7XG4gICAgICBsZXQgcHRzID0gYXVkaW9TYW1wbGUucHRzO1xuICAgICAgaWYgKGxhc3RQVFMgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBtb3JlIHRoYW4gb25lIHNhbXBsZSwgc2V0IHRoZSBkdXJhdGlvbiBvZiB0aGUgc2FtcGxlIHRvIHRoZSBcInJlYWxcIiBkdXJhdGlvbjsgdGhlIFBUUyBkaWZmIHdpdGhcbiAgICAgICAgLy8gdGhlIHByZXZpb3VzIHNhbXBsZVxuICAgICAgICBjb25zdCBwcmV2U2FtcGxlID0gb3V0cHV0U2FtcGxlc1tqIC0gMV07XG4gICAgICAgIHByZXZTYW1wbGUuZHVyYXRpb24gPSBNYXRoLnJvdW5kKChwdHMgLSBsYXN0UFRTKSAvIHNjYWxlRmFjdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjb250aWd1b3VzICYmIHRyYWNrLnNlZ21lbnRDb2RlYyA9PT0gJ2FhYycpIHtcbiAgICAgICAgICAvLyBzZXQgUFRTL0RUUyB0byBleHBlY3RlZCBQVFMvRFRTXG4gICAgICAgICAgcHRzID0gbmV4dEF1ZGlvUHRzO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlbWVtYmVyIGZpcnN0IFBUUyBvZiBvdXIgYXVkaW9TYW1wbGVzXG4gICAgICAgIGZpcnN0UFRTID0gcHRzO1xuICAgICAgICBpZiAobWRhdFNpemUgPiAwKSB7XG4gICAgICAgICAgLyogY29uY2F0ZW5hdGUgdGhlIGF1ZGlvIGRhdGEgYW5kIGNvbnN0cnVjdCB0aGUgbWRhdCBpbiBwbGFjZVxuICAgICAgICAgICAgKG5lZWQgOCBtb3JlIGJ5dGVzIHRvIGZpbGwgbGVuZ3RoIGFuZCBtZGF0IHR5cGUpICovXG4gICAgICAgICAgbWRhdFNpemUgKz0gb2Zmc2V0O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtZGF0ID0gbmV3IFVpbnQ4QXJyYXkobWRhdFNpemUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5lbWl0KEV2ZW50cy5FUlJPUiwgRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTVVYX0VSUk9SLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuUkVNVVhfQUxMT0NfRVJST1IsXG4gICAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgZXJyb3I6IGVycixcbiAgICAgICAgICAgICAgYnl0ZXM6IG1kYXRTaXplLFxuICAgICAgICAgICAgICByZWFzb246IGBmYWlsIGFsbG9jYXRpbmcgYXVkaW8gbWRhdCAke21kYXRTaXplfWBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJhd01QRUcpIHtcbiAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcobWRhdC5idWZmZXIpO1xuICAgICAgICAgICAgdmlldy5zZXRVaW50MzIoMCwgbWRhdFNpemUpO1xuICAgICAgICAgICAgbWRhdC5zZXQoTVA0LnR5cGVzLm1kYXQsIDQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBubyBhdWRpbyBzYW1wbGVzXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtZGF0LnNldCh1bml0LCBvZmZzZXQpO1xuICAgICAgY29uc3QgdW5pdExlbiA9IHVuaXQuYnl0ZUxlbmd0aDtcbiAgICAgIG9mZnNldCArPSB1bml0TGVuO1xuICAgICAgLy8gRGVmYXVsdCB0aGUgc2FtcGxlJ3MgZHVyYXRpb24gdG8gdGhlIGNvbXB1dGVkIG1wNFNhbXBsZUR1cmF0aW9uLCB3aGljaCB3aWxsIGVpdGhlciBiZSAxMDI0IGZvciBBQUMgb3IgMTE1MiBmb3IgTVBFR1xuICAgICAgLy8gSW4gdGhlIGNhc2UgdGhhdCB3ZSBoYXZlIDEgc2FtcGxlLCB0aGlzIHdpbGwgYmUgdGhlIGR1cmF0aW9uLiBJZiB3ZSBoYXZlIG1vcmUgdGhhbiBvbmUgc2FtcGxlLCB0aGUgZHVyYXRpb25cbiAgICAgIC8vIGJlY29tZXMgdGhlIFBUUyBkaWZmIHdpdGggdGhlIHByZXZpb3VzIHNhbXBsZVxuICAgICAgb3V0cHV0U2FtcGxlcy5wdXNoKG5ldyBNcDRTYW1wbGUodHJ1ZSwgbXA0U2FtcGxlRHVyYXRpb24sIHVuaXRMZW4sIDApKTtcbiAgICAgIGxhc3RQVFMgPSBwdHM7XG4gICAgfVxuXG4gICAgLy8gV2UgY291bGQgZW5kIHVwIHdpdGggbm8gYXVkaW8gc2FtcGxlcyBpZiBhbGwgaW5wdXQgc2FtcGxlcyB3ZXJlIG92ZXJsYXBwaW5nIHdpdGggdGhlIHByZXZpb3VzbHkgcmVtdXhlZCBvbmVzXG4gICAgY29uc3QgbmJTYW1wbGVzID0gb3V0cHV0U2FtcGxlcy5sZW5ndGg7XG4gICAgaWYgKCFuYlNhbXBsZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUaGUgbmV4dCBhdWRpbyBzYW1wbGUgUFRTIHNob3VsZCBiZSBlcXVhbCB0byBsYXN0IHNhbXBsZSBQVFMgKyBkdXJhdGlvblxuICAgIGNvbnN0IGxhc3RTYW1wbGUgPSBvdXRwdXRTYW1wbGVzW291dHB1dFNhbXBsZXMubGVuZ3RoIC0gMV07XG4gICAgdGhpcy5uZXh0QXVkaW9QdHMgPSBuZXh0QXVkaW9QdHMgPSBsYXN0UFRTICsgc2NhbGVGYWN0b3IgKiBsYXN0U2FtcGxlLmR1cmF0aW9uO1xuXG4gICAgLy8gU2V0IHRoZSB0cmFjayBzYW1wbGVzIGZyb20gaW5wdXRTYW1wbGVzIHRvIG91dHB1dFNhbXBsZXMgYmVmb3JlIHJlbXV4aW5nXG4gICAgY29uc3QgbW9vZiA9IHJhd01QRUcgPyBuZXcgVWludDhBcnJheSgwKSA6IE1QNC5tb29mKHRyYWNrLnNlcXVlbmNlTnVtYmVyKyssIGZpcnN0UFRTIC8gc2NhbGVGYWN0b3IsIF9leHRlbmRzKHt9LCB0cmFjaywge1xuICAgICAgc2FtcGxlczogb3V0cHV0U2FtcGxlc1xuICAgIH0pKTtcblxuICAgIC8vIENsZWFyIHRoZSB0cmFjayBzYW1wbGVzLiBUaGlzIGFsc28gY2xlYXJzIHRoZSBzYW1wbGVzIGFycmF5IGluIHRoZSBkZW11eGVyLCBzaW5jZSB0aGUgcmVmZXJlbmNlIGlzIHNoYXJlZFxuICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgICBjb25zdCBzdGFydCA9IGZpcnN0UFRTIC8gaW5wdXRUaW1lU2NhbGU7XG4gICAgY29uc3QgZW5kID0gbmV4dEF1ZGlvUHRzIC8gaW5wdXRUaW1lU2NhbGU7XG4gICAgY29uc3QgdHlwZSA9ICdhdWRpbyc7XG4gICAgY29uc3QgYXVkaW9EYXRhID0ge1xuICAgICAgZGF0YTE6IG1vb2YsXG4gICAgICBkYXRhMjogbWRhdCxcbiAgICAgIHN0YXJ0UFRTOiBzdGFydCxcbiAgICAgIGVuZFBUUzogZW5kLFxuICAgICAgc3RhcnREVFM6IHN0YXJ0LFxuICAgICAgZW5kRFRTOiBlbmQsXG4gICAgICB0eXBlLFxuICAgICAgaGFzQXVkaW86IHRydWUsXG4gICAgICBoYXNWaWRlbzogZmFsc2UsXG4gICAgICBuYjogbmJTYW1wbGVzXG4gICAgfTtcbiAgICB0aGlzLmlzQXVkaW9Db250aWd1b3VzID0gdHJ1ZTtcbiAgICByZXR1cm4gYXVkaW9EYXRhO1xuICB9XG4gIHJlbXV4RW1wdHlBdWRpbyh0cmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgdmlkZW9EYXRhKSB7XG4gICAgY29uc3QgaW5wdXRUaW1lU2NhbGUgPSB0cmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICBjb25zdCBtcDR0aW1lU2NhbGUgPSB0cmFjay5zYW1wbGVyYXRlID8gdHJhY2suc2FtcGxlcmF0ZSA6IGlucHV0VGltZVNjYWxlO1xuICAgIGNvbnN0IHNjYWxlRmFjdG9yID0gaW5wdXRUaW1lU2NhbGUgLyBtcDR0aW1lU2NhbGU7XG4gICAgY29uc3QgbmV4dEF1ZGlvUHRzID0gdGhpcy5uZXh0QXVkaW9QdHM7XG4gICAgLy8gc3luYyB3aXRoIHZpZGVvJ3MgdGltZXN0YW1wXG4gICAgY29uc3QgaW5pdERUUyA9IHRoaXMuX2luaXREVFM7XG4gICAgY29uc3QgaW5pdDkwa0h6ID0gaW5pdERUUy5iYXNlVGltZSAqIDkwMDAwIC8gaW5pdERUUy50aW1lc2NhbGU7XG4gICAgY29uc3Qgc3RhcnREVFMgPSAobmV4dEF1ZGlvUHRzICE9PSBudWxsID8gbmV4dEF1ZGlvUHRzIDogdmlkZW9EYXRhLnN0YXJ0RFRTICogaW5wdXRUaW1lU2NhbGUpICsgaW5pdDkwa0h6O1xuICAgIGNvbnN0IGVuZERUUyA9IHZpZGVvRGF0YS5lbmREVFMgKiBpbnB1dFRpbWVTY2FsZSArIGluaXQ5MGtIejtcbiAgICAvLyBvbmUgc2FtcGxlJ3MgZHVyYXRpb24gdmFsdWVcbiAgICBjb25zdCBmcmFtZUR1cmF0aW9uID0gc2NhbGVGYWN0b3IgKiBBQUNfU0FNUExFU19QRVJfRlJBTUU7XG4gICAgLy8gc2FtcGxlcyBjb3VudCBvZiB0aGlzIHNlZ21lbnQncyBkdXJhdGlvblxuICAgIGNvbnN0IG5iU2FtcGxlcyA9IE1hdGguY2VpbCgoZW5kRFRTIC0gc3RhcnREVFMpIC8gZnJhbWVEdXJhdGlvbik7XG4gICAgLy8gc2lsZW50IGZyYW1lXG4gICAgY29uc3Qgc2lsZW50RnJhbWUgPSBBQUMuZ2V0U2lsZW50RnJhbWUodHJhY2subWFuaWZlc3RDb2RlYyB8fCB0cmFjay5jb2RlYywgdHJhY2suY2hhbm5lbENvdW50KTtcbiAgICBsb2dnZXIud2FybignW21wNC1yZW11eGVyXTogcmVtdXggZW1wdHkgQXVkaW8nKTtcbiAgICAvLyBDYW4ndCByZW11eCBpZiB3ZSBjYW4ndCBnZW5lcmF0ZSBhIHNpbGVudCBmcmFtZS4uLlxuICAgIGlmICghc2lsZW50RnJhbWUpIHtcbiAgICAgIGxvZ2dlci50cmFjZSgnW21wNC1yZW11eGVyXTogVW5hYmxlIHRvIHJlbXV4RW1wdHlBdWRpbyBzaW5jZSB3ZSB3ZXJlIHVuYWJsZSB0byBnZXQgYSBzaWxlbnQgZnJhbWUgZm9yIGdpdmVuIGF1ZGlvIGNvZGVjJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNhbXBsZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5iU2FtcGxlczsgaSsrKSB7XG4gICAgICBjb25zdCBzdGFtcCA9IHN0YXJ0RFRTICsgaSAqIGZyYW1lRHVyYXRpb247XG4gICAgICBzYW1wbGVzLnB1c2goe1xuICAgICAgICB1bml0OiBzaWxlbnRGcmFtZSxcbiAgICAgICAgcHRzOiBzdGFtcCxcbiAgICAgICAgZHRzOiBzdGFtcFxuICAgICAgfSk7XG4gICAgfVxuICAgIHRyYWNrLnNhbXBsZXMgPSBzYW1wbGVzO1xuICAgIHJldHVybiB0aGlzLnJlbXV4QXVkaW8odHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGZhbHNlKTtcbiAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplUHRzKHZhbHVlLCByZWZlcmVuY2UpIHtcbiAgbGV0IG9mZnNldDtcbiAgaWYgKHJlZmVyZW5jZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAocmVmZXJlbmNlIDwgdmFsdWUpIHtcbiAgICAvLyAtIDJeMzNcbiAgICBvZmZzZXQgPSAtODU4OTkzNDU5MjtcbiAgfSBlbHNlIHtcbiAgICAvLyArIDJeMzNcbiAgICBvZmZzZXQgPSA4NTg5OTM0NTkyO1xuICB9XG4gIC8qIFBUUyBpcyAzM2JpdCAoZnJvbSAwIHRvIDJeMzMgLTEpXG4gICAgaWYgZGlmZiBiZXR3ZWVuIHZhbHVlIGFuZCByZWZlcmVuY2UgaXMgYmlnZ2VyIHRoYW4gaGFsZiBvZiB0aGUgYW1wbGl0dWRlICgyXjMyKSB0aGVuIGl0IG1lYW5zIHRoYXRcbiAgICBQVFMgbG9vcGluZyBvY2N1cmVkLiBmaWxsIHRoZSBnYXAgKi9cbiAgd2hpbGUgKE1hdGguYWJzKHZhbHVlIC0gcmVmZXJlbmNlKSA+IDQyOTQ5NjcyOTYpIHtcbiAgICB2YWx1ZSArPSBvZmZzZXQ7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZmluZEtleWZyYW1lSW5kZXgoc2FtcGxlcykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc2FtcGxlc1tpXS5rZXkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiBmbHVzaFRleHRUcmFja01ldGFkYXRhQ3VlU2FtcGxlcyh0cmFjaywgdGltZU9mZnNldCwgaW5pdFBUUywgaW5pdERUUykge1xuICBjb25zdCBsZW5ndGggPSB0cmFjay5zYW1wbGVzLmxlbmd0aDtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaW5wdXRUaW1lU2NhbGUgPSB0cmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNvbnN0IHNhbXBsZSA9IHRyYWNrLnNhbXBsZXNbaW5kZXhdO1xuICAgIC8vIHNldHRpbmcgaWQzIHB0cywgZHRzIHRvIHJlbGF0aXZlIHRpbWVcbiAgICAvLyB1c2luZyB0aGlzLl9pbml0UFRTIGFuZCB0aGlzLl9pbml0RFRTIHRvIGNhbGN1bGF0ZSByZWxhdGl2ZSB0aW1lXG4gICAgc2FtcGxlLnB0cyA9IG5vcm1hbGl6ZVB0cyhzYW1wbGUucHRzIC0gaW5pdFBUUy5iYXNlVGltZSAqIGlucHV0VGltZVNjYWxlIC8gaW5pdFBUUy50aW1lc2NhbGUsIHRpbWVPZmZzZXQgKiBpbnB1dFRpbWVTY2FsZSkgLyBpbnB1dFRpbWVTY2FsZTtcbiAgICBzYW1wbGUuZHRzID0gbm9ybWFsaXplUHRzKHNhbXBsZS5kdHMgLSBpbml0RFRTLmJhc2VUaW1lICogaW5wdXRUaW1lU2NhbGUgLyBpbml0RFRTLnRpbWVzY2FsZSwgdGltZU9mZnNldCAqIGlucHV0VGltZVNjYWxlKSAvIGlucHV0VGltZVNjYWxlO1xuICB9XG4gIGNvbnN0IHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzO1xuICB0cmFjay5zYW1wbGVzID0gW107XG4gIHJldHVybiB7XG4gICAgc2FtcGxlc1xuICB9O1xufVxuZnVuY3Rpb24gZmx1c2hUZXh0VHJhY2tVc2VyZGF0YUN1ZVNhbXBsZXModHJhY2ssIHRpbWVPZmZzZXQsIGluaXRQVFMpIHtcbiAgY29uc3QgbGVuZ3RoID0gdHJhY2suc2FtcGxlcy5sZW5ndGg7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGlucHV0VGltZVNjYWxlID0gdHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBzYW1wbGUgPSB0cmFjay5zYW1wbGVzW2luZGV4XTtcbiAgICAvLyBzZXR0aW5nIHRleHQgcHRzLCBkdHMgdG8gcmVsYXRpdmUgdGltZVxuICAgIC8vIHVzaW5nIHRoaXMuX2luaXRQVFMgYW5kIHRoaXMuX2luaXREVFMgdG8gY2FsY3VsYXRlIHJlbGF0aXZlIHRpbWVcbiAgICBzYW1wbGUucHRzID0gbm9ybWFsaXplUHRzKHNhbXBsZS5wdHMgLSBpbml0UFRTLmJhc2VUaW1lICogaW5wdXRUaW1lU2NhbGUgLyBpbml0UFRTLnRpbWVzY2FsZSwgdGltZU9mZnNldCAqIGlucHV0VGltZVNjYWxlKSAvIGlucHV0VGltZVNjYWxlO1xuICB9XG4gIHRyYWNrLnNhbXBsZXMuc29ydCgoYSwgYikgPT4gYS5wdHMgLSBiLnB0cyk7XG4gIGNvbnN0IHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzO1xuICB0cmFjay5zYW1wbGVzID0gW107XG4gIHJldHVybiB7XG4gICAgc2FtcGxlc1xuICB9O1xufVxuY2xhc3MgTXA0U2FtcGxlIHtcbiAgY29uc3RydWN0b3IoaXNLZXlmcmFtZSwgZHVyYXRpb24sIHNpemUsIGN0cykge1xuICAgIHRoaXMuc2l6ZSA9IHZvaWQgMDtcbiAgICB0aGlzLmR1cmF0aW9uID0gdm9pZCAwO1xuICAgIHRoaXMuY3RzID0gdm9pZCAwO1xuICAgIHRoaXMuZmxhZ3MgPSB2b2lkIDA7XG4gICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgdGhpcy5jdHMgPSBjdHM7XG4gICAgdGhpcy5mbGFncyA9IHtcbiAgICAgIGlzTGVhZGluZzogMCxcbiAgICAgIGlzRGVwZW5kZWRPbjogMCxcbiAgICAgIGhhc1JlZHVuZGFuY3k6IDAsXG4gICAgICBkZWdyYWRQcmlvOiAwLFxuICAgICAgZGVwZW5kc09uOiBpc0tleWZyYW1lID8gMiA6IDEsXG4gICAgICBpc05vblN5bmM6IGlzS2V5ZnJhbWUgPyAwIDogMVxuICAgIH07XG4gIH1cbn1cblxuY2xhc3MgUGFzc1Rocm91Z2hSZW11eGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5lbWl0SW5pdFNlZ21lbnQgPSBmYWxzZTtcbiAgICB0aGlzLmF1ZGlvQ29kZWMgPSB2b2lkIDA7XG4gICAgdGhpcy52aWRlb0NvZGVjID0gdm9pZCAwO1xuICAgIHRoaXMuaW5pdERhdGEgPSB2b2lkIDA7XG4gICAgdGhpcy5pbml0UFRTID0gbnVsbDtcbiAgICB0aGlzLmluaXRUcmFja3MgPSB2b2lkIDA7XG4gICAgdGhpcy5sYXN0RW5kVGltZSA9IG51bGw7XG4gIH1cbiAgZGVzdHJveSgpIHt9XG4gIHJlc2V0VGltZVN0YW1wKGRlZmF1bHRJbml0UFRTKSB7XG4gICAgdGhpcy5pbml0UFRTID0gZGVmYXVsdEluaXRQVFM7XG4gICAgdGhpcy5sYXN0RW5kVGltZSA9IG51bGw7XG4gIH1cbiAgcmVzZXROZXh0VGltZXN0YW1wKCkge1xuICAgIHRoaXMubGFzdEVuZFRpbWUgPSBudWxsO1xuICB9XG4gIHJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGRlY3J5cHRkYXRhKSB7XG4gICAgdGhpcy5hdWRpb0NvZGVjID0gYXVkaW9Db2RlYztcbiAgICB0aGlzLnZpZGVvQ29kZWMgPSB2aWRlb0NvZGVjO1xuICAgIHRoaXMuZ2VuZXJhdGVJbml0U2VnbWVudChwYXRjaEVuY3lwdGlvbkRhdGEoaW5pdFNlZ21lbnQsIGRlY3J5cHRkYXRhKSk7XG4gICAgdGhpcy5lbWl0SW5pdFNlZ21lbnQgPSB0cnVlO1xuICB9XG4gIGdlbmVyYXRlSW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQpIHtcbiAgICBsZXQge1xuICAgICAgYXVkaW9Db2RlYyxcbiAgICAgIHZpZGVvQ29kZWNcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIShpbml0U2VnbWVudCAhPSBudWxsICYmIGluaXRTZWdtZW50LmJ5dGVMZW5ndGgpKSB7XG4gICAgICB0aGlzLmluaXRUcmFja3MgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmluaXREYXRhID0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbml0RGF0YSA9IHRoaXMuaW5pdERhdGEgPSBwYXJzZUluaXRTZWdtZW50KGluaXRTZWdtZW50KTtcblxuICAgIC8vIEdldCBjb2RlYyBmcm9tIGluaXRTZWdtZW50IG9yIGZhbGxiYWNrIHRvIGRlZmF1bHRcbiAgICBpZiAoaW5pdERhdGEuYXVkaW8pIHtcbiAgICAgIGF1ZGlvQ29kZWMgPSBnZXRQYXJzZWRUcmFja0NvZGVjKGluaXREYXRhLmF1ZGlvLCBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU8pO1xuICAgIH1cbiAgICBpZiAoaW5pdERhdGEudmlkZW8pIHtcbiAgICAgIHZpZGVvQ29kZWMgPSBnZXRQYXJzZWRUcmFja0NvZGVjKGluaXREYXRhLnZpZGVvLCBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU8pO1xuICAgIH1cbiAgICBjb25zdCB0cmFja3MgPSB7fTtcbiAgICBpZiAoaW5pdERhdGEuYXVkaW8gJiYgaW5pdERhdGEudmlkZW8pIHtcbiAgICAgIHRyYWNrcy5hdWRpb3ZpZGVvID0ge1xuICAgICAgICBjb250YWluZXI6ICd2aWRlby9tcDQnLFxuICAgICAgICBjb2RlYzogYXVkaW9Db2RlYyArICcsJyArIHZpZGVvQ29kZWMsXG4gICAgICAgIGluaXRTZWdtZW50LFxuICAgICAgICBpZDogJ21haW4nXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoaW5pdERhdGEuYXVkaW8pIHtcbiAgICAgIHRyYWNrcy5hdWRpbyA9IHtcbiAgICAgICAgY29udGFpbmVyOiAnYXVkaW8vbXA0JyxcbiAgICAgICAgY29kZWM6IGF1ZGlvQ29kZWMsXG4gICAgICAgIGluaXRTZWdtZW50LFxuICAgICAgICBpZDogJ2F1ZGlvJ1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGluaXREYXRhLnZpZGVvKSB7XG4gICAgICB0cmFja3MudmlkZW8gPSB7XG4gICAgICAgIGNvbnRhaW5lcjogJ3ZpZGVvL21wNCcsXG4gICAgICAgIGNvZGVjOiB2aWRlb0NvZGVjLFxuICAgICAgICBpbml0U2VnbWVudCxcbiAgICAgICAgaWQ6ICdtYWluJ1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLndhcm4oJ1twYXNzdGhyb3VnaC1yZW11eGVyLnRzXTogaW5pdFNlZ21lbnQgZG9lcyBub3QgY29udGFpbiBtb292IG9yIHRyYWsgYm94ZXMuJyk7XG4gICAgfVxuICAgIHRoaXMuaW5pdFRyYWNrcyA9IHRyYWNrcztcbiAgfVxuICByZW11eChhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcbiAgICB2YXIgX2luaXREYXRhLCBfaW5pdERhdGEyO1xuICAgIGxldCB7XG4gICAgICBpbml0UFRTLFxuICAgICAgbGFzdEVuZFRpbWVcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBhdWRpbzogdW5kZWZpbmVkLFxuICAgICAgdmlkZW86IHVuZGVmaW5lZCxcbiAgICAgIHRleHQ6IHRleHRUcmFjayxcbiAgICAgIGlkMzogaWQzVHJhY2ssXG4gICAgICBpbml0U2VnbWVudDogdW5kZWZpbmVkXG4gICAgfTtcblxuICAgIC8vIElmIHdlIGhhdmVuJ3QgeWV0IHNldCBhIGxhc3RFbmREVFMsIG9yIGl0IHdhcyByZXNldCwgc2V0IGl0IHRvIHRoZSBwcm92aWRlZCB0aW1lT2Zmc2V0LiBXZSB3YW50IHRvIHVzZSB0aGVcbiAgICAvLyBsYXN0RW5kRFRTIG92ZXIgdGltZU9mZnNldCB3aGVuZXZlciBwb3NzaWJsZTsgZHVyaW5nIHByb2dyZXNzaXZlIHBsYXliYWNrLCB0aGUgbWVkaWEgc291cmNlIHdpbGwgbm90IHVwZGF0ZVxuICAgIC8vIHRoZSBtZWRpYSBkdXJhdGlvbiAod2hpY2ggaXMgd2hhdCB0aW1lT2Zmc2V0IGlzIHByb3ZpZGVkIGFzKSBiZWZvcmUgd2UgbmVlZCB0byBwcm9jZXNzIHRoZSBuZXh0IGNodW5rLlxuICAgIGlmICghaXNGaW5pdGVOdW1iZXIobGFzdEVuZFRpbWUpKSB7XG4gICAgICBsYXN0RW5kVGltZSA9IHRoaXMubGFzdEVuZFRpbWUgPSB0aW1lT2Zmc2V0IHx8IDA7XG4gICAgfVxuXG4gICAgLy8gVGhlIGJpbmFyeSBzZWdtZW50IGRhdGEgaXMgYWRkZWQgdG8gdGhlIHZpZGVvVHJhY2sgaW4gdGhlIG1wNGRlbXV4ZXIuIFdlIGRvbid0IGNoZWNrIHRvIHNlZSBpZiB0aGUgZGF0YSBpcyBvbmx5XG4gICAgLy8gYXVkaW8gb3IgdmlkZW8gKG9yIGJvdGgpOyBhZGRpbmcgaXQgdG8gdmlkZW8gd2FzIGFuIGFyYml0cmFyeSBjaG9pY2UuXG4gICAgY29uc3QgZGF0YSA9IHZpZGVvVHJhY2suc2FtcGxlcztcbiAgICBpZiAoIShkYXRhICE9IG51bGwgJiYgZGF0YS5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCBpbml0U2VnbWVudCA9IHtcbiAgICAgIGluaXRQVFM6IHVuZGVmaW5lZCxcbiAgICAgIHRpbWVzY2FsZTogMVxuICAgIH07XG4gICAgbGV0IGluaXREYXRhID0gdGhpcy5pbml0RGF0YTtcbiAgICBpZiAoISgoX2luaXREYXRhID0gaW5pdERhdGEpICE9IG51bGwgJiYgX2luaXREYXRhLmxlbmd0aCkpIHtcbiAgICAgIHRoaXMuZ2VuZXJhdGVJbml0U2VnbWVudChkYXRhKTtcbiAgICAgIGluaXREYXRhID0gdGhpcy5pbml0RGF0YTtcbiAgICB9XG4gICAgaWYgKCEoKF9pbml0RGF0YTIgPSBpbml0RGF0YSkgIT0gbnVsbCAmJiBfaW5pdERhdGEyLmxlbmd0aCkpIHtcbiAgICAgIC8vIFdlIGNhbid0IHJlbXV4IGlmIHRoZSBpbml0U2VnbWVudCBjb3VsZCBub3QgYmUgZ2VuZXJhdGVkXG4gICAgICBsb2dnZXIud2FybignW3Bhc3N0aHJvdWdoLXJlbXV4ZXIudHNdOiBGYWlsZWQgdG8gZ2VuZXJhdGUgaW5pdFNlZ21lbnQuJyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAodGhpcy5lbWl0SW5pdFNlZ21lbnQpIHtcbiAgICAgIGluaXRTZWdtZW50LnRyYWNrcyA9IHRoaXMuaW5pdFRyYWNrcztcbiAgICAgIHRoaXMuZW1pdEluaXRTZWdtZW50ID0gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGR1cmF0aW9uID0gZ2V0RHVyYXRpb24oZGF0YSwgaW5pdERhdGEpO1xuICAgIGNvbnN0IHN0YXJ0RFRTID0gZ2V0U3RhcnREVFMoaW5pdERhdGEsIGRhdGEpO1xuICAgIGNvbnN0IGRlY29kZVRpbWUgPSBzdGFydERUUyA9PT0gbnVsbCA/IHRpbWVPZmZzZXQgOiBzdGFydERUUztcbiAgICBpZiAoaXNJbnZhbGlkSW5pdFB0cyhpbml0UFRTLCBkZWNvZGVUaW1lLCB0aW1lT2Zmc2V0LCBkdXJhdGlvbikgfHwgaW5pdFNlZ21lbnQudGltZXNjYWxlICE9PSBpbml0UFRTLnRpbWVzY2FsZSAmJiBhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcbiAgICAgIGluaXRTZWdtZW50LmluaXRQVFMgPSBkZWNvZGVUaW1lIC0gdGltZU9mZnNldDtcbiAgICAgIGlmIChpbml0UFRTICYmIGluaXRQVFMudGltZXNjYWxlID09PSAxKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKGBBZGp1c3RpbmcgaW5pdFBUUyBieSAke2luaXRTZWdtZW50LmluaXRQVFMgLSBpbml0UFRTLmJhc2VUaW1lfWApO1xuICAgICAgfVxuICAgICAgdGhpcy5pbml0UFRTID0gaW5pdFBUUyA9IHtcbiAgICAgICAgYmFzZVRpbWU6IGluaXRTZWdtZW50LmluaXRQVFMsXG4gICAgICAgIHRpbWVzY2FsZTogMVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gYXVkaW9UcmFjayA/IGRlY29kZVRpbWUgLSBpbml0UFRTLmJhc2VUaW1lIC8gaW5pdFBUUy50aW1lc2NhbGUgOiBsYXN0RW5kVGltZTtcbiAgICBjb25zdCBlbmRUaW1lID0gc3RhcnRUaW1lICsgZHVyYXRpb247XG4gICAgb2Zmc2V0U3RhcnREVFMoaW5pdERhdGEsIGRhdGEsIGluaXRQVFMuYmFzZVRpbWUgLyBpbml0UFRTLnRpbWVzY2FsZSk7XG4gICAgaWYgKGR1cmF0aW9uID4gMCkge1xuICAgICAgdGhpcy5sYXN0RW5kVGltZSA9IGVuZFRpbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci53YXJuKCdEdXJhdGlvbiBwYXJzZWQgZnJvbSBtcDQgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiB6ZXJvJyk7XG4gICAgICB0aGlzLnJlc2V0TmV4dFRpbWVzdGFtcCgpO1xuICAgIH1cbiAgICBjb25zdCBoYXNBdWRpbyA9ICEhaW5pdERhdGEuYXVkaW87XG4gICAgY29uc3QgaGFzVmlkZW8gPSAhIWluaXREYXRhLnZpZGVvO1xuICAgIGxldCB0eXBlID0gJyc7XG4gICAgaWYgKGhhc0F1ZGlvKSB7XG4gICAgICB0eXBlICs9ICdhdWRpbyc7XG4gICAgfVxuICAgIGlmIChoYXNWaWRlbykge1xuICAgICAgdHlwZSArPSAndmlkZW8nO1xuICAgIH1cbiAgICBjb25zdCB0cmFjayA9IHtcbiAgICAgIGRhdGExOiBkYXRhLFxuICAgICAgc3RhcnRQVFM6IHN0YXJ0VGltZSxcbiAgICAgIHN0YXJ0RFRTOiBzdGFydFRpbWUsXG4gICAgICBlbmRQVFM6IGVuZFRpbWUsXG4gICAgICBlbmREVFM6IGVuZFRpbWUsXG4gICAgICB0eXBlLFxuICAgICAgaGFzQXVkaW8sXG4gICAgICBoYXNWaWRlbyxcbiAgICAgIG5iOiAxLFxuICAgICAgZHJvcHBlZDogMFxuICAgIH07XG4gICAgcmVzdWx0LmF1ZGlvID0gdHJhY2sudHlwZSA9PT0gJ2F1ZGlvJyA/IHRyYWNrIDogdW5kZWZpbmVkO1xuICAgIHJlc3VsdC52aWRlbyA9IHRyYWNrLnR5cGUgIT09ICdhdWRpbycgPyB0cmFjayA6IHVuZGVmaW5lZDtcbiAgICByZXN1bHQuaW5pdFNlZ21lbnQgPSBpbml0U2VnbWVudDtcbiAgICByZXN1bHQuaWQzID0gZmx1c2hUZXh0VHJhY2tNZXRhZGF0YUN1ZVNhbXBsZXMoaWQzVHJhY2ssIHRpbWVPZmZzZXQsIGluaXRQVFMsIGluaXRQVFMpO1xuICAgIGlmICh0ZXh0VHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdC50ZXh0ID0gZmx1c2hUZXh0VHJhY2tVc2VyZGF0YUN1ZVNhbXBsZXModGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBpbml0UFRTKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuZnVuY3Rpb24gaXNJbnZhbGlkSW5pdFB0cyhpbml0UFRTLCBzdGFydERUUywgdGltZU9mZnNldCwgZHVyYXRpb24pIHtcbiAgaWYgKGluaXRQVFMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyBJbml0UFRTIGlzIGludmFsaWQgd2hlbiBkaXN0YW5jZSBmcm9tIHByb2dyYW0gd291bGQgYmUgbW9yZSB0aGFuIHNlZ21lbnQgZHVyYXRpb24gb3IgYSBtaW5pbXVtIG9mIG9uZSBzZWNvbmRcbiAgY29uc3QgbWluRHVyYXRpb24gPSBNYXRoLm1heChkdXJhdGlvbiwgMSk7XG4gIGNvbnN0IHN0YXJ0VGltZSA9IHN0YXJ0RFRTIC0gaW5pdFBUUy5iYXNlVGltZSAvIGluaXRQVFMudGltZXNjYWxlO1xuICByZXR1cm4gTWF0aC5hYnMoc3RhcnRUaW1lIC0gdGltZU9mZnNldCkgPiBtaW5EdXJhdGlvbjtcbn1cbmZ1bmN0aW9uIGdldFBhcnNlZFRyYWNrQ29kZWModHJhY2ssIHR5cGUpIHtcbiAgY29uc3QgcGFyc2VkQ29kZWMgPSB0cmFjayA9PSBudWxsID8gdm9pZCAwIDogdHJhY2suY29kZWM7XG4gIGlmIChwYXJzZWRDb2RlYyAmJiBwYXJzZWRDb2RlYy5sZW5ndGggPiA0KSB7XG4gICAgcmV0dXJuIHBhcnNlZENvZGVjO1xuICB9XG4gIGlmICh0eXBlID09PSBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU8pIHtcbiAgICBpZiAocGFyc2VkQ29kZWMgPT09ICdlYy0zJyB8fCBwYXJzZWRDb2RlYyA9PT0gJ2FjLTMnIHx8IHBhcnNlZENvZGVjID09PSAnYWxhYycpIHtcbiAgICAgIHJldHVybiBwYXJzZWRDb2RlYztcbiAgICB9XG4gICAgaWYgKHBhcnNlZENvZGVjID09PSAnZkxhQycgfHwgcGFyc2VkQ29kZWMgPT09ICdPcHVzJykge1xuICAgICAgLy8gT3B0aW5nIG5vdCB0byBnZXQgYHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZWAgZnJvbSBwbGF5ZXIgY29uZmlnIGZvciBpc1N1cHBvcnRlZCgpIGNoZWNrIGZvciBzaW1wbGljaXR5XG4gICAgICBjb25zdCBwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UgPSBmYWxzZTtcbiAgICAgIHJldHVybiBnZXRDb2RlY0NvbXBhdGlibGVOYW1lKHBhcnNlZENvZGVjLCBwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSAnbXA0YS40MC41JztcbiAgICBsb2dnZXIuaW5mbyhgUGFyc2VkIGF1ZGlvIGNvZGVjIFwiJHtwYXJzZWRDb2RlY31cIiBvciBhdWRpbyBvYmplY3QgdHlwZSBub3QgaGFuZGxlZC4gVXNpbmcgXCIke3Jlc3VsdH1cImApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLy8gUHJvdmlkZSBkZWZhdWx0cyBiYXNlZCBvbiBjb2RlYyB0eXBlXG4gIC8vIFRoaXMgYWxsb3dzIGZvciBzb21lIHBsYXliYWNrIG9mIHNvbWUgZm1wNCBwbGF5bGlzdHMgd2l0aG91dCBDT0RFQ1MgZGVmaW5lZCBpbiBtYW5pZmVzdFxuICBsb2dnZXIud2FybihgVW5oYW5kbGVkIHZpZGVvIGNvZGVjIFwiJHtwYXJzZWRDb2RlY31cImApO1xuICBpZiAocGFyc2VkQ29kZWMgPT09ICdodmMxJyB8fCBwYXJzZWRDb2RlYyA9PT0gJ2hldjEnKSB7XG4gICAgcmV0dXJuICdodmMxLjEuNi5MMTIwLjkwJztcbiAgfVxuICBpZiAocGFyc2VkQ29kZWMgPT09ICdhdjAxJykge1xuICAgIHJldHVybiAnYXYwMS4wLjA0TS4wOCc7XG4gIH1cbiAgcmV0dXJuICdhdmMxLjQyZTAxZSc7XG59XG5cbmxldCBub3c7XG4vLyBwZXJmb3JtYW5jZS5ub3coKSBub3QgYXZhaWxhYmxlIG9uIFdlYldvcmtlciwgYXQgbGVhc3Qgb24gU2FmYXJpIERlc2t0b3BcbnRyeSB7XG4gIG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93LmJpbmQoc2VsZi5wZXJmb3JtYW5jZSk7XG59IGNhdGNoIChlcnIpIHtcbiAgbG9nZ2VyLmRlYnVnKCdVbmFibGUgdG8gdXNlIFBlcmZvcm1hbmNlIEFQSSBvbiB0aGlzIGVudmlyb25tZW50Jyk7XG4gIG5vdyA9IG9wdGlvbmFsU2VsZiA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9uYWxTZWxmLkRhdGUubm93O1xufVxuY29uc3QgbXV4Q29uZmlnID0gW3tcbiAgZGVtdXg6IE1QNERlbXV4ZXIsXG4gIHJlbXV4OiBQYXNzVGhyb3VnaFJlbXV4ZXJcbn0sIHtcbiAgZGVtdXg6IFRTRGVtdXhlcixcbiAgcmVtdXg6IE1QNFJlbXV4ZXJcbn0sIHtcbiAgZGVtdXg6IEFBQ0RlbXV4ZXIsXG4gIHJlbXV4OiBNUDRSZW11eGVyXG59LCB7XG4gIGRlbXV4OiBNUDNEZW11eGVyLFxuICByZW11eDogTVA0UmVtdXhlclxufV07XG57XG4gIG11eENvbmZpZy5zcGxpY2UoMiwgMCwge1xuICAgIGRlbXV4OiBBQzNEZW11eGVyLFxuICAgIHJlbXV4OiBNUDRSZW11eGVyXG4gIH0pO1xufVxuY2xhc3MgVHJhbnNtdXhlciB7XG4gIGNvbnN0cnVjdG9yKG9ic2VydmVyLCB0eXBlU3VwcG9ydGVkLCBjb25maWcsIHZlbmRvciwgaWQpIHtcbiAgICB0aGlzLmFzeW5jID0gZmFsc2U7XG4gICAgdGhpcy5vYnNlcnZlciA9IHZvaWQgMDtcbiAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy52ZW5kb3IgPSB2b2lkIDA7XG4gICAgdGhpcy5pZCA9IHZvaWQgMDtcbiAgICB0aGlzLmRlbXV4ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5yZW11eGVyID0gdm9pZCAwO1xuICAgIHRoaXMuZGVjcnlwdGVyID0gdm9pZCAwO1xuICAgIHRoaXMucHJvYmUgPSB2b2lkIDA7XG4gICAgdGhpcy5kZWNyeXB0aW9uUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy50cmFuc211eENvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLmN1cnJlbnRUcmFuc211eFN0YXRlID0gdm9pZCAwO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB0eXBlU3VwcG9ydGVkO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMudmVuZG9yID0gdmVuZG9yO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgfVxuICBjb25maWd1cmUodHJhbnNtdXhDb25maWcpIHtcbiAgICB0aGlzLnRyYW5zbXV4Q29uZmlnID0gdHJhbnNtdXhDb25maWc7XG4gICAgaWYgKHRoaXMuZGVjcnlwdGVyKSB7XG4gICAgICB0aGlzLmRlY3J5cHRlci5yZXNldCgpO1xuICAgIH1cbiAgfVxuICBwdXNoKGRhdGEsIGRlY3J5cHRkYXRhLCBjaHVua01ldGEsIHN0YXRlKSB7XG4gICAgY29uc3Qgc3RhdHMgPSBjaHVua01ldGEudHJhbnNtdXhpbmc7XG4gICAgc3RhdHMuZXhlY3V0ZVN0YXJ0ID0gbm93KCk7XG4gICAgbGV0IHVpbnREYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gICAgY29uc3Qge1xuICAgICAgY3VycmVudFRyYW5zbXV4U3RhdGUsXG4gICAgICB0cmFuc211eENvbmZpZ1xuICAgIH0gPSB0aGlzO1xuICAgIGlmIChzdGF0ZSkge1xuICAgICAgdGhpcy5jdXJyZW50VHJhbnNtdXhTdGF0ZSA9IHN0YXRlO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjb250aWd1b3VzLFxuICAgICAgZGlzY29udGludWl0eSxcbiAgICAgIHRyYWNrU3dpdGNoLFxuICAgICAgYWNjdXJhdGVUaW1lT2Zmc2V0LFxuICAgICAgdGltZU9mZnNldCxcbiAgICAgIGluaXRTZWdtZW50Q2hhbmdlXG4gICAgfSA9IHN0YXRlIHx8IGN1cnJlbnRUcmFuc211eFN0YXRlO1xuICAgIGNvbnN0IHtcbiAgICAgIGF1ZGlvQ29kZWMsXG4gICAgICB2aWRlb0NvZGVjLFxuICAgICAgZGVmYXVsdEluaXRQdHMsXG4gICAgICBkdXJhdGlvbixcbiAgICAgIGluaXRTZWdtZW50RGF0YVxuICAgIH0gPSB0cmFuc211eENvbmZpZztcbiAgICBjb25zdCBrZXlEYXRhID0gZ2V0RW5jcnlwdGlvblR5cGUodWludERhdGEsIGRlY3J5cHRkYXRhKTtcbiAgICBpZiAoa2V5RGF0YSAmJiBrZXlEYXRhLm1ldGhvZCA9PT0gJ0FFUy0xMjgnKSB7XG4gICAgICBjb25zdCBkZWNyeXB0ZXIgPSB0aGlzLmdldERlY3J5cHRlcigpO1xuICAgICAgLy8gU29mdHdhcmUgZGVjcnlwdGlvbiBpcyBzeW5jaHJvbm91czsgd2ViQ3J5cHRvIGlzIG5vdFxuICAgICAgaWYgKGRlY3J5cHRlci5pc1N5bmMoKSkge1xuICAgICAgICAvLyBTb2Z0d2FyZSBkZWNyeXB0aW9uIGlzIHByb2dyZXNzaXZlLiBQcm9ncmVzc2l2ZSBkZWNyeXB0aW9uIG1heSBub3QgcmV0dXJuIGEgcmVzdWx0IG9uIGVhY2ggY2FsbC4gQW55IGNhY2hlZFxuICAgICAgICAvLyBkYXRhIGlzIGhhbmRsZWQgaW4gdGhlIGZsdXNoKCkgY2FsbFxuICAgICAgICBsZXQgZGVjcnlwdGVkRGF0YSA9IGRlY3J5cHRlci5zb2Z0d2FyZURlY3J5cHQodWludERhdGEsIGtleURhdGEua2V5LmJ1ZmZlciwga2V5RGF0YS5pdi5idWZmZXIpO1xuICAgICAgICAvLyBGb3IgTG93LUxhdGVuY3kgSExTIFBhcnRzLCBkZWNyeXB0IGluIHBsYWNlLCBzaW5jZSBwYXJ0IHBhcnNpbmcgaXMgZXhwZWN0ZWQgb24gcHVzaCBwcm9ncmVzc1xuICAgICAgICBjb25zdCBsb2FkaW5nUGFydHMgPSBjaHVua01ldGEucGFydCA+IC0xO1xuICAgICAgICBpZiAobG9hZGluZ1BhcnRzKSB7XG4gICAgICAgICAgZGVjcnlwdGVkRGF0YSA9IGRlY3J5cHRlci5mbHVzaCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVjcnlwdGVkRGF0YSkge1xuICAgICAgICAgIHN0YXRzLmV4ZWN1dGVFbmQgPSBub3coKTtcbiAgICAgICAgICByZXR1cm4gZW1wdHlSZXN1bHQoY2h1bmtNZXRhKTtcbiAgICAgICAgfVxuICAgICAgICB1aW50RGF0YSA9IG5ldyBVaW50OEFycmF5KGRlY3J5cHRlZERhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kZWNyeXB0aW9uUHJvbWlzZSA9IGRlY3J5cHRlci53ZWJDcnlwdG9EZWNyeXB0KHVpbnREYXRhLCBrZXlEYXRhLmtleS5idWZmZXIsIGtleURhdGEuaXYuYnVmZmVyKS50aGVuKGRlY3J5cHRlZERhdGEgPT4ge1xuICAgICAgICAgIC8vIENhbGxpbmcgcHVzaCBoZXJlIGlzIGltcG9ydGFudDsgaWYgZmx1c2goKSBpcyBjYWxsZWQgd2hpbGUgdGhpcyBpcyBzdGlsbCByZXNvbHZpbmcsIHRoaXMgZW5zdXJlcyB0aGF0XG4gICAgICAgICAgLy8gdGhlIGRlY3J5cHRlZCBkYXRhIGhhcyBiZWVuIHRyYW5zbXV4ZWRcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnB1c2goZGVjcnlwdGVkRGF0YSwgbnVsbCwgY2h1bmtNZXRhKTtcbiAgICAgICAgICB0aGlzLmRlY3J5cHRpb25Qcm9taXNlID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdGlvblByb21pc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc2V0TXV4ZXJzID0gdGhpcy5uZWVkc1Byb2JpbmcoZGlzY29udGludWl0eSwgdHJhY2tTd2l0Y2gpO1xuICAgIGlmIChyZXNldE11eGVycykge1xuICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNvbmZpZ3VyZVRyYW5zbXV4ZXIodWludERhdGEpO1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKGBbdHJhbnNtdXhlcl0gJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB0aGlzLm9ic2VydmVyLmVtaXQoRXZlbnRzLkVSUk9SLCBFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsXG4gICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZVxuICAgICAgICB9KTtcbiAgICAgICAgc3RhdHMuZXhlY3V0ZUVuZCA9IG5vdygpO1xuICAgICAgICByZXR1cm4gZW1wdHlSZXN1bHQoY2h1bmtNZXRhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRpc2NvbnRpbnVpdHkgfHwgdHJhY2tTd2l0Y2ggfHwgaW5pdFNlZ21lbnRDaGFuZ2UgfHwgcmVzZXRNdXhlcnMpIHtcbiAgICAgIHRoaXMucmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudERhdGEsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGR1cmF0aW9uLCBkZWNyeXB0ZGF0YSk7XG4gICAgfVxuICAgIGlmIChkaXNjb250aW51aXR5IHx8IGluaXRTZWdtZW50Q2hhbmdlIHx8IHJlc2V0TXV4ZXJzKSB7XG4gICAgICB0aGlzLnJlc2V0SW5pdGlhbFRpbWVzdGFtcChkZWZhdWx0SW5pdFB0cyk7XG4gICAgfVxuICAgIGlmICghY29udGlndW91cykge1xuICAgICAgdGhpcy5yZXNldENvbnRpZ3VpdHkoKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy50cmFuc211eCh1aW50RGF0YSwga2V5RGF0YSwgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBjaHVua01ldGEpO1xuICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHRoaXMuY3VycmVudFRyYW5zbXV4U3RhdGU7XG4gICAgY3VycmVudFN0YXRlLmNvbnRpZ3VvdXMgPSB0cnVlO1xuICAgIGN1cnJlbnRTdGF0ZS5kaXNjb250aW51aXR5ID0gZmFsc2U7XG4gICAgY3VycmVudFN0YXRlLnRyYWNrU3dpdGNoID0gZmFsc2U7XG4gICAgc3RhdHMuZXhlY3V0ZUVuZCA9IG5vdygpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBEdWUgdG8gZGF0YSBjYWNoaW5nLCBmbHVzaCBjYWxscyBjYW4gcHJvZHVjZSBtb3JlIHRoYW4gb25lIFRyYW5zbXV4ZXJSZXN1bHQgKGhlbmNlIHRoZSBBcnJheSB0eXBlKVxuICBmbHVzaChjaHVua01ldGEpIHtcbiAgICBjb25zdCBzdGF0cyA9IGNodW5rTWV0YS50cmFuc211eGluZztcbiAgICBzdGF0cy5leGVjdXRlU3RhcnQgPSBub3coKTtcbiAgICBjb25zdCB7XG4gICAgICBkZWNyeXB0ZXIsXG4gICAgICBjdXJyZW50VHJhbnNtdXhTdGF0ZSxcbiAgICAgIGRlY3J5cHRpb25Qcm9taXNlXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGRlY3J5cHRpb25Qcm9taXNlKSB7XG4gICAgICAvLyBVcG9uIHJlc29sdXRpb24sIHRoZSBkZWNyeXB0aW9uIHByb21pc2UgY2FsbHMgcHVzaCgpIGFuZCByZXR1cm5zIGl0cyBUcmFuc211eGVyUmVzdWx0IHVwIHRoZSBzdGFjay4gVGhlcmVmb3JlXG4gICAgICAvLyBvbmx5IGZsdXNoaW5nIGlzIHJlcXVpcmVkIGZvciBhc3luYyBkZWNyeXB0aW9uXG4gICAgICByZXR1cm4gZGVjcnlwdGlvblByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsdXNoKGNodW5rTWV0YSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgdHJhbnNtdXhSZXN1bHRzID0gW107XG4gICAgY29uc3Qge1xuICAgICAgdGltZU9mZnNldFxuICAgIH0gPSBjdXJyZW50VHJhbnNtdXhTdGF0ZTtcbiAgICBpZiAoZGVjcnlwdGVyKSB7XG4gICAgICAvLyBUaGUgZGVjcnlwdGVyIG1heSBoYXZlIGRhdGEgY2FjaGVkLCB3aGljaCBuZWVkcyB0byBiZSBkZW11eGVkLiBJbiB0aGlzIGNhc2Ugd2UnbGwgaGF2ZSB0d28gVHJhbnNtdXhSZXN1bHRzXG4gICAgICAvLyBUaGlzIGhhcHBlbnMgaW4gdGhlIGNhc2UgdGhhdCB3ZSByZWNlaXZlIG9ubHkgMSBwdXNoIGNhbGwgZm9yIGEgc2VnbWVudCAoZWl0aGVyIGZvciBub24tcHJvZ3Jlc3NpdmUgZG93bmxvYWRzLFxuICAgICAgLy8gb3IgZm9yIHByb2dyZXNzaXZlIGRvd25sb2FkcyB3aXRoIHNtYWxsIHNlZ21lbnRzKVxuICAgICAgY29uc3QgZGVjcnlwdGVkRGF0YSA9IGRlY3J5cHRlci5mbHVzaCgpO1xuICAgICAgaWYgKGRlY3J5cHRlZERhdGEpIHtcbiAgICAgICAgLy8gUHVzaCBhbHdheXMgcmV0dXJucyBhIFRyYW5zbXV4ZXJSZXN1bHQgaWYgZGVjcnlwdGRhdGEgaXMgbnVsbFxuICAgICAgICB0cmFuc211eFJlc3VsdHMucHVzaCh0aGlzLnB1c2goZGVjcnlwdGVkRGF0YSwgbnVsbCwgY2h1bmtNZXRhKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGRlbXV4ZXIsXG4gICAgICByZW11eGVyXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFkZW11eGVyIHx8ICFyZW11eGVyKSB7XG4gICAgICAvLyBJZiBwcm9iaW5nIGZhaWxlZCwgdGhlbiBIbHMuanMgaGFzIGJlZW4gZ2l2ZW4gY29udGVudCBpdHMgbm90IGFibGUgdG8gaGFuZGxlXG4gICAgICBzdGF0cy5leGVjdXRlRW5kID0gbm93KCk7XG4gICAgICByZXR1cm4gW2VtcHR5UmVzdWx0KGNodW5rTWV0YSldO1xuICAgIH1cbiAgICBjb25zdCBkZW11eFJlc3VsdE9yUHJvbWlzZSA9IGRlbXV4ZXIuZmx1c2godGltZU9mZnNldCk7XG4gICAgaWYgKGlzUHJvbWlzZShkZW11eFJlc3VsdE9yUHJvbWlzZSkpIHtcbiAgICAgIC8vIERlY3J5cHQgZmluYWwgU0FNUExFLUFFUyBzYW1wbGVzXG4gICAgICByZXR1cm4gZGVtdXhSZXN1bHRPclByb21pc2UudGhlbihkZW11eFJlc3VsdCA9PiB7XG4gICAgICAgIHRoaXMuZmx1c2hSZW11eCh0cmFuc211eFJlc3VsdHMsIGRlbXV4UmVzdWx0LCBjaHVua01ldGEpO1xuICAgICAgICByZXR1cm4gdHJhbnNtdXhSZXN1bHRzO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuZmx1c2hSZW11eCh0cmFuc211eFJlc3VsdHMsIGRlbXV4UmVzdWx0T3JQcm9taXNlLCBjaHVua01ldGEpO1xuICAgIHJldHVybiB0cmFuc211eFJlc3VsdHM7XG4gIH1cbiAgZmx1c2hSZW11eCh0cmFuc211eFJlc3VsdHMsIGRlbXV4UmVzdWx0LCBjaHVua01ldGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBhdWRpb1RyYWNrLFxuICAgICAgdmlkZW9UcmFjayxcbiAgICAgIGlkM1RyYWNrLFxuICAgICAgdGV4dFRyYWNrXG4gICAgfSA9IGRlbXV4UmVzdWx0O1xuICAgIGNvbnN0IHtcbiAgICAgIGFjY3VyYXRlVGltZU9mZnNldCxcbiAgICAgIHRpbWVPZmZzZXRcbiAgICB9ID0gdGhpcy5jdXJyZW50VHJhbnNtdXhTdGF0ZTtcbiAgICBsb2dnZXIubG9nKGBbdHJhbnNtdXhlci50c106IEZsdXNoZWQgZnJhZ21lbnQgJHtjaHVua01ldGEuc259JHtjaHVua01ldGEucGFydCA+IC0xID8gJyBwOiAnICsgY2h1bmtNZXRhLnBhcnQgOiAnJ30gb2YgbGV2ZWwgJHtjaHVua01ldGEubGV2ZWx9YCk7XG4gICAgY29uc3QgcmVtdXhSZXN1bHQgPSB0aGlzLnJlbXV4ZXIucmVtdXgoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0LCB0cnVlLCB0aGlzLmlkKTtcbiAgICB0cmFuc211eFJlc3VsdHMucHVzaCh7XG4gICAgICByZW11eFJlc3VsdCxcbiAgICAgIGNodW5rTWV0YVxuICAgIH0pO1xuICAgIGNodW5rTWV0YS50cmFuc211eGluZy5leGVjdXRlRW5kID0gbm93KCk7XG4gIH1cbiAgcmVzZXRJbml0aWFsVGltZXN0YW1wKGRlZmF1bHRJbml0UHRzKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGVtdXhlcixcbiAgICAgIHJlbXV4ZXJcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWRlbXV4ZXIgfHwgIXJlbXV4ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVtdXhlci5yZXNldFRpbWVTdGFtcChkZWZhdWx0SW5pdFB0cyk7XG4gICAgcmVtdXhlci5yZXNldFRpbWVTdGFtcChkZWZhdWx0SW5pdFB0cyk7XG4gIH1cbiAgcmVzZXRDb250aWd1aXR5KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRlbXV4ZXIsXG4gICAgICByZW11eGVyXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFkZW11eGVyIHx8ICFyZW11eGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlbXV4ZXIucmVzZXRDb250aWd1aXR5KCk7XG4gICAgcmVtdXhlci5yZXNldE5leHRUaW1lc3RhbXAoKTtcbiAgfVxuICByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50RGF0YSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbiwgZGVjcnlwdGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBkZW11eGVyLFxuICAgICAgcmVtdXhlclxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghZGVtdXhlciB8fCAhcmVtdXhlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZW11eGVyLnJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnREYXRhLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0cmFja0R1cmF0aW9uKTtcbiAgICByZW11eGVyLnJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnREYXRhLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBkZWNyeXB0ZGF0YSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5kZW11eGVyKSB7XG4gICAgICB0aGlzLmRlbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5kZW11eGVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZW11eGVyKSB7XG4gICAgICB0aGlzLnJlbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5yZW11eGVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICB0cmFuc211eChkYXRhLCBrZXlEYXRhLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGNodW5rTWV0YSkge1xuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKGtleURhdGEgJiYga2V5RGF0YS5tZXRob2QgPT09ICdTQU1QTEUtQUVTJykge1xuICAgICAgcmVzdWx0ID0gdGhpcy50cmFuc211eFNhbXBsZUFlcyhkYXRhLCBrZXlEYXRhLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGNodW5rTWV0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMudHJhbnNtdXhVbmVuY3J5cHRlZChkYXRhLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGNodW5rTWV0YSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdHJhbnNtdXhVbmVuY3J5cHRlZChkYXRhLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGNodW5rTWV0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGF1ZGlvVHJhY2ssXG4gICAgICB2aWRlb1RyYWNrLFxuICAgICAgaWQzVHJhY2ssXG4gICAgICB0ZXh0VHJhY2tcbiAgICB9ID0gdGhpcy5kZW11eGVyLmRlbXV4KGRhdGEsIHRpbWVPZmZzZXQsIGZhbHNlLCAhdGhpcy5jb25maWcucHJvZ3Jlc3NpdmUpO1xuICAgIGNvbnN0IHJlbXV4UmVzdWx0ID0gdGhpcy5yZW11eGVyLnJlbXV4KGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgZmFsc2UsIHRoaXMuaWQpO1xuICAgIHJldHVybiB7XG4gICAgICByZW11eFJlc3VsdCxcbiAgICAgIGNodW5rTWV0YVxuICAgIH07XG4gIH1cbiAgdHJhbnNtdXhTYW1wbGVBZXMoZGF0YSwgZGVjcnlwdERhdGEsIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVtdXhlci5kZW11eFNhbXBsZUFlcyhkYXRhLCBkZWNyeXB0RGF0YSwgdGltZU9mZnNldCkudGhlbihkZW11eFJlc3VsdCA9PiB7XG4gICAgICBjb25zdCByZW11eFJlc3VsdCA9IHRoaXMucmVtdXhlci5yZW11eChkZW11eFJlc3VsdC5hdWRpb1RyYWNrLCBkZW11eFJlc3VsdC52aWRlb1RyYWNrLCBkZW11eFJlc3VsdC5pZDNUcmFjaywgZGVtdXhSZXN1bHQudGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGZhbHNlLCB0aGlzLmlkKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbXV4UmVzdWx0LFxuICAgICAgICBjaHVua01ldGFcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgY29uZmlndXJlVHJhbnNtdXhlcihkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29uZmlnLFxuICAgICAgb2JzZXJ2ZXIsXG4gICAgICB0eXBlU3VwcG9ydGVkLFxuICAgICAgdmVuZG9yXG4gICAgfSA9IHRoaXM7XG4gICAgLy8gcHJvYmUgZm9yIGNvbnRlbnQgdHlwZVxuICAgIGxldCBtdXg7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG11eENvbmZpZy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIF9tdXhDb25maWckaSRkZW11eDtcbiAgICAgIGlmICgoX211eENvbmZpZyRpJGRlbXV4ID0gbXV4Q29uZmlnW2ldLmRlbXV4KSAhPSBudWxsICYmIF9tdXhDb25maWckaSRkZW11eC5wcm9iZShkYXRhKSkge1xuICAgICAgICBtdXggPSBtdXhDb25maWdbaV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW11eCkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignRmFpbGVkIHRvIGZpbmQgZGVtdXhlciBieSBwcm9iaW5nIGZyYWdtZW50IGRhdGEnKTtcbiAgICB9XG4gICAgLy8gc28gbGV0J3MgY2hlY2sgdGhhdCBjdXJyZW50IHJlbXV4ZXIgYW5kIGRlbXV4ZXIgYXJlIHN0aWxsIHZhbGlkXG4gICAgY29uc3QgZGVtdXhlciA9IHRoaXMuZGVtdXhlcjtcbiAgICBjb25zdCByZW11eGVyID0gdGhpcy5yZW11eGVyO1xuICAgIGNvbnN0IFJlbXV4ZXIgPSBtdXgucmVtdXg7XG4gICAgY29uc3QgRGVtdXhlciA9IG11eC5kZW11eDtcbiAgICBpZiAoIXJlbXV4ZXIgfHwgIShyZW11eGVyIGluc3RhbmNlb2YgUmVtdXhlcikpIHtcbiAgICAgIHRoaXMucmVtdXhlciA9IG5ldyBSZW11eGVyKG9ic2VydmVyLCBjb25maWcsIHR5cGVTdXBwb3J0ZWQsIHZlbmRvcik7XG4gICAgfVxuICAgIGlmICghZGVtdXhlciB8fCAhKGRlbXV4ZXIgaW5zdGFuY2VvZiBEZW11eGVyKSkge1xuICAgICAgdGhpcy5kZW11eGVyID0gbmV3IERlbXV4ZXIob2JzZXJ2ZXIsIGNvbmZpZywgdHlwZVN1cHBvcnRlZCk7XG4gICAgICB0aGlzLnByb2JlID0gRGVtdXhlci5wcm9iZTtcbiAgICB9XG4gIH1cbiAgbmVlZHNQcm9iaW5nKGRpc2NvbnRpbnVpdHksIHRyYWNrU3dpdGNoKSB7XG4gICAgLy8gaW4gY2FzZSBvZiBjb250aW51aXR5IGNoYW5nZSwgb3IgdHJhY2sgc3dpdGNoXG4gICAgLy8gd2UgbWlnaHQgc3dpdGNoIGZyb20gY29udGVudCB0eXBlIChBQUMgY29udGFpbmVyIHRvIFRTIGNvbnRhaW5lciwgb3IgVFMgdG8gZm1wNCBmb3IgZXhhbXBsZSlcbiAgICByZXR1cm4gIXRoaXMuZGVtdXhlciB8fCAhdGhpcy5yZW11eGVyIHx8IGRpc2NvbnRpbnVpdHkgfHwgdHJhY2tTd2l0Y2g7XG4gIH1cbiAgZ2V0RGVjcnlwdGVyKCkge1xuICAgIGxldCBkZWNyeXB0ZXIgPSB0aGlzLmRlY3J5cHRlcjtcbiAgICBpZiAoIWRlY3J5cHRlcikge1xuICAgICAgZGVjcnlwdGVyID0gdGhpcy5kZWNyeXB0ZXIgPSBuZXcgRGVjcnlwdGVyKHRoaXMuY29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY3J5cHRlcjtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0RW5jcnlwdGlvblR5cGUoZGF0YSwgZGVjcnlwdERhdGEpIHtcbiAgbGV0IGVuY3J5cHRpb25UeXBlID0gbnVsbDtcbiAgaWYgKGRhdGEuYnl0ZUxlbmd0aCA+IDAgJiYgKGRlY3J5cHREYXRhID09IG51bGwgPyB2b2lkIDAgOiBkZWNyeXB0RGF0YS5rZXkpICE9IG51bGwgJiYgZGVjcnlwdERhdGEuaXYgIT09IG51bGwgJiYgZGVjcnlwdERhdGEubWV0aG9kICE9IG51bGwpIHtcbiAgICBlbmNyeXB0aW9uVHlwZSA9IGRlY3J5cHREYXRhO1xuICB9XG4gIHJldHVybiBlbmNyeXB0aW9uVHlwZTtcbn1cbmNvbnN0IGVtcHR5UmVzdWx0ID0gY2h1bmtNZXRhID0+ICh7XG4gIHJlbXV4UmVzdWx0OiB7fSxcbiAgY2h1bmtNZXRhXG59KTtcbmZ1bmN0aW9uIGlzUHJvbWlzZShwKSB7XG4gIHJldHVybiAndGhlbicgaW4gcCAmJiBwLnRoZW4gaW5zdGFuY2VvZiBGdW5jdGlvbjtcbn1cbmNsYXNzIFRyYW5zbXV4Q29uZmlnIHtcbiAgY29uc3RydWN0b3IoYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgaW5pdFNlZ21lbnREYXRhLCBkdXJhdGlvbiwgZGVmYXVsdEluaXRQdHMpIHtcbiAgICB0aGlzLmF1ZGlvQ29kZWMgPSB2b2lkIDA7XG4gICAgdGhpcy52aWRlb0NvZGVjID0gdm9pZCAwO1xuICAgIHRoaXMuaW5pdFNlZ21lbnREYXRhID0gdm9pZCAwO1xuICAgIHRoaXMuZHVyYXRpb24gPSB2b2lkIDA7XG4gICAgdGhpcy5kZWZhdWx0SW5pdFB0cyA9IHZvaWQgMDtcbiAgICB0aGlzLmF1ZGlvQ29kZWMgPSBhdWRpb0NvZGVjO1xuICAgIHRoaXMudmlkZW9Db2RlYyA9IHZpZGVvQ29kZWM7XG4gICAgdGhpcy5pbml0U2VnbWVudERhdGEgPSBpbml0U2VnbWVudERhdGE7XG4gICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIHRoaXMuZGVmYXVsdEluaXRQdHMgPSBkZWZhdWx0SW5pdFB0cyB8fCBudWxsO1xuICB9XG59XG5jbGFzcyBUcmFuc211eFN0YXRlIHtcbiAgY29uc3RydWN0b3IoZGlzY29udGludWl0eSwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0LCB0cmFja1N3aXRjaCwgdGltZU9mZnNldCwgaW5pdFNlZ21lbnRDaGFuZ2UpIHtcbiAgICB0aGlzLmRpc2NvbnRpbnVpdHkgPSB2b2lkIDA7XG4gICAgdGhpcy5jb250aWd1b3VzID0gdm9pZCAwO1xuICAgIHRoaXMuYWNjdXJhdGVUaW1lT2Zmc2V0ID0gdm9pZCAwO1xuICAgIHRoaXMudHJhY2tTd2l0Y2ggPSB2b2lkIDA7XG4gICAgdGhpcy50aW1lT2Zmc2V0ID0gdm9pZCAwO1xuICAgIHRoaXMuaW5pdFNlZ21lbnRDaGFuZ2UgPSB2b2lkIDA7XG4gICAgdGhpcy5kaXNjb250aW51aXR5ID0gZGlzY29udGludWl0eTtcbiAgICB0aGlzLmNvbnRpZ3VvdXMgPSBjb250aWd1b3VzO1xuICAgIHRoaXMuYWNjdXJhdGVUaW1lT2Zmc2V0ID0gYWNjdXJhdGVUaW1lT2Zmc2V0O1xuICAgIHRoaXMudHJhY2tTd2l0Y2ggPSB0cmFja1N3aXRjaDtcbiAgICB0aGlzLnRpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0O1xuICAgIHRoaXMuaW5pdFNlZ21lbnRDaGFuZ2UgPSBpbml0U2VnbWVudENoYW5nZTtcbiAgfVxufVxuXG52YXIgZXZlbnRlbWl0dGVyMyA9IHtleHBvcnRzOiB7fX07XG5cbihmdW5jdGlvbiAobW9kdWxlKSB7XG5cblx0dmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcblx0ICAsIHByZWZpeCA9ICd+JztcblxuXHQvKipcblx0ICogQ29uc3RydWN0b3IgdG8gY3JlYXRlIGEgc3RvcmFnZSBmb3Igb3VyIGBFRWAgb2JqZWN0cy5cblx0ICogQW4gYEV2ZW50c2AgaW5zdGFuY2UgaXMgYSBwbGFpbiBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyBhcmUgZXZlbnQgbmFtZXMuXG5cdCAqXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gRXZlbnRzKCkge31cblxuXHQvL1xuXHQvLyBXZSB0cnkgdG8gbm90IGluaGVyaXQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuIEluIHNvbWUgZW5naW5lcyBjcmVhdGluZyBhblxuXHQvLyBpbnN0YW5jZSBpbiB0aGlzIHdheSBpcyBmYXN0ZXIgdGhhbiBjYWxsaW5nIGBPYmplY3QuY3JlYXRlKG51bGwpYCBkaXJlY3RseS5cblx0Ly8gSWYgYE9iamVjdC5jcmVhdGUobnVsbClgIGlzIG5vdCBzdXBwb3J0ZWQgd2UgcHJlZml4IHRoZSBldmVudCBuYW1lcyB3aXRoIGFcblx0Ly8gY2hhcmFjdGVyIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBidWlsdC1pbiBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90XG5cdC8vIG92ZXJyaWRkZW4gb3IgdXNlZCBhcyBhbiBhdHRhY2sgdmVjdG9yLlxuXHQvL1xuXHRpZiAoT2JqZWN0LmNyZWF0ZSkge1xuXHQgIEV2ZW50cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5cdCAgLy9cblx0ICAvLyBUaGlzIGhhY2sgaXMgbmVlZGVkIGJlY2F1c2UgdGhlIGBfX3Byb3RvX19gIHByb3BlcnR5IGlzIHN0aWxsIGluaGVyaXRlZCBpblxuXHQgIC8vIHNvbWUgb2xkIGJyb3dzZXJzIGxpa2UgQW5kcm9pZCA0LCBpUGhvbmUgNS4xLCBPcGVyYSAxMSBhbmQgU2FmYXJpIDUuXG5cdCAgLy9cblx0ICBpZiAoIW5ldyBFdmVudHMoKS5fX3Byb3RvX18pIHByZWZpeCA9IGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIGV2ZW50IGxpc3RlbmVyLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG5cdCAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29uY2U9ZmFsc2VdIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gRUUoZm4sIGNvbnRleHQsIG9uY2UpIHtcblx0ICB0aGlzLmZuID0gZm47XG5cdCAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcblx0ICB0aGlzLm9uY2UgPSBvbmNlIHx8IGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuXHQgKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cblx0ICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cblx0ICogQHBhcmFtIHtCb29sZWFufSBvbmNlIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG5cdCAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcblx0ICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG5cdCAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cdCAgfVxuXG5cdCAgdmFyIGxpc3RlbmVyID0gbmV3IEVFKGZuLCBjb250ZXh0IHx8IGVtaXR0ZXIsIG9uY2UpXG5cdCAgICAsIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cblx0ICBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdKSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IGxpc3RlbmVyLCBlbWl0dGVyLl9ldmVudHNDb3VudCsrO1xuXHQgIGVsc2UgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XS5mbikgZW1pdHRlci5fZXZlbnRzW2V2dF0ucHVzaChsaXN0ZW5lcik7XG5cdCAgZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IFtlbWl0dGVyLl9ldmVudHNbZXZ0XSwgbGlzdGVuZXJdO1xuXG5cdCAgcmV0dXJuIGVtaXR0ZXI7XG5cdH1cblxuXHQvKipcblx0ICogQ2xlYXIgZXZlbnQgYnkgbmFtZS5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2dCBUaGUgRXZlbnQgbmFtZS5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGNsZWFyRXZlbnQoZW1pdHRlciwgZXZ0KSB7XG5cdCAgaWYgKC0tZW1pdHRlci5fZXZlbnRzQ291bnQgPT09IDApIGVtaXR0ZXIuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcblx0ICBlbHNlIGRlbGV0ZSBlbWl0dGVyLl9ldmVudHNbZXZ0XTtcblx0fVxuXG5cdC8qKlxuXHQgKiBNaW5pbWFsIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZSB0aGF0IGlzIG1vbGRlZCBhZ2FpbnN0IHRoZSBOb2RlLmpzXG5cdCAqIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZS5cblx0ICpcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdGZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcblx0ICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG5cdCAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybiBhbiBhcnJheSBsaXN0aW5nIHRoZSBldmVudHMgZm9yIHdoaWNoIHRoZSBlbWl0dGVyIGhhcyByZWdpc3RlcmVkXG5cdCAqIGxpc3RlbmVycy5cblx0ICpcblx0ICogQHJldHVybnMge0FycmF5fVxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuXHQgIHZhciBuYW1lcyA9IFtdXG5cdCAgICAsIGV2ZW50c1xuXHQgICAgLCBuYW1lO1xuXG5cdCAgaWYgKHRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSByZXR1cm4gbmFtZXM7XG5cblx0ICBmb3IgKG5hbWUgaW4gKGV2ZW50cyA9IHRoaXMuX2V2ZW50cykpIHtcblx0ICAgIGlmIChoYXMuY2FsbChldmVudHMsIG5hbWUpKSBuYW1lcy5wdXNoKHByZWZpeCA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lKTtcblx0ICB9XG5cblx0ICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuXHQgICAgcmV0dXJuIG5hbWVzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGV2ZW50cykpO1xuXHQgIH1cblxuXHQgIHJldHVybiBuYW1lcztcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJuIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cblx0ICpcblx0ICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSByZWdpc3RlcmVkIGxpc3RlbmVycy5cblx0ICogQHB1YmxpY1xuXHQgKi9cblx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoZXZlbnQpIHtcblx0ICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuXHQgICAgLCBoYW5kbGVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG5cdCAgaWYgKCFoYW5kbGVycykgcmV0dXJuIFtdO1xuXHQgIGlmIChoYW5kbGVycy5mbikgcmV0dXJuIFtoYW5kbGVycy5mbl07XG5cblx0ICBmb3IgKHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aCwgZWUgPSBuZXcgQXJyYXkobCk7IGkgPCBsOyBpKyspIHtcblx0ICAgIGVlW2ldID0gaGFuZGxlcnNbaV0uZm47XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm4gdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgbGlzdGVuaW5nIHRvIGEgZ2l2ZW4gZXZlbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWJlciBvZiBsaXN0ZW5lcnMuXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdEV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcblx0ICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuXHQgICAgLCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuXHQgIGlmICghbGlzdGVuZXJzKSByZXR1cm4gMDtcblx0ICBpZiAobGlzdGVuZXJzLmZuKSByZXR1cm4gMTtcblx0ICByZXR1cm4gbGlzdGVuZXJzLmxlbmd0aDtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbHMgZWFjaCBvZiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZXZlbnQgaGFkIGxpc3RlbmVycywgZWxzZSBgZmFsc2VgLlxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50LCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcblx0ICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuXHQgIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiBmYWxzZTtcblxuXHQgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XVxuXHQgICAgLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoXG5cdCAgICAsIGFyZ3Ncblx0ICAgICwgaTtcblxuXHQgIGlmIChsaXN0ZW5lcnMuZm4pIHtcblx0ICAgIGlmIChsaXN0ZW5lcnMub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG5cdCAgICBzd2l0Y2ggKGxlbikge1xuXHQgICAgICBjYXNlIDE6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCksIHRydWU7XG5cdCAgICAgIGNhc2UgMjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSksIHRydWU7XG5cdCAgICAgIGNhc2UgMzogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIpLCB0cnVlO1xuXHQgICAgICBjYXNlIDQ6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMyksIHRydWU7XG5cdCAgICAgIGNhc2UgNTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCksIHRydWU7XG5cdCAgICAgIGNhc2UgNjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCwgYTUpLCB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICBmb3IgKGkgPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGkgPCBsZW47IGkrKykge1xuXHQgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblx0ICAgIH1cblxuXHQgICAgbGlzdGVuZXJzLmZuLmFwcGx5KGxpc3RlbmVycy5jb250ZXh0LCBhcmdzKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdmFyIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGhcblx0ICAgICAgLCBqO1xuXG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0ICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbaV0uZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cblx0ICAgICAgc3dpdGNoIChsZW4pIHtcblx0ICAgICAgICBjYXNlIDE6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0KTsgYnJlYWs7XG5cdCAgICAgICAgY2FzZSAyOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEpOyBicmVhaztcblx0ICAgICAgICBjYXNlIDM6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIpOyBicmVhaztcblx0ICAgICAgICBjYXNlIDQ6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIsIGEzKTsgYnJlYWs7XG5cdCAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgIGlmICghYXJncykgZm9yIChqID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBqIDwgbGVuOyBqKyspIHtcblx0ICAgICAgICAgICAgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5hcHBseShsaXN0ZW5lcnNbaV0uY29udGV4dCwgYXJncyk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuXHQgKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cblx0ICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGZuLCBjb250ZXh0KSB7XG5cdCAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgZmFsc2UpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGQgYSBvbmUtdGltZSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cblx0ICpcblx0ICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG5cdCAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuXHQgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdEV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UoZXZlbnQsIGZuLCBjb250ZXh0KSB7XG5cdCAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgdHJ1ZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZSB0aGUgbGlzdGVuZXJzIG9mIGEgZ2l2ZW4gZXZlbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IG1hdGNoIHRoaXMgZnVuY3Rpb24uXG5cdCAqIEBwYXJhbSB7Kn0gY29udGV4dCBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgaGF2ZSB0aGlzIGNvbnRleHQuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBPbmx5IHJlbW92ZSBvbmUtdGltZSBsaXN0ZW5lcnMuXG5cdCAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cblx0ICogQHB1YmxpY1xuXHQgKi9cblx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuXHQgIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG5cdCAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIHRoaXM7XG5cdCAgaWYgKCFmbikge1xuXHQgICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfVxuXG5cdCAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG5cdCAgaWYgKGxpc3RlbmVycy5mbikge1xuXHQgICAgaWYgKFxuXHQgICAgICBsaXN0ZW5lcnMuZm4gPT09IGZuICYmXG5cdCAgICAgICghb25jZSB8fCBsaXN0ZW5lcnMub25jZSkgJiZcblx0ICAgICAgKCFjb250ZXh0IHx8IGxpc3RlbmVycy5jb250ZXh0ID09PSBjb250ZXh0KVxuXHQgICAgKSB7XG5cdCAgICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcblx0ICAgIH1cblx0ICB9IGVsc2Uge1xuXHQgICAgZm9yICh2YXIgaSA9IDAsIGV2ZW50cyA9IFtdLCBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0ICAgICAgaWYgKFxuXHQgICAgICAgIGxpc3RlbmVyc1tpXS5mbiAhPT0gZm4gfHxcblx0ICAgICAgICAob25jZSAmJiAhbGlzdGVuZXJzW2ldLm9uY2UpIHx8XG5cdCAgICAgICAgKGNvbnRleHQgJiYgbGlzdGVuZXJzW2ldLmNvbnRleHQgIT09IGNvbnRleHQpXG5cdCAgICAgICkge1xuXHQgICAgICAgIGV2ZW50cy5wdXNoKGxpc3RlbmVyc1tpXSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgLy9cblx0ICAgIC8vIFJlc2V0IHRoZSBhcnJheSwgb3IgcmVtb3ZlIGl0IGNvbXBsZXRlbHkgaWYgd2UgaGF2ZSBubyBtb3JlIGxpc3RlbmVycy5cblx0ICAgIC8vXG5cdCAgICBpZiAoZXZlbnRzLmxlbmd0aCkgdGhpcy5fZXZlbnRzW2V2dF0gPSBldmVudHMubGVuZ3RoID09PSAxID8gZXZlbnRzWzBdIDogZXZlbnRzO1xuXHQgICAgZWxzZSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhbGwgbGlzdGVuZXJzLCBvciB0aG9zZSBvZiB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gW2V2ZW50XSBUaGUgZXZlbnQgbmFtZS5cblx0ICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuXHQgIHZhciBldnQ7XG5cblx0ICBpZiAoZXZlbnQpIHtcblx0ICAgIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cdCAgICBpZiAodGhpcy5fZXZlbnRzW2V2dF0pIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuXHQgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuXHQgIH1cblxuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8vXG5cdC8vIEFsaWFzIG1ldGhvZHMgbmFtZXMgYmVjYXVzZSBwZW9wbGUgcm9sbCBsaWtlIHRoYXQuXG5cdC8vXG5cdEV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub247XG5cblx0Ly9cblx0Ly8gRXhwb3NlIHRoZSBwcmVmaXguXG5cdC8vXG5cdEV2ZW50RW1pdHRlci5wcmVmaXhlZCA9IHByZWZpeDtcblxuXHQvL1xuXHQvLyBBbGxvdyBgRXZlbnRFbWl0dGVyYCB0byBiZSBpbXBvcnRlZCBhcyBtb2R1bGUgbmFtZXNwYWNlLlxuXHQvL1xuXHRFdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5cdC8vXG5cdC8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuXHQvL1xuXHR7XG5cdCAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cdH0gXG59IChldmVudGVtaXR0ZXIzKSk7XG5cbnZhciBldmVudGVtaXR0ZXIzRXhwb3J0cyA9IGV2ZW50ZW1pdHRlcjMuZXhwb3J0cztcbnZhciBFdmVudEVtaXR0ZXIgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoZXZlbnRlbWl0dGVyM0V4cG9ydHMpO1xuXG5jbGFzcyBUcmFuc211eGVySW50ZXJmYWNlIHtcbiAgY29uc3RydWN0b3IoaGxzLCBpZCwgb25UcmFuc211eENvbXBsZXRlLCBvbkZsdXNoKSB7XG4gICAgdGhpcy5lcnJvciA9IG51bGw7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5pZCA9IHZvaWQgMDtcbiAgICB0aGlzLm9ic2VydmVyID0gdm9pZCAwO1xuICAgIHRoaXMuZnJhZyA9IG51bGw7XG4gICAgdGhpcy5wYXJ0ID0gbnVsbDtcbiAgICB0aGlzLnVzZVdvcmtlciA9IHZvaWQgMDtcbiAgICB0aGlzLndvcmtlckNvbnRleHQgPSBudWxsO1xuICAgIHRoaXMub253bXNnID0gdm9pZCAwO1xuICAgIHRoaXMudHJhbnNtdXhlciA9IG51bGw7XG4gICAgdGhpcy5vblRyYW5zbXV4Q29tcGxldGUgPSB2b2lkIDA7XG4gICAgdGhpcy5vbkZsdXNoID0gdm9pZCAwO1xuICAgIGNvbnN0IGNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMudXNlV29ya2VyID0gISFjb25maWcuZW5hYmxlV29ya2VyO1xuICAgIHRoaXMub25UcmFuc211eENvbXBsZXRlID0gb25UcmFuc211eENvbXBsZXRlO1xuICAgIHRoaXMub25GbHVzaCA9IG9uRmx1c2g7XG4gICAgY29uc3QgZm9yd2FyZE1lc3NhZ2UgPSAoZXYsIGRhdGEpID0+IHtcbiAgICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgICAgZGF0YS5mcmFnID0gdGhpcy5mcmFnO1xuICAgICAgZGF0YS5pZCA9IHRoaXMuaWQ7XG4gICAgICBpZiAoZXYgPT09IEV2ZW50cy5FUlJPUikge1xuICAgICAgICB0aGlzLmVycm9yID0gZGF0YS5lcnJvcjtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoZXYsIGRhdGEpO1xuICAgIH07XG5cbiAgICAvLyBmb3J3YXJkIGV2ZW50cyB0byBtYWluIHRocmVhZFxuICAgIHRoaXMub2JzZXJ2ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgdGhpcy5vYnNlcnZlci5vbihFdmVudHMuRlJBR19ERUNSWVBURUQsIGZvcndhcmRNZXNzYWdlKTtcbiAgICB0aGlzLm9ic2VydmVyLm9uKEV2ZW50cy5FUlJPUiwgZm9yd2FyZE1lc3NhZ2UpO1xuICAgIGNvbnN0IE1lZGlhU291cmNlID0gZ2V0TWVkaWFTb3VyY2UoY29uZmlnLnByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSkgfHwge1xuICAgICAgaXNUeXBlU3VwcG9ydGVkOiAoKSA9PiBmYWxzZVxuICAgIH07XG4gICAgY29uc3QgbTJ0c1R5cGVTdXBwb3J0ZWQgPSB7XG4gICAgICBtcGVnOiBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ2F1ZGlvL21wZWcnKSxcbiAgICAgIG1wMzogTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCdhdWRpby9tcDQ7IGNvZGVjcz1cIm1wM1wiJyksXG4gICAgICBhYzM6IE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgnYXVkaW8vbXA0OyBjb2RlY3M9XCJhYy0zXCInKSBcbiAgICB9O1xuXG4gICAgLy8gbmF2aWdhdG9yLnZlbmRvciBpcyBub3QgYWx3YXlzIGF2YWlsYWJsZSBpbiBXZWIgV29ya2VyXG4gICAgLy8gcmVmZXIgdG8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dvcmtlckdsb2JhbFNjb3BlL25hdmlnYXRvclxuICAgIGNvbnN0IHZlbmRvciA9IG5hdmlnYXRvci52ZW5kb3I7XG4gICAgaWYgKHRoaXMudXNlV29ya2VyICYmIHR5cGVvZiBXb3JrZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCBjYW5DcmVhdGVXb3JrZXIgPSBjb25maWcud29ya2VyUGF0aCB8fCBoYXNVTURXb3JrZXIoKTtcbiAgICAgIGlmIChjYW5DcmVhdGVXb3JrZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoY29uZmlnLndvcmtlclBhdGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coYGxvYWRpbmcgV2ViIFdvcmtlciAke2NvbmZpZy53b3JrZXJQYXRofSBmb3IgXCIke2lkfVwiYCk7XG4gICAgICAgICAgICB0aGlzLndvcmtlckNvbnRleHQgPSBsb2FkV29ya2VyKGNvbmZpZy53b3JrZXJQYXRoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgaW5qZWN0aW5nIFdlYiBXb3JrZXIgZm9yIFwiJHtpZH1cImApO1xuICAgICAgICAgICAgdGhpcy53b3JrZXJDb250ZXh0ID0gaW5qZWN0V29ya2VyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMub253bXNnID0gZXYgPT4gdGhpcy5vbldvcmtlck1lc3NhZ2UoZXYpO1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHdvcmtlclxuICAgICAgICAgIH0gPSB0aGlzLndvcmtlckNvbnRleHQ7XG4gICAgICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLm9ud21zZyk7XG4gICAgICAgICAgd29ya2VyLm9uZXJyb3IgPSBldmVudCA9PiB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgJHtldmVudC5tZXNzYWdlfSAgKCR7ZXZlbnQuZmlsZW5hbWV9OiR7ZXZlbnQubGluZW5vfSlgKTtcbiAgICAgICAgICAgIGNvbmZpZy5lbmFibGVXb3JrZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBFcnJvciBpbiBcIiR7aWR9XCIgV2ViIFdvcmtlciwgZmFsbGJhY2sgdG8gaW5saW5lYCk7XG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuSU5URVJOQUxfRVhDRVBUSU9OLFxuICAgICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICAgIGV2ZW50OiAnZGVtdXhlcldvcmtlcicsXG4gICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBjbWQ6ICdpbml0JyxcbiAgICAgICAgICAgIHR5cGVTdXBwb3J0ZWQ6IG0ydHNUeXBlU3VwcG9ydGVkLFxuICAgICAgICAgICAgdmVuZG9yOiB2ZW5kb3IsXG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBjb25maWc6IEpTT04uc3RyaW5naWZ5KGNvbmZpZylcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYEVycm9yIHNldHRpbmcgdXAgXCIke2lkfVwiIFdlYiBXb3JrZXIsIGZhbGxiYWNrIHRvIGlubGluZWAsIGVycik7XG4gICAgICAgICAgdGhpcy5yZXNldFdvcmtlcigpO1xuICAgICAgICAgIHRoaXMuZXJyb3IgPSBudWxsO1xuICAgICAgICAgIHRoaXMudHJhbnNtdXhlciA9IG5ldyBUcmFuc211eGVyKHRoaXMub2JzZXJ2ZXIsIG0ydHNUeXBlU3VwcG9ydGVkLCBjb25maWcsIHZlbmRvciwgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy50cmFuc211eGVyID0gbmV3IFRyYW5zbXV4ZXIodGhpcy5vYnNlcnZlciwgbTJ0c1R5cGVTdXBwb3J0ZWQsIGNvbmZpZywgdmVuZG9yLCBpZCk7XG4gIH1cbiAgcmVzZXRXb3JrZXIoKSB7XG4gICAgaWYgKHRoaXMud29ya2VyQ29udGV4dCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB3b3JrZXIsXG4gICAgICAgIG9iamVjdFVSTFxuICAgICAgfSA9IHRoaXMud29ya2VyQ29udGV4dDtcbiAgICAgIGlmIChvYmplY3RVUkwpIHtcbiAgICAgICAgLy8gcmV2b2tlIHRoZSBPYmplY3QgVVJMIHRoYXQgd2FzIHVzZWQgdG8gY3JlYXRlIHRyYW5zbXV4ZXIgd29ya2VyLCBzbyBhcyBub3QgdG8gbGVhayBpdFxuICAgICAgICBzZWxmLlVSTC5yZXZva2VPYmplY3RVUkwob2JqZWN0VVJMKTtcbiAgICAgIH1cbiAgICAgIHdvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5vbndtc2cpO1xuICAgICAgd29ya2VyLm9uZXJyb3IgPSBudWxsO1xuICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgdGhpcy53b3JrZXJDb250ZXh0ID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy53b3JrZXJDb250ZXh0KSB7XG4gICAgICB0aGlzLnJlc2V0V29ya2VyKCk7XG4gICAgICB0aGlzLm9ud21zZyA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdHJhbnNtdXhlciA9IHRoaXMudHJhbnNtdXhlcjtcbiAgICAgIGlmICh0cmFuc211eGVyKSB7XG4gICAgICAgIHRyYW5zbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnRyYW5zbXV4ZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXI7XG4gICAgaWYgKG9ic2VydmVyKSB7XG4gICAgICBvYnNlcnZlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgdGhpcy5mcmFnID0gbnVsbDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5vYnNlcnZlciA9IG51bGw7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuaGxzID0gbnVsbDtcbiAgfVxuICBwdXNoKGRhdGEsIGluaXRTZWdtZW50RGF0YSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZnJhZywgcGFydCwgZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhLCBkZWZhdWx0SW5pdFBUUykge1xuICAgIHZhciBfZnJhZyRpbml0U2VnbWVudCwgX2xhc3RGcmFnJGluaXRTZWdtZW50O1xuICAgIGNodW5rTWV0YS50cmFuc211eGluZy5zdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3Qge1xuICAgICAgdHJhbnNtdXhlclxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHRpbWVPZmZzZXQgPSBwYXJ0ID8gcGFydC5zdGFydCA6IGZyYWcuc3RhcnQ7XG4gICAgLy8gVE9ETzogcHVzaCBcImNsZWFyLWxlYWRcIiBkZWNyeXB0IGRhdGEgZm9yIHVuZW5jcnlwdGVkIGZyYWdtZW50cyBpbiBzdHJlYW1zIHdpdGggZW5jcnlwdGVkIG9uZXNcbiAgICBjb25zdCBkZWNyeXB0ZGF0YSA9IGZyYWcuZGVjcnlwdGRhdGE7XG4gICAgY29uc3QgbGFzdEZyYWcgPSB0aGlzLmZyYWc7XG4gICAgY29uc3QgZGlzY29udGludWl0eSA9ICEobGFzdEZyYWcgJiYgZnJhZy5jYyA9PT0gbGFzdEZyYWcuY2MpO1xuICAgIGNvbnN0IHRyYWNrU3dpdGNoID0gIShsYXN0RnJhZyAmJiBjaHVua01ldGEubGV2ZWwgPT09IGxhc3RGcmFnLmxldmVsKTtcbiAgICBjb25zdCBzbkRpZmYgPSBsYXN0RnJhZyA/IGNodW5rTWV0YS5zbiAtIGxhc3RGcmFnLnNuIDogLTE7XG4gICAgY29uc3QgcGFydERpZmYgPSB0aGlzLnBhcnQgPyBjaHVua01ldGEucGFydCAtIHRoaXMucGFydC5pbmRleCA6IC0xO1xuICAgIGNvbnN0IHByb2dyZXNzaXZlID0gc25EaWZmID09PSAwICYmIGNodW5rTWV0YS5pZCA+IDEgJiYgY2h1bmtNZXRhLmlkID09PSAobGFzdEZyYWcgPT0gbnVsbCA/IHZvaWQgMCA6IGxhc3RGcmFnLnN0YXRzLmNodW5rQ291bnQpO1xuICAgIGNvbnN0IGNvbnRpZ3VvdXMgPSAhdHJhY2tTd2l0Y2ggJiYgKHNuRGlmZiA9PT0gMSB8fCBzbkRpZmYgPT09IDAgJiYgKHBhcnREaWZmID09PSAxIHx8IHByb2dyZXNzaXZlICYmIHBhcnREaWZmIDw9IDApKTtcbiAgICBjb25zdCBub3cgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGlmICh0cmFja1N3aXRjaCB8fCBzbkRpZmYgfHwgZnJhZy5zdGF0cy5wYXJzaW5nLnN0YXJ0ID09PSAwKSB7XG4gICAgICBmcmFnLnN0YXRzLnBhcnNpbmcuc3RhcnQgPSBub3c7XG4gICAgfVxuICAgIGlmIChwYXJ0ICYmIChwYXJ0RGlmZiB8fCAhY29udGlndW91cykpIHtcbiAgICAgIHBhcnQuc3RhdHMucGFyc2luZy5zdGFydCA9IG5vdztcbiAgICB9XG4gICAgY29uc3QgaW5pdFNlZ21lbnRDaGFuZ2UgPSAhKGxhc3RGcmFnICYmICgoX2ZyYWckaW5pdFNlZ21lbnQgPSBmcmFnLmluaXRTZWdtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2ZyYWckaW5pdFNlZ21lbnQudXJsKSA9PT0gKChfbGFzdEZyYWckaW5pdFNlZ21lbnQgPSBsYXN0RnJhZy5pbml0U2VnbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9sYXN0RnJhZyRpbml0U2VnbWVudC51cmwpKTtcbiAgICBjb25zdCBzdGF0ZSA9IG5ldyBUcmFuc211eFN0YXRlKGRpc2NvbnRpbnVpdHksIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCwgdHJhY2tTd2l0Y2gsIHRpbWVPZmZzZXQsIGluaXRTZWdtZW50Q2hhbmdlKTtcbiAgICBpZiAoIWNvbnRpZ3VvdXMgfHwgZGlzY29udGludWl0eSB8fCBpbml0U2VnbWVudENoYW5nZSkge1xuICAgICAgbG9nZ2VyLmxvZyhgW3RyYW5zbXV4ZXItaW50ZXJmYWNlLCAke2ZyYWcudHlwZX1dOiBTdGFydGluZyBuZXcgdHJhbnNtdXggc2Vzc2lvbiBmb3Igc246ICR7Y2h1bmtNZXRhLnNufSBwOiAke2NodW5rTWV0YS5wYXJ0fSBsZXZlbDogJHtjaHVua01ldGEubGV2ZWx9IGlkOiAke2NodW5rTWV0YS5pZH1cbiAgICAgICAgZGlzY29udGludWl0eTogJHtkaXNjb250aW51aXR5fVxuICAgICAgICB0cmFja1N3aXRjaDogJHt0cmFja1N3aXRjaH1cbiAgICAgICAgY29udGlndW91czogJHtjb250aWd1b3VzfVxuICAgICAgICBhY2N1cmF0ZVRpbWVPZmZzZXQ6ICR7YWNjdXJhdGVUaW1lT2Zmc2V0fVxuICAgICAgICB0aW1lT2Zmc2V0OiAke3RpbWVPZmZzZXR9XG4gICAgICAgIGluaXRTZWdtZW50Q2hhbmdlOiAke2luaXRTZWdtZW50Q2hhbmdlfWApO1xuICAgICAgY29uc3QgY29uZmlnID0gbmV3IFRyYW5zbXV4Q29uZmlnKGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGluaXRTZWdtZW50RGF0YSwgZHVyYXRpb24sIGRlZmF1bHRJbml0UFRTKTtcbiAgICAgIHRoaXMuY29uZmlndXJlVHJhbnNtdXhlcihjb25maWcpO1xuICAgIH1cbiAgICB0aGlzLmZyYWcgPSBmcmFnO1xuICAgIHRoaXMucGFydCA9IHBhcnQ7XG5cbiAgICAvLyBGcmFncyB3aXRoIHNuIG9mICdpbml0U2VnbWVudCcgYXJlIG5vdCB0cmFuc211eGVkXG4gICAgaWYgKHRoaXMud29ya2VyQ29udGV4dCkge1xuICAgICAgLy8gcG9zdCBmcmFnbWVudCBwYXlsb2FkIGFzIHRyYW5zZmVyYWJsZSBvYmplY3RzIGZvciBBcnJheUJ1ZmZlciAobm8gY29weSlcbiAgICAgIHRoaXMud29ya2VyQ29udGV4dC53b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBjbWQ6ICdkZW11eCcsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGRlY3J5cHRkYXRhLFxuICAgICAgICBjaHVua01ldGEsXG4gICAgICAgIHN0YXRlXG4gICAgICB9LCBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBbZGF0YV0gOiBbXSk7XG4gICAgfSBlbHNlIGlmICh0cmFuc211eGVyKSB7XG4gICAgICBjb25zdCB0cmFuc211eFJlc3VsdCA9IHRyYW5zbXV4ZXIucHVzaChkYXRhLCBkZWNyeXB0ZGF0YSwgY2h1bmtNZXRhLCBzdGF0ZSk7XG4gICAgICBpZiAoaXNQcm9taXNlKHRyYW5zbXV4UmVzdWx0KSkge1xuICAgICAgICB0cmFuc211eGVyLmFzeW5jID0gdHJ1ZTtcbiAgICAgICAgdHJhbnNtdXhSZXN1bHQudGhlbihkYXRhID0+IHtcbiAgICAgICAgICB0aGlzLmhhbmRsZVRyYW5zbXV4Q29tcGxldGUoZGF0YSk7XG4gICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICB0aGlzLnRyYW5zbXV4ZXJFcnJvcihlcnJvciwgY2h1bmtNZXRhLCAndHJhbnNtdXhlci1pbnRlcmZhY2UgcHVzaCBlcnJvcicpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zbXV4ZXIuYXN5bmMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYW5kbGVUcmFuc211eENvbXBsZXRlKHRyYW5zbXV4UmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZmx1c2goY2h1bmtNZXRhKSB7XG4gICAgY2h1bmtNZXRhLnRyYW5zbXV4aW5nLnN0YXJ0ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCB7XG4gICAgICB0cmFuc211eGVyXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKHRoaXMud29ya2VyQ29udGV4dCkge1xuICAgICAgdGhpcy53b3JrZXJDb250ZXh0Lndvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGNtZDogJ2ZsdXNoJyxcbiAgICAgICAgY2h1bmtNZXRhXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRyYW5zbXV4ZXIpIHtcbiAgICAgIGxldCB0cmFuc211eFJlc3VsdCA9IHRyYW5zbXV4ZXIuZmx1c2goY2h1bmtNZXRhKTtcbiAgICAgIGNvbnN0IGFzeW5jRmx1c2ggPSBpc1Byb21pc2UodHJhbnNtdXhSZXN1bHQpO1xuICAgICAgaWYgKGFzeW5jRmx1c2ggfHwgdHJhbnNtdXhlci5hc3luYykge1xuICAgICAgICBpZiAoIWlzUHJvbWlzZSh0cmFuc211eFJlc3VsdCkpIHtcbiAgICAgICAgICB0cmFuc211eFJlc3VsdCA9IFByb21pc2UucmVzb2x2ZSh0cmFuc211eFJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNtdXhSZXN1bHQudGhlbihkYXRhID0+IHtcbiAgICAgICAgICB0aGlzLmhhbmRsZUZsdXNoUmVzdWx0KGRhdGEsIGNodW5rTWV0YSk7XG4gICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICB0aGlzLnRyYW5zbXV4ZXJFcnJvcihlcnJvciwgY2h1bmtNZXRhLCAndHJhbnNtdXhlci1pbnRlcmZhY2UgZmx1c2ggZXJyb3InKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhbmRsZUZsdXNoUmVzdWx0KHRyYW5zbXV4UmVzdWx0LCBjaHVua01ldGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0cmFuc211eGVyRXJyb3IoZXJyb3IsIGNodW5rTWV0YSwgcmVhc29uKSB7XG4gICAgaWYgKCF0aGlzLmhscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLFxuICAgICAgY2h1bmtNZXRhLFxuICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgZXJyb3IsXG4gICAgICBlcnI6IGVycm9yLFxuICAgICAgcmVhc29uXG4gICAgfSk7XG4gIH1cbiAgaGFuZGxlRmx1c2hSZXN1bHQocmVzdWx0cywgY2h1bmtNZXRhKSB7XG4gICAgcmVzdWx0cy5mb3JFYWNoKHJlc3VsdCA9PiB7XG4gICAgICB0aGlzLmhhbmRsZVRyYW5zbXV4Q29tcGxldGUocmVzdWx0KTtcbiAgICB9KTtcbiAgICB0aGlzLm9uRmx1c2goY2h1bmtNZXRhKTtcbiAgfVxuICBvbldvcmtlck1lc3NhZ2UoZXYpIHtcbiAgICBjb25zdCBkYXRhID0gZXYuZGF0YTtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBzd2l0Y2ggKGRhdGEuZXZlbnQpIHtcbiAgICAgIGNhc2UgJ2luaXQnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF90aGlzJHdvcmtlckNvbnRleHQ7XG4gICAgICAgICAgY29uc3Qgb2JqZWN0VVJMID0gKF90aGlzJHdvcmtlckNvbnRleHQgPSB0aGlzLndvcmtlckNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyR3b3JrZXJDb250ZXh0Lm9iamVjdFVSTDtcbiAgICAgICAgICBpZiAob2JqZWN0VVJMKSB7XG4gICAgICAgICAgICAvLyByZXZva2UgdGhlIE9iamVjdCBVUkwgdGhhdCB3YXMgdXNlZCB0byBjcmVhdGUgdHJhbnNtdXhlciB3b3JrZXIsIHNvIGFzIG5vdCB0byBsZWFrIGl0XG4gICAgICAgICAgICBzZWxmLlVSTC5yZXZva2VPYmplY3RVUkwob2JqZWN0VVJMKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ3RyYW5zbXV4Q29tcGxldGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVUcmFuc211eENvbXBsZXRlKGRhdGEuZGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2ZsdXNoJzpcbiAgICAgICAge1xuICAgICAgICAgIHRoaXMub25GbHVzaChkYXRhLmRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIC8vIHBhc3MgbG9ncyBmcm9tIHRoZSB3b3JrZXIgdGhyZWFkIHRvIHRoZSBtYWluIGxvZ2dlclxuICAgICAgY2FzZSAnd29ya2VyTG9nJzpcbiAgICAgICAgaWYgKGxvZ2dlcltkYXRhLmRhdGEubG9nVHlwZV0pIHtcbiAgICAgICAgICBsb2dnZXJbZGF0YS5kYXRhLmxvZ1R5cGVdKGRhdGEuZGF0YS5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBkYXRhLmRhdGEgPSBkYXRhLmRhdGEgfHwge307XG4gICAgICAgICAgZGF0YS5kYXRhLmZyYWcgPSB0aGlzLmZyYWc7XG4gICAgICAgICAgZGF0YS5kYXRhLmlkID0gdGhpcy5pZDtcbiAgICAgICAgICBobHMudHJpZ2dlcihkYXRhLmV2ZW50LCBkYXRhLmRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICB9XG4gIGNvbmZpZ3VyZVRyYW5zbXV4ZXIoY29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHJhbnNtdXhlclxuICAgIH0gPSB0aGlzO1xuICAgIGlmICh0aGlzLndvcmtlckNvbnRleHQpIHtcbiAgICAgIHRoaXMud29ya2VyQ29udGV4dC53b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBjbWQ6ICdjb25maWd1cmUnLFxuICAgICAgICBjb25maWdcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHJhbnNtdXhlcikge1xuICAgICAgdHJhbnNtdXhlci5jb25maWd1cmUoY29uZmlnKTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlVHJhbnNtdXhDb21wbGV0ZShyZXN1bHQpIHtcbiAgICByZXN1bHQuY2h1bmtNZXRhLnRyYW5zbXV4aW5nLmVuZCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgdGhpcy5vblRyYW5zbXV4Q29tcGxldGUocmVzdWx0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdWJ0aXRsZU9wdGlvbnNJZGVudGljYWwodHJhY2tMaXN0MSwgdHJhY2tMaXN0Mikge1xuICBpZiAodHJhY2tMaXN0MS5sZW5ndGggIT09IHRyYWNrTGlzdDIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhY2tMaXN0MS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghbWVkaWFBdHRyaWJ1dGVzSWRlbnRpY2FsKHRyYWNrTGlzdDFbaV0uYXR0cnMsIHRyYWNrTGlzdDJbaV0uYXR0cnMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gbWVkaWFBdHRyaWJ1dGVzSWRlbnRpY2FsKGF0dHJzMSwgYXR0cnMyLCBjdXN0b21BdHRyaWJ1dGVzKSB7XG4gIC8vIE1lZGlhIG9wdGlvbnMgd2l0aCB0aGUgc2FtZSByZW5kaXRpb24gSUQgbXVzdCBiZSBiaXQgaWRlbnRpY2FsXG4gIGNvbnN0IHN0YWJsZVJlbmRpdGlvbklkID0gYXR0cnMxWydTVEFCTEUtUkVORElUSU9OLUlEJ107XG4gIGlmIChzdGFibGVSZW5kaXRpb25JZCAmJiAhY3VzdG9tQXR0cmlidXRlcykge1xuICAgIHJldHVybiBzdGFibGVSZW5kaXRpb25JZCA9PT0gYXR0cnMyWydTVEFCTEUtUkVORElUSU9OLUlEJ107XG4gIH1cbiAgLy8gV2hlbiByZW5kaXRpb24gSUQgaXMgbm90IHByZXNlbnQsIGNvbXBhcmUgYXR0cmlidXRlc1xuICByZXR1cm4gIShjdXN0b21BdHRyaWJ1dGVzIHx8IFsnTEFOR1VBR0UnLCAnTkFNRScsICdDSEFSQUNURVJJU1RJQ1MnLCAnQVVUT1NFTEVDVCcsICdERUZBVUxUJywgJ0ZPUkNFRCcsICdBU1NPQy1MQU5HVUFHRSddKS5zb21lKHN1YnRpdGxlQXR0cmlidXRlID0+IGF0dHJzMVtzdWJ0aXRsZUF0dHJpYnV0ZV0gIT09IGF0dHJzMltzdWJ0aXRsZUF0dHJpYnV0ZV0pO1xufVxuZnVuY3Rpb24gc3VidGl0bGVUcmFja01hdGNoZXNUZXh0VHJhY2soc3VidGl0bGVUcmFjaywgdGV4dFRyYWNrKSB7XG4gIHJldHVybiB0ZXh0VHJhY2subGFiZWwudG9Mb3dlckNhc2UoKSA9PT0gc3VidGl0bGVUcmFjay5uYW1lLnRvTG93ZXJDYXNlKCkgJiYgKCF0ZXh0VHJhY2subGFuZ3VhZ2UgfHwgdGV4dFRyYWNrLmxhbmd1YWdlLnRvTG93ZXJDYXNlKCkgPT09IChzdWJ0aXRsZVRyYWNrLmxhbmcgfHwgJycpLnRvTG93ZXJDYXNlKCkpO1xufVxuXG5jb25zdCBUSUNLX0lOVEVSVkFMJDIgPSAxMDA7IC8vIGhvdyBvZnRlbiB0byB0aWNrIGluIG1zXG5cbmNsYXNzIEF1ZGlvU3RyZWFtQ29udHJvbGxlciBleHRlbmRzIEJhc2VTdHJlYW1Db250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoaGxzLCBmcmFnbWVudFRyYWNrZXIsIGtleUxvYWRlcikge1xuICAgIHN1cGVyKGhscywgZnJhZ21lbnRUcmFja2VyLCBrZXlMb2FkZXIsICdbYXVkaW8tc3RyZWFtLWNvbnRyb2xsZXJdJywgUGxheWxpc3RMZXZlbFR5cGUuQVVESU8pO1xuICAgIHRoaXMudmlkZW9CdWZmZXIgPSBudWxsO1xuICAgIHRoaXMudmlkZW9UcmFja0NDID0gLTE7XG4gICAgdGhpcy53YWl0aW5nVmlkZW9DQyA9IC0xO1xuICAgIHRoaXMuYnVmZmVyZWRUcmFjayA9IG51bGw7XG4gICAgdGhpcy5zd2l0Y2hpbmdUcmFjayA9IG51bGw7XG4gICAgdGhpcy50cmFja0lkID0gLTE7XG4gICAgdGhpcy53YWl0aW5nRGF0YSA9IG51bGw7XG4gICAgdGhpcy5tYWluRGV0YWlscyA9IG51bGw7XG4gICAgdGhpcy5mbHVzaGluZyA9IGZhbHNlO1xuICAgIHRoaXMuYnVmZmVyRmx1c2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuY2FjaGVkVHJhY2tMb2FkZWREYXRhID0gbnVsbDtcbiAgICB0aGlzLl9yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIG9uSGFuZGxlckRlc3Ryb3lpbmcoKSB7XG4gICAgdGhpcy5fdW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHN1cGVyLm9uSGFuZGxlckRlc3Ryb3lpbmcoKTtcbiAgICB0aGlzLm1haW5EZXRhaWxzID0gbnVsbDtcbiAgICB0aGlzLmJ1ZmZlcmVkVHJhY2sgPSBudWxsO1xuICAgIHRoaXMuc3dpdGNoaW5nVHJhY2sgPSBudWxsO1xuICB9XG4gIF9yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkFVRElPX1RSQUNLU19VUERBVEVELCB0aGlzLm9uQXVkaW9UcmFja3NVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSElORywgdGhpcy5vbkF1ZGlvVHJhY2tTd2l0Y2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQVVESU9fVFJBQ0tfTE9BREVELCB0aGlzLm9uQXVkaW9UcmFja0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9SRVNFVCwgdGhpcy5vbkJ1ZmZlclJlc2V0LCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9DUkVBVEVELCB0aGlzLm9uQnVmZmVyQ3JlYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfRkxVU0hFRCwgdGhpcy5vbkJ1ZmZlckZsdXNoZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuSU5JVF9QVFNfRk9VTkQsIHRoaXMub25Jbml0UHRzRm91bmQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gIH1cbiAgX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkFVRElPX1RSQUNLU19VUERBVEVELCB0aGlzLm9uQXVkaW9UcmFja3NVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hJTkcsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5BVURJT19UUkFDS19MT0FERUQsIHRoaXMub25BdWRpb1RyYWNrTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfUkVTRVQsIHRoaXMub25CdWZmZXJSZXNldCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0NSRUFURUQsIHRoaXMub25CdWZmZXJDcmVhdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0ZMVVNIRUQsIHRoaXMub25CdWZmZXJGbHVzaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5JTklUX1BUU19GT1VORCwgdGhpcy5vbkluaXRQdHNGb3VuZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gIH1cblxuICAvLyBJTklUX1BUU19GT1VORCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgdmlkZW8gdHJhY2sgcGFyc2VkIGluIHRoZSBzdHJlYW0tY29udHJvbGxlciBoYXMgYSBuZXcgUFRTIHZhbHVlXG4gIG9uSW5pdFB0c0ZvdW5kKGV2ZW50LCB7XG4gICAgZnJhZyxcbiAgICBpZCxcbiAgICBpbml0UFRTLFxuICAgIHRpbWVzY2FsZVxuICB9KSB7XG4gICAgLy8gQWx3YXlzIHVwZGF0ZSB0aGUgbmV3IElOSVQgUFRTXG4gICAgLy8gQ2FuIGNoYW5nZSBkdWUgbGV2ZWwgc3dpdGNoXG4gICAgaWYgKGlkID09PSAnbWFpbicpIHtcbiAgICAgIGNvbnN0IGNjID0gZnJhZy5jYztcbiAgICAgIHRoaXMuaW5pdFBUU1tmcmFnLmNjXSA9IHtcbiAgICAgICAgYmFzZVRpbWU6IGluaXRQVFMsXG4gICAgICAgIHRpbWVzY2FsZVxuICAgICAgfTtcbiAgICAgIHRoaXMubG9nKGBJbml0UFRTIGZvciBjYzogJHtjY30gZm91bmQgZnJvbSBtYWluOiAke2luaXRQVFN9YCk7XG4gICAgICB0aGlzLnZpZGVvVHJhY2tDQyA9IGNjO1xuICAgICAgLy8gSWYgd2UgYXJlIHdhaXRpbmcsIHRpY2sgaW1tZWRpYXRlbHkgdG8gdW5ibG9jayBhdWRpbyBmcmFnbWVudCB0cmFuc211eGluZ1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLldBSVRJTkdfSU5JVF9QVFMpIHtcbiAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0YXJ0TG9hZChzdGFydFBvc2l0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmxldmVscykge1xuICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbjtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYXN0Q3VycmVudFRpbWUgPSB0aGlzLmxhc3RDdXJyZW50VGltZTtcbiAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgdGhpcy5zZXRJbnRlcnZhbChUSUNLX0lOVEVSVkFMJDIpO1xuICAgIGlmIChsYXN0Q3VycmVudFRpbWUgPiAwICYmIHN0YXJ0UG9zaXRpb24gPT09IC0xKSB7XG4gICAgICB0aGlzLmxvZyhgT3ZlcnJpZGUgc3RhcnRQb3NpdGlvbiB3aXRoIGxhc3RDdXJyZW50VGltZSBAJHtsYXN0Q3VycmVudFRpbWUudG9GaXhlZCgzKX1gKTtcbiAgICAgIHN0YXJ0UG9zaXRpb24gPSBsYXN0Q3VycmVudFRpbWU7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLldBSVRJTkdfVFJBQ0s7XG4gICAgfVxuICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gc3RhcnRQb3NpdGlvbjtcbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuICBkb1RpY2soKSB7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIFN0YXRlLklETEU6XG4gICAgICAgIHRoaXMuZG9UaWNrSWRsZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RhdGUuV0FJVElOR19UUkFDSzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfbGV2ZWxzJHRyYWNrSWQ7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgbGV2ZWxzLFxuICAgICAgICAgICAgdHJhY2tJZFxuICAgICAgICAgIH0gPSB0aGlzO1xuICAgICAgICAgIGNvbnN0IGRldGFpbHMgPSBsZXZlbHMgPT0gbnVsbCA/IHZvaWQgMCA6IChfbGV2ZWxzJHRyYWNrSWQgPSBsZXZlbHNbdHJhY2tJZF0pID09IG51bGwgPyB2b2lkIDAgOiBfbGV2ZWxzJHRyYWNrSWQuZGV0YWlscztcbiAgICAgICAgICBpZiAoZGV0YWlscykge1xuICAgICAgICAgICAgaWYgKHRoaXMud2FpdEZvckNkblR1bmVJbihkZXRhaWxzKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5XQUlUSU5HX0lOSVRfUFRTO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfdGhpcyRtZWRpYTtcbiAgICAgICAgICBjb25zdCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICBjb25zdCByZXRyeURhdGUgPSB0aGlzLnJldHJ5RGF0ZTtcbiAgICAgICAgICAvLyBpZiBjdXJyZW50IHRpbWUgaXMgZ3QgdGhhbiByZXRyeURhdGUsIG9yIGlmIG1lZGlhIHNlZWtpbmcgbGV0J3Mgc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gcmV0cnkgbG9hZGluZ1xuICAgICAgICAgIGlmICghcmV0cnlEYXRlIHx8IG5vdyA+PSByZXRyeURhdGUgfHwgKF90aGlzJG1lZGlhID0gdGhpcy5tZWRpYSkgIT0gbnVsbCAmJiBfdGhpcyRtZWRpYS5zZWVraW5nKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGxldmVscyxcbiAgICAgICAgICAgICAgdHJhY2tJZFxuICAgICAgICAgICAgfSA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmxvZygnUmV0cnlEYXRlIHJlYWNoZWQsIHN3aXRjaCBiYWNrIHRvIElETEUgc3RhdGUnKTtcbiAgICAgICAgICAgIHRoaXMucmVzZXRTdGFydFdoZW5Ob3RMb2FkZWQoKGxldmVscyA9PSBudWxsID8gdm9pZCAwIDogbGV2ZWxzW3RyYWNrSWRdKSB8fCBudWxsKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBTdGF0ZS5XQUlUSU5HX0lOSVRfUFRTOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gRW5zdXJlIHdlIGRvbid0IGdldCBzdHVjayBpbiB0aGUgV0FJVElOR19JTklUX1BUUyBzdGF0ZSBpZiB0aGUgd2FpdGluZyBmcmFnIENDIGRvZXNuJ3QgbWF0Y2ggYW55IGluaXRQVFNcbiAgICAgICAgICBjb25zdCB3YWl0aW5nRGF0YSA9IHRoaXMud2FpdGluZ0RhdGE7XG4gICAgICAgICAgaWYgKHdhaXRpbmdEYXRhKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgIHBhcnQsXG4gICAgICAgICAgICAgIGNhY2hlLFxuICAgICAgICAgICAgICBjb21wbGV0ZVxuICAgICAgICAgICAgfSA9IHdhaXRpbmdEYXRhO1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5pdFBUU1tmcmFnLmNjXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHRoaXMud2FpdGluZ0RhdGEgPSBudWxsO1xuICAgICAgICAgICAgICB0aGlzLndhaXRpbmdWaWRlb0NDID0gLTE7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkc7XG4gICAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBjYWNoZS5mbHVzaCgpO1xuICAgICAgICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgICAgcGFydCxcbiAgICAgICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBudWxsXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHRoaXMuX2hhbmRsZUZyYWdtZW50TG9hZFByb2dyZXNzKGRhdGEpO1xuICAgICAgICAgICAgICBpZiAoY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBzdXBlci5faGFuZGxlRnJhZ21lbnRMb2FkQ29tcGxldGUoZGF0YSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy52aWRlb1RyYWNrQ0MgIT09IHRoaXMud2FpdGluZ1ZpZGVvQ0MpIHtcbiAgICAgICAgICAgICAgLy8gRHJvcCB3YWl0aW5nIGZyYWdtZW50IGlmIHZpZGVvVHJhY2tDQyBoYXMgY2hhbmdlZCBzaW5jZSB3YWl0aW5nRnJhZ21lbnQgd2FzIHNldCBhbmQgaW5pdFBUUyB3YXMgbm90IGZvdW5kXG4gICAgICAgICAgICAgIHRoaXMubG9nKGBXYWl0aW5nIGZyYWdtZW50IGNjICgke2ZyYWcuY2N9KSBjYW5jZWxsZWQgYmVjYXVzZSB2aWRlbyBpcyBhdCBjYyAke3RoaXMudmlkZW9UcmFja0NDfWApO1xuICAgICAgICAgICAgICB0aGlzLmNsZWFyV2FpdGluZ0ZyYWdtZW50KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBEcm9wIHdhaXRpbmcgZnJhZ21lbnQgaWYgYW4gZWFybGllciBmcmFnbWVudCBpcyBuZWVkZWRcbiAgICAgICAgICAgICAgY29uc3QgcG9zID0gdGhpcy5nZXRMb2FkUG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgY29uc3QgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKHRoaXMubWVkaWFCdWZmZXIsIHBvcywgdGhpcy5jb25maWcubWF4QnVmZmVySG9sZSk7XG4gICAgICAgICAgICAgIGNvbnN0IHdhaXRpbmdGcmFnbWVudEF0UG9zaXRpb24gPSBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QoYnVmZmVySW5mby5lbmQsIHRoaXMuY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGZyYWcpO1xuICAgICAgICAgICAgICBpZiAod2FpdGluZ0ZyYWdtZW50QXRQb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZyhgV2FpdGluZyBmcmFnbWVudCBjYyAoJHtmcmFnLmNjfSkgQCAke2ZyYWcuc3RhcnR9IGNhbmNlbGxlZCBiZWNhdXNlIGFub3RoZXIgZnJhZ21lbnQgYXQgJHtidWZmZXJJbmZvLmVuZH0gaXMgbmVlZGVkYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhcldhaXRpbmdGcmFnbWVudCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm9uVGlja0VuZCgpO1xuICB9XG4gIGNsZWFyV2FpdGluZ0ZyYWdtZW50KCkge1xuICAgIGNvbnN0IHdhaXRpbmdEYXRhID0gdGhpcy53YWl0aW5nRGF0YTtcbiAgICBpZiAod2FpdGluZ0RhdGEpIHtcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KHdhaXRpbmdEYXRhLmZyYWcpO1xuICAgICAgdGhpcy53YWl0aW5nRGF0YSA9IG51bGw7XG4gICAgICB0aGlzLndhaXRpbmdWaWRlb0NDID0gLTE7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICB9XG4gIH1cbiAgcmVzZXRMb2FkaW5nU3RhdGUoKSB7XG4gICAgdGhpcy5jbGVhcldhaXRpbmdGcmFnbWVudCgpO1xuICAgIHN1cGVyLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gIH1cbiAgb25UaWNrRW5kKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lZGlhXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCEobWVkaWEgIT0gbnVsbCAmJiBtZWRpYS5yZWFkeVN0YXRlKSkge1xuICAgICAgLy8gRXhpdCBlYXJseSBpZiB3ZSBkb24ndCBoYXZlIG1lZGlhIG9yIGlmIHRoZSBtZWRpYSBoYXNuJ3QgYnVmZmVyZWQgYW55dGhpbmcgeWV0IChyZWFkeVN0YXRlIDApXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gIH1cbiAgZG9UaWNrSWRsZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHMsXG4gICAgICBsZXZlbHMsXG4gICAgICBtZWRpYSxcbiAgICAgIHRyYWNrSWRcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBjb25maWcgPSBobHMuY29uZmlnO1xuXG4gICAgLy8gMS4gaWYgdmlkZW8gbm90IGF0dGFjaGVkIEFORFxuICAgIC8vICAgIHN0YXJ0IGZyYWdtZW50IGFscmVhZHkgcmVxdWVzdGVkIE9SIHN0YXJ0IGZyYWcgcHJlZmV0Y2ggbm90IGVuYWJsZWRcbiAgICAvLyAyLiBpZiB0cmFja3Mgb3IgdHJhY2sgbm90IGxvYWRlZCBhbmQgc2VsZWN0ZWRcbiAgICAvLyB0aGVuIGV4aXQgbG9vcFxuICAgIC8vID0+IGlmIG1lZGlhIG5vdCBhdHRhY2hlZCBidXQgc3RhcnQgZnJhZyBwcmVmZXRjaCBpcyBlbmFibGVkIGFuZCBzdGFydCBmcmFnIG5vdCByZXF1ZXN0ZWQgeWV0LCB3ZSB3aWxsIG5vdCBleGl0IGxvb3BcbiAgICBpZiAoIW1lZGlhICYmICh0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCB8fCAhY29uZmlnLnN0YXJ0RnJhZ1ByZWZldGNoKSB8fCAhKGxldmVscyAhPSBudWxsICYmIGxldmVsc1t0cmFja0lkXSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGV2ZWxJbmZvID0gbGV2ZWxzW3RyYWNrSWRdO1xuICAgIGNvbnN0IHRyYWNrRGV0YWlscyA9IGxldmVsSW5mby5kZXRhaWxzO1xuICAgIGlmICghdHJhY2tEZXRhaWxzIHx8IHRyYWNrRGV0YWlscy5saXZlICYmIHRoaXMubGV2ZWxMYXN0TG9hZGVkICE9PSBsZXZlbEluZm8gfHwgdGhpcy53YWl0Rm9yQ2RuVHVuZUluKHRyYWNrRGV0YWlscykpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5XQUlUSU5HX1RSQUNLO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBidWZmZXJhYmxlID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhO1xuICAgIGlmICh0aGlzLmJ1ZmZlckZsdXNoZWQgJiYgYnVmZmVyYWJsZSkge1xuICAgICAgdGhpcy5idWZmZXJGbHVzaGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmFmdGVyQnVmZmVyRmx1c2hlZChidWZmZXJhYmxlLCBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU8sIFBsYXlsaXN0TGV2ZWxUeXBlLkFVRElPKTtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVySW5mbyA9IHRoaXMuZ2V0RndkQnVmZmVySW5mbyhidWZmZXJhYmxlLCBQbGF5bGlzdExldmVsVHlwZS5BVURJTyk7XG4gICAgaWYgKGJ1ZmZlckluZm8gPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYnVmZmVyZWRUcmFjayxcbiAgICAgIHN3aXRjaGluZ1RyYWNrXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFzd2l0Y2hpbmdUcmFjayAmJiB0aGlzLl9zdHJlYW1FbmRlZChidWZmZXJJbmZvLCB0cmFja0RldGFpbHMpKSB7XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0VPUywge1xuICAgICAgICB0eXBlOiAnYXVkaW8nXG4gICAgICB9KTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FTkRFRDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWFpbkJ1ZmZlckluZm8gPSB0aGlzLmdldEZ3ZEJ1ZmZlckluZm8odGhpcy52aWRlb0J1ZmZlciA/IHRoaXMudmlkZW9CdWZmZXIgOiB0aGlzLm1lZGlhLCBQbGF5bGlzdExldmVsVHlwZS5NQUlOKTtcbiAgICBjb25zdCBidWZmZXJMZW4gPSBidWZmZXJJbmZvLmxlbjtcbiAgICBjb25zdCBtYXhCdWZMZW4gPSB0aGlzLmdldE1heEJ1ZmZlckxlbmd0aChtYWluQnVmZmVySW5mbyA9PSBudWxsID8gdm9pZCAwIDogbWFpbkJ1ZmZlckluZm8ubGVuKTtcbiAgICBjb25zdCBmcmFnbWVudHMgPSB0cmFja0RldGFpbHMuZnJhZ21lbnRzO1xuICAgIGNvbnN0IHN0YXJ0ID0gZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgIGxldCB0YXJnZXRCdWZmZXJUaW1lID0gdGhpcy5mbHVzaGluZyA/IHRoaXMuZ2V0TG9hZFBvc2l0aW9uKCkgOiBidWZmZXJJbmZvLmVuZDtcbiAgICBpZiAoc3dpdGNoaW5nVHJhY2sgJiYgbWVkaWEpIHtcbiAgICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0TG9hZFBvc2l0aW9uKCk7XG4gICAgICAvLyBTVEFCTEVcbiAgICAgIGlmIChidWZmZXJlZFRyYWNrICYmICFtZWRpYUF0dHJpYnV0ZXNJZGVudGljYWwoc3dpdGNoaW5nVHJhY2suYXR0cnMsIGJ1ZmZlcmVkVHJhY2suYXR0cnMpKSB7XG4gICAgICAgIHRhcmdldEJ1ZmZlclRpbWUgPSBwb3M7XG4gICAgICB9XG4gICAgICAvLyBpZiBjdXJyZW50VGltZSAocG9zKSBpcyBsZXNzIHRoYW4gYWx0IGF1ZGlvIHBsYXlsaXN0IHN0YXJ0IHRpbWUsIGl0IG1lYW5zIHRoYXQgYWx0IGF1ZGlvIGlzIGFoZWFkIG9mIGN1cnJlbnRUaW1lXG4gICAgICBpZiAodHJhY2tEZXRhaWxzLlBUU0tub3duICYmIHBvcyA8IHN0YXJ0KSB7XG4gICAgICAgIC8vIGlmIGV2ZXJ5dGhpbmcgaXMgYnVmZmVyZWQgZnJvbSBwb3MgdG8gc3RhcnQgb3IgaWYgYXVkaW8gYnVmZmVyIHVwZnJvbnQsIGxldCdzIHNlZWsgdG8gc3RhcnRcbiAgICAgICAgaWYgKGJ1ZmZlckluZm8uZW5kID4gc3RhcnQgfHwgYnVmZmVySW5mby5uZXh0U3RhcnQpIHtcbiAgICAgICAgICB0aGlzLmxvZygnQWx0IGF1ZGlvIHRyYWNrIGFoZWFkIG9mIG1haW4gdHJhY2ssIHNlZWsgdG8gc3RhcnQgb2YgYWx0IGF1ZGlvIHRyYWNrJyk7XG4gICAgICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSBzdGFydCArIDAuMDU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiBidWZmZXIgbGVuZ3RoIGlzIGxlc3MgdGhhbiBtYXhCdWZMZW4sIG9yIG5lYXIgdGhlIGVuZCwgZmluZCBhIGZyYWdtZW50IHRvIGxvYWRcbiAgICBpZiAoYnVmZmVyTGVuID49IG1heEJ1ZkxlbiAmJiAhc3dpdGNoaW5nVHJhY2sgJiYgdGFyZ2V0QnVmZmVyVGltZSA8IGZyYWdtZW50c1tmcmFnbWVudHMubGVuZ3RoIC0gMV0uc3RhcnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGZyYWcgPSB0aGlzLmdldE5leHRGcmFnbWVudCh0YXJnZXRCdWZmZXJUaW1lLCB0cmFja0RldGFpbHMpO1xuICAgIGxldCBhdEdhcCA9IGZhbHNlO1xuICAgIC8vIEF2b2lkIGxvb3AgbG9hZGluZyBieSB1c2luZyBuZXh0TG9hZFBvc2l0aW9uIHNldCBmb3IgYmFja3RyYWNraW5nIGFuZCBza2lwcGluZyBjb25zZWN1dGl2ZSBHQVAgdGFnc1xuICAgIGlmIChmcmFnICYmIHRoaXMuaXNMb29wTG9hZGluZyhmcmFnLCB0YXJnZXRCdWZmZXJUaW1lKSkge1xuICAgICAgYXRHYXAgPSAhIWZyYWcuZ2FwO1xuICAgICAgZnJhZyA9IHRoaXMuZ2V0TmV4dEZyYWdtZW50TG9vcExvYWRpbmcoZnJhZywgdHJhY2tEZXRhaWxzLCBidWZmZXJJbmZvLCBQbGF5bGlzdExldmVsVHlwZS5NQUlOLCBtYXhCdWZMZW4pO1xuICAgIH1cbiAgICBpZiAoIWZyYWcpIHtcbiAgICAgIHRoaXMuYnVmZmVyRmx1c2hlZCA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQnVmZmVyIGF1ZGlvIHVwIHRvIG9uZSB0YXJnZXQgZHVyYXRpb24gYWhlYWQgb2YgbWFpbiBidWZmZXJcbiAgICBjb25zdCBhdEJ1ZmZlclN5bmNMaW1pdCA9IG1haW5CdWZmZXJJbmZvICYmIGZyYWcuc3RhcnQgPiBtYWluQnVmZmVySW5mby5lbmQgKyB0cmFja0RldGFpbHMudGFyZ2V0ZHVyYXRpb247XG4gICAgaWYgKGF0QnVmZmVyU3luY0xpbWl0IHx8XG4gICAgLy8gT3Igd2FpdCBmb3IgbWFpbiBidWZmZXIgYWZ0ZXIgYnVmZmluZyBzb21lIGF1ZGlvXG4gICAgIShtYWluQnVmZmVySW5mbyAhPSBudWxsICYmIG1haW5CdWZmZXJJbmZvLmxlbikgJiYgYnVmZmVySW5mby5sZW4pIHtcbiAgICAgIC8vIENoZWNrIGZyYWdtZW50LXRyYWNrZXIgZm9yIG1haW4gZnJhZ21lbnRzIHNpbmNlIEdBUCBzZWdtZW50cyBkbyBub3Qgc2hvdyB1cCBpbiBidWZmZXJJbmZvXG4gICAgICBjb25zdCBtYWluRnJhZyA9IHRoaXMuZ2V0QXBwZW5kZWRGcmFnKGZyYWcuc3RhcnQsIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pO1xuICAgICAgaWYgKG1haW5GcmFnID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIEJyaWRnZSBnYXBzIGluIG1haW4gYnVmZmVyXG4gICAgICBhdEdhcCB8fCAoYXRHYXAgPSAhIW1haW5GcmFnLmdhcCB8fCAhIWF0QnVmZmVyU3luY0xpbWl0ICYmIG1haW5CdWZmZXJJbmZvLmxlbiA9PT0gMCk7XG4gICAgICBpZiAoYXRCdWZmZXJTeW5jTGltaXQgJiYgIWF0R2FwIHx8IGF0R2FwICYmIGJ1ZmZlckluZm8ubmV4dFN0YXJ0ICYmIGJ1ZmZlckluZm8ubmV4dFN0YXJ0IDwgbWFpbkZyYWcuZW5kKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sb2FkRnJhZ21lbnQoZnJhZywgbGV2ZWxJbmZvLCB0YXJnZXRCdWZmZXJUaW1lKTtcbiAgfVxuICBnZXRNYXhCdWZmZXJMZW5ndGgobWFpbkJ1ZmZlckxlbmd0aCkge1xuICAgIGNvbnN0IG1heENvbmZpZ0J1ZmZlciA9IHN1cGVyLmdldE1heEJ1ZmZlckxlbmd0aCgpO1xuICAgIGlmICghbWFpbkJ1ZmZlckxlbmd0aCkge1xuICAgICAgcmV0dXJuIG1heENvbmZpZ0J1ZmZlcjtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG1heENvbmZpZ0J1ZmZlciwgbWFpbkJ1ZmZlckxlbmd0aCksIHRoaXMuY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCk7XG4gIH1cbiAgb25NZWRpYURldGFjaGluZygpIHtcbiAgICB0aGlzLnZpZGVvQnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmJ1ZmZlckZsdXNoZWQgPSB0aGlzLmZsdXNoaW5nID0gZmFsc2U7XG4gICAgc3VwZXIub25NZWRpYURldGFjaGluZygpO1xuICB9XG4gIG9uQXVkaW9UcmFja3NVcGRhdGVkKGV2ZW50LCB7XG4gICAgYXVkaW9UcmFja3NcbiAgfSkge1xuICAgIC8vIFJlc2V0IHRyYW54bXV4ZXIgaXMgZXNzZW50aWFsIGZvciBsYXJnZSBjb250ZXh0IHN3aXRjaGVzIChDb250ZW50IFN0ZWVyaW5nKVxuICAgIHRoaXMucmVzZXRUcmFuc211eGVyKCk7XG4gICAgdGhpcy5sZXZlbHMgPSBhdWRpb1RyYWNrcy5tYXAobWVkaWFQbGF5bGlzdCA9PiBuZXcgTGV2ZWwobWVkaWFQbGF5bGlzdCkpO1xuICB9XG4gIG9uQXVkaW9UcmFja1N3aXRjaGluZyhldmVudCwgZGF0YSkge1xuICAgIC8vIGlmIGFueSBVUkwgZm91bmQgb24gbmV3IGF1ZGlvIHRyYWNrLCBpdCBpcyBhbiBhbHRlcm5hdGUgYXVkaW8gdHJhY2tcbiAgICBjb25zdCBhbHRBdWRpbyA9ICEhZGF0YS51cmw7XG4gICAgdGhpcy50cmFja0lkID0gZGF0YS5pZDtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnQ3VycmVudFxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChmcmFnQ3VycmVudCkge1xuICAgICAgZnJhZ0N1cnJlbnQuYWJvcnRSZXF1ZXN0cygpO1xuICAgICAgdGhpcy5yZW1vdmVVbmJ1ZmZlcmVkRnJhZ3MoZnJhZ0N1cnJlbnQuc3RhcnQpO1xuICAgIH1cbiAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgLy8gZGVzdHJveSB1c2VsZXNzIHRyYW5zbXV4ZXIgd2hlbiBzd2l0Y2hpbmcgYXVkaW8gdG8gbWFpblxuICAgIGlmICghYWx0QXVkaW8pIHtcbiAgICAgIHRoaXMucmVzZXRUcmFuc211eGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHN3aXRjaGluZyB0byBhdWRpbyB0cmFjaywgc3RhcnQgdGltZXIgaWYgbm90IGFscmVhZHkgc3RhcnRlZFxuICAgICAgdGhpcy5zZXRJbnRlcnZhbChUSUNLX0lOVEVSVkFMJDIpO1xuICAgIH1cblxuICAgIC8vIHNob3VsZCB3ZSBzd2l0Y2ggdHJhY2tzID9cbiAgICBpZiAoYWx0QXVkaW8pIHtcbiAgICAgIHRoaXMuc3dpdGNoaW5nVHJhY2sgPSBkYXRhO1xuICAgICAgLy8gbWFpbiBhdWRpbyB0cmFjayBhcmUgaGFuZGxlZCBieSBzdHJlYW0tY29udHJvbGxlciwganVzdCBkbyBzb21ldGhpbmcgaWYgc3dpdGNoaW5nIHRvIGFsdCBhdWRpbyB0cmFja1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB0aGlzLmZsdXNoQXVkaW9JZk5lZWRlZChkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zd2l0Y2hpbmdUcmFjayA9IG51bGw7XG4gICAgICB0aGlzLmJ1ZmZlcmVkVHJhY2sgPSBkYXRhO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gICAgfVxuICAgIHRoaXMudGljaygpO1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUFsbEZyYWdtZW50cygpO1xuICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgICB0aGlzLmJ1ZmZlckZsdXNoZWQgPSB0aGlzLmZsdXNoaW5nID0gZmFsc2U7XG4gICAgdGhpcy5sZXZlbHMgPSB0aGlzLm1haW5EZXRhaWxzID0gdGhpcy53YWl0aW5nRGF0YSA9IHRoaXMuYnVmZmVyZWRUcmFjayA9IHRoaXMuY2FjaGVkVHJhY2tMb2FkZWREYXRhID0gdGhpcy5zd2l0Y2hpbmdUcmFjayA9IG51bGw7XG4gICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnRyYWNrSWQgPSB0aGlzLnZpZGVvVHJhY2tDQyA9IHRoaXMud2FpdGluZ1ZpZGVvQ0MgPSAtMTtcbiAgfVxuICBvbkxldmVsTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5tYWluRGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICBpZiAodGhpcy5jYWNoZWRUcmFja0xvYWRlZERhdGEgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkFVRElPX1RSQUNLX0xPQURFRCwgdGhpcy5jYWNoZWRUcmFja0xvYWRlZERhdGEpO1xuICAgICAgdGhpcy5jYWNoZWRUcmFja0xvYWRlZERhdGEgPSBudWxsO1xuICAgIH1cbiAgfVxuICBvbkF1ZGlvVHJhY2tMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgX3RyYWNrJGRldGFpbHM7XG4gICAgaWYgKHRoaXMubWFpbkRldGFpbHMgPT0gbnVsbCkge1xuICAgICAgdGhpcy5jYWNoZWRUcmFja0xvYWRlZERhdGEgPSBkYXRhO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBsZXZlbHNcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBkZXRhaWxzOiBuZXdEZXRhaWxzLFxuICAgICAgaWQ6IHRyYWNrSWRcbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoIWxldmVscykge1xuICAgICAgdGhpcy53YXJuKGBBdWRpbyB0cmFja3Mgd2VyZSByZXNldCB3aGlsZSBsb2FkaW5nIGxldmVsICR7dHJhY2tJZH1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sb2coYEF1ZGlvIHRyYWNrICR7dHJhY2tJZH0gbG9hZGVkIFske25ld0RldGFpbHMuc3RhcnRTTn0sJHtuZXdEZXRhaWxzLmVuZFNOfV0ke25ld0RldGFpbHMubGFzdFBhcnRTbiA/IGBbcGFydC0ke25ld0RldGFpbHMubGFzdFBhcnRTbn0tJHtuZXdEZXRhaWxzLmxhc3RQYXJ0SW5kZXh9XWAgOiAnJ30sZHVyYXRpb246JHtuZXdEZXRhaWxzLnRvdGFsZHVyYXRpb259YCk7XG4gICAgY29uc3QgdHJhY2sgPSBsZXZlbHNbdHJhY2tJZF07XG4gICAgbGV0IHNsaWRpbmcgPSAwO1xuICAgIGlmIChuZXdEZXRhaWxzLmxpdmUgfHwgKF90cmFjayRkZXRhaWxzID0gdHJhY2suZGV0YWlscykgIT0gbnVsbCAmJiBfdHJhY2skZGV0YWlscy5saXZlKSB7XG4gICAgICB0aGlzLmNoZWNrTGl2ZVVwZGF0ZShuZXdEZXRhaWxzKTtcbiAgICAgIGNvbnN0IG1haW5EZXRhaWxzID0gdGhpcy5tYWluRGV0YWlscztcbiAgICAgIGlmIChuZXdEZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkIHx8ICFtYWluRGV0YWlscykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRyYWNrLmRldGFpbHMgJiYgbmV3RGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUgJiYgbWFpbkRldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBvdXIgYXVkaW8gcmVuZGl0aW9uIGlzIGFsaWduZWQgd2l0aCB0aGUgXCJtYWluXCIgcmVuZGl0aW9uLCB1c2luZ1xuICAgICAgICAvLyBwZHQgYXMgb3VyIHJlZmVyZW5jZSB0aW1lcy5cbiAgICAgICAgYWxpZ25NZWRpYVBsYXlsaXN0QnlQRFQobmV3RGV0YWlscywgbWFpbkRldGFpbHMpO1xuICAgICAgICBzbGlkaW5nID0gbmV3RGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX3RoaXMkbGV2ZWxMYXN0TG9hZGVkO1xuICAgICAgICBzbGlkaW5nID0gdGhpcy5hbGlnblBsYXlsaXN0cyhuZXdEZXRhaWxzLCB0cmFjay5kZXRhaWxzLCAoX3RoaXMkbGV2ZWxMYXN0TG9hZGVkID0gdGhpcy5sZXZlbExhc3RMb2FkZWQpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRsZXZlbExhc3RMb2FkZWQuZGV0YWlscyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRyYWNrLmRldGFpbHMgPSBuZXdEZXRhaWxzO1xuICAgIHRoaXMubGV2ZWxMYXN0TG9hZGVkID0gdHJhY2s7XG5cbiAgICAvLyBjb21wdXRlIHN0YXJ0IHBvc2l0aW9uIGlmIHdlIGFyZSBhbGlnbmVkIHdpdGggdGhlIG1haW4gcGxheWxpc3RcbiAgICBpZiAoIXRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkICYmICh0aGlzLm1haW5EZXRhaWxzIHx8ICFuZXdEZXRhaWxzLmxpdmUpKSB7XG4gICAgICB0aGlzLnNldFN0YXJ0UG9zaXRpb24odGhpcy5tYWluRGV0YWlscyB8fCBuZXdEZXRhaWxzLCBzbGlkaW5nKTtcbiAgICB9XG4gICAgLy8gb25seSBzd2l0Y2ggYmFjayB0byBJRExFIHN0YXRlIGlmIHdlIHdlcmUgd2FpdGluZyBmb3IgdHJhY2sgdG8gc3RhcnQgZG93bmxvYWRpbmcgYSBuZXcgZnJhZ21lbnRcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19UUkFDSyAmJiAhdGhpcy53YWl0Rm9yQ2RuVHVuZUluKG5ld0RldGFpbHMpKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICB9XG5cbiAgICAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgdGhpcy50aWNrKCk7XG4gIH1cbiAgX2hhbmRsZUZyYWdtZW50TG9hZFByb2dyZXNzKGRhdGEpIHtcbiAgICB2YXIgX2ZyYWckaW5pdFNlZ21lbnQ7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIHBhcnQsXG4gICAgICBwYXlsb2FkXG4gICAgfSA9IGRhdGE7XG4gICAgY29uc3Qge1xuICAgICAgY29uZmlnLFxuICAgICAgdHJhY2tJZCxcbiAgICAgIGxldmVsc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmICghbGV2ZWxzKSB7XG4gICAgICB0aGlzLndhcm4oYEF1ZGlvIHRyYWNrcyB3ZXJlIHJlc2V0IHdoaWxlIGZyYWdtZW50IGxvYWQgd2FzIGluIHByb2dyZXNzLiBGcmFnbWVudCAke2ZyYWcuc259IG9mIGxldmVsICR7ZnJhZy5sZXZlbH0gd2lsbCBub3QgYmUgYnVmZmVyZWRgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdHJhY2sgPSBsZXZlbHNbdHJhY2tJZF07XG4gICAgaWYgKCF0cmFjaykge1xuICAgICAgdGhpcy53YXJuKCdBdWRpbyB0cmFjayBpcyB1bmRlZmluZWQgb24gZnJhZ21lbnQgbG9hZCBwcm9ncmVzcycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkZXRhaWxzID0gdHJhY2suZGV0YWlscztcbiAgICBpZiAoIWRldGFpbHMpIHtcbiAgICAgIHRoaXMud2FybignQXVkaW8gdHJhY2sgZGV0YWlscyB1bmRlZmluZWQgb24gZnJhZ21lbnQgbG9hZCBwcm9ncmVzcycpO1xuICAgICAgdGhpcy5yZW1vdmVVbmJ1ZmZlcmVkRnJhZ3MoZnJhZy5zdGFydCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGF1ZGlvQ29kZWMgPSBjb25maWcuZGVmYXVsdEF1ZGlvQ29kZWMgfHwgdHJhY2suYXVkaW9Db2RlYyB8fCAnbXA0YS40MC4yJztcbiAgICBsZXQgdHJhbnNtdXhlciA9IHRoaXMudHJhbnNtdXhlcjtcbiAgICBpZiAoIXRyYW5zbXV4ZXIpIHtcbiAgICAgIHRyYW5zbXV4ZXIgPSB0aGlzLnRyYW5zbXV4ZXIgPSBuZXcgVHJhbnNtdXhlckludGVyZmFjZSh0aGlzLmhscywgUGxheWxpc3RMZXZlbFR5cGUuQVVESU8sIHRoaXMuX2hhbmRsZVRyYW5zbXV4Q29tcGxldGUuYmluZCh0aGlzKSwgdGhpcy5faGFuZGxlVHJhbnNtdXhlckZsdXNoLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgdmlkZW8gaW5pdFBUU1xuICAgIC8vIElmIG5vdCB3ZSBuZWVkIHRvIHdhaXQgZm9yIGl0XG4gICAgY29uc3QgaW5pdFBUUyA9IHRoaXMuaW5pdFBUU1tmcmFnLmNjXTtcbiAgICBjb25zdCBpbml0U2VnbWVudERhdGEgPSAoX2ZyYWckaW5pdFNlZ21lbnQgPSBmcmFnLmluaXRTZWdtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2ZyYWckaW5pdFNlZ21lbnQuZGF0YTtcbiAgICBpZiAoaW5pdFBUUyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyB0aGlzLmxvZyhgVHJhbnNtdXhpbmcgJHtzbn0gb2YgWyR7ZGV0YWlscy5zdGFydFNOfSAsJHtkZXRhaWxzLmVuZFNOfV0sdHJhY2sgJHt0cmFja0lkfWApO1xuICAgICAgLy8gdGltZSBPZmZzZXQgaXMgYWNjdXJhdGUgaWYgbGV2ZWwgUFRTIGlzIGtub3duLCBvciBpZiBwbGF5bGlzdCBpcyBub3Qgc2xpZGluZyAobm90IGxpdmUpXG4gICAgICBjb25zdCBhY2N1cmF0ZVRpbWVPZmZzZXQgPSBmYWxzZTsgLy8gZGV0YWlscy5QVFNLbm93biB8fCAhZGV0YWlscy5saXZlO1xuICAgICAgY29uc3QgcGFydEluZGV4ID0gcGFydCA/IHBhcnQuaW5kZXggOiAtMTtcbiAgICAgIGNvbnN0IHBhcnRpYWwgPSBwYXJ0SW5kZXggIT09IC0xO1xuICAgICAgY29uc3QgY2h1bmtNZXRhID0gbmV3IENodW5rTWV0YWRhdGEoZnJhZy5sZXZlbCwgZnJhZy5zbiwgZnJhZy5zdGF0cy5jaHVua0NvdW50LCBwYXlsb2FkLmJ5dGVMZW5ndGgsIHBhcnRJbmRleCwgcGFydGlhbCk7XG4gICAgICB0cmFuc211eGVyLnB1c2gocGF5bG9hZCwgaW5pdFNlZ21lbnREYXRhLCBhdWRpb0NvZGVjLCAnJywgZnJhZywgcGFydCwgZGV0YWlscy50b3RhbGR1cmF0aW9uLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGNodW5rTWV0YSwgaW5pdFBUUyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nKGBVbmtub3duIHZpZGVvIFBUUyBmb3IgY2MgJHtmcmFnLmNjfSwgd2FpdGluZyBmb3IgdmlkZW8gUFRTIGJlZm9yZSBkZW11eGluZyBhdWRpbyBmcmFnICR7ZnJhZy5zbn0gb2YgWyR7ZGV0YWlscy5zdGFydFNOfSAsJHtkZXRhaWxzLmVuZFNOfV0sdHJhY2sgJHt0cmFja0lkfWApO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjYWNoZVxuICAgICAgfSA9IHRoaXMud2FpdGluZ0RhdGEgPSB0aGlzLndhaXRpbmdEYXRhIHx8IHtcbiAgICAgICAgZnJhZyxcbiAgICAgICAgcGFydCxcbiAgICAgICAgY2FjaGU6IG5ldyBDaHVua0NhY2hlKCksXG4gICAgICAgIGNvbXBsZXRlOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGNhY2hlLnB1c2gobmV3IFVpbnQ4QXJyYXkocGF5bG9hZCkpO1xuICAgICAgdGhpcy53YWl0aW5nVmlkZW9DQyA9IHRoaXMudmlkZW9UcmFja0NDO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLldBSVRJTkdfSU5JVF9QVFM7XG4gICAgfVxuICB9XG4gIF9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZShmcmFnTG9hZGVkRGF0YSkge1xuICAgIGlmICh0aGlzLndhaXRpbmdEYXRhKSB7XG4gICAgICB0aGlzLndhaXRpbmdEYXRhLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIuX2hhbmRsZUZyYWdtZW50TG9hZENvbXBsZXRlKGZyYWdMb2FkZWREYXRhKTtcbiAgfVxuICBvbkJ1ZmZlclJlc2V0KCAvKiBldmVudDogRXZlbnRzLkJVRkZFUl9SRVNFVCAqL1xuICApIHtcbiAgICAvLyByZXNldCByZWZlcmVuY2UgdG8gc291cmNlYnVmZmVyc1xuICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLnZpZGVvQnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XG4gIH1cbiAgb25CdWZmZXJDcmVhdGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3QgYXVkaW9UcmFjayA9IGRhdGEudHJhY2tzLmF1ZGlvO1xuICAgIGlmIChhdWRpb1RyYWNrKSB7XG4gICAgICB0aGlzLm1lZGlhQnVmZmVyID0gYXVkaW9UcmFjay5idWZmZXIgfHwgbnVsbDtcbiAgICB9XG4gICAgaWYgKGRhdGEudHJhY2tzLnZpZGVvKSB7XG4gICAgICB0aGlzLnZpZGVvQnVmZmVyID0gZGF0YS50cmFja3MudmlkZW8uYnVmZmVyIHx8IG51bGw7XG4gICAgfVxuICB9XG4gIG9uRnJhZ0J1ZmZlcmVkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIHBhcnRcbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoZnJhZy50eXBlICE9PSBQbGF5bGlzdExldmVsVHlwZS5BVURJTykge1xuICAgICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhICYmIGZyYWcudHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTikge1xuICAgICAgICBjb25zdCBidWZmZXJhYmxlID0gdGhpcy52aWRlb0J1ZmZlciB8fCB0aGlzLm1lZGlhO1xuICAgICAgICBpZiAoYnVmZmVyYWJsZSkge1xuICAgICAgICAgIGNvbnN0IGJ1ZmZlcmVkVGltZVJhbmdlcyA9IEJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZChidWZmZXJhYmxlKTtcbiAgICAgICAgICBpZiAoYnVmZmVyZWRUaW1lUmFuZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgLy8gSWYgYSBsZXZlbCBzd2l0Y2ggd2FzIHJlcXVlc3RlZCB3aGlsZSBhIGZyYWdtZW50IHdhcyBidWZmZXJpbmcsIGl0IHdpbGwgZW1pdCB0aGUgRlJBR19CVUZGRVJFRCBldmVudCB1cG9uIGNvbXBsZXRpb25cbiAgICAgIC8vIEF2b2lkIHNldHRpbmcgc3RhdGUgYmFjayB0byBJRExFIG9yIGNvbmNsdWRpbmcgdGhlIGF1ZGlvIHN3aXRjaDsgb3RoZXJ3aXNlLCB0aGUgc3dpdGNoZWQtdG8gdHJhY2sgd2lsbCBub3QgYnVmZmVyXG4gICAgICB0aGlzLndhcm4oYEZyYWdtZW50ICR7ZnJhZy5zbn0ke3BhcnQgPyAnIHA6ICcgKyBwYXJ0LmluZGV4IDogJyd9IG9mIGxldmVsICR7ZnJhZy5sZXZlbH0gZmluaXNoZWQgYnVmZmVyaW5nLCBidXQgd2FzIGFib3J0ZWQuIHN0YXRlOiAke3RoaXMuc3RhdGV9LCBhdWRpb1N3aXRjaDogJHt0aGlzLnN3aXRjaGluZ1RyYWNrID8gdGhpcy5zd2l0Y2hpbmdUcmFjay5uYW1lIDogJ2ZhbHNlJ31gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGZyYWcuc24gIT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gZnJhZztcbiAgICAgIGNvbnN0IHRyYWNrID0gdGhpcy5zd2l0Y2hpbmdUcmFjaztcbiAgICAgIGlmICh0cmFjaykge1xuICAgICAgICB0aGlzLmJ1ZmZlcmVkVHJhY2sgPSB0cmFjaztcbiAgICAgICAgdGhpcy5zd2l0Y2hpbmdUcmFjayA9IG51bGw7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSEVELCBfb2JqZWN0U3ByZWFkMih7fSwgdHJhY2spKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5mcmFnQnVmZmVyZWRDb21wbGV0ZShmcmFnLCBwYXJ0KTtcbiAgfVxuICBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF9kYXRhJGNvbnRleHQ7XG4gICAgaWYgKGRhdGEuZmF0YWwpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FUlJPUjtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpdGNoIChkYXRhLmRldGFpbHMpIHtcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfR0FQOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19ERUNSWVBUX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQ6XG4gICAgICAgIHRoaXMub25GcmFnbWVudE9yS2V5TG9hZEVycm9yKFBsYXlsaXN0TGV2ZWxUeXBlLkFVRElPLCBkYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuTEVWRUxfUEFSU0lOR19FUlJPUjpcbiAgICAgICAgLy8gaW4gY2FzZSBvZiBub24gZmF0YWwgZXJyb3Igd2hpbGUgbG9hZGluZyB0cmFjaywgaWYgbm90IHJldHJ5aW5nIHRvIGxvYWQgdHJhY2ssIHN3aXRjaCBiYWNrIHRvIElETEVcbiAgICAgICAgaWYgKCFkYXRhLmxldmVsUmV0cnkgJiYgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19UUkFDSyAmJiAoKF9kYXRhJGNvbnRleHQgPSBkYXRhLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YSRjb250ZXh0LnR5cGUpID09PSBQbGF5bGlzdENvbnRleHRUeXBlLkFVRElPX1RSQUNLKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5EX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0ZVTExfRVJST1I6XG4gICAgICAgIGlmICghZGF0YS5wYXJlbnQgfHwgZGF0YS5wYXJlbnQgIT09ICdhdWRpbycpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRfRVJST1IpIHtcbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlZHVjZUxlbmd0aEFuZEZsdXNoQnVmZmVyKGRhdGEpKSB7XG4gICAgICAgICAgdGhpcy5idWZmZXJlZFRyYWNrID0gbnVsbDtcbiAgICAgICAgICBzdXBlci5mbHVzaE1haW5CdWZmZXIoMCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCAnYXVkaW8nKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLklOVEVSTkFMX0VYQ0VQVElPTjpcbiAgICAgICAgdGhpcy5yZWNvdmVyV29ya2VyRXJyb3IoZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBvbkJ1ZmZlckZsdXNoaW5nKGV2ZW50LCB7XG4gICAgdHlwZVxuICB9KSB7XG4gICAgaWYgKHR5cGUgIT09IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFTykge1xuICAgICAgdGhpcy5mbHVzaGluZyA9IHRydWU7XG4gICAgfVxuICB9XG4gIG9uQnVmZmVyRmx1c2hlZChldmVudCwge1xuICAgIHR5cGVcbiAgfSkge1xuICAgIGlmICh0eXBlICE9PSBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU8pIHtcbiAgICAgIHRoaXMuZmx1c2hpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuYnVmZmVyRmx1c2hlZCA9IHRydWU7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuRU5ERUQpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB9XG4gICAgICBjb25zdCBtZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWFCdWZmZXIgfHwgdGhpcy5tZWRpYTtcbiAgICAgIGlmIChtZWRpYUJ1ZmZlcikge1xuICAgICAgICB0aGlzLmFmdGVyQnVmZmVyRmx1c2hlZChtZWRpYUJ1ZmZlciwgdHlwZSwgUGxheWxpc3RMZXZlbFR5cGUuQVVESU8pO1xuICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2hhbmRsZVRyYW5zbXV4Q29tcGxldGUodHJhbnNtdXhSZXN1bHQpIHtcbiAgICB2YXIgX2lkMyRzYW1wbGVzO1xuICAgIGNvbnN0IGlkID0gJ2F1ZGlvJztcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICByZW11eFJlc3VsdCxcbiAgICAgIGNodW5rTWV0YVxuICAgIH0gPSB0cmFuc211eFJlc3VsdDtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5nZXRDdXJyZW50Q29udGV4dChjaHVua01ldGEpO1xuICAgIGlmICghY29udGV4dCkge1xuICAgICAgdGhpcy5yZXNldFdoZW5NaXNzaW5nQ29udGV4dChjaHVua01ldGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBmcmFnLFxuICAgICAgcGFydCxcbiAgICAgIGxldmVsXG4gICAgfSA9IGNvbnRleHQ7XG4gICAgY29uc3Qge1xuICAgICAgZGV0YWlsc1xuICAgIH0gPSBsZXZlbDtcbiAgICBjb25zdCB7XG4gICAgICBhdWRpbyxcbiAgICAgIHRleHQsXG4gICAgICBpZDMsXG4gICAgICBpbml0U2VnbWVudFxuICAgIH0gPSByZW11eFJlc3VsdDtcblxuICAgIC8vIENoZWNrIGlmIHRoZSBjdXJyZW50IGZyYWdtZW50IGhhcyBiZWVuIGFib3J0ZWQuIFdlIGNoZWNrIHRoaXMgYnkgZmlyc3Qgc2VlaW5nIGlmIHdlJ3JlIHN0aWxsIHBsYXlpbmcgdGhlIGN1cnJlbnQgbGV2ZWwuXG4gICAgLy8gSWYgd2UgYXJlLCBzdWJzZXF1ZW50bHkgY2hlY2sgaWYgdGhlIGN1cnJlbnRseSBsb2FkaW5nIGZyYWdtZW50IChmcmFnQ3VycmVudCkgaGFzIGNoYW5nZWQuXG4gICAgaWYgKHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpIHx8ICFkZXRhaWxzKSB7XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBUlNJTkc7XG4gICAgaWYgKHRoaXMuc3dpdGNoaW5nVHJhY2sgJiYgYXVkaW8pIHtcbiAgICAgIHRoaXMuY29tcGxldGVBdWRpb1N3aXRjaCh0aGlzLnN3aXRjaGluZ1RyYWNrKTtcbiAgICB9XG4gICAgaWYgKGluaXRTZWdtZW50ICE9IG51bGwgJiYgaW5pdFNlZ21lbnQudHJhY2tzKSB7XG4gICAgICBjb25zdCBtYXBGcmFnbWVudCA9IGZyYWcuaW5pdFNlZ21lbnQgfHwgZnJhZztcbiAgICAgIHRoaXMuX2J1ZmZlckluaXRTZWdtZW50KGxldmVsLCBpbml0U2VnbWVudC50cmFja3MsIG1hcEZyYWdtZW50LCBjaHVua01ldGEpO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsIHtcbiAgICAgICAgZnJhZzogbWFwRnJhZ21lbnQsXG4gICAgICAgIGlkLFxuICAgICAgICB0cmFja3M6IGluaXRTZWdtZW50LnRyYWNrc1xuICAgICAgfSk7XG4gICAgICAvLyBPbmx5IGZsdXNoIGF1ZGlvIGZyb20gb2xkIGF1ZGlvIHRyYWNrcyB3aGVuIFBUUyBpcyBrbm93biBvbiBuZXcgYXVkaW8gdHJhY2tcbiAgICB9XG4gICAgaWYgKGF1ZGlvKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHN0YXJ0UFRTLFxuICAgICAgICBlbmRQVFMsXG4gICAgICAgIHN0YXJ0RFRTLFxuICAgICAgICBlbmREVFNcbiAgICAgIH0gPSBhdWRpbztcbiAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgIHBhcnQuZWxlbWVudGFyeVN0cmVhbXNbRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPXSA9IHtcbiAgICAgICAgICBzdGFydFBUUyxcbiAgICAgICAgICBlbmRQVFMsXG4gICAgICAgICAgc3RhcnREVFMsXG4gICAgICAgICAgZW5kRFRTXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBmcmFnLnNldEVsZW1lbnRhcnlTdHJlYW1JbmZvKEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJTywgc3RhcnRQVFMsIGVuZFBUUywgc3RhcnREVFMsIGVuZERUUyk7XG4gICAgICB0aGlzLmJ1ZmZlckZyYWdtZW50RGF0YShhdWRpbywgZnJhZywgcGFydCwgY2h1bmtNZXRhKTtcbiAgICB9XG4gICAgaWYgKGlkMyAhPSBudWxsICYmIChfaWQzJHNhbXBsZXMgPSBpZDMuc2FtcGxlcykgIT0gbnVsbCAmJiBfaWQzJHNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBlbWl0dGVkSUQzID0gX2V4dGVuZHMoe1xuICAgICAgICBpZCxcbiAgICAgICAgZnJhZyxcbiAgICAgICAgZGV0YWlsc1xuICAgICAgfSwgaWQzKTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX1BBUlNJTkdfTUVUQURBVEEsIGVtaXR0ZWRJRDMpO1xuICAgIH1cbiAgICBpZiAodGV4dCkge1xuICAgICAgY29uc3QgZW1pdHRlZFRleHQgPSBfZXh0ZW5kcyh7XG4gICAgICAgIGlkLFxuICAgICAgICBmcmFnLFxuICAgICAgICBkZXRhaWxzXG4gICAgICB9LCB0ZXh0KTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIGVtaXR0ZWRUZXh0KTtcbiAgICB9XG4gIH1cbiAgX2J1ZmZlckluaXRTZWdtZW50KGN1cnJlbnRMZXZlbCwgdHJhY2tzLCBmcmFnLCBjaHVua01ldGEpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBkZWxldGUgYW55IHZpZGVvIHRyYWNrIGZvdW5kIG9uIGF1ZGlvIHRyYW5zbXV4ZXJcbiAgICBpZiAodHJhY2tzLnZpZGVvKSB7XG4gICAgICBkZWxldGUgdHJhY2tzLnZpZGVvO1xuICAgIH1cblxuICAgIC8vIGluY2x1ZGUgbGV2ZWxDb2RlYyBpbiBhdWRpbyBhbmQgdmlkZW8gdHJhY2tzXG4gICAgY29uc3QgdHJhY2sgPSB0cmFja3MuYXVkaW87XG4gICAgaWYgKCF0cmFjaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cmFjay5pZCA9ICdhdWRpbyc7XG4gICAgY29uc3QgdmFyaWFudEF1ZGlvQ29kZWNzID0gY3VycmVudExldmVsLmF1ZGlvQ29kZWM7XG4gICAgdGhpcy5sb2coYEluaXQgYXVkaW8gYnVmZmVyLCBjb250YWluZXI6JHt0cmFjay5jb250YWluZXJ9LCBjb2RlY3NbbGV2ZWwvcGFyc2VkXT1bJHt2YXJpYW50QXVkaW9Db2RlY3N9LyR7dHJhY2suY29kZWN9XWApO1xuICAgIC8vIFNvdXJjZUJ1ZmZlciB3aWxsIHVzZSB0cmFjay5sZXZlbENvZGVjIGlmIGRlZmluZWRcbiAgICBpZiAodmFyaWFudEF1ZGlvQ29kZWNzICYmIHZhcmlhbnRBdWRpb0NvZGVjcy5zcGxpdCgnLCcpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdHJhY2subGV2ZWxDb2RlYyA9IHZhcmlhbnRBdWRpb0NvZGVjcztcbiAgICB9XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0NPREVDUywgdHJhY2tzKTtcbiAgICBjb25zdCBpbml0U2VnbWVudCA9IHRyYWNrLmluaXRTZWdtZW50O1xuICAgIGlmIChpbml0U2VnbWVudCAhPSBudWxsICYmIGluaXRTZWdtZW50LmJ5dGVMZW5ndGgpIHtcbiAgICAgIGNvbnN0IHNlZ21lbnQgPSB7XG4gICAgICAgIHR5cGU6ICdhdWRpbycsXG4gICAgICAgIGZyYWcsXG4gICAgICAgIHBhcnQ6IG51bGwsXG4gICAgICAgIGNodW5rTWV0YSxcbiAgICAgICAgcGFyZW50OiBmcmFnLnR5cGUsXG4gICAgICAgIGRhdGE6IGluaXRTZWdtZW50XG4gICAgICB9O1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0FQUEVORElORywgc2VnbWVudCk7XG4gICAgfVxuICAgIC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICB0aGlzLnRpY2tJbW1lZGlhdGUoKTtcbiAgfVxuICBsb2FkRnJhZ21lbnQoZnJhZywgdHJhY2ssIHRhcmdldEJ1ZmZlclRpbWUpIHtcbiAgICAvLyBvbmx5IGxvYWQgaWYgZnJhZ21lbnQgaXMgbm90IGxvYWRlZCBvciBpZiBpbiBhdWRpbyBzd2l0Y2hcbiAgICBjb25zdCBmcmFnU3RhdGUgPSB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnKTtcbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gZnJhZztcblxuICAgIC8vIHdlIGZvcmNlIGEgZnJhZyBsb2FkaW5nIGluIGF1ZGlvIHN3aXRjaCBhcyBmcmFnbWVudCB0cmFja2VyIG1pZ2h0IG5vdCBoYXZlIGV2aWN0ZWQgcHJldmlvdXMgZnJhZ3MgaW4gY2FzZSBvZiBxdWljayBhdWRpbyBzd2l0Y2hcbiAgICBpZiAodGhpcy5zd2l0Y2hpbmdUcmFjayB8fCBmcmFnU3RhdGUgPT09IEZyYWdtZW50U3RhdGUuTk9UX0xPQURFRCB8fCBmcmFnU3RhdGUgPT09IEZyYWdtZW50U3RhdGUuUEFSVElBTCkge1xuICAgICAgdmFyIF90cmFjayRkZXRhaWxzMjtcbiAgICAgIGlmIChmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICAgIHRoaXMuX2xvYWRJbml0U2VnbWVudChmcmFnLCB0cmFjayk7XG4gICAgICB9IGVsc2UgaWYgKChfdHJhY2skZGV0YWlsczIgPSB0cmFjay5kZXRhaWxzKSAhPSBudWxsICYmIF90cmFjayRkZXRhaWxzMi5saXZlICYmICF0aGlzLmluaXRQVFNbZnJhZy5jY10pIHtcbiAgICAgICAgdGhpcy5sb2coYFdhaXRpbmcgZm9yIHZpZGVvIFBUUyBpbiBjb250aW51aXR5IGNvdW50ZXIgJHtmcmFnLmNjfSBvZiBsaXZlIHN0cmVhbSBiZWZvcmUgbG9hZGluZyBhdWRpbyBmcmFnbWVudCAke2ZyYWcuc259IG9mIGxldmVsICR7dGhpcy50cmFja0lkfWApO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19JTklUX1BUUztcbiAgICAgICAgY29uc3QgbWFpbkRldGFpbHMgPSB0aGlzLm1haW5EZXRhaWxzO1xuICAgICAgICBpZiAobWFpbkRldGFpbHMgJiYgbWFpbkRldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0ICE9PSB0cmFjay5kZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydCkge1xuICAgICAgICAgIGFsaWduTWVkaWFQbGF5bGlzdEJ5UERUKHRyYWNrLmRldGFpbHMsIG1haW5EZXRhaWxzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSB0cnVlO1xuICAgICAgICBzdXBlci5sb2FkRnJhZ21lbnQoZnJhZywgdHJhY2ssIHRhcmdldEJ1ZmZlclRpbWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNsZWFyVHJhY2tlcklmTmVlZGVkKGZyYWcpO1xuICAgIH1cbiAgfVxuICBmbHVzaEF1ZGlvSWZOZWVkZWQoc3dpdGNoaW5nVHJhY2spIHtcbiAgICBjb25zdCB7XG4gICAgICBtZWRpYSxcbiAgICAgIGJ1ZmZlcmVkVHJhY2tcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBidWZmZXJlZEF0dHJpYnV0ZXMgPSBidWZmZXJlZFRyYWNrID09IG51bGwgPyB2b2lkIDAgOiBidWZmZXJlZFRyYWNrLmF0dHJzO1xuICAgIGNvbnN0IHN3aXRjaEF0dHJpYnV0ZXMgPSBzd2l0Y2hpbmdUcmFjay5hdHRycztcbiAgICBpZiAobWVkaWEgJiYgYnVmZmVyZWRBdHRyaWJ1dGVzICYmIChidWZmZXJlZEF0dHJpYnV0ZXMuQ0hBTk5FTFMgIT09IHN3aXRjaEF0dHJpYnV0ZXMuQ0hBTk5FTFMgfHwgYnVmZmVyZWRUcmFjay5uYW1lICE9PSBzd2l0Y2hpbmdUcmFjay5uYW1lIHx8IGJ1ZmZlcmVkVHJhY2subGFuZyAhPT0gc3dpdGNoaW5nVHJhY2subGFuZykpIHtcbiAgICAgIHRoaXMubG9nKCdTd2l0Y2hpbmcgYXVkaW8gdHJhY2sgOiBmbHVzaGluZyBhbGwgYXVkaW8nKTtcbiAgICAgIHN1cGVyLmZsdXNoTWFpbkJ1ZmZlcigwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksICdhdWRpbycpO1xuICAgICAgdGhpcy5idWZmZXJlZFRyYWNrID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgY29tcGxldGVBdWRpb1N3aXRjaChzd2l0Y2hpbmdUcmFjaykge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIHRoaXMuZmx1c2hBdWRpb0lmTmVlZGVkKHN3aXRjaGluZ1RyYWNrKTtcbiAgICB0aGlzLmJ1ZmZlcmVkVHJhY2sgPSBzd2l0Y2hpbmdUcmFjaztcbiAgICB0aGlzLnN3aXRjaGluZ1RyYWNrID0gbnVsbDtcbiAgICBobHMudHJpZ2dlcihFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENIRUQsIF9vYmplY3RTcHJlYWQyKHt9LCBzd2l0Y2hpbmdUcmFjaykpO1xuICB9XG59XG5cbmNsYXNzIEF1ZGlvVHJhY2tDb250cm9sbGVyIGV4dGVuZHMgQmFzZVBsYXlsaXN0Q29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHN1cGVyKGhscywgJ1thdWRpby10cmFjay1jb250cm9sbGVyXScpO1xuICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgdGhpcy5ncm91cElkcyA9IG51bGw7XG4gICAgdGhpcy50cmFja3NJbkdyb3VwID0gW107XG4gICAgdGhpcy50cmFja0lkID0gLTE7XG4gICAgdGhpcy5jdXJyZW50VHJhY2sgPSBudWxsO1xuICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gdHJ1ZTtcbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX0xPQURJTkcsIHRoaXMub25MZXZlbExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxfU1dJVENISU5HLCB0aGlzLm9uTGV2ZWxTd2l0Y2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQVVESU9fVFJBQ0tfTE9BREVELCB0aGlzLm9uQXVkaW9UcmFja0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfVxuICB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9TV0lUQ0hJTkcsIHRoaXMub25MZXZlbFN3aXRjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQVVESU9fVFJBQ0tfTE9BREVELCB0aGlzLm9uQXVkaW9UcmFja0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLnRyYWNrcy5sZW5ndGggPSAwO1xuICAgIHRoaXMudHJhY2tzSW5Hcm91cC5sZW5ndGggPSAwO1xuICAgIHRoaXMuY3VycmVudFRyYWNrID0gbnVsbDtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cbiAgb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgdGhpcy50cmFja3MgPSBbXTtcbiAgICB0aGlzLnRyYWNrc0luR3JvdXAgPSBbXTtcbiAgICB0aGlzLmdyb3VwSWRzID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRUcmFjayA9IG51bGw7XG4gICAgdGhpcy50cmFja0lkID0gLTE7XG4gICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSB0cnVlO1xuICB9XG4gIG9uTWFuaWZlc3RQYXJzZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLnRyYWNrcyA9IGRhdGEuYXVkaW9UcmFja3MgfHwgW107XG4gIH1cbiAgb25BdWRpb1RyYWNrTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgaWQsXG4gICAgICBncm91cElkLFxuICAgICAgZGV0YWlsc1xuICAgIH0gPSBkYXRhO1xuICAgIGNvbnN0IHRyYWNrSW5BY3RpdmVHcm91cCA9IHRoaXMudHJhY2tzSW5Hcm91cFtpZF07XG4gICAgaWYgKCF0cmFja0luQWN0aXZlR3JvdXAgfHwgdHJhY2tJbkFjdGl2ZUdyb3VwLmdyb3VwSWQgIT09IGdyb3VwSWQpIHtcbiAgICAgIHRoaXMud2FybihgQXVkaW8gdHJhY2sgd2l0aCBpZDoke2lkfSBhbmQgZ3JvdXA6JHtncm91cElkfSBub3QgZm91bmQgaW4gYWN0aXZlIGdyb3VwICR7dHJhY2tJbkFjdGl2ZUdyb3VwID09IG51bGwgPyB2b2lkIDAgOiB0cmFja0luQWN0aXZlR3JvdXAuZ3JvdXBJZH1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VyRGV0YWlscyA9IHRyYWNrSW5BY3RpdmVHcm91cC5kZXRhaWxzO1xuICAgIHRyYWNrSW5BY3RpdmVHcm91cC5kZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICAgIHRoaXMubG9nKGBBdWRpbyB0cmFjayAke2lkfSBcIiR7dHJhY2tJbkFjdGl2ZUdyb3VwLm5hbWV9XCIgbGFuZzoke3RyYWNrSW5BY3RpdmVHcm91cC5sYW5nfSBncm91cDoke2dyb3VwSWR9IGxvYWRlZCBbJHtkZXRhaWxzLnN0YXJ0U059LSR7ZGV0YWlscy5lbmRTTn1dYCk7XG4gICAgaWYgKGlkID09PSB0aGlzLnRyYWNrSWQpIHtcbiAgICAgIHRoaXMucGxheWxpc3RMb2FkZWQoaWQsIGRhdGEsIGN1ckRldGFpbHMpO1xuICAgIH1cbiAgfVxuICBvbkxldmVsTG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgIHRoaXMuc3dpdGNoTGV2ZWwoZGF0YS5sZXZlbCk7XG4gIH1cbiAgb25MZXZlbFN3aXRjaGluZyhldmVudCwgZGF0YSkge1xuICAgIHRoaXMuc3dpdGNoTGV2ZWwoZGF0YS5sZXZlbCk7XG4gIH1cbiAgc3dpdGNoTGV2ZWwobGV2ZWxJbmRleCkge1xuICAgIGNvbnN0IGxldmVsSW5mbyA9IHRoaXMuaGxzLmxldmVsc1tsZXZlbEluZGV4XTtcbiAgICBpZiAoIWxldmVsSW5mbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhdWRpb0dyb3VwcyA9IGxldmVsSW5mby5hdWRpb0dyb3VwcyB8fCBudWxsO1xuICAgIGNvbnN0IGN1cnJlbnRHcm91cHMgPSB0aGlzLmdyb3VwSWRzO1xuICAgIGxldCBjdXJyZW50VHJhY2sgPSB0aGlzLmN1cnJlbnRUcmFjaztcbiAgICBpZiAoIWF1ZGlvR3JvdXBzIHx8IChjdXJyZW50R3JvdXBzID09IG51bGwgPyB2b2lkIDAgOiBjdXJyZW50R3JvdXBzLmxlbmd0aCkgIT09IChhdWRpb0dyb3VwcyA9PSBudWxsID8gdm9pZCAwIDogYXVkaW9Hcm91cHMubGVuZ3RoKSB8fCBhdWRpb0dyb3VwcyAhPSBudWxsICYmIGF1ZGlvR3JvdXBzLnNvbWUoZ3JvdXBJZCA9PiAoY3VycmVudEdyb3VwcyA9PSBudWxsID8gdm9pZCAwIDogY3VycmVudEdyb3Vwcy5pbmRleE9mKGdyb3VwSWQpKSA9PT0gLTEpKSB7XG4gICAgICB0aGlzLmdyb3VwSWRzID0gYXVkaW9Hcm91cHM7XG4gICAgICB0aGlzLnRyYWNrSWQgPSAtMTtcbiAgICAgIHRoaXMuY3VycmVudFRyYWNrID0gbnVsbDtcbiAgICAgIGNvbnN0IGF1ZGlvVHJhY2tzID0gdGhpcy50cmFja3MuZmlsdGVyKHRyYWNrID0+ICFhdWRpb0dyb3VwcyB8fCBhdWRpb0dyb3Vwcy5pbmRleE9mKHRyYWNrLmdyb3VwSWQpICE9PSAtMSk7XG4gICAgICBpZiAoYXVkaW9UcmFja3MubGVuZ3RoKSB7XG4gICAgICAgIC8vIERpc2FibGUgc2VsZWN0RGVmYXVsdFRyYWNrIGlmIHRoZXJlIGFyZSBubyBkZWZhdWx0IHRyYWNrc1xuICAgICAgICBpZiAodGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgJiYgIWF1ZGlvVHJhY2tzLnNvbWUodHJhY2sgPT4gdHJhY2suZGVmYXVsdCkpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRyYWNrLmlkIHNob3VsZCBtYXRjaCBobHMuYXVkaW9UcmFja3MgaW5kZXhcbiAgICAgICAgYXVkaW9UcmFja3MuZm9yRWFjaCgodHJhY2ssIGkpID0+IHtcbiAgICAgICAgICB0cmFjay5pZCA9IGk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICghY3VycmVudFRyYWNrICYmICF0aGlzLnRyYWNrc0luR3JvdXAubGVuZ3RoKSB7XG4gICAgICAgIC8vIERvIG5vdCBkaXNwYXRjaCBBVURJT19UUkFDS1NfVVBEQVRFRCB3aGVuIHRoZXJlIHdlcmUgYW5kIGFyZSBubyB0cmFja3NcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy50cmFja3NJbkdyb3VwID0gYXVkaW9UcmFja3M7XG5cbiAgICAgIC8vIEZpbmQgcHJlZmVycmVkIHRyYWNrXG4gICAgICBjb25zdCBhdWRpb1ByZWZlcmVuY2UgPSB0aGlzLmhscy5jb25maWcuYXVkaW9QcmVmZXJlbmNlO1xuICAgICAgaWYgKCFjdXJyZW50VHJhY2sgJiYgYXVkaW9QcmVmZXJlbmNlKSB7XG4gICAgICAgIGNvbnN0IGdyb3VwSW5kZXggPSBmaW5kTWF0Y2hpbmdPcHRpb24oYXVkaW9QcmVmZXJlbmNlLCBhdWRpb1RyYWNrcywgYXVkaW9NYXRjaFByZWRpY2F0ZSk7XG4gICAgICAgIGlmIChncm91cEluZGV4ID4gLTEpIHtcbiAgICAgICAgICBjdXJyZW50VHJhY2sgPSBhdWRpb1RyYWNrc1tncm91cEluZGV4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBhbGxJbmRleCA9IGZpbmRNYXRjaGluZ09wdGlvbihhdWRpb1ByZWZlcmVuY2UsIHRoaXMudHJhY2tzKTtcbiAgICAgICAgICBjdXJyZW50VHJhY2sgPSB0aGlzLnRyYWNrc1thbGxJbmRleF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gU2VsZWN0IGluaXRpYWwgdHJhY2tcbiAgICAgIGxldCB0cmFja0lkID0gdGhpcy5maW5kVHJhY2tJZChjdXJyZW50VHJhY2spO1xuICAgICAgaWYgKHRyYWNrSWQgPT09IC0xICYmIGN1cnJlbnRUcmFjaykge1xuICAgICAgICB0cmFja0lkID0gdGhpcy5maW5kVHJhY2tJZChudWxsKTtcbiAgICAgIH1cblxuICAgICAgLy8gRGlzcGF0Y2ggZXZlbnRzIGFuZCBsb2FkIHRyYWNrIGlmIG5lZWRlZFxuICAgICAgY29uc3QgYXVkaW9UcmFja3NVcGRhdGVkID0ge1xuICAgICAgICBhdWRpb1RyYWNrc1xuICAgICAgfTtcbiAgICAgIHRoaXMubG9nKGBVcGRhdGluZyBhdWRpbyB0cmFja3MsICR7YXVkaW9UcmFja3MubGVuZ3RofSB0cmFjayhzKSBmb3VuZCBpbiBncm91cChzKTogJHthdWRpb0dyb3VwcyA9PSBudWxsID8gdm9pZCAwIDogYXVkaW9Hcm91cHMuam9pbignLCcpfWApO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQVVESU9fVFJBQ0tTX1VQREFURUQsIGF1ZGlvVHJhY2tzVXBkYXRlZCk7XG4gICAgICBjb25zdCBzZWxlY3RlZFRyYWNrSWQgPSB0aGlzLnRyYWNrSWQ7XG4gICAgICBpZiAodHJhY2tJZCAhPT0gLTEgJiYgc2VsZWN0ZWRUcmFja0lkID09PSAtMSkge1xuICAgICAgICB0aGlzLnNldEF1ZGlvVHJhY2sodHJhY2tJZCk7XG4gICAgICB9IGVsc2UgaWYgKGF1ZGlvVHJhY2tzLmxlbmd0aCAmJiBzZWxlY3RlZFRyYWNrSWQgPT09IC0xKSB7XG4gICAgICAgIHZhciBfdGhpcyRncm91cElkcztcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYE5vIGF1ZGlvIHRyYWNrIHNlbGVjdGVkIGZvciBjdXJyZW50IGF1ZGlvIGdyb3VwLUlEKHMpOiAkeyhfdGhpcyRncm91cElkcyA9IHRoaXMuZ3JvdXBJZHMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRncm91cElkcy5qb2luKCcsJyl9IHRyYWNrIGNvdW50OiAke2F1ZGlvVHJhY2tzLmxlbmd0aH1gKTtcbiAgICAgICAgdGhpcy53YXJuKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfRVJST1IsXG4gICAgICAgICAgZmF0YWw6IHRydWUsXG4gICAgICAgICAgZXJyb3JcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnNob3VsZFJlbG9hZFBsYXlsaXN0KGN1cnJlbnRUcmFjaykpIHtcbiAgICAgIC8vIFJldHJ5IHBsYXlsaXN0IGxvYWRpbmcgaWYgbm8gcGxheWxpc3QgaXMgb3IgaGFzIGJlZW4gbG9hZGVkIHlldFxuICAgICAgdGhpcy5zZXRBdWRpb1RyYWNrKHRoaXMudHJhY2tJZCk7XG4gICAgfVxuICB9XG4gIG9uRXJyb3IoZXZlbnQsIGRhdGEpIHtcbiAgICBpZiAoZGF0YS5mYXRhbCB8fCAhZGF0YS5jb250ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkYXRhLmNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSyAmJiBkYXRhLmNvbnRleHQuaWQgPT09IHRoaXMudHJhY2tJZCAmJiAoIXRoaXMuZ3JvdXBJZHMgfHwgdGhpcy5ncm91cElkcy5pbmRleE9mKGRhdGEuY29udGV4dC5ncm91cElkKSAhPT0gLTEpKSB7XG4gICAgICB0aGlzLnJlcXVlc3RTY2hlZHVsZWQgPSAtMTtcbiAgICAgIHRoaXMuY2hlY2tSZXRyeShkYXRhKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGFsbEF1ZGlvVHJhY2tzKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrcztcbiAgfVxuICBnZXQgYXVkaW9UcmFja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2tzSW5Hcm91cDtcbiAgfVxuICBnZXQgYXVkaW9UcmFjaygpIHtcbiAgICByZXR1cm4gdGhpcy50cmFja0lkO1xuICB9XG4gIHNldCBhdWRpb1RyYWNrKG5ld0lkKSB7XG4gICAgLy8gSWYgYXVkaW8gdHJhY2sgaXMgc2VsZWN0ZWQgZnJvbSBBUEkgdGhlbiBkb24ndCBjaG9vc2UgZnJvbSB0aGUgbWFuaWZlc3QgZGVmYXVsdCB0cmFja1xuICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gZmFsc2U7XG4gICAgdGhpcy5zZXRBdWRpb1RyYWNrKG5ld0lkKTtcbiAgfVxuICBzZXRBdWRpb09wdGlvbihhdWRpb09wdGlvbikge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5jb25maWcuYXVkaW9QcmVmZXJlbmNlID0gYXVkaW9PcHRpb247XG4gICAgaWYgKGF1ZGlvT3B0aW9uKSB7XG4gICAgICBjb25zdCBhbGxBdWRpb1RyYWNrcyA9IHRoaXMuYWxsQXVkaW9UcmFja3M7XG4gICAgICB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IGZhbHNlO1xuICAgICAgaWYgKGFsbEF1ZGlvVHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAvLyBGaXJzdCBzZWUgaWYgY3VycmVudCBvcHRpb24gbWF0Y2hlcyAobm8gc3dpdGNoIG9wKVxuICAgICAgICBjb25zdCBjdXJyZW50VHJhY2sgPSB0aGlzLmN1cnJlbnRUcmFjaztcbiAgICAgICAgaWYgKGN1cnJlbnRUcmFjayAmJiBtYXRjaGVzT3B0aW9uKGF1ZGlvT3B0aW9uLCBjdXJyZW50VHJhY2ssIGF1ZGlvTWF0Y2hQcmVkaWNhdGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRUcmFjaztcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5kIG9wdGlvbiBpbiBhdmFpbGFibGUgdHJhY2tzICh0cmFja3NJbkdyb3VwKVxuICAgICAgICBjb25zdCBncm91cEluZGV4ID0gZmluZE1hdGNoaW5nT3B0aW9uKGF1ZGlvT3B0aW9uLCB0aGlzLnRyYWNrc0luR3JvdXAsIGF1ZGlvTWF0Y2hQcmVkaWNhdGUpO1xuICAgICAgICBpZiAoZ3JvdXBJbmRleCA+IC0xKSB7XG4gICAgICAgICAgY29uc3QgdHJhY2sgPSB0aGlzLnRyYWNrc0luR3JvdXBbZ3JvdXBJbmRleF07XG4gICAgICAgICAgdGhpcy5zZXRBdWRpb1RyYWNrKGdyb3VwSW5kZXgpO1xuICAgICAgICAgIHJldHVybiB0cmFjaztcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50VHJhY2spIHtcbiAgICAgICAgICAvLyBGaW5kIG9wdGlvbiBpbiBuZWFyZXN0IGxldmVsIGF1ZGlvIGdyb3VwXG4gICAgICAgICAgbGV0IHNlYXJjaEluZGV4ID0gaGxzLmxvYWRMZXZlbDtcbiAgICAgICAgICBpZiAoc2VhcmNoSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBzZWFyY2hJbmRleCA9IGhscy5maXJzdEF1dG9MZXZlbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc3dpdGNoSW5kZXggPSBmaW5kQ2xvc2VzdExldmVsV2l0aEF1ZGlvR3JvdXAoYXVkaW9PcHRpb24sIGhscy5sZXZlbHMsIGFsbEF1ZGlvVHJhY2tzLCBzZWFyY2hJbmRleCwgYXVkaW9NYXRjaFByZWRpY2F0ZSk7XG4gICAgICAgICAgaWYgKHN3aXRjaEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgLy8gY291bGQgbm90IGZpbmQgbWF0Y2hpbmcgdmFyaWFudFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGFuZCBzd2l0Y2ggbGV2ZWwgdG8gYWNoZWl2ZSB0aGUgYXVkaW8gZ3JvdXAgc3dpdGNoXG4gICAgICAgICAgaGxzLm5leHRMb2FkTGV2ZWwgPSBzd2l0Y2hJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXVkaW9PcHRpb24uY2hhbm5lbHMgfHwgYXVkaW9PcHRpb24uYXVkaW9Db2RlYykge1xuICAgICAgICAgIC8vIENvdWxkIG5vdCBmaW5kIGEgbWF0Y2ggd2l0aCBjb2RlYyAvIGNoYW5uZWxzIHByZWRpY2F0ZVxuICAgICAgICAgIC8vIEZpbmQgYSBtYXRjaCB3aXRob3V0IGNoYW5uZWxzIG9yIGNvZGVjXG4gICAgICAgICAgY29uc3Qgd2l0aG91dENvZGVjQW5kQ2hhbm5lbHNNYXRjaCA9IGZpbmRNYXRjaGluZ09wdGlvbihhdWRpb09wdGlvbiwgYWxsQXVkaW9UcmFja3MpO1xuICAgICAgICAgIGlmICh3aXRob3V0Q29kZWNBbmRDaGFubmVsc01hdGNoID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBhbGxBdWRpb1RyYWNrc1t3aXRob3V0Q29kZWNBbmRDaGFubmVsc01hdGNoXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgc2V0QXVkaW9UcmFjayhuZXdJZCkge1xuICAgIGNvbnN0IHRyYWNrcyA9IHRoaXMudHJhY2tzSW5Hcm91cDtcblxuICAgIC8vIGNoZWNrIGlmIGxldmVsIGlkeCBpcyB2YWxpZFxuICAgIGlmIChuZXdJZCA8IDAgfHwgbmV3SWQgPj0gdHJhY2tzLmxlbmd0aCkge1xuICAgICAgdGhpcy53YXJuKGBJbnZhbGlkIGF1ZGlvIHRyYWNrIGlkOiAke25ld0lkfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHN0b3BwaW5nIGxpdmUgcmVsb2FkaW5nIHRpbWVyIGlmIGFueVxuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gZmFsc2U7XG4gICAgY29uc3QgbGFzdFRyYWNrID0gdGhpcy5jdXJyZW50VHJhY2s7XG4gICAgY29uc3QgdHJhY2sgPSB0cmFja3NbbmV3SWRdO1xuICAgIGNvbnN0IHRyYWNrTG9hZGVkID0gdHJhY2suZGV0YWlscyAmJiAhdHJhY2suZGV0YWlscy5saXZlO1xuICAgIGlmIChuZXdJZCA9PT0gdGhpcy50cmFja0lkICYmIHRyYWNrID09PSBsYXN0VHJhY2sgJiYgdHJhY2tMb2FkZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sb2coYFN3aXRjaGluZyB0byBhdWRpby10cmFjayAke25ld0lkfSBcIiR7dHJhY2submFtZX1cIiBsYW5nOiR7dHJhY2subGFuZ30gZ3JvdXA6JHt0cmFjay5ncm91cElkfSBjaGFubmVsczoke3RyYWNrLmNoYW5uZWxzfWApO1xuICAgIHRoaXMudHJhY2tJZCA9IG5ld0lkO1xuICAgIHRoaXMuY3VycmVudFRyYWNrID0gdHJhY2s7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENISU5HLCBfb2JqZWN0U3ByZWFkMih7fSwgdHJhY2spKTtcbiAgICAvLyBEbyBub3QgcmVsb2FkIHRyYWNrIHVubGVzcyBsaXZlXG4gICAgaWYgKHRyYWNrTG9hZGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhsc1VybFBhcmFtZXRlcnMgPSB0aGlzLnN3aXRjaFBhcmFtcyh0cmFjay51cmwsIGxhc3RUcmFjayA9PSBudWxsID8gdm9pZCAwIDogbGFzdFRyYWNrLmRldGFpbHMpO1xuICAgIHRoaXMubG9hZFBsYXlsaXN0KGhsc1VybFBhcmFtZXRlcnMpO1xuICB9XG4gIGZpbmRUcmFja0lkKGN1cnJlbnRUcmFjaykge1xuICAgIGNvbnN0IGF1ZGlvVHJhY2tzID0gdGhpcy50cmFja3NJbkdyb3VwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXVkaW9UcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRyYWNrID0gYXVkaW9UcmFja3NbaV07XG4gICAgICBpZiAodGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgJiYgIXRyYWNrLmRlZmF1bHQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIWN1cnJlbnRUcmFjayB8fCBtYXRjaGVzT3B0aW9uKGN1cnJlbnRUcmFjaywgdHJhY2ssIGF1ZGlvTWF0Y2hQcmVkaWNhdGUpKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY3VycmVudFRyYWNrKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGxhbmcsXG4gICAgICAgIGFzc29jTGFuZyxcbiAgICAgICAgY2hhcmFjdGVyaXN0aWNzLFxuICAgICAgICBhdWRpb0NvZGVjLFxuICAgICAgICBjaGFubmVsc1xuICAgICAgfSA9IGN1cnJlbnRUcmFjaztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXVkaW9UcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdHJhY2sgPSBhdWRpb1RyYWNrc1tpXTtcbiAgICAgICAgaWYgKG1hdGNoZXNPcHRpb24oe1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgbGFuZyxcbiAgICAgICAgICBhc3NvY0xhbmcsXG4gICAgICAgICAgY2hhcmFjdGVyaXN0aWNzLFxuICAgICAgICAgIGF1ZGlvQ29kZWMsXG4gICAgICAgICAgY2hhbm5lbHNcbiAgICAgICAgfSwgdHJhY2ssIGF1ZGlvTWF0Y2hQcmVkaWNhdGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXVkaW9UcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdHJhY2sgPSBhdWRpb1RyYWNrc1tpXTtcbiAgICAgICAgaWYgKG1lZGlhQXR0cmlidXRlc0lkZW50aWNhbChjdXJyZW50VHJhY2suYXR0cnMsIHRyYWNrLmF0dHJzLCBbJ0xBTkdVQUdFJywgJ0FTU09DLUxBTkdVQUdFJywgJ0NIQVJBQ1RFUklTVElDUyddKSkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF1ZGlvVHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRyYWNrID0gYXVkaW9UcmFja3NbaV07XG4gICAgICAgIGlmIChtZWRpYUF0dHJpYnV0ZXNJZGVudGljYWwoY3VycmVudFRyYWNrLmF0dHJzLCB0cmFjay5hdHRycywgWydMQU5HVUFHRSddKSkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICBsb2FkUGxheWxpc3QoaGxzVXJsUGFyYW1ldGVycykge1xuICAgIGNvbnN0IGF1ZGlvVHJhY2sgPSB0aGlzLmN1cnJlbnRUcmFjaztcbiAgICBpZiAodGhpcy5zaG91bGRMb2FkUGxheWxpc3QoYXVkaW9UcmFjaykgJiYgYXVkaW9UcmFjaykge1xuICAgICAgc3VwZXIubG9hZFBsYXlsaXN0KCk7XG4gICAgICBjb25zdCBpZCA9IGF1ZGlvVHJhY2suaWQ7XG4gICAgICBjb25zdCBncm91cElkID0gYXVkaW9UcmFjay5ncm91cElkO1xuICAgICAgbGV0IHVybCA9IGF1ZGlvVHJhY2sudXJsO1xuICAgICAgaWYgKGhsc1VybFBhcmFtZXRlcnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB1cmwgPSBobHNVcmxQYXJhbWV0ZXJzLmFkZERpcmVjdGl2ZXModXJsKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLndhcm4oYENvdWxkIG5vdCBjb25zdHJ1Y3QgbmV3IFVSTCB3aXRoIEhMUyBEZWxpdmVyeSBEaXJlY3RpdmVzOiAke2Vycm9yfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyB0cmFjayBub3QgcmV0cmlldmVkIHlldCwgb3IgbGl2ZSBwbGF5bGlzdCB3ZSBuZWVkIHRvIChyZSlsb2FkIGl0XG4gICAgICB0aGlzLmxvZyhgbG9hZGluZyBhdWRpby10cmFjayBwbGF5bGlzdCAke2lkfSBcIiR7YXVkaW9UcmFjay5uYW1lfVwiIGxhbmc6JHthdWRpb1RyYWNrLmxhbmd9IGdyb3VwOiR7Z3JvdXBJZH1gKTtcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQVVESU9fVFJBQ0tfTE9BRElORywge1xuICAgICAgICB1cmwsXG4gICAgICAgIGlkLFxuICAgICAgICBncm91cElkLFxuICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXM6IGhsc1VybFBhcmFtZXRlcnMgfHwgbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IFRJQ0tfSU5URVJWQUwkMSA9IDUwMDsgLy8gaG93IG9mdGVuIHRvIHRpY2sgaW4gbXNcblxuY2xhc3MgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyIGV4dGVuZHMgQmFzZVN0cmVhbUNvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihobHMsIGZyYWdtZW50VHJhY2tlciwga2V5TG9hZGVyKSB7XG4gICAgc3VwZXIoaGxzLCBmcmFnbWVudFRyYWNrZXIsIGtleUxvYWRlciwgJ1tzdWJ0aXRsZS1zdHJlYW0tY29udHJvbGxlcl0nLCBQbGF5bGlzdExldmVsVHlwZS5TVUJUSVRMRSk7XG4gICAgdGhpcy5jdXJyZW50VHJhY2tJZCA9IC0xO1xuICAgIHRoaXMudHJhY2tzQnVmZmVyZWQgPSBbXTtcbiAgICB0aGlzLm1haW5EZXRhaWxzID0gbnVsbDtcbiAgICB0aGlzLl9yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIG9uSGFuZGxlckRlc3Ryb3lpbmcoKSB7XG4gICAgdGhpcy5fdW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHN1cGVyLm9uSGFuZGxlckRlc3Ryb3lpbmcoKTtcbiAgICB0aGlzLm1haW5EZXRhaWxzID0gbnVsbDtcbiAgfVxuICBfcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLlNVQlRJVExFX1RSQUNLU19VUERBVEVELCB0aGlzLm9uU3VidGl0bGVUcmFja3NVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLlNVQlRJVExFX1RSQUNLX1NXSVRDSCwgdGhpcy5vblN1YnRpdGxlVHJhY2tTd2l0Y2gsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuU1VCVElUTEVfVFJBQ0tfTE9BREVELCB0aGlzLm9uU3VidGl0bGVUcmFja0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwgdGhpcy5vblN1YnRpdGxlRnJhZ1Byb2Nlc3NlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgfVxuICBfdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuU1VCVElUTEVfVFJBQ0tTX1VQREFURUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLlNVQlRJVExFX1RSQUNLX1NXSVRDSCwgdGhpcy5vblN1YnRpdGxlVHJhY2tTd2l0Y2gsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLlNVQlRJVExFX1RSQUNLX0xPQURFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB0aGlzLm9uU3VidGl0bGVGcmFnUHJvY2Vzc2VkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gIH1cbiAgc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pIHtcbiAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgdGhpcy5zZXRJbnRlcnZhbChUSUNLX0lOVEVSVkFMJDEpO1xuICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gc3RhcnRQb3NpdGlvbjtcbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLm1haW5EZXRhaWxzID0gbnVsbDtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVBbGxGcmFnbWVudHMoKTtcbiAgfVxuICBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgIHRoaXMudHJhY2tzQnVmZmVyZWQgPSBbXTtcbiAgICBzdXBlci5vbk1lZGlhRGV0YWNoaW5nKCk7XG4gIH1cbiAgb25MZXZlbExvYWRlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMubWFpbkRldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gIH1cbiAgb25TdWJ0aXRsZUZyYWdQcm9jZXNzZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnLFxuICAgICAgc3VjY2Vzc1xuICAgIH0gPSBkYXRhO1xuICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gZnJhZztcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICBpZiAoIXN1Y2Nlc3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVyZWQgPSB0aGlzLnRyYWNrc0J1ZmZlcmVkW3RoaXMuY3VycmVudFRyYWNrSWRdO1xuICAgIGlmICghYnVmZmVyZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUvdXBkYXRlIGEgYnVmZmVyZWQgYXJyYXkgbWF0Y2hpbmcgdGhlIGludGVyZmFjZSB1c2VkIGJ5IEJ1ZmZlckhlbHBlci5idWZmZXJlZEluZm9cbiAgICAvLyBzbyB3ZSBjYW4gcmUtdXNlIHRoZSBsb2dpYyB1c2VkIHRvIGRldGVjdCBob3cgbXVjaCBoYXMgYmVlbiBidWZmZXJlZFxuICAgIGxldCB0aW1lUmFuZ2U7XG4gICAgY29uc3QgZnJhZ1N0YXJ0ID0gZnJhZy5zdGFydDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZnJhZ1N0YXJ0ID49IGJ1ZmZlcmVkW2ldLnN0YXJ0ICYmIGZyYWdTdGFydCA8PSBidWZmZXJlZFtpXS5lbmQpIHtcbiAgICAgICAgdGltZVJhbmdlID0gYnVmZmVyZWRbaV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmcmFnRW5kID0gZnJhZy5zdGFydCArIGZyYWcuZHVyYXRpb247XG4gICAgaWYgKHRpbWVSYW5nZSkge1xuICAgICAgdGltZVJhbmdlLmVuZCA9IGZyYWdFbmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVSYW5nZSA9IHtcbiAgICAgICAgc3RhcnQ6IGZyYWdTdGFydCxcbiAgICAgICAgZW5kOiBmcmFnRW5kXG4gICAgICB9O1xuICAgICAgYnVmZmVyZWQucHVzaCh0aW1lUmFuZ2UpO1xuICAgIH1cbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5mcmFnQnVmZmVyZWQoZnJhZyk7XG4gICAgdGhpcy5mcmFnQnVmZmVyZWRDb21wbGV0ZShmcmFnLCBudWxsKTtcbiAgfVxuICBvbkJ1ZmZlckZsdXNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3RhcnRPZmZzZXQsXG4gICAgICBlbmRPZmZzZXRcbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoc3RhcnRPZmZzZXQgPT09IDAgJiYgZW5kT2Zmc2V0ICE9PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgIGNvbnN0IGVuZE9mZnNldFN1YnRpdGxlcyA9IGVuZE9mZnNldCAtIDE7XG4gICAgICBpZiAoZW5kT2Zmc2V0U3VidGl0bGVzIDw9IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGF0YS5lbmRPZmZzZXRTdWJ0aXRsZXMgPSBNYXRoLm1heCgwLCBlbmRPZmZzZXRTdWJ0aXRsZXMpO1xuICAgICAgdGhpcy50cmFja3NCdWZmZXJlZC5mb3JFYWNoKGJ1ZmZlcmVkID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXJlZC5sZW5ndGg7KSB7XG4gICAgICAgICAgaWYgKGJ1ZmZlcmVkW2ldLmVuZCA8PSBlbmRPZmZzZXRTdWJ0aXRsZXMpIHtcbiAgICAgICAgICAgIGJ1ZmZlcmVkLnNoaWZ0KCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGJ1ZmZlcmVkW2ldLnN0YXJ0IDwgZW5kT2Zmc2V0U3VidGl0bGVzKSB7XG4gICAgICAgICAgICBidWZmZXJlZFtpXS5zdGFydCA9IGVuZE9mZnNldFN1YnRpdGxlcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudHNJblJhbmdlKHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXRTdWJ0aXRsZXMsIFBsYXlsaXN0TGV2ZWxUeXBlLlNVQlRJVExFKTtcbiAgICB9XG4gIH1cbiAgb25GcmFnQnVmZmVyZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEgJiYgZGF0YS5mcmFnLnR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pIHtcbiAgICAgIHZhciBfdGhpcyRtZWRpYTtcbiAgICAgIGlmICgoX3RoaXMkbWVkaWEgPSB0aGlzLm1lZGlhKSAhPSBudWxsICYmIF90aGlzJG1lZGlhLmJ1ZmZlcmVkLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBJZiBzb21ldGhpbmcgZ29lcyB3cm9uZywgcHJvY2VlZCB0byBuZXh0IGZyYWcsIGlmIHdlIHdlcmUgcHJvY2Vzc2luZyBvbmUuXG4gIG9uRXJyb3IoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCBmcmFnID0gZGF0YS5mcmFnO1xuICAgIGlmICgoZnJhZyA9PSBudWxsID8gdm9pZCAwIDogZnJhZy50eXBlKSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuU1VCVElUTEUpIHtcbiAgICAgIGlmICh0aGlzLmZyYWdDdXJyZW50KSB7XG4gICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQuYWJvcnRSZXF1ZXN0cygpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFN0YXRlLlNUT1BQRUQpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gR290IGFsbCBuZXcgc3VidGl0bGUgbGV2ZWxzLlxuICBvblN1YnRpdGxlVHJhY2tzVXBkYXRlZChldmVudCwge1xuICAgIHN1YnRpdGxlVHJhY2tzXG4gIH0pIHtcbiAgICBpZiAodGhpcy5sZXZlbHMgJiYgc3VidGl0bGVPcHRpb25zSWRlbnRpY2FsKHRoaXMubGV2ZWxzLCBzdWJ0aXRsZVRyYWNrcykpIHtcbiAgICAgIHRoaXMubGV2ZWxzID0gc3VidGl0bGVUcmFja3MubWFwKG1lZGlhUGxheWxpc3QgPT4gbmV3IExldmVsKG1lZGlhUGxheWxpc3QpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy50cmFja3NCdWZmZXJlZCA9IFtdO1xuICAgIHRoaXMubGV2ZWxzID0gc3VidGl0bGVUcmFja3MubWFwKG1lZGlhUGxheWxpc3QgPT4ge1xuICAgICAgY29uc3QgbGV2ZWwgPSBuZXcgTGV2ZWwobWVkaWFQbGF5bGlzdCk7XG4gICAgICB0aGlzLnRyYWNrc0J1ZmZlcmVkW2xldmVsLmlkXSA9IFtdO1xuICAgICAgcmV0dXJuIGxldmVsO1xuICAgIH0pO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50c0luUmFuZ2UoMCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBQbGF5bGlzdExldmVsVHlwZS5TVUJUSVRMRSk7XG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgIHRoaXMubWVkaWFCdWZmZXIgPSBudWxsO1xuICB9XG4gIG9uU3VidGl0bGVUcmFja1N3aXRjaChldmVudCwgZGF0YSkge1xuICAgIHZhciBfdGhpcyRsZXZlbHM7XG4gICAgdGhpcy5jdXJyZW50VHJhY2tJZCA9IGRhdGEuaWQ7XG4gICAgaWYgKCEoKF90aGlzJGxldmVscyA9IHRoaXMubGV2ZWxzKSAhPSBudWxsICYmIF90aGlzJGxldmVscy5sZW5ndGgpIHx8IHRoaXMuY3VycmVudFRyYWNrSWQgPT09IC0xKSB7XG4gICAgICB0aGlzLmNsZWFySW50ZXJ2YWwoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0cmFjayBoYXMgdGhlIG5lY2Vzc2FyeSBkZXRhaWxzIHRvIGxvYWQgZnJhZ21lbnRzXG4gICAgY29uc3QgY3VycmVudFRyYWNrID0gdGhpcy5sZXZlbHNbdGhpcy5jdXJyZW50VHJhY2tJZF07XG4gICAgaWYgKGN1cnJlbnRUcmFjayAhPSBudWxsICYmIGN1cnJlbnRUcmFjay5kZXRhaWxzKSB7XG4gICAgICB0aGlzLm1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYUJ1ZmZlclRpbWVSYW5nZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFRyYWNrKSB7XG4gICAgICB0aGlzLnNldEludGVydmFsKFRJQ0tfSU5URVJWQUwkMSk7XG4gICAgfVxuICB9XG5cbiAgLy8gR290IGEgbmV3IHNldCBvZiBzdWJ0aXRsZSBmcmFnbWVudHMuXG4gIG9uU3VidGl0bGVUcmFja0xvYWRlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBfdHJhY2skZGV0YWlscztcbiAgICBjb25zdCB7XG4gICAgICBjdXJyZW50VHJhY2tJZCxcbiAgICAgIGxldmVsc1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIGRldGFpbHM6IG5ld0RldGFpbHMsXG4gICAgICBpZDogdHJhY2tJZFxuICAgIH0gPSBkYXRhO1xuICAgIGlmICghbGV2ZWxzKSB7XG4gICAgICB0aGlzLndhcm4oYFN1YnRpdGxlIHRyYWNrcyB3ZXJlIHJlc2V0IHdoaWxlIGxvYWRpbmcgbGV2ZWwgJHt0cmFja0lkfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0cmFjayA9IGxldmVsc1tjdXJyZW50VHJhY2tJZF07XG4gICAgaWYgKHRyYWNrSWQgPj0gbGV2ZWxzLmxlbmd0aCB8fCB0cmFja0lkICE9PSBjdXJyZW50VHJhY2tJZCB8fCAhdHJhY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sb2coYFN1YnRpdGxlIHRyYWNrICR7dHJhY2tJZH0gbG9hZGVkIFske25ld0RldGFpbHMuc3RhcnRTTn0sJHtuZXdEZXRhaWxzLmVuZFNOfV0ke25ld0RldGFpbHMubGFzdFBhcnRTbiA/IGBbcGFydC0ke25ld0RldGFpbHMubGFzdFBhcnRTbn0tJHtuZXdEZXRhaWxzLmxhc3RQYXJ0SW5kZXh9XWAgOiAnJ30sZHVyYXRpb246JHtuZXdEZXRhaWxzLnRvdGFsZHVyYXRpb259YCk7XG4gICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWFCdWZmZXJUaW1lUmFuZ2VzO1xuICAgIGxldCBzbGlkaW5nID0gMDtcbiAgICBpZiAobmV3RGV0YWlscy5saXZlIHx8IChfdHJhY2skZGV0YWlscyA9IHRyYWNrLmRldGFpbHMpICE9IG51bGwgJiYgX3RyYWNrJGRldGFpbHMubGl2ZSkge1xuICAgICAgY29uc3QgbWFpbkRldGFpbHMgPSB0aGlzLm1haW5EZXRhaWxzO1xuICAgICAgaWYgKG5ld0RldGFpbHMuZGVsdGFVcGRhdGVGYWlsZWQgfHwgIW1haW5EZXRhaWxzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1haW5TbGlkaW5nU3RhcnRGcmFnbWVudCA9IG1haW5EZXRhaWxzLmZyYWdtZW50c1swXTtcbiAgICAgIGlmICghdHJhY2suZGV0YWlscykge1xuICAgICAgICBpZiAobmV3RGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUgJiYgbWFpbkRldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgICAgICAgYWxpZ25NZWRpYVBsYXlsaXN0QnlQRFQobmV3RGV0YWlscywgbWFpbkRldGFpbHMpO1xuICAgICAgICAgIHNsaWRpbmcgPSBuZXdEZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydDtcbiAgICAgICAgfSBlbHNlIGlmIChtYWluU2xpZGluZ1N0YXJ0RnJhZ21lbnQpIHtcbiAgICAgICAgICAvLyBsaW5lIHVwIGxpdmUgcGxheWxpc3Qgd2l0aCBtYWluIHNvIHRoYXQgZnJhZ21lbnRzIGluIHJhbmdlIGFyZSBsb2FkZWRcbiAgICAgICAgICBzbGlkaW5nID0gbWFpblNsaWRpbmdTdGFydEZyYWdtZW50LnN0YXJ0O1xuICAgICAgICAgIGFkZFNsaWRpbmcobmV3RGV0YWlscywgc2xpZGluZyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfdGhpcyRsZXZlbExhc3RMb2FkZWQ7XG4gICAgICAgIHNsaWRpbmcgPSB0aGlzLmFsaWduUGxheWxpc3RzKG5ld0RldGFpbHMsIHRyYWNrLmRldGFpbHMsIChfdGhpcyRsZXZlbExhc3RMb2FkZWQgPSB0aGlzLmxldmVsTGFzdExvYWRlZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGxldmVsTGFzdExvYWRlZC5kZXRhaWxzKTtcbiAgICAgICAgaWYgKHNsaWRpbmcgPT09IDAgJiYgbWFpblNsaWRpbmdTdGFydEZyYWdtZW50KSB7XG4gICAgICAgICAgLy8gcmVhbGlnbiB3aXRoIG1haW4gd2hlbiB0aGVyZSBpcyBubyBvdmVybGFwIHdpdGggbGFzdCByZWZyZXNoXG4gICAgICAgICAgc2xpZGluZyA9IG1haW5TbGlkaW5nU3RhcnRGcmFnbWVudC5zdGFydDtcbiAgICAgICAgICBhZGRTbGlkaW5nKG5ld0RldGFpbHMsIHNsaWRpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRyYWNrLmRldGFpbHMgPSBuZXdEZXRhaWxzO1xuICAgIHRoaXMubGV2ZWxMYXN0TG9hZGVkID0gdHJhY2s7XG4gICAgaWYgKCF0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCAmJiAodGhpcy5tYWluRGV0YWlscyB8fCAhbmV3RGV0YWlscy5saXZlKSkge1xuICAgICAgdGhpcy5zZXRTdGFydFBvc2l0aW9uKHRoaXMubWFpbkRldGFpbHMgfHwgbmV3RGV0YWlscywgc2xpZGluZyk7XG4gICAgfVxuXG4gICAgLy8gdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgIHRoaXMudGljaygpO1xuXG4gICAgLy8gSWYgcGxheWxpc3QgaXMgbWlzYWxpZ25lZCBiZWNhdXNlIG9mIGJhZCBQRFQgb3IgZHJpZnQsIGRlbGV0ZSBkZXRhaWxzIHRvIHJlc3luYyB3aXRoIG1haW4gb24gcmVsb2FkXG4gICAgaWYgKG5ld0RldGFpbHMubGl2ZSAmJiAhdGhpcy5mcmFnQ3VycmVudCAmJiB0aGlzLm1lZGlhICYmIHRoaXMuc3RhdGUgPT09IFN0YXRlLklETEUpIHtcbiAgICAgIGNvbnN0IGZvdW5kRnJhZyA9IGZpbmRGcmFnbWVudEJ5UFRTKG51bGwsIG5ld0RldGFpbHMuZnJhZ21lbnRzLCB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lLCAwKTtcbiAgICAgIGlmICghZm91bmRGcmFnKSB7XG4gICAgICAgIHRoaXMud2FybignU3VidGl0bGUgcGxheWxpc3Qgbm90IGFsaWduZWQgd2l0aCBwbGF5YmFjaycpO1xuICAgICAgICB0cmFjay5kZXRhaWxzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfaGFuZGxlRnJhZ21lbnRMb2FkQ29tcGxldGUoZnJhZ0xvYWRlZERhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnLFxuICAgICAgcGF5bG9hZFxuICAgIH0gPSBmcmFnTG9hZGVkRGF0YTtcbiAgICBjb25zdCBkZWNyeXB0RGF0YSA9IGZyYWcuZGVjcnlwdGRhdGE7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgaWYgKHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGNoZWNrIHRvIHNlZSBpZiB0aGUgcGF5bG9hZCBuZWVkcyB0byBiZSBkZWNyeXB0ZWRcbiAgICBpZiAocGF5bG9hZCAmJiBwYXlsb2FkLmJ5dGVMZW5ndGggPiAwICYmIGRlY3J5cHREYXRhICE9IG51bGwgJiYgZGVjcnlwdERhdGEua2V5ICYmIGRlY3J5cHREYXRhLml2ICYmIGRlY3J5cHREYXRhLm1ldGhvZCA9PT0gJ0FFUy0xMjgnKSB7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIC8vIGRlY3J5cHQgdGhlIHN1YnRpdGxlc1xuICAgICAgdGhpcy5kZWNyeXB0ZXIuZGVjcnlwdChuZXcgVWludDhBcnJheShwYXlsb2FkKSwgZGVjcnlwdERhdGEua2V5LmJ1ZmZlciwgZGVjcnlwdERhdGEuaXYuYnVmZmVyKS5jYXRjaChlcnIgPT4ge1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0RFQ1JZUFRfRVJST1IsXG4gICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgICAgcmVhc29uOiBlcnIubWVzc2FnZSxcbiAgICAgICAgICBmcmFnXG4gICAgICAgIH0pO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9KS50aGVuKGRlY3J5cHRlZERhdGEgPT4ge1xuICAgICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0RFQ1JZUFRFRCwge1xuICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgcGF5bG9hZDogZGVjcnlwdGVkRGF0YSxcbiAgICAgICAgICBzdGF0czoge1xuICAgICAgICAgICAgdHN0YXJ0OiBzdGFydFRpbWUsXG4gICAgICAgICAgICB0ZGVjcnlwdDogZW5kVGltZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICB0aGlzLndhcm4oYCR7ZXJyLm5hbWV9OiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBkb1RpY2soKSB7XG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLklETEUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY3VycmVudFRyYWNrSWQsXG4gICAgICAgIGxldmVsc1xuICAgICAgfSA9IHRoaXM7XG4gICAgICBjb25zdCB0cmFjayA9IGxldmVscyA9PSBudWxsID8gdm9pZCAwIDogbGV2ZWxzW2N1cnJlbnRUcmFja0lkXTtcbiAgICAgIGlmICghdHJhY2sgfHwgIWxldmVscy5sZW5ndGggfHwgIXRyYWNrLmRldGFpbHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBjb25maWdcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgY29uc3QgY3VycmVudFRpbWUgPSB0aGlzLmdldExvYWRQb3NpdGlvbigpO1xuICAgICAgY29uc3QgYnVmZmVyZWRJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlcmVkSW5mbyh0aGlzLnRyYWNrc0J1ZmZlcmVkW3RoaXMuY3VycmVudFRyYWNrSWRdIHx8IFtdLCBjdXJyZW50VGltZSwgY29uZmlnLm1heEJ1ZmZlckhvbGUpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBlbmQ6IHRhcmdldEJ1ZmZlclRpbWUsXG4gICAgICAgIGxlbjogYnVmZmVyTGVuXG4gICAgICB9ID0gYnVmZmVyZWRJbmZvO1xuICAgICAgY29uc3QgbWFpbkJ1ZmZlckluZm8gPSB0aGlzLmdldEZ3ZEJ1ZmZlckluZm8odGhpcy5tZWRpYSwgUGxheWxpc3RMZXZlbFR5cGUuTUFJTik7XG4gICAgICBjb25zdCB0cmFja0RldGFpbHMgPSB0cmFjay5kZXRhaWxzO1xuICAgICAgY29uc3QgbWF4QnVmTGVuID0gdGhpcy5nZXRNYXhCdWZmZXJMZW5ndGgobWFpbkJ1ZmZlckluZm8gPT0gbnVsbCA/IHZvaWQgMCA6IG1haW5CdWZmZXJJbmZvLmxlbikgKyB0cmFja0RldGFpbHMubGV2ZWxUYXJnZXREdXJhdGlvbjtcbiAgICAgIGlmIChidWZmZXJMZW4gPiBtYXhCdWZMZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZnJhZ21lbnRzID0gdHJhY2tEZXRhaWxzLmZyYWdtZW50cztcbiAgICAgIGNvbnN0IGZyYWdMZW4gPSBmcmFnbWVudHMubGVuZ3RoO1xuICAgICAgY29uc3QgZW5kID0gdHJhY2tEZXRhaWxzLmVkZ2U7XG4gICAgICBsZXQgZm91bmRGcmFnID0gbnVsbDtcbiAgICAgIGNvbnN0IGZyYWdQcmV2aW91cyA9IHRoaXMuZnJhZ1ByZXZpb3VzO1xuICAgICAgaWYgKHRhcmdldEJ1ZmZlclRpbWUgPCBlbmQpIHtcbiAgICAgICAgY29uc3QgdG9sZXJhbmNlID0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2U7XG4gICAgICAgIGNvbnN0IGxvb2t1cFRvbGVyYW5jZSA9IHRhcmdldEJ1ZmZlclRpbWUgPiBlbmQgLSB0b2xlcmFuY2UgPyAwIDogdG9sZXJhbmNlO1xuICAgICAgICBmb3VuZEZyYWcgPSBmaW5kRnJhZ21lbnRCeVBUUyhmcmFnUHJldmlvdXMsIGZyYWdtZW50cywgTWF0aC5tYXgoZnJhZ21lbnRzWzBdLnN0YXJ0LCB0YXJnZXRCdWZmZXJUaW1lKSwgbG9va3VwVG9sZXJhbmNlKTtcbiAgICAgICAgaWYgKCFmb3VuZEZyYWcgJiYgZnJhZ1ByZXZpb3VzICYmIGZyYWdQcmV2aW91cy5zdGFydCA8IGZyYWdtZW50c1swXS5zdGFydCkge1xuICAgICAgICAgIGZvdW5kRnJhZyA9IGZyYWdtZW50c1swXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm91bmRGcmFnID0gZnJhZ21lbnRzW2ZyYWdMZW4gLSAxXTtcbiAgICAgIH1cbiAgICAgIGlmICghZm91bmRGcmFnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvdW5kRnJhZyA9IHRoaXMubWFwVG9Jbml0RnJhZ1doZW5SZXF1aXJlZChmb3VuZEZyYWcpO1xuICAgICAgaWYgKGZvdW5kRnJhZy5zbiAhPT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgICAvLyBMb2FkIGVhcmxpZXIgZnJhZ21lbnQgaW4gc2FtZSBkaXNjb250aW51aXR5IHRvIG1ha2UgdXAgZm9yIG1pc2FsaWduZWQgcGxheWxpc3RzIGFuZCBjdWVzIHRoYXQgZXh0ZW5kIGJleW9uZCBlbmQgb2Ygc2VnbWVudFxuICAgICAgICBjb25zdCBjdXJTTklkeCA9IGZvdW5kRnJhZy5zbiAtIHRyYWNrRGV0YWlscy5zdGFydFNOO1xuICAgICAgICBjb25zdCBwcmV2RnJhZyA9IGZyYWdtZW50c1tjdXJTTklkeCAtIDFdO1xuICAgICAgICBpZiAocHJldkZyYWcgJiYgcHJldkZyYWcuY2MgPT09IGZvdW5kRnJhZy5jYyAmJiB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShwcmV2RnJhZykgPT09IEZyYWdtZW50U3RhdGUuTk9UX0xPQURFRCkge1xuICAgICAgICAgIGZvdW5kRnJhZyA9IHByZXZGcmFnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZm91bmRGcmFnKSA9PT0gRnJhZ21lbnRTdGF0ZS5OT1RfTE9BREVEKSB7XG4gICAgICAgIC8vIG9ubHkgbG9hZCBpZiBmcmFnbWVudCBpcyBub3QgbG9hZGVkXG4gICAgICAgIHRoaXMubG9hZEZyYWdtZW50KGZvdW5kRnJhZywgdHJhY2ssIHRhcmdldEJ1ZmZlclRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXRNYXhCdWZmZXJMZW5ndGgobWFpbkJ1ZmZlckxlbmd0aCkge1xuICAgIGNvbnN0IG1heENvbmZpZ0J1ZmZlciA9IHN1cGVyLmdldE1heEJ1ZmZlckxlbmd0aCgpO1xuICAgIGlmICghbWFpbkJ1ZmZlckxlbmd0aCkge1xuICAgICAgcmV0dXJuIG1heENvbmZpZ0J1ZmZlcjtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgubWF4KG1heENvbmZpZ0J1ZmZlciwgbWFpbkJ1ZmZlckxlbmd0aCk7XG4gIH1cbiAgbG9hZEZyYWdtZW50KGZyYWcsIGxldmVsLCB0YXJnZXRCdWZmZXJUaW1lKSB7XG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7XG4gICAgaWYgKGZyYWcuc24gPT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgIHRoaXMuX2xvYWRJbml0U2VnbWVudChmcmFnLCBsZXZlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgIHN1cGVyLmxvYWRGcmFnbWVudChmcmFnLCBsZXZlbCwgdGFyZ2V0QnVmZmVyVGltZSk7XG4gICAgfVxuICB9XG4gIGdldCBtZWRpYUJ1ZmZlclRpbWVSYW5nZXMoKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXJhYmxlSW5zdGFuY2UodGhpcy50cmFja3NCdWZmZXJlZFt0aGlzLmN1cnJlbnRUcmFja0lkXSB8fCBbXSk7XG4gIH1cbn1cbmNsYXNzIEJ1ZmZlcmFibGVJbnN0YW5jZSB7XG4gIGNvbnN0cnVjdG9yKHRpbWVyYW5nZXMpIHtcbiAgICB0aGlzLmJ1ZmZlcmVkID0gdm9pZCAwO1xuICAgIGNvbnN0IGdldFJhbmdlID0gKG5hbWUsIGluZGV4LCBsZW5ndGgpID0+IHtcbiAgICAgIGluZGV4ID0gaW5kZXggPj4+IDA7XG4gICAgICBpZiAoaW5kZXggPiBsZW5ndGggLSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oYEZhaWxlZCB0byBleGVjdXRlICcke25hbWV9JyBvbiAnVGltZVJhbmdlcyc6IFRoZSBpbmRleCBwcm92aWRlZCAoJHtpbmRleH0pIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbWF4aW11bSBib3VuZCAoJHtsZW5ndGh9KWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRpbWVyYW5nZXNbaW5kZXhdW25hbWVdO1xuICAgIH07XG4gICAgdGhpcy5idWZmZXJlZCA9IHtcbiAgICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aW1lcmFuZ2VzLmxlbmd0aDtcbiAgICAgIH0sXG4gICAgICBlbmQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGdldFJhbmdlKCdlbmQnLCBpbmRleCwgdGltZXJhbmdlcy5sZW5ndGgpO1xuICAgICAgfSxcbiAgICAgIHN0YXJ0KGluZGV4KSB7XG4gICAgICAgIHJldHVybiBnZXRSYW5nZSgnc3RhcnQnLCBpbmRleCwgdGltZXJhbmdlcy5sZW5ndGgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxuY2xhc3MgU3VidGl0bGVUcmFja0NvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlUGxheWxpc3RDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgc3VwZXIoaGxzLCAnW3N1YnRpdGxlLXRyYWNrLWNvbnRyb2xsZXJdJyk7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy50cmFja3MgPSBbXTtcbiAgICB0aGlzLmdyb3VwSWRzID0gbnVsbDtcbiAgICB0aGlzLnRyYWNrc0luR3JvdXAgPSBbXTtcbiAgICB0aGlzLnRyYWNrSWQgPSAtMTtcbiAgICB0aGlzLmN1cnJlbnRUcmFjayA9IG51bGw7XG4gICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSB0cnVlO1xuICAgIHRoaXMucXVldWVkRGVmYXVsdFRyYWNrID0gLTE7XG4gICAgdGhpcy5hc3luY1BvbGxUcmFja0NoYW5nZSA9ICgpID0+IHRoaXMucG9sbFRyYWNrQ2hhbmdlKDApO1xuICAgIHRoaXMudXNlVGV4dFRyYWNrUG9sbGluZyA9IGZhbHNlO1xuICAgIHRoaXMuc3VidGl0bGVQb2xsaW5nSW50ZXJ2YWwgPSAtMTtcbiAgICB0aGlzLl9zdWJ0aXRsZURpc3BsYXkgPSB0cnVlO1xuICAgIHRoaXMub25UZXh0VHJhY2tzQ2hhbmdlZCA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy51c2VUZXh0VHJhY2tQb2xsaW5nKSB7XG4gICAgICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnN1YnRpdGxlUG9sbGluZ0ludGVydmFsKTtcbiAgICAgIH1cbiAgICAgIC8vIE1lZGlhIGlzIHVuZGVmaW5lZCB3aGVuIHN3aXRjaGluZyBzdHJlYW1zIHZpYSBsb2FkU291cmNlKClcbiAgICAgIGlmICghdGhpcy5tZWRpYSB8fCAhdGhpcy5obHMuY29uZmlnLnJlbmRlclRleHRUcmFja3NOYXRpdmVseSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgdGV4dFRyYWNrID0gbnVsbDtcbiAgICAgIGNvbnN0IHRyYWNrcyA9IGZpbHRlclN1YnRpdGxlVHJhY2tzKHRoaXMubWVkaWEudGV4dFRyYWNrcyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodHJhY2tzW2ldLm1vZGUgPT09ICdoaWRkZW4nKSB7XG4gICAgICAgICAgLy8gRG8gbm90IGJyZWFrIGluIGNhc2UgdGhlcmUgaXMgYSBmb2xsb3dpbmcgdHJhY2sgd2l0aCBzaG93aW5nLlxuICAgICAgICAgIHRleHRUcmFjayA9IHRyYWNrc1tpXTtcbiAgICAgICAgfSBlbHNlIGlmICh0cmFja3NbaV0ubW9kZSA9PT0gJ3Nob3dpbmcnKSB7XG4gICAgICAgICAgdGV4dFRyYWNrID0gdHJhY2tzW2ldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEZpbmQgaW50ZXJuYWwgdHJhY2sgaW5kZXggZm9yIFRleHRUcmFja1xuICAgICAgY29uc3QgdHJhY2tJZCA9IHRoaXMuZmluZFRyYWNrRm9yVGV4dFRyYWNrKHRleHRUcmFjayk7XG4gICAgICBpZiAodGhpcy5zdWJ0aXRsZVRyYWNrICE9PSB0cmFja0lkKSB7XG4gICAgICAgIHRoaXMuc2V0U3VidGl0bGVUcmFjayh0cmFja0lkKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHRoaXMudHJhY2tzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy50cmFja3NJbkdyb3VwLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5jdXJyZW50VHJhY2sgPSBudWxsO1xuICAgIHRoaXMub25UZXh0VHJhY2tzQ2hhbmdlZCA9IHRoaXMuYXN5bmNQb2xsVHJhY2tDaGFuZ2UgPSBudWxsO1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxuICBnZXQgc3VidGl0bGVEaXNwbGF5KCkge1xuICAgIHJldHVybiB0aGlzLl9zdWJ0aXRsZURpc3BsYXk7XG4gIH1cbiAgc2V0IHN1YnRpdGxlRGlzcGxheSh2YWx1ZSkge1xuICAgIHRoaXMuX3N1YnRpdGxlRGlzcGxheSA9IHZhbHVlO1xuICAgIGlmICh0aGlzLnRyYWNrSWQgPiAtMSkge1xuICAgICAgdGhpcy50b2dnbGVUcmFja01vZGVzKCk7XG4gICAgfVxuICB9XG4gIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxfTE9BRElORywgdGhpcy5vbkxldmVsTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9TV0lUQ0hJTkcsIHRoaXMub25MZXZlbFN3aXRjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5TVUJUSVRMRV9UUkFDS19MT0FERUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9XG4gIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX0xPQURJTkcsIHRoaXMub25MZXZlbExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX1NXSVRDSElORywgdGhpcy5vbkxldmVsU3dpdGNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5TVUJUSVRMRV9UUkFDS19MT0FERUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfVxuXG4gIC8vIExpc3RlbiBmb3Igc3VidGl0bGUgdHJhY2sgY2hhbmdlLCB0aGVuIGV4dHJhY3QgdGhlIGN1cnJlbnQgdHJhY2sgSUQuXG4gIG9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5xdWV1ZWREZWZhdWx0VHJhY2sgPiAtMSkge1xuICAgICAgdGhpcy5zdWJ0aXRsZVRyYWNrID0gdGhpcy5xdWV1ZWREZWZhdWx0VHJhY2s7XG4gICAgICB0aGlzLnF1ZXVlZERlZmF1bHRUcmFjayA9IC0xO1xuICAgIH1cbiAgICB0aGlzLnVzZVRleHRUcmFja1BvbGxpbmcgPSAhKHRoaXMubWVkaWEudGV4dFRyYWNrcyAmJiAnb25jaGFuZ2UnIGluIHRoaXMubWVkaWEudGV4dFRyYWNrcyk7XG4gICAgaWYgKHRoaXMudXNlVGV4dFRyYWNrUG9sbGluZykge1xuICAgICAgdGhpcy5wb2xsVHJhY2tDaGFuZ2UoNTAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tZWRpYS50ZXh0VHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuYXN5bmNQb2xsVHJhY2tDaGFuZ2UpO1xuICAgIH1cbiAgfVxuICBwb2xsVHJhY2tDaGFuZ2UodGltZW91dCkge1xuICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnN1YnRpdGxlUG9sbGluZ0ludGVydmFsKTtcbiAgICB0aGlzLnN1YnRpdGxlUG9sbGluZ0ludGVydmFsID0gc2VsZi5zZXRJbnRlcnZhbCh0aGlzLm9uVGV4dFRyYWNrc0NoYW5nZWQsIHRpbWVvdXQpO1xuICB9XG4gIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnN1YnRpdGxlUG9sbGluZ0ludGVydmFsKTtcbiAgICBpZiAoIXRoaXMudXNlVGV4dFRyYWNrUG9sbGluZykge1xuICAgICAgdGhpcy5tZWRpYS50ZXh0VHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuYXN5bmNQb2xsVHJhY2tDaGFuZ2UpO1xuICAgIH1cbiAgICBpZiAodGhpcy50cmFja0lkID4gLTEpIHtcbiAgICAgIHRoaXMucXVldWVkRGVmYXVsdFRyYWNrID0gdGhpcy50cmFja0lkO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0VHJhY2tzID0gZmlsdGVyU3VidGl0bGVUcmFja3ModGhpcy5tZWRpYS50ZXh0VHJhY2tzKTtcbiAgICAvLyBDbGVhciBsb2FkZWQgY3VlcyBvbiBtZWRpYSBkZXRhY2htZW50IGZyb20gdHJhY2tzXG4gICAgdGV4dFRyYWNrcy5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgIGNsZWFyQ3VycmVudEN1ZXModHJhY2spO1xuICAgIH0pO1xuICAgIC8vIERpc2FibGUgYWxsIHN1YnRpdGxlIHRyYWNrcyBiZWZvcmUgZGV0YWNobWVudCBzbyB3aGVuIHJlYXR0YWNoZWQgb25seSB0cmFja3MgaW4gdGhhdCBjb250ZW50IGFyZSBlbmFibGVkLlxuICAgIHRoaXMuc3VidGl0bGVUcmFjayA9IC0xO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgdGhpcy5ncm91cElkcyA9IG51bGw7XG4gICAgdGhpcy50cmFja3NJbkdyb3VwID0gW107XG4gICAgdGhpcy50cmFja0lkID0gLTE7XG4gICAgdGhpcy5jdXJyZW50VHJhY2sgPSBudWxsO1xuICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIEZpcmVkIHdoZW5ldmVyIGEgbmV3IG1hbmlmZXN0IGlzIGxvYWRlZC5cbiAgb25NYW5pZmVzdFBhcnNlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMudHJhY2tzID0gZGF0YS5zdWJ0aXRsZVRyYWNrcztcbiAgfVxuICBvblN1YnRpdGxlVHJhY2tMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIGdyb3VwSWQsXG4gICAgICBkZXRhaWxzXG4gICAgfSA9IGRhdGE7XG4gICAgY29uc3QgdHJhY2tJbkFjdGl2ZUdyb3VwID0gdGhpcy50cmFja3NJbkdyb3VwW2lkXTtcbiAgICBpZiAoIXRyYWNrSW5BY3RpdmVHcm91cCB8fCB0cmFja0luQWN0aXZlR3JvdXAuZ3JvdXBJZCAhPT0gZ3JvdXBJZCkge1xuICAgICAgdGhpcy53YXJuKGBTdWJ0aXRsZSB0cmFjayB3aXRoIGlkOiR7aWR9IGFuZCBncm91cDoke2dyb3VwSWR9IG5vdCBmb3VuZCBpbiBhY3RpdmUgZ3JvdXAgJHt0cmFja0luQWN0aXZlR3JvdXAgPT0gbnVsbCA/IHZvaWQgMCA6IHRyYWNrSW5BY3RpdmVHcm91cC5ncm91cElkfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJEZXRhaWxzID0gdHJhY2tJbkFjdGl2ZUdyb3VwLmRldGFpbHM7XG4gICAgdHJhY2tJbkFjdGl2ZUdyb3VwLmRldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgdGhpcy5sb2coYFN1YnRpdGxlIHRyYWNrICR7aWR9IFwiJHt0cmFja0luQWN0aXZlR3JvdXAubmFtZX1cIiBsYW5nOiR7dHJhY2tJbkFjdGl2ZUdyb3VwLmxhbmd9IGdyb3VwOiR7Z3JvdXBJZH0gbG9hZGVkIFske2RldGFpbHMuc3RhcnRTTn0tJHtkZXRhaWxzLmVuZFNOfV1gKTtcbiAgICBpZiAoaWQgPT09IHRoaXMudHJhY2tJZCkge1xuICAgICAgdGhpcy5wbGF5bGlzdExvYWRlZChpZCwgZGF0YSwgY3VyRGV0YWlscyk7XG4gICAgfVxuICB9XG4gIG9uTGV2ZWxMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5zd2l0Y2hMZXZlbChkYXRhLmxldmVsKTtcbiAgfVxuICBvbkxldmVsU3dpdGNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5zd2l0Y2hMZXZlbChkYXRhLmxldmVsKTtcbiAgfVxuICBzd2l0Y2hMZXZlbChsZXZlbEluZGV4KSB7XG4gICAgY29uc3QgbGV2ZWxJbmZvID0gdGhpcy5obHMubGV2ZWxzW2xldmVsSW5kZXhdO1xuICAgIGlmICghbGV2ZWxJbmZvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN1YnRpdGxlR3JvdXBzID0gbGV2ZWxJbmZvLnN1YnRpdGxlR3JvdXBzIHx8IG51bGw7XG4gICAgY29uc3QgY3VycmVudEdyb3VwcyA9IHRoaXMuZ3JvdXBJZHM7XG4gICAgbGV0IGN1cnJlbnRUcmFjayA9IHRoaXMuY3VycmVudFRyYWNrO1xuICAgIGlmICghc3VidGl0bGVHcm91cHMgfHwgKGN1cnJlbnRHcm91cHMgPT0gbnVsbCA/IHZvaWQgMCA6IGN1cnJlbnRHcm91cHMubGVuZ3RoKSAhPT0gKHN1YnRpdGxlR3JvdXBzID09IG51bGwgPyB2b2lkIDAgOiBzdWJ0aXRsZUdyb3Vwcy5sZW5ndGgpIHx8IHN1YnRpdGxlR3JvdXBzICE9IG51bGwgJiYgc3VidGl0bGVHcm91cHMuc29tZShncm91cElkID0+IChjdXJyZW50R3JvdXBzID09IG51bGwgPyB2b2lkIDAgOiBjdXJyZW50R3JvdXBzLmluZGV4T2YoZ3JvdXBJZCkpID09PSAtMSkpIHtcbiAgICAgIHRoaXMuZ3JvdXBJZHMgPSBzdWJ0aXRsZUdyb3VwcztcbiAgICAgIHRoaXMudHJhY2tJZCA9IC0xO1xuICAgICAgdGhpcy5jdXJyZW50VHJhY2sgPSBudWxsO1xuICAgICAgY29uc3Qgc3VidGl0bGVUcmFja3MgPSB0aGlzLnRyYWNrcy5maWx0ZXIodHJhY2sgPT4gIXN1YnRpdGxlR3JvdXBzIHx8IHN1YnRpdGxlR3JvdXBzLmluZGV4T2YodHJhY2suZ3JvdXBJZCkgIT09IC0xKTtcbiAgICAgIGlmIChzdWJ0aXRsZVRyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gRGlzYWJsZSBzZWxlY3REZWZhdWx0VHJhY2sgaWYgdGhlcmUgYXJlIG5vIGRlZmF1bHQgdHJhY2tzXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdERlZmF1bHRUcmFjayAmJiAhc3VidGl0bGVUcmFja3Muc29tZSh0cmFjayA9PiB0cmFjay5kZWZhdWx0KSkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHJhY2suaWQgc2hvdWxkIG1hdGNoIGhscy5hdWRpb1RyYWNrcyBpbmRleFxuICAgICAgICBzdWJ0aXRsZVRyYWNrcy5mb3JFYWNoKCh0cmFjaywgaSkgPT4ge1xuICAgICAgICAgIHRyYWNrLmlkID0gaTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKCFjdXJyZW50VHJhY2sgJiYgIXRoaXMudHJhY2tzSW5Hcm91cC5sZW5ndGgpIHtcbiAgICAgICAgLy8gRG8gbm90IGRpc3BhdGNoIFNVQlRJVExFX1RSQUNLU19VUERBVEVEIHdoZW4gdGhlcmUgd2VyZSBhbmQgYXJlIG5vIHRyYWNrc1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnRyYWNrc0luR3JvdXAgPSBzdWJ0aXRsZVRyYWNrcztcblxuICAgICAgLy8gRmluZCBwcmVmZXJyZWQgdHJhY2tcbiAgICAgIGNvbnN0IHN1YnRpdGxlUHJlZmVyZW5jZSA9IHRoaXMuaGxzLmNvbmZpZy5zdWJ0aXRsZVByZWZlcmVuY2U7XG4gICAgICBpZiAoIWN1cnJlbnRUcmFjayAmJiBzdWJ0aXRsZVByZWZlcmVuY2UpIHtcbiAgICAgICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgZ3JvdXBJbmRleCA9IGZpbmRNYXRjaGluZ09wdGlvbihzdWJ0aXRsZVByZWZlcmVuY2UsIHN1YnRpdGxlVHJhY2tzKTtcbiAgICAgICAgaWYgKGdyb3VwSW5kZXggPiAtMSkge1xuICAgICAgICAgIGN1cnJlbnRUcmFjayA9IHN1YnRpdGxlVHJhY2tzW2dyb3VwSW5kZXhdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGFsbEluZGV4ID0gZmluZE1hdGNoaW5nT3B0aW9uKHN1YnRpdGxlUHJlZmVyZW5jZSwgdGhpcy50cmFja3MpO1xuICAgICAgICAgIGN1cnJlbnRUcmFjayA9IHRoaXMudHJhY2tzW2FsbEluZGV4XTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBTZWxlY3QgaW5pdGlhbCB0cmFja1xuICAgICAgbGV0IHRyYWNrSWQgPSB0aGlzLmZpbmRUcmFja0lkKGN1cnJlbnRUcmFjayk7XG4gICAgICBpZiAodHJhY2tJZCA9PT0gLTEgJiYgY3VycmVudFRyYWNrKSB7XG4gICAgICAgIHRyYWNrSWQgPSB0aGlzLmZpbmRUcmFja0lkKG51bGwpO1xuICAgICAgfVxuXG4gICAgICAvLyBEaXNwYXRjaCBldmVudHMgYW5kIGxvYWQgdHJhY2sgaWYgbmVlZGVkXG4gICAgICBjb25zdCBzdWJ0aXRsZVRyYWNrc1VwZGF0ZWQgPSB7XG4gICAgICAgIHN1YnRpdGxlVHJhY2tzXG4gICAgICB9O1xuICAgICAgdGhpcy5sb2coYFVwZGF0aW5nIHN1YnRpdGxlIHRyYWNrcywgJHtzdWJ0aXRsZVRyYWNrcy5sZW5ndGh9IHRyYWNrKHMpIGZvdW5kIGluIFwiJHtzdWJ0aXRsZUdyb3VwcyA9PSBudWxsID8gdm9pZCAwIDogc3VidGl0bGVHcm91cHMuam9pbignLCcpfVwiIGdyb3VwLWlkYCk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5TVUJUSVRMRV9UUkFDS1NfVVBEQVRFRCwgc3VidGl0bGVUcmFja3NVcGRhdGVkKTtcbiAgICAgIGlmICh0cmFja0lkICE9PSAtMSAmJiB0aGlzLnRyYWNrSWQgPT09IC0xKSB7XG4gICAgICAgIHRoaXMuc2V0U3VidGl0bGVUcmFjayh0cmFja0lkKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuc2hvdWxkUmVsb2FkUGxheWxpc3QoY3VycmVudFRyYWNrKSkge1xuICAgICAgLy8gUmV0cnkgcGxheWxpc3QgbG9hZGluZyBpZiBubyBwbGF5bGlzdCBpcyBvciBoYXMgYmVlbiBsb2FkZWQgeWV0XG4gICAgICB0aGlzLnNldFN1YnRpdGxlVHJhY2sodGhpcy50cmFja0lkKTtcbiAgICB9XG4gIH1cbiAgZmluZFRyYWNrSWQoY3VycmVudFRyYWNrKSB7XG4gICAgY29uc3QgdHJhY2tzID0gdGhpcy50cmFja3NJbkdyb3VwO1xuICAgIGNvbnN0IHNlbGVjdERlZmF1bHQgPSB0aGlzLnNlbGVjdERlZmF1bHRUcmFjaztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdHJhY2sgPSB0cmFja3NbaV07XG4gICAgICBpZiAoc2VsZWN0RGVmYXVsdCAmJiAhdHJhY2suZGVmYXVsdCB8fCAhc2VsZWN0RGVmYXVsdCAmJiAhY3VycmVudFRyYWNrKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFjdXJyZW50VHJhY2sgfHwgbWF0Y2hlc09wdGlvbih0cmFjaywgY3VycmVudFRyYWNrKSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGN1cnJlbnRUcmFjaykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdHJhY2sgPSB0cmFja3NbaV07XG4gICAgICAgIGlmIChtZWRpYUF0dHJpYnV0ZXNJZGVudGljYWwoY3VycmVudFRyYWNrLmF0dHJzLCB0cmFjay5hdHRycywgWydMQU5HVUFHRScsICdBU1NPQy1MQU5HVUFHRScsICdDSEFSQUNURVJJU1RJQ1MnXSkpIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdHJhY2sgPSB0cmFja3NbaV07XG4gICAgICAgIGlmIChtZWRpYUF0dHJpYnV0ZXNJZGVudGljYWwoY3VycmVudFRyYWNrLmF0dHJzLCB0cmFjay5hdHRycywgWydMQU5HVUFHRSddKSkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICBmaW5kVHJhY2tGb3JUZXh0VHJhY2sodGV4dFRyYWNrKSB7XG4gICAgaWYgKHRleHRUcmFjaykge1xuICAgICAgY29uc3QgdHJhY2tzID0gdGhpcy50cmFja3NJbkdyb3VwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdHJhY2sgPSB0cmFja3NbaV07XG4gICAgICAgIGlmIChzdWJ0aXRsZVRyYWNrTWF0Y2hlc1RleHRUcmFjayh0cmFjaywgdGV4dFRyYWNrKSkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKGRhdGEuZmF0YWwgfHwgIWRhdGEuY29udGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGF0YS5jb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuU1VCVElUTEVfVFJBQ0sgJiYgZGF0YS5jb250ZXh0LmlkID09PSB0aGlzLnRyYWNrSWQgJiYgKCF0aGlzLmdyb3VwSWRzIHx8IHRoaXMuZ3JvdXBJZHMuaW5kZXhPZihkYXRhLmNvbnRleHQuZ3JvdXBJZCkgIT09IC0xKSkge1xuICAgICAgdGhpcy5jaGVja1JldHJ5KGRhdGEpO1xuICAgIH1cbiAgfVxuICBnZXQgYWxsU3VidGl0bGVUcmFja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2tzO1xuICB9XG5cbiAgLyoqIGdldCBhbHRlcm5hdGUgc3VidGl0bGUgdHJhY2tzIGxpc3QgZnJvbSBwbGF5bGlzdCAqKi9cbiAgZ2V0IHN1YnRpdGxlVHJhY2tzKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrc0luR3JvdXA7XG4gIH1cblxuICAvKiogZ2V0L3NldCBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgc3VidGl0bGUgdHJhY2sgKGJhc2VkIG9uIGluZGV4IGluIHN1YnRpdGxlIHRyYWNrIGxpc3RzKSAqKi9cbiAgZ2V0IHN1YnRpdGxlVHJhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2tJZDtcbiAgfVxuICBzZXQgc3VidGl0bGVUcmFjayhuZXdJZCkge1xuICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gZmFsc2U7XG4gICAgdGhpcy5zZXRTdWJ0aXRsZVRyYWNrKG5ld0lkKTtcbiAgfVxuICBzZXRTdWJ0aXRsZU9wdGlvbihzdWJ0aXRsZU9wdGlvbikge1xuICAgIHRoaXMuaGxzLmNvbmZpZy5zdWJ0aXRsZVByZWZlcmVuY2UgPSBzdWJ0aXRsZU9wdGlvbjtcbiAgICBpZiAoc3VidGl0bGVPcHRpb24pIHtcbiAgICAgIGNvbnN0IGFsbFN1YnRpdGxlVHJhY2tzID0gdGhpcy5hbGxTdWJ0aXRsZVRyYWNrcztcbiAgICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gZmFsc2U7XG4gICAgICBpZiAoYWxsU3VidGl0bGVUcmFja3MubGVuZ3RoKSB7XG4gICAgICAgIC8vIEZpcnN0IHNlZSBpZiBjdXJyZW50IG9wdGlvbiBtYXRjaGVzIChubyBzd2l0Y2ggb3ApXG4gICAgICAgIGNvbnN0IGN1cnJlbnRUcmFjayA9IHRoaXMuY3VycmVudFRyYWNrO1xuICAgICAgICBpZiAoY3VycmVudFRyYWNrICYmIG1hdGNoZXNPcHRpb24oc3VidGl0bGVPcHRpb24sIGN1cnJlbnRUcmFjaykpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudFRyYWNrO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmQgb3B0aW9uIGluIGN1cnJlbnQgZ3JvdXBcbiAgICAgICAgY29uc3QgZ3JvdXBJbmRleCA9IGZpbmRNYXRjaGluZ09wdGlvbihzdWJ0aXRsZU9wdGlvbiwgdGhpcy50cmFja3NJbkdyb3VwKTtcbiAgICAgICAgaWYgKGdyb3VwSW5kZXggPiAtMSkge1xuICAgICAgICAgIGNvbnN0IHRyYWNrID0gdGhpcy50cmFja3NJbkdyb3VwW2dyb3VwSW5kZXhdO1xuICAgICAgICAgIHRoaXMuc2V0U3VidGl0bGVUcmFjayhncm91cEluZGV4KTtcbiAgICAgICAgICByZXR1cm4gdHJhY2s7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFRyYWNrKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBpcyBub3QgdGhlIGluaXRpYWwgc2VsZWN0aW9uIHJldHVybiBudWxsXG4gICAgICAgICAgLy8gb3B0aW9uIHNob3VsZCBoYXZlIG1hdGNoZWQgb25lIGluIGFjdGl2ZSBncm91cFxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEZpbmQgdGhlIG9wdGlvbiBpbiBhbGwgdHJhY2tzIGZvciBpbml0aWFsIHNlbGVjdGlvblxuICAgICAgICAgIGNvbnN0IGFsbEluZGV4ID0gZmluZE1hdGNoaW5nT3B0aW9uKHN1YnRpdGxlT3B0aW9uLCBhbGxTdWJ0aXRsZVRyYWNrcyk7XG4gICAgICAgICAgaWYgKGFsbEluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBhbGxTdWJ0aXRsZVRyYWNrc1thbGxJbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxvYWRQbGF5bGlzdChobHNVcmxQYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIubG9hZFBsYXlsaXN0KCk7XG4gICAgY29uc3QgY3VycmVudFRyYWNrID0gdGhpcy5jdXJyZW50VHJhY2s7XG4gICAgaWYgKHRoaXMuc2hvdWxkTG9hZFBsYXlsaXN0KGN1cnJlbnRUcmFjaykgJiYgY3VycmVudFRyYWNrKSB7XG4gICAgICBjb25zdCBpZCA9IGN1cnJlbnRUcmFjay5pZDtcbiAgICAgIGNvbnN0IGdyb3VwSWQgPSBjdXJyZW50VHJhY2suZ3JvdXBJZDtcbiAgICAgIGxldCB1cmwgPSBjdXJyZW50VHJhY2sudXJsO1xuICAgICAgaWYgKGhsc1VybFBhcmFtZXRlcnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB1cmwgPSBobHNVcmxQYXJhbWV0ZXJzLmFkZERpcmVjdGl2ZXModXJsKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLndhcm4oYENvdWxkIG5vdCBjb25zdHJ1Y3QgbmV3IFVSTCB3aXRoIEhMUyBEZWxpdmVyeSBEaXJlY3RpdmVzOiAke2Vycm9yfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmxvZyhgTG9hZGluZyBzdWJ0aXRsZSBwbGF5bGlzdCBmb3IgaWQgJHtpZH1gKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLlNVQlRJVExFX1RSQUNLX0xPQURJTkcsIHtcbiAgICAgICAgdXJsLFxuICAgICAgICBpZCxcbiAgICAgICAgZ3JvdXBJZCxcbiAgICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzOiBobHNVcmxQYXJhbWV0ZXJzIHx8IG51bGxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNhYmxlcyB0aGUgb2xkIHN1YnRpdGxlVHJhY2sgYW5kIHNldHMgY3VycmVudCBtb2RlIG9uIHRoZSBuZXh0IHN1YnRpdGxlVHJhY2suXG4gICAqIFRoaXMgb3BlcmF0ZXMgb24gdGhlIERPTSB0ZXh0VHJhY2tzLlxuICAgKiBBIHZhbHVlIG9mIC0xIHdpbGwgZGlzYWJsZSBhbGwgc3VidGl0bGUgdHJhY2tzLlxuICAgKi9cbiAgdG9nZ2xlVHJhY2tNb2RlcygpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZWRpYVxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghbWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGV4dFRyYWNrcyA9IGZpbHRlclN1YnRpdGxlVHJhY2tzKG1lZGlhLnRleHRUcmFja3MpO1xuICAgIGNvbnN0IGN1cnJlbnRUcmFjayA9IHRoaXMuY3VycmVudFRyYWNrO1xuICAgIGxldCBuZXh0VHJhY2s7XG4gICAgaWYgKGN1cnJlbnRUcmFjaykge1xuICAgICAgbmV4dFRyYWNrID0gdGV4dFRyYWNrcy5maWx0ZXIodGV4dFRyYWNrID0+IHN1YnRpdGxlVHJhY2tNYXRjaGVzVGV4dFRyYWNrKGN1cnJlbnRUcmFjaywgdGV4dFRyYWNrKSlbMF07XG4gICAgICBpZiAoIW5leHRUcmFjaykge1xuICAgICAgICB0aGlzLndhcm4oYFVuYWJsZSB0byBmaW5kIHN1YnRpdGxlIFRleHRUcmFjayB3aXRoIG5hbWUgXCIke2N1cnJlbnRUcmFjay5uYW1lfVwiIGFuZCBsYW5ndWFnZSBcIiR7Y3VycmVudFRyYWNrLmxhbmd9XCJgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgW10uc2xpY2UuY2FsbCh0ZXh0VHJhY2tzKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgIGlmICh0cmFjay5tb2RlICE9PSAnZGlzYWJsZWQnICYmIHRyYWNrICE9PSBuZXh0VHJhY2spIHtcbiAgICAgICAgdHJhY2subW9kZSA9ICdkaXNhYmxlZCc7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKG5leHRUcmFjaykge1xuICAgICAgY29uc3QgbW9kZSA9IHRoaXMuc3VidGl0bGVEaXNwbGF5ID8gJ3Nob3dpbmcnIDogJ2hpZGRlbic7XG4gICAgICBpZiAobmV4dFRyYWNrLm1vZGUgIT09IG1vZGUpIHtcbiAgICAgICAgbmV4dFRyYWNrLm1vZGUgPSBtb2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBpcyByZXNwb25zaWJsZSBmb3IgdmFsaWRhdGluZyB0aGUgc3VidGl0bGUgaW5kZXggYW5kIHBlcmlvZGljYWxseSByZWxvYWRpbmcgaWYgbGl2ZS5cbiAgICogRGlzcGF0Y2hlcyB0aGUgU1VCVElUTEVfVFJBQ0tfU1dJVENIIGV2ZW50LCB3aGljaCBpbnN0cnVjdHMgdGhlIHN1YnRpdGxlLXN0cmVhbS1jb250cm9sbGVyIHRvIGxvYWQgdGhlIHNlbGVjdGVkIHRyYWNrLlxuICAgKi9cbiAgc2V0U3VidGl0bGVUcmFjayhuZXdJZCkge1xuICAgIGNvbnN0IHRyYWNrcyA9IHRoaXMudHJhY2tzSW5Hcm91cDtcblxuICAgIC8vIHNldHRpbmcgdGhpcy5zdWJ0aXRsZVRyYWNrIHdpbGwgdHJpZ2dlciBpbnRlcm5hbCBsb2dpY1xuICAgIC8vIGlmIG1lZGlhIGhhcyBub3QgYmVlbiBhdHRhY2hlZCB5ZXQsIGl0IHdpbGwgZmFpbFxuICAgIC8vIHdlIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIGRlZmF1bHQgdHJhY2sgaWRcbiAgICAvLyBhbmQgd2UnbGwgc2V0IHN1YnRpdGxlVHJhY2sgd2hlbiBvbk1lZGlhQXR0YWNoZWQgaXMgdHJpZ2dlcmVkXG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICB0aGlzLnF1ZXVlZERlZmF1bHRUcmFjayA9IG5ld0lkO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGV4aXQgaWYgdHJhY2sgaWQgYXMgYWxyZWFkeSBzZXQgb3IgaW52YWxpZFxuICAgIGlmIChuZXdJZCA8IC0xIHx8IG5ld0lkID49IHRyYWNrcy5sZW5ndGggfHwgIWlzRmluaXRlTnVtYmVyKG5ld0lkKSkge1xuICAgICAgdGhpcy53YXJuKGBJbnZhbGlkIHN1YnRpdGxlIHRyYWNrIGlkOiAke25ld0lkfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHN0b3BwaW5nIGxpdmUgcmVsb2FkaW5nIHRpbWVyIGlmIGFueVxuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gZmFsc2U7XG4gICAgY29uc3QgbGFzdFRyYWNrID0gdGhpcy5jdXJyZW50VHJhY2s7XG4gICAgY29uc3QgdHJhY2sgPSB0cmFja3NbbmV3SWRdIHx8IG51bGw7XG4gICAgdGhpcy50cmFja0lkID0gbmV3SWQ7XG4gICAgdGhpcy5jdXJyZW50VHJhY2sgPSB0cmFjaztcbiAgICB0aGlzLnRvZ2dsZVRyYWNrTW9kZXMoKTtcbiAgICBpZiAoIXRyYWNrKSB7XG4gICAgICAvLyBzd2l0Y2ggdG8gLTFcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLlNVQlRJVExFX1RSQUNLX1NXSVRDSCwge1xuICAgICAgICBpZDogbmV3SWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0cmFja0xvYWRlZCA9ICEhdHJhY2suZGV0YWlscyAmJiAhdHJhY2suZGV0YWlscy5saXZlO1xuICAgIGlmIChuZXdJZCA9PT0gdGhpcy50cmFja0lkICYmIHRyYWNrID09PSBsYXN0VHJhY2sgJiYgdHJhY2tMb2FkZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sb2coYFN3aXRjaGluZyB0byBzdWJ0aXRsZS10cmFjayAke25ld0lkfWAgKyAodHJhY2sgPyBgIFwiJHt0cmFjay5uYW1lfVwiIGxhbmc6JHt0cmFjay5sYW5nfSBncm91cDoke3RyYWNrLmdyb3VwSWR9YCA6ICcnKSk7XG4gICAgY29uc3Qge1xuICAgICAgaWQsXG4gICAgICBncm91cElkID0gJycsXG4gICAgICBuYW1lLFxuICAgICAgdHlwZSxcbiAgICAgIHVybFxuICAgIH0gPSB0cmFjaztcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5TVUJUSVRMRV9UUkFDS19TV0lUQ0gsIHtcbiAgICAgIGlkLFxuICAgICAgZ3JvdXBJZCxcbiAgICAgIG5hbWUsXG4gICAgICB0eXBlLFxuICAgICAgdXJsXG4gICAgfSk7XG4gICAgY29uc3QgaGxzVXJsUGFyYW1ldGVycyA9IHRoaXMuc3dpdGNoUGFyYW1zKHRyYWNrLnVybCwgbGFzdFRyYWNrID09IG51bGwgPyB2b2lkIDAgOiBsYXN0VHJhY2suZGV0YWlscyk7XG4gICAgdGhpcy5sb2FkUGxheWxpc3QoaGxzVXJsUGFyYW1ldGVycyk7XG4gIH1cbn1cblxuY2xhc3MgQnVmZmVyT3BlcmF0aW9uUXVldWUge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2VCdWZmZXJSZWZlcmVuY2UpIHtcbiAgICB0aGlzLmJ1ZmZlcnMgPSB2b2lkIDA7XG4gICAgdGhpcy5xdWV1ZXMgPSB7XG4gICAgICB2aWRlbzogW10sXG4gICAgICBhdWRpbzogW10sXG4gICAgICBhdWRpb3ZpZGVvOiBbXVxuICAgIH07XG4gICAgdGhpcy5idWZmZXJzID0gc291cmNlQnVmZmVyUmVmZXJlbmNlO1xuICB9XG4gIGFwcGVuZChvcGVyYXRpb24sIHR5cGUsIHBlbmRpbmcpIHtcbiAgICBjb25zdCBxdWV1ZSA9IHRoaXMucXVldWVzW3R5cGVdO1xuICAgIHF1ZXVlLnB1c2gob3BlcmF0aW9uKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFwZW5kaW5nKSB7XG4gICAgICB0aGlzLmV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgIH1cbiAgfVxuICBpbnNlcnRBYm9ydChvcGVyYXRpb24sIHR5cGUpIHtcbiAgICBjb25zdCBxdWV1ZSA9IHRoaXMucXVldWVzW3R5cGVdO1xuICAgIHF1ZXVlLnVuc2hpZnQob3BlcmF0aW9uKTtcbiAgICB0aGlzLmV4ZWN1dGVOZXh0KHR5cGUpO1xuICB9XG4gIGFwcGVuZEJsb2NrZXIodHlwZSkge1xuICAgIGxldCBleGVjdXRlO1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGV4ZWN1dGUgPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHtcbiAgICAgIGV4ZWN1dGUsXG4gICAgICBvblN0YXJ0OiAoKSA9PiB7fSxcbiAgICAgIG9uQ29tcGxldGU6ICgpID0+IHt9LFxuICAgICAgb25FcnJvcjogKCkgPT4ge31cbiAgICB9O1xuICAgIHRoaXMuYXBwZW5kKG9wZXJhdGlvbiwgdHlwZSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgZXhlY3V0ZU5leHQodHlwZSkge1xuICAgIGNvbnN0IHF1ZXVlID0gdGhpcy5xdWV1ZXNbdHlwZV07XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgY29uc3Qgb3BlcmF0aW9uID0gcXVldWVbMF07XG4gICAgICB0cnkge1xuICAgICAgICAvLyBPcGVyYXRpb25zIGFyZSBleHBlY3RlZCB0byByZXN1bHQgaW4gYW4gJ3VwZGF0ZWVuZCcgZXZlbnQgYmVpbmcgZmlyZWQuIElmIG5vdCwgdGhlIHF1ZXVlIHdpbGwgbG9jay4gT3BlcmF0aW9uc1xuICAgICAgICAvLyB3aGljaCBkbyBub3QgZW5kIHdpdGggdGhpcyBldmVudCBtdXN0IGNhbGwgX29uU0JVcGRhdGVFbmQgbWFudWFsbHlcbiAgICAgICAgb3BlcmF0aW9uLmV4ZWN1dGUoKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKGBbYnVmZmVyLW9wZXJhdGlvbi1xdWV1ZV06IEV4Y2VwdGlvbiBleGVjdXRpbmcgXCIke3R5cGV9XCIgU291cmNlQnVmZmVyIG9wZXJhdGlvbjogJHtlcnJvcn1gKTtcbiAgICAgICAgb3BlcmF0aW9uLm9uRXJyb3IoZXJyb3IpO1xuXG4gICAgICAgIC8vIE9ubHkgc2hpZnQgdGhlIGN1cnJlbnQgb3BlcmF0aW9uIG9mZiwgb3RoZXJ3aXNlIHRoZSB1cGRhdGVlbmQgaGFuZGxlciB3aWxsIGRvIHRoaXMgZm9yIHVzXG4gICAgICAgIGNvbnN0IHNiID0gdGhpcy5idWZmZXJzW3R5cGVdO1xuICAgICAgICBpZiAoIShzYiAhPSBudWxsICYmIHNiLnVwZGF0aW5nKSkge1xuICAgICAgICAgIHRoaXMuc2hpZnRBbmRFeGVjdXRlTmV4dCh0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBzaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpIHtcbiAgICB0aGlzLnF1ZXVlc1t0eXBlXS5zaGlmdCgpO1xuICAgIHRoaXMuZXhlY3V0ZU5leHQodHlwZSk7XG4gIH1cbiAgY3VycmVudCh0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMucXVldWVzW3R5cGVdWzBdO1xuICB9XG59XG5cbmNvbnN0IFZJREVPX0NPREVDX1BST0ZJTEVfUkVQTEFDRSA9IC8oYXZjWzEyMzRdfGh2YzF8aGV2MXxkdmhbMWVdfHZwMDl8YXYwMSkoPzpcXC5bXi4sXSspKy87XG5jbGFzcyBCdWZmZXJDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgLy8gVGhlIGxldmVsIGRldGFpbHMgdXNlZCB0byBkZXRlcm1pbmUgZHVyYXRpb24sIHRhcmdldC1kdXJhdGlvbiBhbmQgbGl2ZVxuICAgIHRoaXMuZGV0YWlscyA9IG51bGw7XG4gICAgLy8gY2FjaGUgdGhlIHNlbGYgZ2VuZXJhdGVkIG9iamVjdCB1cmwgdG8gZGV0ZWN0IGhpamFjayBvZiB2aWRlbyB0YWdcbiAgICB0aGlzLl9vYmplY3RVcmwgPSBudWxsO1xuICAgIC8vIEEgcXVldWUgb2YgYnVmZmVyIG9wZXJhdGlvbnMgd2hpY2ggcmVxdWlyZSB0aGUgU291cmNlQnVmZmVyIHRvIG5vdCBiZSB1cGRhdGluZyB1cG9uIGV4ZWN1dGlvblxuICAgIHRoaXMub3BlcmF0aW9uUXVldWUgPSB2b2lkIDA7XG4gICAgLy8gUmVmZXJlbmNlcyB0byBldmVudCBsaXN0ZW5lcnMgZm9yIGVhY2ggU291cmNlQnVmZmVyLCBzbyB0aGF0IHRoZXkgY2FuIGJlIHJlZmVyZW5jZWQgZm9yIGV2ZW50IHJlbW92YWxcbiAgICB0aGlzLmxpc3RlbmVycyA9IHZvaWQgMDtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICAvLyBUaGUgbnVtYmVyIG9mIEJVRkZFUl9DT0RFQyBldmVudHMgcmVjZWl2ZWQgYmVmb3JlIGFueSBzb3VyY2VCdWZmZXJzIGFyZSBjcmVhdGVkXG4gICAgdGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkID0gMDtcbiAgICAvLyBUaGUgdG90YWwgbnVtYmVyIG9mIEJVRkZFUl9DT0RFQyBldmVudHMgcmVjZWl2ZWRcbiAgICB0aGlzLl9idWZmZXJDb2RlY0V2ZW50c1RvdGFsID0gMDtcbiAgICAvLyBBIHJlZmVyZW5jZSB0byB0aGUgYXR0YWNoZWQgbWVkaWEgZWxlbWVudFxuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIC8vIEEgcmVmZXJlbmNlIHRvIHRoZSBhY3RpdmUgbWVkaWEgc291cmNlXG4gICAgdGhpcy5tZWRpYVNvdXJjZSA9IG51bGw7XG4gICAgLy8gTGFzdCBNUDMgYXVkaW8gY2h1bmsgYXBwZW5kZWRcbiAgICB0aGlzLmxhc3RNcGVnQXVkaW9DaHVuayA9IG51bGw7XG4gICAgdGhpcy5hcHBlbmRTb3VyY2UgPSB2b2lkIDA7XG4gICAgLy8gY291bnRlcnNcbiAgICB0aGlzLmFwcGVuZEVycm9ycyA9IHtcbiAgICAgIGF1ZGlvOiAwLFxuICAgICAgdmlkZW86IDAsXG4gICAgICBhdWRpb3ZpZGVvOiAwXG4gICAgfTtcbiAgICB0aGlzLnRyYWNrcyA9IHt9O1xuICAgIHRoaXMucGVuZGluZ1RyYWNrcyA9IHt9O1xuICAgIHRoaXMuc291cmNlQnVmZmVyID0gdm9pZCAwO1xuICAgIHRoaXMubG9nID0gdm9pZCAwO1xuICAgIHRoaXMud2FybiA9IHZvaWQgMDtcbiAgICB0aGlzLmVycm9yID0gdm9pZCAwO1xuICAgIHRoaXMuX29uRW5kU3RyZWFtaW5nID0gZXZlbnQgPT4ge1xuICAgICAgaWYgKCF0aGlzLmhscykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmhscy5wYXVzZUJ1ZmZlcmluZygpO1xuICAgIH07XG4gICAgdGhpcy5fb25TdGFydFN0cmVhbWluZyA9IGV2ZW50ID0+IHtcbiAgICAgIGlmICghdGhpcy5obHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5obHMucmVzdW1lQnVmZmVyaW5nKCk7XG4gICAgfTtcbiAgICAvLyBLZWVwIGFzIGFycm93IGZ1bmN0aW9ucyBzbyB0aGF0IHdlIGNhbiBkaXJlY3RseSByZWZlcmVuY2UgdGhlc2UgZnVuY3Rpb25zIGRpcmVjdGx5IGFzIGV2ZW50IGxpc3RlbmVyc1xuICAgIHRoaXMuX29uTWVkaWFTb3VyY2VPcGVuID0gKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBtZWRpYSxcbiAgICAgICAgbWVkaWFTb3VyY2VcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgdGhpcy5sb2coJ01lZGlhIHNvdXJjZSBvcGVuZWQnKTtcbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdlbXB0aWVkJywgdGhpcy5fb25NZWRpYUVtcHRpZWQpO1xuICAgICAgICB0aGlzLnVwZGF0ZU1lZGlhRWxlbWVudER1cmF0aW9uKCk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLk1FRElBX0FUVEFDSEVELCB7XG4gICAgICAgICAgbWVkaWEsXG4gICAgICAgICAgbWVkaWFTb3VyY2U6IG1lZGlhU291cmNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKG1lZGlhU291cmNlKSB7XG4gICAgICAgIC8vIG9uY2UgcmVjZWl2ZWQsIGRvbid0IGxpc3RlbiBhbnltb3JlIHRvIHNvdXJjZW9wZW4gZXZlbnRcbiAgICAgICAgbWVkaWFTb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIHRoaXMuX29uTWVkaWFTb3VyY2VPcGVuKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2hlY2tQZW5kaW5nVHJhY2tzKCk7XG4gICAgfTtcbiAgICB0aGlzLl9vbk1lZGlhU291cmNlQ2xvc2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLmxvZygnTWVkaWEgc291cmNlIGNsb3NlZCcpO1xuICAgIH07XG4gICAgdGhpcy5fb25NZWRpYVNvdXJjZUVuZGVkID0gKCkgPT4ge1xuICAgICAgdGhpcy5sb2coJ01lZGlhIHNvdXJjZSBlbmRlZCcpO1xuICAgIH07XG4gICAgdGhpcy5fb25NZWRpYUVtcHRpZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1lZGlhU3JjLFxuICAgICAgICBfb2JqZWN0VXJsXG4gICAgICB9ID0gdGhpcztcbiAgICAgIGlmIChtZWRpYVNyYyAhPT0gX29iamVjdFVybCkge1xuICAgICAgICBsb2dnZXIuZXJyb3IoYE1lZGlhIGVsZW1lbnQgc3JjIHdhcyBzZXQgd2hpbGUgYXR0YWNoaW5nIE1lZGlhU291cmNlICgke19vYmplY3RVcmx9ID4gJHttZWRpYVNyY30pYCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICBjb25zdCBsb2dQcmVmaXggPSAnW2J1ZmZlci1jb250cm9sbGVyXSc7XG4gICAgdGhpcy5hcHBlbmRTb3VyY2UgPSBobHMuY29uZmlnLnByZWZlck1hbmFnZWRNZWRpYVNvdXJjZTtcbiAgICB0aGlzLmxvZyA9IGxvZ2dlci5sb2cuYmluZChsb2dnZXIsIGxvZ1ByZWZpeCk7XG4gICAgdGhpcy53YXJuID0gbG9nZ2VyLndhcm4uYmluZChsb2dnZXIsIGxvZ1ByZWZpeCk7XG4gICAgdGhpcy5lcnJvciA9IGxvZ2dlci5lcnJvci5iaW5kKGxvZ2dlciwgbG9nUHJlZml4KTtcbiAgICB0aGlzLl9pbml0U291cmNlQnVmZmVyKCk7XG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIGhhc1NvdXJjZVR5cGVzKCkge1xuICAgIHJldHVybiB0aGlzLmdldFNvdXJjZUJ1ZmZlclR5cGVzKCkubGVuZ3RoID4gMCB8fCBPYmplY3Qua2V5cyh0aGlzLnBlbmRpbmdUcmFja3MpLmxlbmd0aCA+IDA7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmRldGFpbHMgPSBudWxsO1xuICAgIHRoaXMubGFzdE1wZWdBdWRpb0NodW5rID0gbnVsbDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSBudWxsO1xuICB9XG4gIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfUkVTRVQsIHRoaXMub25CdWZmZXJSZXNldCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfQVBQRU5ESU5HLCB0aGlzLm9uQnVmZmVyQXBwZW5kaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9DT0RFQ1MsIHRoaXMub25CdWZmZXJDb2RlY3MsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0VPUywgdGhpcy5vbkJ1ZmZlckVvcywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfUEFSU0VELCB0aGlzLm9uRnJhZ1BhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX0NIQU5HRUQsIHRoaXMub25GcmFnQ2hhbmdlZCwgdGhpcyk7XG4gIH1cbiAgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfUkVTRVQsIHRoaXMub25CdWZmZXJSZXNldCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0FQUEVORElORywgdGhpcy5vbkJ1ZmZlckFwcGVuZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0NPREVDUywgdGhpcy5vbkJ1ZmZlckNvZGVjcywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0VPUywgdGhpcy5vbkJ1ZmZlckVvcywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB0aGlzLm9uQnVmZmVyRmx1c2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX1VQREFURUQsIHRoaXMub25MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfUEFSU0VELCB0aGlzLm9uRnJhZ1BhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19DSEFOR0VELCB0aGlzLm9uRnJhZ0NoYW5nZWQsIHRoaXMpO1xuICB9XG4gIF9pbml0U291cmNlQnVmZmVyKCkge1xuICAgIHRoaXMuc291cmNlQnVmZmVyID0ge307XG4gICAgdGhpcy5vcGVyYXRpb25RdWV1ZSA9IG5ldyBCdWZmZXJPcGVyYXRpb25RdWV1ZSh0aGlzLnNvdXJjZUJ1ZmZlcik7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSB7XG4gICAgICBhdWRpbzogW10sXG4gICAgICB2aWRlbzogW10sXG4gICAgICBhdWRpb3ZpZGVvOiBbXVxuICAgIH07XG4gICAgdGhpcy5hcHBlbmRFcnJvcnMgPSB7XG4gICAgICBhdWRpbzogMCxcbiAgICAgIHZpZGVvOiAwLFxuICAgICAgYXVkaW92aWRlbzogMFxuICAgIH07XG4gICAgdGhpcy5sYXN0TXBlZ0F1ZGlvQ2h1bmsgPSBudWxsO1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCA9IHRoaXMuX2J1ZmZlckNvZGVjRXZlbnRzVG90YWwgPSAwO1xuICAgIHRoaXMuZGV0YWlscyA9IG51bGw7XG4gIH1cbiAgb25NYW5pZmVzdFBhcnNlZChldmVudCwgZGF0YSkge1xuICAgIC8vIGluIGNhc2Ugb2YgYWx0IGF1ZGlvIDIgQlVGRkVSX0NPREVDUyBldmVudHMgd2lsbCBiZSB0cmlnZ2VyZWQsIG9uZSBwZXIgc3RyZWFtIGNvbnRyb2xsZXJcbiAgICAvLyBzb3VyY2VidWZmZXJzIHdpbGwgYmUgY3JlYXRlZCBhbGwgYXQgb25jZSB3aGVuIHRoZSBleHBlY3RlZCBuYiBvZiB0cmFja3Mgd2lsbCBiZSByZWFjaGVkXG4gICAgLy8gaW4gY2FzZSBhbHQgYXVkaW8gaXMgbm90IHVzZWQsIG9ubHkgb25lIEJVRkZFUl9DT0RFQyBldmVudCB3aWxsIGJlIGZpcmVkIGZyb20gbWFpbiBzdHJlYW0gY29udHJvbGxlclxuICAgIC8vIGl0IHdpbGwgY29udGFpbiB0aGUgZXhwZWN0ZWQgbmIgb2Ygc291cmNlIGJ1ZmZlcnMsIG5vIG5lZWQgdG8gY29tcHV0ZSBpdFxuICAgIGxldCBjb2RlY0V2ZW50cyA9IDI7XG4gICAgaWYgKGRhdGEuYXVkaW8gJiYgIWRhdGEudmlkZW8gfHwgIWRhdGEuYWx0QXVkaW8gfHwgIXRydWUpIHtcbiAgICAgIGNvZGVjRXZlbnRzID0gMTtcbiAgICB9XG4gICAgdGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkID0gdGhpcy5fYnVmZmVyQ29kZWNFdmVudHNUb3RhbCA9IGNvZGVjRXZlbnRzO1xuICAgIHRoaXMubG9nKGAke3RoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZH0gYnVmZmVyQ29kZWMgZXZlbnQocykgZXhwZWN0ZWRgKTtcbiAgfVxuICBvbk1lZGlhQXR0YWNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICBjb25zdCBNZWRpYVNvdXJjZSA9IGdldE1lZGlhU291cmNlKHRoaXMuYXBwZW5kU291cmNlKTtcbiAgICBpZiAobWVkaWEgJiYgTWVkaWFTb3VyY2UpIHtcbiAgICAgIHZhciBfbXMkY29uc3RydWN0b3I7XG4gICAgICBjb25zdCBtcyA9IHRoaXMubWVkaWFTb3VyY2UgPSBuZXcgTWVkaWFTb3VyY2UoKTtcbiAgICAgIHRoaXMubG9nKGBjcmVhdGVkIG1lZGlhIHNvdXJjZTogJHsoX21zJGNvbnN0cnVjdG9yID0gbXMuY29uc3RydWN0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfbXMkY29uc3RydWN0b3IubmFtZX1gKTtcbiAgICAgIC8vIE1lZGlhU291cmNlIGxpc3RlbmVycyBhcmUgYXJyb3cgZnVuY3Rpb25zIHdpdGggYSBsZXhpY2FsIHNjb3BlLCBhbmQgZG8gbm90IG5lZWQgdG8gYmUgYm91bmRcbiAgICAgIG1zLmFkZEV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCB0aGlzLl9vbk1lZGlhU291cmNlT3Blbik7XG4gICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VlbmRlZCcsIHRoaXMuX29uTWVkaWFTb3VyY2VFbmRlZCk7XG4gICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VjbG9zZScsIHRoaXMuX29uTWVkaWFTb3VyY2VDbG9zZSk7XG4gICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzdGFydHN0cmVhbWluZycsIHRoaXMuX29uU3RhcnRTdHJlYW1pbmcpO1xuICAgICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignZW5kc3RyZWFtaW5nJywgdGhpcy5fb25FbmRTdHJlYW1pbmcpO1xuXG4gICAgICAvLyBjYWNoZSB0aGUgbG9jYWxseSBnZW5lcmF0ZWQgb2JqZWN0IHVybFxuICAgICAgY29uc3Qgb2JqZWN0VXJsID0gdGhpcy5fb2JqZWN0VXJsID0gc2VsZi5VUkwuY3JlYXRlT2JqZWN0VVJMKG1zKTtcbiAgICAgIC8vIGxpbmsgdmlkZW8gYW5kIG1lZGlhIFNvdXJjZVxuICAgICAgaWYgKHRoaXMuYXBwZW5kU291cmNlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbWVkaWEucmVtb3ZlQXR0cmlidXRlKCdzcmMnKTtcbiAgICAgICAgICAvLyBNYW5hZ2VkTWVkaWFTb3VyY2Ugd2lsbCBub3Qgb3BlbiB3aXRob3V0IGRpc2FibGVSZW1vdGVQbGF5YmFjayBzZXQgdG8gZmFsc2Ugb3Igc291cmNlIGFsdGVybmF0aXZlc1xuICAgICAgICAgIGNvbnN0IE1NUyA9IHNlbGYuTWFuYWdlZE1lZGlhU291cmNlO1xuICAgICAgICAgIG1lZGlhLmRpc2FibGVSZW1vdGVQbGF5YmFjayA9IG1lZGlhLmRpc2FibGVSZW1vdGVQbGF5YmFjayB8fCBNTVMgJiYgbXMgaW5zdGFuY2VvZiBNTVM7XG4gICAgICAgICAgcmVtb3ZlU291cmNlQ2hpbGRyZW4obWVkaWEpO1xuICAgICAgICAgIGFkZFNvdXJjZShtZWRpYSwgb2JqZWN0VXJsKTtcbiAgICAgICAgICBtZWRpYS5sb2FkKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgbWVkaWEuc3JjID0gb2JqZWN0VXJsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZWRpYS5zcmMgPSBvYmplY3RVcmw7XG4gICAgICB9XG4gICAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdlbXB0aWVkJywgdGhpcy5fb25NZWRpYUVtcHRpZWQpO1xuICAgIH1cbiAgfVxuICBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lZGlhLFxuICAgICAgbWVkaWFTb3VyY2UsXG4gICAgICBfb2JqZWN0VXJsXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKG1lZGlhU291cmNlKSB7XG4gICAgICB0aGlzLmxvZygnbWVkaWEgc291cmNlIGRldGFjaGluZycpO1xuICAgICAgaWYgKG1lZGlhU291cmNlLnJlYWR5U3RhdGUgPT09ICdvcGVuJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIGVuZE9mU3RyZWFtIGNvdWxkIHRyaWdnZXIgZXhjZXB0aW9uIGlmIGFueSBzb3VyY2VidWZmZXIgaXMgaW4gdXBkYXRpbmcgc3RhdGVcbiAgICAgICAgICAvLyB3ZSBkb24ndCByZWFsbHkgY2FyZSBhYm91dCBjaGVja2luZyBzb3VyY2VidWZmZXIgc3RhdGUgaGVyZSxcbiAgICAgICAgICAvLyBhcyB3ZSBhcmUgYW55d2F5IGRldGFjaGluZyB0aGUgTWVkaWFTb3VyY2VcbiAgICAgICAgICAvLyBsZXQncyBqdXN0IGF2b2lkIHRoaXMgZXhjZXB0aW9uIHRvIHByb3BhZ2F0ZVxuICAgICAgICAgIG1lZGlhU291cmNlLmVuZE9mU3RyZWFtKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHRoaXMud2Fybihgb25NZWRpYURldGFjaGluZzogJHtlcnIubWVzc2FnZX0gd2hpbGUgY2FsbGluZyBlbmRPZlN0cmVhbWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBDbGVhbiB1cCB0aGUgU291cmNlQnVmZmVycyBieSBpbnZva2luZyBvbkJ1ZmZlclJlc2V0XG4gICAgICB0aGlzLm9uQnVmZmVyUmVzZXQoKTtcbiAgICAgIG1lZGlhU291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCB0aGlzLl9vbk1lZGlhU291cmNlT3Blbik7XG4gICAgICBtZWRpYVNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VlbmRlZCcsIHRoaXMuX29uTWVkaWFTb3VyY2VFbmRlZCk7XG4gICAgICBtZWRpYVNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VjbG9zZScsIHRoaXMuX29uTWVkaWFTb3VyY2VDbG9zZSk7XG4gICAgICBtZWRpYVNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdzdGFydHN0cmVhbWluZycsIHRoaXMuX29uU3RhcnRTdHJlYW1pbmcpO1xuICAgICAgbWVkaWFTb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kc3RyZWFtaW5nJywgdGhpcy5fb25FbmRTdHJlYW1pbmcpO1xuXG4gICAgICAvLyBEZXRhY2ggcHJvcGVybHkgdGhlIE1lZGlhU291cmNlIGZyb20gdGhlIEhUTUxNZWRpYUVsZW1lbnQgYXNcbiAgICAgIC8vIHN1Z2dlc3RlZCBpbiBodHRwczovL2dpdGh1Yi5jb20vdzNjL21lZGlhLXNvdXJjZS9pc3N1ZXMvNTMuXG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW1wdGllZCcsIHRoaXMuX29uTWVkaWFFbXB0aWVkKTtcbiAgICAgICAgaWYgKF9vYmplY3RVcmwpIHtcbiAgICAgICAgICBzZWxmLlVSTC5yZXZva2VPYmplY3RVUkwoX29iamVjdFVybCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhbiB1cCB2aWRlbyB0YWcgc3JjIG9ubHkgaWYgaXQncyBvdXIgb3duIHVybC4gc29tZSBleHRlcm5hbCBsaWJyYXJpZXMgbWlnaHRcbiAgICAgICAgLy8gaGlqYWNrIHRoZSB2aWRlbyB0YWcgYW5kIGNoYW5nZSBpdHMgJ3NyYycgd2l0aG91dCBkZXN0cm95aW5nIHRoZSBIbHMgaW5zdGFuY2UgZmlyc3RcbiAgICAgICAgaWYgKHRoaXMubWVkaWFTcmMgPT09IF9vYmplY3RVcmwpIHtcbiAgICAgICAgICBtZWRpYS5yZW1vdmVBdHRyaWJ1dGUoJ3NyYycpO1xuICAgICAgICAgIGlmICh0aGlzLmFwcGVuZFNvdXJjZSkge1xuICAgICAgICAgICAgcmVtb3ZlU291cmNlQ2hpbGRyZW4obWVkaWEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtZWRpYS5sb2FkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy53YXJuKCdtZWRpYXxzb3VyY2Uuc3JjIHdhcyBjaGFuZ2VkIGJ5IGEgdGhpcmQgcGFydHkgLSBza2lwIGNsZWFudXAnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5tZWRpYVNvdXJjZSA9IG51bGw7XG4gICAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICAgIHRoaXMuX29iamVjdFVybCA9IG51bGw7XG4gICAgICB0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgPSB0aGlzLl9idWZmZXJDb2RlY0V2ZW50c1RvdGFsO1xuICAgICAgdGhpcy5wZW5kaW5nVHJhY2tzID0ge307XG4gICAgICB0aGlzLnRyYWNrcyA9IHt9O1xuICAgIH1cbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5NRURJQV9ERVRBQ0hFRCwgdW5kZWZpbmVkKTtcbiAgfVxuICBvbkJ1ZmZlclJlc2V0KCkge1xuICAgIHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKS5mb3JFYWNoKHR5cGUgPT4ge1xuICAgICAgdGhpcy5yZXNldEJ1ZmZlcih0eXBlKTtcbiAgICB9KTtcbiAgICB0aGlzLl9pbml0U291cmNlQnVmZmVyKCk7XG4gIH1cbiAgcmVzZXRCdWZmZXIodHlwZSkge1xuICAgIGNvbnN0IHNiID0gdGhpcy5zb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgdHJ5IHtcbiAgICAgIGlmIChzYikge1xuICAgICAgICB2YXIgX3RoaXMkbWVkaWFTb3VyY2U7XG4gICAgICAgIHRoaXMucmVtb3ZlQnVmZmVyTGlzdGVuZXJzKHR5cGUpO1xuICAgICAgICAvLyBTeW5jaHJvbm91c2x5IHJlbW92ZSB0aGUgU0IgZnJvbSB0aGUgbWFwIGJlZm9yZSB0aGUgbmV4dCBjYWxsIGluIG9yZGVyIHRvIHByZXZlbnQgYW4gYXN5bmMgZnVuY3Rpb24gZnJvbVxuICAgICAgICAvLyBhY2Nlc3NpbmcgaXRcbiAgICAgICAgdGhpcy5zb3VyY2VCdWZmZXJbdHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICgoX3RoaXMkbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlKSAhPSBudWxsICYmIF90aGlzJG1lZGlhU291cmNlLnNvdXJjZUJ1ZmZlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5tZWRpYVNvdXJjZS5yZW1vdmVTb3VyY2VCdWZmZXIoc2IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLndhcm4oYG9uQnVmZmVyUmVzZXQgJHt0eXBlfWAsIGVycik7XG4gICAgfVxuICB9XG4gIG9uQnVmZmVyQ29kZWNzKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qgc291cmNlQnVmZmVyQ291bnQgPSB0aGlzLmdldFNvdXJjZUJ1ZmZlclR5cGVzKCkubGVuZ3RoO1xuICAgIGNvbnN0IHRyYWNrTmFtZXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgICB0cmFja05hbWVzLmZvckVhY2godHJhY2tOYW1lID0+IHtcbiAgICAgIGlmIChzb3VyY2VCdWZmZXJDb3VudCkge1xuICAgICAgICAvLyBjaGVjayBpZiBTb3VyY2VCdWZmZXIgY29kZWMgbmVlZHMgdG8gY2hhbmdlXG4gICAgICAgIGNvbnN0IHRyYWNrID0gdGhpcy50cmFja3NbdHJhY2tOYW1lXTtcbiAgICAgICAgaWYgKHRyYWNrICYmIHR5cGVvZiB0cmFjay5idWZmZXIuY2hhbmdlVHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBfdHJhY2tDb2RlYztcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGNvZGVjLFxuICAgICAgICAgICAgbGV2ZWxDb2RlYyxcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIG1ldGFkYXRhXG4gICAgICAgICAgfSA9IGRhdGFbdHJhY2tOYW1lXTtcbiAgICAgICAgICBjb25zdCBjdXJyZW50Q29kZWNGdWxsID0gcGlja01vc3RDb21wbGV0ZUNvZGVjTmFtZSh0cmFjay5jb2RlYywgdHJhY2subGV2ZWxDb2RlYyk7XG4gICAgICAgICAgY29uc3QgY3VycmVudENvZGVjID0gY3VycmVudENvZGVjRnVsbCA9PSBudWxsID8gdm9pZCAwIDogY3VycmVudENvZGVjRnVsbC5yZXBsYWNlKFZJREVPX0NPREVDX1BST0ZJTEVfUkVQTEFDRSwgJyQxJyk7XG4gICAgICAgICAgbGV0IHRyYWNrQ29kZWMgPSBwaWNrTW9zdENvbXBsZXRlQ29kZWNOYW1lKGNvZGVjLCBsZXZlbENvZGVjKTtcbiAgICAgICAgICBjb25zdCBuZXh0Q29kZWMgPSAoX3RyYWNrQ29kZWMgPSB0cmFja0NvZGVjKSA9PSBudWxsID8gdm9pZCAwIDogX3RyYWNrQ29kZWMucmVwbGFjZShWSURFT19DT0RFQ19QUk9GSUxFX1JFUExBQ0UsICckMScpO1xuICAgICAgICAgIGlmICh0cmFja0NvZGVjICYmIGN1cnJlbnRDb2RlYyAhPT0gbmV4dENvZGVjKSB7XG4gICAgICAgICAgICBpZiAodHJhY2tOYW1lLnNsaWNlKDAsIDUpID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICAgIHRyYWNrQ29kZWMgPSBnZXRDb2RlY0NvbXBhdGlibGVOYW1lKHRyYWNrQ29kZWMsIHRoaXMuaGxzLmNvbmZpZy5wcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWltZVR5cGUgPSBgJHtjb250YWluZXJ9O2NvZGVjcz0ke3RyYWNrQ29kZWN9YDtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hhbmdlVHlwZSh0cmFja05hbWUsIG1pbWVUeXBlKTtcbiAgICAgICAgICAgIHRoaXMubG9nKGBzd2l0Y2hpbmcgY29kZWMgJHtjdXJyZW50Q29kZWNGdWxsfSB0byAke3RyYWNrQ29kZWN9YCk7XG4gICAgICAgICAgICB0aGlzLnRyYWNrc1t0cmFja05hbWVdID0ge1xuICAgICAgICAgICAgICBidWZmZXI6IHRyYWNrLmJ1ZmZlcixcbiAgICAgICAgICAgICAgY29kZWMsXG4gICAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgICAgbGV2ZWxDb2RlYyxcbiAgICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgICAgIGlkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgc291cmNlIGJ1ZmZlcihzKSBub3QgY3JlYXRlZCB5ZXQsIGFwcGVuZGVkIGJ1ZmZlciB0cmFja3MgaW4gdGhpcy5wZW5kaW5nVHJhY2tzXG4gICAgICAgIHRoaXMucGVuZGluZ1RyYWNrc1t0cmFja05hbWVdID0gZGF0YVt0cmFja05hbWVdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gaWYgc291cmNlYnVmZmVycyBhbHJlYWR5IGNyZWF0ZWQsIGRvIG5vdGhpbmcgLi4uXG4gICAgaWYgKHNvdXJjZUJ1ZmZlckNvdW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgPSBNYXRoLm1heCh0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgLSAxLCAwKTtcbiAgICBpZiAodGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkICE9PSBidWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkKSB7XG4gICAgICB0aGlzLmxvZyhgJHtidWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkfSBidWZmZXJDb2RlYyBldmVudChzKSBleHBlY3RlZCAke3RyYWNrTmFtZXMuam9pbignLCcpfWApO1xuICAgICAgdGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkID0gYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZDtcbiAgICB9XG4gICAgaWYgKHRoaXMubWVkaWFTb3VyY2UgJiYgdGhpcy5tZWRpYVNvdXJjZS5yZWFkeVN0YXRlID09PSAnb3BlbicpIHtcbiAgICAgIHRoaXMuY2hlY2tQZW5kaW5nVHJhY2tzKCk7XG4gICAgfVxuICB9XG4gIGFwcGVuZENoYW5nZVR5cGUodHlwZSwgbWltZVR5cGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBvcGVyYXRpb25RdWV1ZVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHtcbiAgICAgIGV4ZWN1dGU6ICgpID0+IHtcbiAgICAgICAgY29uc3Qgc2IgPSB0aGlzLnNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICAgICAgaWYgKHNiKSB7XG4gICAgICAgICAgdGhpcy5sb2coYGNoYW5naW5nICR7dHlwZX0gc291cmNlQnVmZmVyIHR5cGUgdG8gJHttaW1lVHlwZX1gKTtcbiAgICAgICAgICBzYi5jaGFuZ2VUeXBlKG1pbWVUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBvcGVyYXRpb25RdWV1ZS5zaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgICAgfSxcbiAgICAgIG9uU3RhcnQ6ICgpID0+IHt9LFxuICAgICAgb25Db21wbGV0ZTogKCkgPT4ge30sXG4gICAgICBvbkVycm9yOiBlcnJvciA9PiB7XG4gICAgICAgIHRoaXMud2FybihgRmFpbGVkIHRvIGNoYW5nZSAke3R5cGV9IFNvdXJjZUJ1ZmZlciB0eXBlYCwgZXJyb3IpO1xuICAgICAgfVxuICAgIH07XG4gICAgb3BlcmF0aW9uUXVldWUuYXBwZW5kKG9wZXJhdGlvbiwgdHlwZSwgISF0aGlzLnBlbmRpbmdUcmFja3NbdHlwZV0pO1xuICB9XG4gIG9uQnVmZmVyQXBwZW5kaW5nKGV2ZW50LCBldmVudERhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHMsXG4gICAgICBvcGVyYXRpb25RdWV1ZSxcbiAgICAgIHRyYWNrc1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICB0eXBlLFxuICAgICAgZnJhZyxcbiAgICAgIHBhcnQsXG4gICAgICBjaHVua01ldGFcbiAgICB9ID0gZXZlbnREYXRhO1xuICAgIGNvbnN0IGNodW5rU3RhdHMgPSBjaHVua01ldGEuYnVmZmVyaW5nW3R5cGVdO1xuICAgIGNvbnN0IGJ1ZmZlckFwcGVuZGluZ1N0YXJ0ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjaHVua1N0YXRzLnN0YXJ0ID0gYnVmZmVyQXBwZW5kaW5nU3RhcnQ7XG4gICAgY29uc3QgZnJhZ0J1ZmZlcmluZyA9IGZyYWcuc3RhdHMuYnVmZmVyaW5nO1xuICAgIGNvbnN0IHBhcnRCdWZmZXJpbmcgPSBwYXJ0ID8gcGFydC5zdGF0cy5idWZmZXJpbmcgOiBudWxsO1xuICAgIGlmIChmcmFnQnVmZmVyaW5nLnN0YXJ0ID09PSAwKSB7XG4gICAgICBmcmFnQnVmZmVyaW5nLnN0YXJ0ID0gYnVmZmVyQXBwZW5kaW5nU3RhcnQ7XG4gICAgfVxuICAgIGlmIChwYXJ0QnVmZmVyaW5nICYmIHBhcnRCdWZmZXJpbmcuc3RhcnQgPT09IDApIHtcbiAgICAgIHBhcnRCdWZmZXJpbmcuc3RhcnQgPSBidWZmZXJBcHBlbmRpbmdTdGFydDtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBPbmx5IHVwZGF0ZSB0aW1lc3RhbXBPZmZzZXQgd2hlbiBhdWRpby9tcGVnIGZyYWdtZW50IG9yIHBhcnQgaXMgbm90IGNvbnRpZ3VvdXMgd2l0aCBwcmV2aW91c2x5IGFwcGVuZGVkXG4gICAgLy8gQWRqdXN0aW5nIGBTb3VyY2VCdWZmZXIudGltZXN0YW1wT2Zmc2V0YCAoZGVzaXJlZCBwb2ludCBpbiB0aGUgdGltZWxpbmUgd2hlcmUgdGhlIG5leHQgZnJhbWVzIHNob3VsZCBiZSBhcHBlbmRlZClcbiAgICAvLyBpbiBDaHJvbWUgYnJvd3NlciB3aGVuIHdlIGRldGVjdCBNUEVHIGF1ZGlvIGNvbnRhaW5lciBhbmQgdGltZSBkZWx0YSBiZXR3ZWVuIGxldmVsIFBUUyBhbmQgYFNvdXJjZUJ1ZmZlci50aW1lc3RhbXBPZmZzZXRgXG4gICAgLy8gaXMgZ3JlYXRlciB0aGFuIDEwMG1zICh0aGlzIGlzIGVub3VnaCB0byBoYW5kbGUgc2VlayBmb3IgVk9EIG9yIGxldmVsIGNoYW5nZSBmb3IgTElWRSB2aWRlb3MpLlxuICAgIC8vIE1vcmUgaW5mbyBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvMzMyI2lzc3VlY29tbWVudC0yNTc5ODY0ODZcbiAgICBjb25zdCBhdWRpb1RyYWNrID0gdHJhY2tzLmF1ZGlvO1xuICAgIGxldCBjaGVja1RpbWVzdGFtcE9mZnNldCA9IGZhbHNlO1xuICAgIGlmICh0eXBlID09PSAnYXVkaW8nICYmIChhdWRpb1RyYWNrID09IG51bGwgPyB2b2lkIDAgOiBhdWRpb1RyYWNrLmNvbnRhaW5lcikgPT09ICdhdWRpby9tcGVnJykge1xuICAgICAgY2hlY2tUaW1lc3RhbXBPZmZzZXQgPSAhdGhpcy5sYXN0TXBlZ0F1ZGlvQ2h1bmsgfHwgY2h1bmtNZXRhLmlkID09PSAxIHx8IHRoaXMubGFzdE1wZWdBdWRpb0NodW5rLnNuICE9PSBjaHVua01ldGEuc247XG4gICAgICB0aGlzLmxhc3RNcGVnQXVkaW9DaHVuayA9IGNodW5rTWV0YTtcbiAgICB9XG4gICAgY29uc3QgZnJhZ1N0YXJ0ID0gZnJhZy5zdGFydDtcbiAgICBjb25zdCBvcGVyYXRpb24gPSB7XG4gICAgICBleGVjdXRlOiAoKSA9PiB7XG4gICAgICAgIGNodW5rU3RhdHMuZXhlY3V0ZVN0YXJ0ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgaWYgKGNoZWNrVGltZXN0YW1wT2Zmc2V0KSB7XG4gICAgICAgICAgY29uc3Qgc2IgPSB0aGlzLnNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICAgICAgICBpZiAoc2IpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gZnJhZ1N0YXJ0IC0gc2IudGltZXN0YW1wT2Zmc2V0O1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGRlbHRhKSA+PSAwLjEpIHtcbiAgICAgICAgICAgICAgdGhpcy5sb2coYFVwZGF0aW5nIGF1ZGlvIFNvdXJjZUJ1ZmZlciB0aW1lc3RhbXBPZmZzZXQgdG8gJHtmcmFnU3RhcnR9IChkZWx0YTogJHtkZWx0YX0pIHNuOiAke2ZyYWcuc259KWApO1xuICAgICAgICAgICAgICBzYi50aW1lc3RhbXBPZmZzZXQgPSBmcmFnU3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXBwZW5kRXhlY3V0b3IoZGF0YSwgdHlwZSk7XG4gICAgICB9LFxuICAgICAgb25TdGFydDogKCkgPT4ge1xuICAgICAgICAvLyBsb2dnZXIuZGVidWcoYFtidWZmZXItY29udHJvbGxlcl06ICR7dHlwZX0gU291cmNlQnVmZmVyIHVwZGF0ZXN0YXJ0YCk7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAvLyBsb2dnZXIuZGVidWcoYFtidWZmZXItY29udHJvbGxlcl06ICR7dHlwZX0gU291cmNlQnVmZmVyIHVwZGF0ZWVuZGApO1xuICAgICAgICBjb25zdCBlbmQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBjaHVua1N0YXRzLmV4ZWN1dGVFbmQgPSBjaHVua1N0YXRzLmVuZCA9IGVuZDtcbiAgICAgICAgaWYgKGZyYWdCdWZmZXJpbmcuZmlyc3QgPT09IDApIHtcbiAgICAgICAgICBmcmFnQnVmZmVyaW5nLmZpcnN0ID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0QnVmZmVyaW5nICYmIHBhcnRCdWZmZXJpbmcuZmlyc3QgPT09IDApIHtcbiAgICAgICAgICBwYXJ0QnVmZmVyaW5nLmZpcnN0ID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzb3VyY2VCdWZmZXJcbiAgICAgICAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHRpbWVSYW5nZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB0eXBlIGluIHNvdXJjZUJ1ZmZlcikge1xuICAgICAgICAgIHRpbWVSYW5nZXNbdHlwZV0gPSBCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQoc291cmNlQnVmZmVyW3R5cGVdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwcGVuZEVycm9yc1t0eXBlXSA9IDA7XG4gICAgICAgIGlmICh0eXBlID09PSAnYXVkaW8nIHx8IHR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICB0aGlzLmFwcGVuZEVycm9ycy5hdWRpb3ZpZGVvID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFwcGVuZEVycm9ycy5hdWRpbyA9IDA7XG4gICAgICAgICAgdGhpcy5hcHBlbmRFcnJvcnMudmlkZW8gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9BUFBFTkRFRCwge1xuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgZnJhZyxcbiAgICAgICAgICBwYXJ0LFxuICAgICAgICAgIGNodW5rTWV0YSxcbiAgICAgICAgICBwYXJlbnQ6IGZyYWcudHlwZSxcbiAgICAgICAgICB0aW1lUmFuZ2VzXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIG9uRXJyb3I6IGVycm9yID0+IHtcbiAgICAgICAgLy8gaW4gY2FzZSBhbnkgZXJyb3Igb2NjdXJlZCB3aGlsZSBhcHBlbmRpbmcsIHB1dCBiYWNrIHNlZ21lbnQgaW4gc2VnbWVudHMgdGFibGVcbiAgICAgICAgY29uc3QgZXZlbnQgPSB7XG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgICBwYXJlbnQ6IGZyYWcudHlwZSxcbiAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORF9FUlJPUixcbiAgICAgICAgICBzb3VyY2VCdWZmZXJOYW1lOiB0eXBlLFxuICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgcGFydCxcbiAgICAgICAgICBjaHVua01ldGEsXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgZXJyOiBlcnJvcixcbiAgICAgICAgICBmYXRhbDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IERPTUV4Y2VwdGlvbi5RVU9UQV9FWENFRURFRF9FUlIpIHtcbiAgICAgICAgICAvLyBRdW90YUV4Y2VlZGVkRXJyb3I6IGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZnJhc3RydWN0dXJlLmh0bWwjcXVvdGFleGNlZWRlZGVycm9yXG4gICAgICAgICAgLy8gbGV0J3Mgc3RvcCBhcHBlbmRpbmcgYW55IHNlZ21lbnRzLCBhbmQgcmVwb3J0IEJVRkZFUl9GVUxMX0VSUk9SIGVycm9yXG4gICAgICAgICAgZXZlbnQuZGV0YWlscyA9IEVycm9yRGV0YWlscy5CVUZGRVJfRlVMTF9FUlJPUjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBhcHBlbmRFcnJvckNvdW50ID0gKyt0aGlzLmFwcGVuZEVycm9yc1t0eXBlXTtcbiAgICAgICAgICBldmVudC5kZXRhaWxzID0gRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRfRVJST1I7XG4gICAgICAgICAgLyogd2l0aCBVSEQgY29udGVudCwgd2UgY291bGQgZ2V0IGxvb3Agb2YgcXVvdGEgZXhjZWVkZWQgZXJyb3IgdW50aWxcbiAgICAgICAgICAgIGJyb3dzZXIgaXMgYWJsZSB0byBldmljdCBzb21lIGRhdGEgZnJvbSBzb3VyY2VidWZmZXIuIFJldHJ5aW5nIGNhbiBoZWxwIHJlY292ZXIuXG4gICAgICAgICAgKi9cbiAgICAgICAgICB0aGlzLndhcm4oYEZhaWxlZCAke2FwcGVuZEVycm9yQ291bnR9LyR7aGxzLmNvbmZpZy5hcHBlbmRFcnJvck1heFJldHJ5fSB0aW1lcyB0byBhcHBlbmQgc2VnbWVudCBpbiBcIiR7dHlwZX1cIiBzb3VyY2VCdWZmZXJgKTtcbiAgICAgICAgICBpZiAoYXBwZW5kRXJyb3JDb3VudCA+PSBobHMuY29uZmlnLmFwcGVuZEVycm9yTWF4UmV0cnkpIHtcbiAgICAgICAgICAgIGV2ZW50LmZhdGFsID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCBldmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBvcGVyYXRpb25RdWV1ZS5hcHBlbmQob3BlcmF0aW9uLCB0eXBlLCAhIXRoaXMucGVuZGluZ1RyYWNrc1t0eXBlXSk7XG4gIH1cbiAgb25CdWZmZXJGbHVzaGluZyhldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG9wZXJhdGlvblF1ZXVlXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgZmx1c2hPcGVyYXRpb24gPSB0eXBlID0+ICh7XG4gICAgICBleGVjdXRlOiB0aGlzLnJlbW92ZUV4ZWN1dG9yLmJpbmQodGhpcywgdHlwZSwgZGF0YS5zdGFydE9mZnNldCwgZGF0YS5lbmRPZmZzZXQpLFxuICAgICAgb25TdGFydDogKCkgPT4ge1xuICAgICAgICAvLyBsb2dnZXIuZGVidWcoYFtidWZmZXItY29udHJvbGxlcl06IFN0YXJ0ZWQgZmx1c2hpbmcgJHtkYXRhLnN0YXJ0T2Zmc2V0fSAtPiAke2RhdGEuZW5kT2Zmc2V0fSBmb3IgJHt0eXBlfSBTb3VyY2UgQnVmZmVyYCk7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAvLyBsb2dnZXIuZGVidWcoYFtidWZmZXItY29udHJvbGxlcl06IEZpbmlzaGVkIGZsdXNoaW5nICR7ZGF0YS5zdGFydE9mZnNldH0gLT4gJHtkYXRhLmVuZE9mZnNldH0gZm9yICR7dHlwZX0gU291cmNlIEJ1ZmZlcmApO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfRkxVU0hFRCwge1xuICAgICAgICAgIHR5cGVcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgb25FcnJvcjogZXJyb3IgPT4ge1xuICAgICAgICB0aGlzLndhcm4oYEZhaWxlZCB0byByZW1vdmUgZnJvbSAke3R5cGV9IFNvdXJjZUJ1ZmZlcmAsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoZGF0YS50eXBlKSB7XG4gICAgICBvcGVyYXRpb25RdWV1ZS5hcHBlbmQoZmx1c2hPcGVyYXRpb24oZGF0YS50eXBlKSwgZGF0YS50eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpLmZvckVhY2godHlwZSA9PiB7XG4gICAgICAgIG9wZXJhdGlvblF1ZXVlLmFwcGVuZChmbHVzaE9wZXJhdGlvbih0eXBlKSwgdHlwZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgb25GcmFnUGFyc2VkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIHBhcnRcbiAgICB9ID0gZGF0YTtcbiAgICBjb25zdCBidWZmZXJzQXBwZW5kZWRUbyA9IFtdO1xuICAgIGNvbnN0IGVsZW1lbnRhcnlTdHJlYW1zID0gcGFydCA/IHBhcnQuZWxlbWVudGFyeVN0cmVhbXMgOiBmcmFnLmVsZW1lbnRhcnlTdHJlYW1zO1xuICAgIGlmIChlbGVtZW50YXJ5U3RyZWFtc1tFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU9WSURFT10pIHtcbiAgICAgIGJ1ZmZlcnNBcHBlbmRlZFRvLnB1c2goJ2F1ZGlvdmlkZW8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVsZW1lbnRhcnlTdHJlYW1zW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJT10pIHtcbiAgICAgICAgYnVmZmVyc0FwcGVuZGVkVG8ucHVzaCgnYXVkaW8nKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50YXJ5U3RyZWFtc1tFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU9dKSB7XG4gICAgICAgIGJ1ZmZlcnNBcHBlbmRlZFRvLnB1c2goJ3ZpZGVvJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG9uVW5ibG9ja2VkID0gKCkgPT4ge1xuICAgICAgY29uc3Qgbm93ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGZyYWcuc3RhdHMuYnVmZmVyaW5nLmVuZCA9IG5vdztcbiAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgIHBhcnQuc3RhdHMuYnVmZmVyaW5nLmVuZCA9IG5vdztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXRzID0gcGFydCA/IHBhcnQuc3RhdHMgOiBmcmFnLnN0YXRzO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRlJBR19CVUZGRVJFRCwge1xuICAgICAgICBmcmFnLFxuICAgICAgICBwYXJ0LFxuICAgICAgICBzdGF0cyxcbiAgICAgICAgaWQ6IGZyYWcudHlwZVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAoYnVmZmVyc0FwcGVuZGVkVG8ubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLndhcm4oYEZyYWdtZW50cyBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIEVsZW1lbnRhcnlTdHJlYW1UeXBlIHNldC4gdHlwZTogJHtmcmFnLnR5cGV9IGxldmVsOiAke2ZyYWcubGV2ZWx9IHNuOiAke2ZyYWcuc259YCk7XG4gICAgfVxuICAgIHRoaXMuYmxvY2tCdWZmZXJzKG9uVW5ibG9ja2VkLCBidWZmZXJzQXBwZW5kZWRUbyk7XG4gIH1cbiAgb25GcmFnQ2hhbmdlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMudHJpbUJ1ZmZlcnMoKTtcbiAgfVxuXG4gIC8vIG9uIEJVRkZFUl9FT1MgbWFyayBtYXRjaGluZyBzb3VyY2VidWZmZXIocykgYXMgZW5kZWQgYW5kIHRyaWdnZXIgY2hlY2tFb3MoKVxuICAvLyBhbiB1bmRlZmluZWQgZGF0YS50eXBlIHdpbGwgbWFyayBhbGwgYnVmZmVycyBhcyBFT1MuXG4gIG9uQnVmZmVyRW9zKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3QgZW5kZWQgPSB0aGlzLmdldFNvdXJjZUJ1ZmZlclR5cGVzKCkucmVkdWNlKChhY2MsIHR5cGUpID0+IHtcbiAgICAgIGNvbnN0IHNiID0gdGhpcy5zb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgICBpZiAoc2IgJiYgKCFkYXRhLnR5cGUgfHwgZGF0YS50eXBlID09PSB0eXBlKSkge1xuICAgICAgICBzYi5lbmRpbmcgPSB0cnVlO1xuICAgICAgICBpZiAoIXNiLmVuZGVkKSB7XG4gICAgICAgICAgc2IuZW5kZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMubG9nKGAke3R5cGV9IHNvdXJjZUJ1ZmZlciBub3cgRU9TYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2MgJiYgISEoIXNiIHx8IHNiLmVuZGVkKTtcbiAgICB9LCB0cnVlKTtcbiAgICBpZiAoZW5kZWQpIHtcbiAgICAgIHRoaXMubG9nKGBRdWV1ZWluZyBtZWRpYVNvdXJjZS5lbmRPZlN0cmVhbSgpYCk7XG4gICAgICB0aGlzLmJsb2NrQnVmZmVycygoKSA9PiB7XG4gICAgICAgIHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKS5mb3JFYWNoKHR5cGUgPT4ge1xuICAgICAgICAgIGNvbnN0IHNiID0gdGhpcy5zb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgICAgICAgaWYgKHNiKSB7XG4gICAgICAgICAgICBzYi5lbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgbWVkaWFTb3VyY2VcbiAgICAgICAgfSA9IHRoaXM7XG4gICAgICAgIGlmICghbWVkaWFTb3VyY2UgfHwgbWVkaWFTb3VyY2UucmVhZHlTdGF0ZSAhPT0gJ29wZW4nKSB7XG4gICAgICAgICAgaWYgKG1lZGlhU291cmNlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZyhgQ291bGQgbm90IGNhbGwgbWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKS4gbWVkaWFTb3VyY2UucmVhZHlTdGF0ZTogJHttZWRpYVNvdXJjZS5yZWFkeVN0YXRlfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2coYENhbGxpbmcgbWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKWApO1xuICAgICAgICAvLyBBbGxvdyB0aGlzIHRvIHRocm93IGFuZCBiZSBjYXVnaHQgYnkgdGhlIGVucXVldWVpbmcgZnVuY3Rpb25cbiAgICAgICAgbWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBvbkxldmVsVXBkYXRlZChldmVudCwge1xuICAgIGRldGFpbHNcbiAgfSkge1xuICAgIGlmICghZGV0YWlscy5mcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gICAgaWYgKHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuYmxvY2tCdWZmZXJzKHRoaXMudXBkYXRlTWVkaWFFbGVtZW50RHVyYXRpb24uYmluZCh0aGlzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXBkYXRlTWVkaWFFbGVtZW50RHVyYXRpb24oKTtcbiAgICB9XG4gIH1cbiAgdHJpbUJ1ZmZlcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzLFxuICAgICAgZGV0YWlscyxcbiAgICAgIG1lZGlhXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFtZWRpYSB8fCBkZXRhaWxzID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZUJ1ZmZlclR5cGVzID0gdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpO1xuICAgIGlmICghc291cmNlQnVmZmVyVHlwZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICBjb25zdCB0YXJnZXREdXJhdGlvbiA9IGRldGFpbHMubGV2ZWxUYXJnZXREdXJhdGlvbjtcblxuICAgIC8vIFN1cHBvcnQgZm9yIGRlcHJlY2F0ZWQgbGl2ZUJhY2tCdWZmZXJMZW5ndGhcbiAgICBjb25zdCBiYWNrQnVmZmVyTGVuZ3RoID0gZGV0YWlscy5saXZlICYmIGNvbmZpZy5saXZlQmFja0J1ZmZlckxlbmd0aCAhPT0gbnVsbCA/IGNvbmZpZy5saXZlQmFja0J1ZmZlckxlbmd0aCA6IGNvbmZpZy5iYWNrQnVmZmVyTGVuZ3RoO1xuICAgIGlmIChpc0Zpbml0ZU51bWJlcihiYWNrQnVmZmVyTGVuZ3RoKSAmJiBiYWNrQnVmZmVyTGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgbWF4QmFja0J1ZmZlckxlbmd0aCA9IE1hdGgubWF4KGJhY2tCdWZmZXJMZW5ndGgsIHRhcmdldER1cmF0aW9uKTtcbiAgICAgIGNvbnN0IHRhcmdldEJhY2tCdWZmZXJQb3NpdGlvbiA9IE1hdGguZmxvb3IoY3VycmVudFRpbWUgLyB0YXJnZXREdXJhdGlvbikgKiB0YXJnZXREdXJhdGlvbiAtIG1heEJhY2tCdWZmZXJMZW5ndGg7XG4gICAgICB0aGlzLmZsdXNoQmFja0J1ZmZlcihjdXJyZW50VGltZSwgdGFyZ2V0RHVyYXRpb24sIHRhcmdldEJhY2tCdWZmZXJQb3NpdGlvbik7XG4gICAgfVxuICAgIGlmIChpc0Zpbml0ZU51bWJlcihjb25maWcuZnJvbnRCdWZmZXJGbHVzaFRocmVzaG9sZCkgJiYgY29uZmlnLmZyb250QnVmZmVyRmx1c2hUaHJlc2hvbGQgPiAwKSB7XG4gICAgICBjb25zdCBmcm9udEJ1ZmZlckxlbmd0aCA9IE1hdGgubWF4KGNvbmZpZy5tYXhCdWZmZXJMZW5ndGgsIGNvbmZpZy5mcm9udEJ1ZmZlckZsdXNoVGhyZXNob2xkKTtcbiAgICAgIGNvbnN0IG1heEZyb250QnVmZmVyTGVuZ3RoID0gTWF0aC5tYXgoZnJvbnRCdWZmZXJMZW5ndGgsIHRhcmdldER1cmF0aW9uKTtcbiAgICAgIGNvbnN0IHRhcmdldEZyb250QnVmZmVyUG9zaXRpb24gPSBNYXRoLmZsb29yKGN1cnJlbnRUaW1lIC8gdGFyZ2V0RHVyYXRpb24pICogdGFyZ2V0RHVyYXRpb24gKyBtYXhGcm9udEJ1ZmZlckxlbmd0aDtcbiAgICAgIHRoaXMuZmx1c2hGcm9udEJ1ZmZlcihjdXJyZW50VGltZSwgdGFyZ2V0RHVyYXRpb24sIHRhcmdldEZyb250QnVmZmVyUG9zaXRpb24pO1xuICAgIH1cbiAgfVxuICBmbHVzaEJhY2tCdWZmZXIoY3VycmVudFRpbWUsIHRhcmdldER1cmF0aW9uLCB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICBkZXRhaWxzLFxuICAgICAgc291cmNlQnVmZmVyXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc291cmNlQnVmZmVyVHlwZXMgPSB0aGlzLmdldFNvdXJjZUJ1ZmZlclR5cGVzKCk7XG4gICAgc291cmNlQnVmZmVyVHlwZXMuZm9yRWFjaCh0eXBlID0+IHtcbiAgICAgIGNvbnN0IHNiID0gc291cmNlQnVmZmVyW3R5cGVdO1xuICAgICAgaWYgKHNiKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlcmVkID0gQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKHNiKTtcbiAgICAgICAgLy8gd2hlbiB0YXJnZXQgYnVmZmVyIHN0YXJ0IGV4Y2VlZHMgYWN0dWFsIGJ1ZmZlciBzdGFydFxuICAgICAgICBpZiAoYnVmZmVyZWQubGVuZ3RoID4gMCAmJiB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb24gPiBidWZmZXJlZC5zdGFydCgwKSkge1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJBQ0tfQlVGRkVSX1JFQUNIRUQsIHtcbiAgICAgICAgICAgIGJ1ZmZlckVuZDogdGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBTdXBwb3J0IGZvciBkZXByZWNhdGVkIGV2ZW50OlxuICAgICAgICAgIGlmIChkZXRhaWxzICE9IG51bGwgJiYgZGV0YWlscy5saXZlKSB7XG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5MSVZFX0JBQ0tfQlVGRkVSX1JFQUNIRUQsIHtcbiAgICAgICAgICAgICAgYnVmZmVyRW5kOiB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc2IuZW5kZWQgJiYgYnVmZmVyZWQuZW5kKGJ1ZmZlcmVkLmxlbmd0aCAtIDEpIC0gY3VycmVudFRpbWUgPCB0YXJnZXREdXJhdGlvbiAqIDIpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKGBDYW5ub3QgZmx1c2ggJHt0eXBlfSBiYWNrIGJ1ZmZlciB3aGlsZSBTb3VyY2VCdWZmZXIgaXMgaW4gZW5kZWQgc3RhdGVgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB7XG4gICAgICAgICAgICBzdGFydE9mZnNldDogMCxcbiAgICAgICAgICAgIGVuZE9mZnNldDogdGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uLFxuICAgICAgICAgICAgdHlwZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZmx1c2hGcm9udEJ1ZmZlcihjdXJyZW50VGltZSwgdGFyZ2V0RHVyYXRpb24sIHRhcmdldEZyb250QnVmZmVyUG9zaXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICBzb3VyY2VCdWZmZXJcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBzb3VyY2VCdWZmZXJUeXBlcyA9IHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKTtcbiAgICBzb3VyY2VCdWZmZXJUeXBlcy5mb3JFYWNoKHR5cGUgPT4ge1xuICAgICAgY29uc3Qgc2IgPSBzb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgICBpZiAoc2IpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyZWQgPSBCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQoc2IpO1xuICAgICAgICBjb25zdCBudW1CdWZmZXJlZFJhbmdlcyA9IGJ1ZmZlcmVkLmxlbmd0aDtcbiAgICAgICAgLy8gVGhlIGJ1ZmZlciBpcyBlaXRoZXIgZW1wdHkgb3IgY29udGlndW91c1xuICAgICAgICBpZiAobnVtQnVmZmVyZWRSYW5nZXMgPCAyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1ZmZlclN0YXJ0ID0gYnVmZmVyZWQuc3RhcnQobnVtQnVmZmVyZWRSYW5nZXMgLSAxKTtcbiAgICAgICAgY29uc3QgYnVmZmVyRW5kID0gYnVmZmVyZWQuZW5kKG51bUJ1ZmZlcmVkUmFuZ2VzIC0gMSk7XG4gICAgICAgIC8vIE5vIGZsdXNoIGlmIHdlIGNhbiB0b2xlcmF0ZSB0aGUgY3VycmVudCBidWZmZXIgbGVuZ3RoIG9yIHRoZSBjdXJyZW50IGJ1ZmZlciByYW5nZSB3ZSB3b3VsZCBmbHVzaCBpcyBjb250aWd1b3VzIHdpdGggY3VycmVudCBwb3NpdGlvblxuICAgICAgICBpZiAodGFyZ2V0RnJvbnRCdWZmZXJQb3NpdGlvbiA+IGJ1ZmZlclN0YXJ0IHx8IGN1cnJlbnRUaW1lID49IGJ1ZmZlclN0YXJ0ICYmIGN1cnJlbnRUaW1lIDw9IGJ1ZmZlckVuZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChzYi5lbmRlZCAmJiBjdXJyZW50VGltZSAtIGJ1ZmZlckVuZCA8IDIgKiB0YXJnZXREdXJhdGlvbikge1xuICAgICAgICAgIHRoaXMubG9nKGBDYW5ub3QgZmx1c2ggJHt0eXBlfSBmcm9udCBidWZmZXIgd2hpbGUgU291cmNlQnVmZmVyIGlzIGluIGVuZGVkIHN0YXRlYCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9GTFVTSElORywge1xuICAgICAgICAgIHN0YXJ0T2Zmc2V0OiBidWZmZXJTdGFydCxcbiAgICAgICAgICBlbmRPZmZzZXQ6IEluZmluaXR5LFxuICAgICAgICAgIHR5cGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIE1lZGlhIFNvdXJjZSBkdXJhdGlvbiB0byBjdXJyZW50IGxldmVsIGR1cmF0aW9uIG9yIG92ZXJyaWRlIHRvIEluZmluaXR5IGlmIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyXG4gICAqICdsaXZlRHVyYXRpb25JbmZpbml0eWAgaXMgc2V0IHRvIGB0cnVlYFxuICAgKiBNb3JlIGRldGFpbHM6IGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy8zNTVcbiAgICovXG4gIHVwZGF0ZU1lZGlhRWxlbWVudER1cmF0aW9uKCkge1xuICAgIGlmICghdGhpcy5kZXRhaWxzIHx8ICF0aGlzLm1lZGlhIHx8ICF0aGlzLm1lZGlhU291cmNlIHx8IHRoaXMubWVkaWFTb3VyY2UucmVhZHlTdGF0ZSAhPT0gJ29wZW4nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGRldGFpbHMsXG4gICAgICBobHMsXG4gICAgICBtZWRpYSxcbiAgICAgIG1lZGlhU291cmNlXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgbGV2ZWxEdXJhdGlvbiA9IGRldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0ICsgZGV0YWlscy50b3RhbGR1cmF0aW9uO1xuICAgIGNvbnN0IG1lZGlhRHVyYXRpb24gPSBtZWRpYS5kdXJhdGlvbjtcbiAgICBjb25zdCBtc0R1cmF0aW9uID0gaXNGaW5pdGVOdW1iZXIobWVkaWFTb3VyY2UuZHVyYXRpb24pID8gbWVkaWFTb3VyY2UuZHVyYXRpb24gOiAwO1xuICAgIGlmIChkZXRhaWxzLmxpdmUgJiYgaGxzLmNvbmZpZy5saXZlRHVyYXRpb25JbmZpbml0eSkge1xuICAgICAgLy8gT3ZlcnJpZGUgZHVyYXRpb24gdG8gSW5maW5pdHlcbiAgICAgIG1lZGlhU291cmNlLmR1cmF0aW9uID0gSW5maW5pdHk7XG4gICAgICB0aGlzLnVwZGF0ZVNlZWthYmxlUmFuZ2UoZGV0YWlscyk7XG4gICAgfSBlbHNlIGlmIChsZXZlbER1cmF0aW9uID4gbXNEdXJhdGlvbiAmJiBsZXZlbER1cmF0aW9uID4gbWVkaWFEdXJhdGlvbiB8fCAhaXNGaW5pdGVOdW1iZXIobWVkaWFEdXJhdGlvbikpIHtcbiAgICAgIC8vIGxldmVsRHVyYXRpb24gd2FzIHRoZSBsYXN0IHZhbHVlIHdlIHNldC5cbiAgICAgIC8vIG5vdCB1c2luZyBtZWRpYVNvdXJjZS5kdXJhdGlvbiBhcyB0aGUgYnJvd3NlciBtYXkgdHdlYWsgdGhpcyB2YWx1ZVxuICAgICAgLy8gb25seSB1cGRhdGUgTWVkaWEgU291cmNlIGR1cmF0aW9uIGlmIGl0cyB2YWx1ZSBpbmNyZWFzZSwgdGhpcyBpcyB0byBhdm9pZFxuICAgICAgLy8gZmx1c2hpbmcgYWxyZWFkeSBidWZmZXJlZCBwb3J0aW9uIHdoZW4gc3dpdGNoaW5nIGJldHdlZW4gcXVhbGl0eSBsZXZlbFxuICAgICAgdGhpcy5sb2coYFVwZGF0aW5nIE1lZGlhIFNvdXJjZSBkdXJhdGlvbiB0byAke2xldmVsRHVyYXRpb24udG9GaXhlZCgzKX1gKTtcbiAgICAgIG1lZGlhU291cmNlLmR1cmF0aW9uID0gbGV2ZWxEdXJhdGlvbjtcbiAgICB9XG4gIH1cbiAgdXBkYXRlU2Vla2FibGVSYW5nZShsZXZlbERldGFpbHMpIHtcbiAgICBjb25zdCBtZWRpYVNvdXJjZSA9IHRoaXMubWVkaWFTb3VyY2U7XG4gICAgY29uc3QgZnJhZ21lbnRzID0gbGV2ZWxEZXRhaWxzLmZyYWdtZW50cztcbiAgICBjb25zdCBsZW4gPSBmcmFnbWVudHMubGVuZ3RoO1xuICAgIGlmIChsZW4gJiYgbGV2ZWxEZXRhaWxzLmxpdmUgJiYgbWVkaWFTb3VyY2UgIT0gbnVsbCAmJiBtZWRpYVNvdXJjZS5zZXRMaXZlU2Vla2FibGVSYW5nZSkge1xuICAgICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heCgwLCBmcmFnbWVudHNbMF0uc3RhcnQpO1xuICAgICAgY29uc3QgZW5kID0gTWF0aC5tYXgoc3RhcnQsIHN0YXJ0ICsgbGV2ZWxEZXRhaWxzLnRvdGFsZHVyYXRpb24pO1xuICAgICAgdGhpcy5sb2coYE1lZGlhIFNvdXJjZSBkdXJhdGlvbiBpcyBzZXQgdG8gJHttZWRpYVNvdXJjZS5kdXJhdGlvbn0uIFNldHRpbmcgc2Vla2FibGUgcmFuZ2UgdG8gJHtzdGFydH0tJHtlbmR9LmApO1xuICAgICAgbWVkaWFTb3VyY2Uuc2V0TGl2ZVNlZWthYmxlUmFuZ2Uoc3RhcnQsIGVuZCk7XG4gICAgfVxuICB9XG4gIGNoZWNrUGVuZGluZ1RyYWNrcygpIHtcbiAgICBjb25zdCB7XG4gICAgICBidWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkLFxuICAgICAgb3BlcmF0aW9uUXVldWUsXG4gICAgICBwZW5kaW5nVHJhY2tzXG4gICAgfSA9IHRoaXM7XG5cbiAgICAvLyBDaGVjayBpZiB3ZSd2ZSByZWNlaXZlZCBhbGwgb2YgdGhlIGV4cGVjdGVkIGJ1ZmZlckNvZGVjIGV2ZW50cy4gV2hlbiBub25lIHJlbWFpbiwgY3JlYXRlIGFsbCB0aGUgc291cmNlQnVmZmVycyBhdCBvbmNlLlxuICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IGJlY2F1c2UgdGhlIE1TRSBzcGVjIGFsbG93cyBpbXBsZW1lbnRhdGlvbnMgdG8gdGhyb3cgUXVvdGFFeGNlZWRlZEVycm9ycyBpZiBjcmVhdGluZyBuZXcgc291cmNlQnVmZmVycyBhZnRlclxuICAgIC8vIGRhdGEgaGFzIGJlZW4gYXBwZW5kZWQgdG8gZXhpc3Rpbmcgb25lcy5cbiAgICAvLyAyIHRyYWNrcyBpcyB0aGUgbWF4IChvbmUgZm9yIGF1ZGlvLCBvbmUgZm9yIHZpZGVvKS4gSWYgd2UndmUgcmVhY2ggdGhpcyBtYXggZ28gYWhlYWQgYW5kIGNyZWF0ZSB0aGUgYnVmZmVycy5cbiAgICBjb25zdCBwZW5kaW5nVHJhY2tzQ291bnQgPSBPYmplY3Qua2V5cyhwZW5kaW5nVHJhY2tzKS5sZW5ndGg7XG4gICAgaWYgKHBlbmRpbmdUcmFja3NDb3VudCAmJiAoIWJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgfHwgcGVuZGluZ1RyYWNrc0NvdW50ID09PSAyIHx8ICdhdWRpb3ZpZGVvJyBpbiBwZW5kaW5nVHJhY2tzKSkge1xuICAgICAgLy8gb2ssIGxldCdzIGNyZWF0ZSB0aGVtIG5vdyAhXG4gICAgICB0aGlzLmNyZWF0ZVNvdXJjZUJ1ZmZlcnMocGVuZGluZ1RyYWNrcyk7XG4gICAgICB0aGlzLnBlbmRpbmdUcmFja3MgPSB7fTtcbiAgICAgIC8vIGFwcGVuZCBhbnkgcGVuZGluZyBzZWdtZW50cyBub3cgIVxuICAgICAgY29uc3QgYnVmZmVycyA9IHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKTtcbiAgICAgIGlmIChidWZmZXJzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfQ1JFQVRFRCwge1xuICAgICAgICAgIHRyYWNrczogdGhpcy50cmFja3NcbiAgICAgICAgfSk7XG4gICAgICAgIGJ1ZmZlcnMuZm9yRWFjaCh0eXBlID0+IHtcbiAgICAgICAgICBvcGVyYXRpb25RdWV1ZS5leGVjdXRlTmV4dCh0eXBlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignY291bGQgbm90IGNyZWF0ZSBzb3VyY2UgYnVmZmVyIGZvciBtZWRpYSBjb2RlYyhzKScpO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SLFxuICAgICAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY3JlYXRlU291cmNlQnVmZmVycyh0cmFja3MpIHtcbiAgICBjb25zdCB7XG4gICAgICBzb3VyY2VCdWZmZXIsXG4gICAgICBtZWRpYVNvdXJjZVxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghbWVkaWFTb3VyY2UpIHtcbiAgICAgIHRocm93IEVycm9yKCdjcmVhdGVTb3VyY2VCdWZmZXJzIGNhbGxlZCB3aGVuIG1lZGlhU291cmNlIHdhcyBudWxsJyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgdHJhY2tOYW1lIGluIHRyYWNrcykge1xuICAgICAgaWYgKCFzb3VyY2VCdWZmZXJbdHJhY2tOYW1lXSkge1xuICAgICAgICBjb25zdCB0cmFjayA9IHRyYWNrc1t0cmFja05hbWVdO1xuICAgICAgICBpZiAoIXRyYWNrKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYHNvdXJjZSBidWZmZXIgZXhpc3RzIGZvciB0cmFjayAke3RyYWNrTmFtZX0sIGhvd2V2ZXIgdHJhY2sgZG9lcyBub3RgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB1c2UgbGV2ZWxDb2RlYyBhcyBmaXJzdCBwcmlvcml0eVxuICAgICAgICBsZXQgY29kZWMgPSB0cmFjay5sZXZlbENvZGVjIHx8IHRyYWNrLmNvZGVjO1xuICAgICAgICBpZiAoY29kZWMpIHtcbiAgICAgICAgICBpZiAodHJhY2tOYW1lLnNsaWNlKDAsIDUpID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICBjb2RlYyA9IGdldENvZGVjQ29tcGF0aWJsZU5hbWUoY29kZWMsIHRoaXMuaGxzLmNvbmZpZy5wcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtaW1lVHlwZSA9IGAke3RyYWNrLmNvbnRhaW5lcn07Y29kZWNzPSR7Y29kZWN9YDtcbiAgICAgICAgdGhpcy5sb2coYGNyZWF0aW5nIHNvdXJjZUJ1ZmZlcigke21pbWVUeXBlfSlgKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBzYiA9IHNvdXJjZUJ1ZmZlclt0cmFja05hbWVdID0gbWVkaWFTb3VyY2UuYWRkU291cmNlQnVmZmVyKG1pbWVUeXBlKTtcbiAgICAgICAgICBjb25zdCBzYk5hbWUgPSB0cmFja05hbWU7XG4gICAgICAgICAgdGhpcy5hZGRCdWZmZXJMaXN0ZW5lcihzYk5hbWUsICd1cGRhdGVzdGFydCcsIHRoaXMuX29uU0JVcGRhdGVTdGFydCk7XG4gICAgICAgICAgdGhpcy5hZGRCdWZmZXJMaXN0ZW5lcihzYk5hbWUsICd1cGRhdGVlbmQnLCB0aGlzLl9vblNCVXBkYXRlRW5kKTtcbiAgICAgICAgICB0aGlzLmFkZEJ1ZmZlckxpc3RlbmVyKHNiTmFtZSwgJ2Vycm9yJywgdGhpcy5fb25TQlVwZGF0ZUVycm9yKTtcbiAgICAgICAgICAvLyBNYW5hZ2VkU291cmNlQnVmZmVyIGJ1ZmZlcmVkY2hhbmdlIGV2ZW50XG4gICAgICAgICAgdGhpcy5hZGRCdWZmZXJMaXN0ZW5lcihzYk5hbWUsICdidWZmZXJlZGNoYW5nZScsICh0eXBlLCBldmVudCkgPT4ge1xuICAgICAgICAgICAgLy8gSWYgbWVkaWEgd2FzIGVqZWN0ZWQgY2hlY2sgZm9yIGEgY2hhbmdlLiBBZGRlZCByYW5nZXMgYXJlIHJlZHVuZGFudCB3aXRoIGNoYW5nZXMgb24gJ3VwZGF0ZWVuZCcgZXZlbnQuXG4gICAgICAgICAgICBjb25zdCByZW1vdmVkUmFuZ2VzID0gZXZlbnQucmVtb3ZlZFJhbmdlcztcbiAgICAgICAgICAgIGlmIChyZW1vdmVkUmFuZ2VzICE9IG51bGwgJiYgcmVtb3ZlZFJhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0ZMVVNIRUQsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0cmFja05hbWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy50cmFja3NbdHJhY2tOYW1lXSA9IHtcbiAgICAgICAgICAgIGJ1ZmZlcjogc2IsXG4gICAgICAgICAgICBjb2RlYzogY29kZWMsXG4gICAgICAgICAgICBjb250YWluZXI6IHRyYWNrLmNvbnRhaW5lcixcbiAgICAgICAgICAgIGxldmVsQ29kZWM6IHRyYWNrLmxldmVsQ29kZWMsXG4gICAgICAgICAgICBtZXRhZGF0YTogdHJhY2subWV0YWRhdGEsXG4gICAgICAgICAgICBpZDogdHJhY2suaWRcbiAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB0aGlzLmVycm9yKGBlcnJvciB3aGlsZSB0cnlpbmcgdG8gYWRkIHNvdXJjZUJ1ZmZlcjogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfQUREX0NPREVDX0VSUk9SLFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IGVycixcbiAgICAgICAgICAgIHNvdXJjZUJ1ZmZlck5hbWU6IHRyYWNrTmFtZSxcbiAgICAgICAgICAgIG1pbWVUeXBlOiBtaW1lVHlwZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBtZWRpYVNyYygpIHtcbiAgICB2YXIgX3RoaXMkbWVkaWE7XG4gICAgY29uc3QgbWVkaWEgPSAoKF90aGlzJG1lZGlhID0gdGhpcy5tZWRpYSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG1lZGlhLmZpcnN0Q2hpbGQpIHx8IHRoaXMubWVkaWE7XG4gICAgcmV0dXJuIG1lZGlhID09IG51bGwgPyB2b2lkIDAgOiBtZWRpYS5zcmM7XG4gIH1cbiAgX29uU0JVcGRhdGVTdGFydCh0eXBlKSB7XG4gICAgY29uc3Qge1xuICAgICAgb3BlcmF0aW9uUXVldWVcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBvcGVyYXRpb24gPSBvcGVyYXRpb25RdWV1ZS5jdXJyZW50KHR5cGUpO1xuICAgIG9wZXJhdGlvbi5vblN0YXJ0KCk7XG4gIH1cbiAgX29uU0JVcGRhdGVFbmQodHlwZSkge1xuICAgIHZhciBfdGhpcyRtZWRpYVNvdXJjZTI7XG4gICAgaWYgKCgoX3RoaXMkbWVkaWFTb3VyY2UyID0gdGhpcy5tZWRpYVNvdXJjZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG1lZGlhU291cmNlMi5yZWFkeVN0YXRlKSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgIHRoaXMucmVzZXRCdWZmZXIodHlwZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIG9wZXJhdGlvblF1ZXVlXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgb3BlcmF0aW9uID0gb3BlcmF0aW9uUXVldWUuY3VycmVudCh0eXBlKTtcbiAgICBvcGVyYXRpb24ub25Db21wbGV0ZSgpO1xuICAgIG9wZXJhdGlvblF1ZXVlLnNoaWZ0QW5kRXhlY3V0ZU5leHQodHlwZSk7XG4gIH1cbiAgX29uU0JVcGRhdGVFcnJvcih0eXBlLCBldmVudCkge1xuICAgIHZhciBfdGhpcyRtZWRpYVNvdXJjZTM7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYCR7dHlwZX0gU291cmNlQnVmZmVyIGVycm9yLiBNZWRpYVNvdXJjZSByZWFkeVN0YXRlOiAkeyhfdGhpcyRtZWRpYVNvdXJjZTMgPSB0aGlzLm1lZGlhU291cmNlKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbWVkaWFTb3VyY2UzLnJlYWR5U3RhdGV9YCk7XG4gICAgdGhpcy5lcnJvcihgJHtlcnJvcn1gLCBldmVudCk7XG4gICAgLy8gYWNjb3JkaW5nIHRvIGh0dHA6Ly93d3cudzMub3JnL1RSL21lZGlhLXNvdXJjZS8jc291cmNlYnVmZmVyLWFwcGVuZC1lcnJvclxuICAgIC8vIFNvdXJjZUJ1ZmZlciBlcnJvcnMgYXJlIG5vdCBuZWNlc3NhcmlseSBmYXRhbDsgaWYgc28sIHRoZSBIVE1MTWVkaWFFbGVtZW50IHdpbGwgZmlyZSBhbiBlcnJvciBldmVudFxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRJTkdfRVJST1IsXG4gICAgICBzb3VyY2VCdWZmZXJOYW1lOiB0eXBlLFxuICAgICAgZXJyb3IsXG4gICAgICBmYXRhbDogZmFsc2VcbiAgICB9KTtcbiAgICAvLyB1cGRhdGVlbmQgaXMgYWx3YXlzIGZpcmVkIGFmdGVyIGVycm9yLCBzbyB3ZSdsbCBhbGxvdyB0aGF0IHRvIHNoaWZ0IHRoZSBjdXJyZW50IG9wZXJhdGlvbiBvZmYgb2YgdGhlIHF1ZXVlXG4gICAgY29uc3Qgb3BlcmF0aW9uID0gdGhpcy5vcGVyYXRpb25RdWV1ZS5jdXJyZW50KHR5cGUpO1xuICAgIGlmIChvcGVyYXRpb24pIHtcbiAgICAgIG9wZXJhdGlvbi5vbkVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cblxuICAvLyBUaGlzIG1ldGhvZCBtdXN0IHJlc3VsdCBpbiBhbiB1cGRhdGVlbmQgZXZlbnQ7IGlmIHJlbW92ZSBpcyBub3QgY2FsbGVkLCBfb25TQlVwZGF0ZUVuZCBtdXN0IGJlIGNhbGxlZCBtYW51YWxseVxuICByZW1vdmVFeGVjdXRvcih0eXBlLCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0KSB7XG4gICAgY29uc3Qge1xuICAgICAgbWVkaWEsXG4gICAgICBtZWRpYVNvdXJjZSxcbiAgICAgIG9wZXJhdGlvblF1ZXVlLFxuICAgICAgc291cmNlQnVmZmVyXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc2IgPSBzb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgaWYgKCFtZWRpYSB8fCAhbWVkaWFTb3VyY2UgfHwgIXNiKSB7XG4gICAgICB0aGlzLndhcm4oYEF0dGVtcHRpbmcgdG8gcmVtb3ZlIGZyb20gdGhlICR7dHlwZX0gU291cmNlQnVmZmVyLCBidXQgaXQgZG9lcyBub3QgZXhpc3RgKTtcbiAgICAgIG9wZXJhdGlvblF1ZXVlLnNoaWZ0QW5kRXhlY3V0ZU5leHQodHlwZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1lZGlhRHVyYXRpb24gPSBpc0Zpbml0ZU51bWJlcihtZWRpYS5kdXJhdGlvbikgPyBtZWRpYS5kdXJhdGlvbiA6IEluZmluaXR5O1xuICAgIGNvbnN0IG1zRHVyYXRpb24gPSBpc0Zpbml0ZU51bWJlcihtZWRpYVNvdXJjZS5kdXJhdGlvbikgPyBtZWRpYVNvdXJjZS5kdXJhdGlvbiA6IEluZmluaXR5O1xuICAgIGNvbnN0IHJlbW92ZVN0YXJ0ID0gTWF0aC5tYXgoMCwgc3RhcnRPZmZzZXQpO1xuICAgIGNvbnN0IHJlbW92ZUVuZCA9IE1hdGgubWluKGVuZE9mZnNldCwgbWVkaWFEdXJhdGlvbiwgbXNEdXJhdGlvbik7XG4gICAgaWYgKHJlbW92ZUVuZCA+IHJlbW92ZVN0YXJ0ICYmICghc2IuZW5kaW5nIHx8IHNiLmVuZGVkKSkge1xuICAgICAgc2IuZW5kZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMubG9nKGBSZW1vdmluZyBbJHtyZW1vdmVTdGFydH0sJHtyZW1vdmVFbmR9XSBmcm9tIHRoZSAke3R5cGV9IFNvdXJjZUJ1ZmZlcmApO1xuICAgICAgc2IucmVtb3ZlKHJlbW92ZVN0YXJ0LCByZW1vdmVFbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDeWNsZSB0aGUgcXVldWVcbiAgICAgIG9wZXJhdGlvblF1ZXVlLnNoaWZ0QW5kRXhlY3V0ZU5leHQodHlwZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gVGhpcyBtZXRob2QgbXVzdCByZXN1bHQgaW4gYW4gdXBkYXRlZW5kIGV2ZW50OyBpZiBhcHBlbmQgaXMgbm90IGNhbGxlZCwgX29uU0JVcGRhdGVFbmQgbXVzdCBiZSBjYWxsZWQgbWFudWFsbHlcbiAgYXBwZW5kRXhlY3V0b3IoZGF0YSwgdHlwZSkge1xuICAgIGNvbnN0IHNiID0gdGhpcy5zb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgaWYgKCFzYikge1xuICAgICAgaWYgKCF0aGlzLnBlbmRpbmdUcmFja3NbdHlwZV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdHRlbXB0aW5nIHRvIGFwcGVuZCB0byB0aGUgJHt0eXBlfSBTb3VyY2VCdWZmZXIsIGJ1dCBpdCBkb2VzIG5vdCBleGlzdGApO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzYi5lbmRlZCA9IGZhbHNlO1xuICAgIHNiLmFwcGVuZEJ1ZmZlcihkYXRhKTtcbiAgfVxuXG4gIC8vIEVucXVldWVzIGFuIG9wZXJhdGlvbiB0byBlYWNoIFNvdXJjZUJ1ZmZlciBxdWV1ZSB3aGljaCwgdXBvbiBleGVjdXRpb24sIHJlc29sdmVzIGEgcHJvbWlzZS4gV2hlbiBhbGwgcHJvbWlzZXNcbiAgLy8gcmVzb2x2ZSwgdGhlIG9uVW5ibG9ja2VkIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkLiBGdW5jdGlvbnMgY2FsbGluZyB0aGlzIG1ldGhvZCBkbyBub3QgbmVlZCB0byB1bmJsb2NrIHRoZSBxdWV1ZVxuICAvLyB1cG9uIGNvbXBsZXRpb24sIHNpbmNlIHdlIGFscmVhZHkgZG8gaXQgaGVyZVxuICBibG9ja0J1ZmZlcnMob25VbmJsb2NrZWQsIGJ1ZmZlcnMgPSB0aGlzLmdldFNvdXJjZUJ1ZmZlclR5cGVzKCkpIHtcbiAgICBpZiAoIWJ1ZmZlcnMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmxvZygnQmxvY2tpbmcgb3BlcmF0aW9uIHJlcXVlc3RlZCwgYnV0IG5vIFNvdXJjZUJ1ZmZlcnMgZXhpc3QnKTtcbiAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4ob25VbmJsb2NrZWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBvcGVyYXRpb25RdWV1ZVxuICAgIH0gPSB0aGlzO1xuXG4gICAgLy8gbG9nZ2VyLmRlYnVnKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiBCbG9ja2luZyAke2J1ZmZlcnN9IFNvdXJjZUJ1ZmZlcmApO1xuICAgIGNvbnN0IGJsb2NraW5nT3BlcmF0aW9ucyA9IGJ1ZmZlcnMubWFwKHR5cGUgPT4gb3BlcmF0aW9uUXVldWUuYXBwZW5kQmxvY2tlcih0eXBlKSk7XG4gICAgUHJvbWlzZS5hbGwoYmxvY2tpbmdPcGVyYXRpb25zKS50aGVuKCgpID0+IHtcbiAgICAgIC8vIGxvZ2dlci5kZWJ1ZyhgW2J1ZmZlci1jb250cm9sbGVyXTogQmxvY2tpbmcgb3BlcmF0aW9uIHJlc29sdmVkOyB1bmJsb2NraW5nICR7YnVmZmVyc30gU291cmNlQnVmZmVyYCk7XG4gICAgICBvblVuYmxvY2tlZCgpO1xuICAgICAgYnVmZmVycy5mb3JFYWNoKHR5cGUgPT4ge1xuICAgICAgICBjb25zdCBzYiA9IHRoaXMuc291cmNlQnVmZmVyW3R5cGVdO1xuICAgICAgICAvLyBPbmx5IGN5Y2xlIHRoZSBxdWV1ZSBpZiB0aGUgU0IgaXMgbm90IHVwZGF0aW5nLiBUaGVyZSdzIGEgYnVnIGluIENocm9tZSB3aGljaCBzZXRzIHRoZSBTQiB1cGRhdGluZyBmbGFnIHRvXG4gICAgICAgIC8vIHRydWUgd2hlbiBjaGFuZ2luZyB0aGUgTWVkaWFTb3VyY2UgZHVyYXRpb24gKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTk1OTM1OSZjYW49MiZxPW1lZGlhc291cmNlJTIwZHVyYXRpb24pXG4gICAgICAgIC8vIFdoaWxlIHRoaXMgaXMgYSB3b3JrYXJvdW5kLCBpdCdzIHByb2JhYmx5IHVzZWZ1bCB0byBoYXZlIGFyb3VuZFxuICAgICAgICBpZiAoIShzYiAhPSBudWxsICYmIHNiLnVwZGF0aW5nKSkge1xuICAgICAgICAgIG9wZXJhdGlvblF1ZXVlLnNoaWZ0QW5kRXhlY3V0ZU5leHQodHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGdldFNvdXJjZUJ1ZmZlclR5cGVzKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnNvdXJjZUJ1ZmZlcik7XG4gIH1cbiAgYWRkQnVmZmVyTGlzdGVuZXIodHlwZSwgZXZlbnQsIGZuKSB7XG4gICAgY29uc3QgYnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgaWYgKCFidWZmZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGlzdGVuZXIgPSBmbi5iaW5kKHRoaXMsIHR5cGUpO1xuICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdLnB1c2goe1xuICAgICAgZXZlbnQsXG4gICAgICBsaXN0ZW5lclxuICAgIH0pO1xuICAgIGJ1ZmZlci5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcik7XG4gIH1cbiAgcmVtb3ZlQnVmZmVyTGlzdGVuZXJzKHR5cGUpIHtcbiAgICBjb25zdCBidWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICBpZiAoIWJ1ZmZlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXS5mb3JFYWNoKGwgPT4ge1xuICAgICAgYnVmZmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIobC5ldmVudCwgbC5saXN0ZW5lcik7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZVNvdXJjZUNoaWxkcmVuKG5vZGUpIHtcbiAgY29uc3Qgc291cmNlQ2hpbGRyZW4gPSBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ3NvdXJjZScpO1xuICBbXS5zbGljZS5jYWxsKHNvdXJjZUNoaWxkcmVuKS5mb3JFYWNoKHNvdXJjZSA9PiB7XG4gICAgbm9kZS5yZW1vdmVDaGlsZChzb3VyY2UpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGFkZFNvdXJjZShtZWRpYSwgdXJsKSB7XG4gIGNvbnN0IHNvdXJjZSA9IHNlbGYuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc291cmNlJyk7XG4gIHNvdXJjZS50eXBlID0gJ3ZpZGVvL21wNCc7XG4gIHNvdXJjZS5zcmMgPSB1cmw7XG4gIG1lZGlhLmFwcGVuZENoaWxkKHNvdXJjZSk7XG59XG5cbi8qKlxuICpcbiAqIFRoaXMgY29kZSB3YXMgcG9ydGVkIGZyb20gdGhlIGRhc2guanMgcHJvamVjdCBhdDpcbiAqICAgaHR0cHM6Ly9naXRodWIuY29tL0Rhc2gtSW5kdXN0cnktRm9ydW0vZGFzaC5qcy9ibG9iL2RldmVsb3BtZW50L2V4dGVybmFscy9jZWE2MDgtcGFyc2VyLmpzXG4gKiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXNoLUluZHVzdHJ5LUZvcnVtL2Rhc2guanMvY29tbWl0LzgyNjliMjZhNzYxZTA4NTNiYjIxZDc4NzgwZWQ5NDUxNDRlY2RkNGQjZGlmZi03MWJjMjk1YTJkNmI2YjcwOTNhMWQzMjkwZDUzYTRiMlxuICpcbiAqIFRoZSBvcmlnaW5hbCBjb3B5cmlnaHQgYXBwZWFycyBiZWxvdzpcbiAqXG4gKiBUaGUgY29weXJpZ2h0IGluIHRoaXMgc29mdHdhcmUgaXMgYmVpbmcgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLFxuICogaW5jbHVkZWQgYmVsb3cuIFRoaXMgc29mdHdhcmUgbWF5IGJlIHN1YmplY3QgdG8gb3RoZXIgdGhpcmQgcGFydHkgYW5kIGNvbnRyaWJ1dG9yXG4gKiByaWdodHMsIGluY2x1ZGluZyBwYXRlbnQgcmlnaHRzLCBhbmQgbm8gc3VjaCByaWdodHMgYXJlIGdyYW50ZWQgdW5kZXIgdGhpcyBsaWNlbnNlLlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNS0yMDE2LCBEQVNIIEluZHVzdHJ5IEZvcnVtLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuICogYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICogIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICogIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yXG4gKiAgb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqICAyLiBOZWl0aGVyIHRoZSBuYW1lIG9mIERhc2ggSW5kdXN0cnkgRm9ydW0gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4gKiAgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgQVMgSVMgQU5EIEFOWVxuICogIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbiAqICBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuXG4gKiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCxcbiAqICBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUXG4gKiAgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICogIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLFxuICogIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbiAqICBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICogIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG4vKipcbiAqICBFeGNlcHRpb25zIGZyb20gcmVndWxhciBBU0NJSS4gQ29kZVBvaW50cyBhcmUgbWFwcGVkIHRvIFVURi0xNiBjb2Rlc1xuICovXG5cbmNvbnN0IHNwZWNpYWxDZWE2MDhDaGFyc0NvZGVzID0ge1xuICAweDJhOiAweGUxLFxuICAvLyBsb3dlcmNhc2UgYSwgYWN1dGUgYWNjZW50XG4gIDB4NWM6IDB4ZTksXG4gIC8vIGxvd2VyY2FzZSBlLCBhY3V0ZSBhY2NlbnRcbiAgMHg1ZTogMHhlZCxcbiAgLy8gbG93ZXJjYXNlIGksIGFjdXRlIGFjY2VudFxuICAweDVmOiAweGYzLFxuICAvLyBsb3dlcmNhc2UgbywgYWN1dGUgYWNjZW50XG4gIDB4NjA6IDB4ZmEsXG4gIC8vIGxvd2VyY2FzZSB1LCBhY3V0ZSBhY2NlbnRcbiAgMHg3YjogMHhlNyxcbiAgLy8gbG93ZXJjYXNlIGMgd2l0aCBjZWRpbGxhXG4gIDB4N2M6IDB4ZjcsXG4gIC8vIGRpdmlzaW9uIHN5bWJvbFxuICAweDdkOiAweGQxLFxuICAvLyB1cHBlcmNhc2UgTiB0aWxkZVxuICAweDdlOiAweGYxLFxuICAvLyBsb3dlcmNhc2UgbiB0aWxkZVxuICAweDdmOiAweDI1ODgsXG4gIC8vIEZ1bGwgYmxvY2tcbiAgLy8gVEhJUyBCTE9DSyBJTkNMVURFUyBUSEUgMTYgRVhURU5ERUQgKFRXTy1CWVRFKSBMSU5FIDIxIENIQVJBQ1RFUlNcbiAgLy8gVEhBVCBDT01FIEZST00gSEkgQllURT0weDExIEFORCBMT1cgQkVUV0VFTiAweDMwIEFORCAweDNGXG4gIC8vIFRISVMgTUVBTlMgVEhBVCBcXHg1MCBNVVNUIEJFIEFEREVEIFRPIFRIRSBWQUxVRVNcbiAgMHg4MDogMHhhZSxcbiAgLy8gUmVnaXN0ZXJlZCBzeW1ib2wgKFIpXG4gIDB4ODE6IDB4YjAsXG4gIC8vIGRlZ3JlZSBzaWduXG4gIDB4ODI6IDB4YmQsXG4gIC8vIDEvMiBzeW1ib2xcbiAgMHg4MzogMHhiZixcbiAgLy8gSW52ZXJ0ZWQgKG9wZW4pIHF1ZXN0aW9uIG1hcmtcbiAgMHg4NDogMHgyMTIyLFxuICAvLyBUcmFkZW1hcmsgc3ltYm9sIChUTSlcbiAgMHg4NTogMHhhMixcbiAgLy8gQ2VudHMgc3ltYm9sXG4gIDB4ODY6IDB4YTMsXG4gIC8vIFBvdW5kcyBzdGVybGluZ1xuICAweDg3OiAweDI2NmEsXG4gIC8vIE11c2ljIDgndGggbm90ZVxuICAweDg4OiAweGUwLFxuICAvLyBsb3dlcmNhc2UgYSwgZ3JhdmUgYWNjZW50XG4gIDB4ODk6IDB4MjAsXG4gIC8vIHRyYW5zcGFyZW50IHNwYWNlIChyZWd1bGFyKVxuICAweDhhOiAweGU4LFxuICAvLyBsb3dlcmNhc2UgZSwgZ3JhdmUgYWNjZW50XG4gIDB4OGI6IDB4ZTIsXG4gIC8vIGxvd2VyY2FzZSBhLCBjaXJjdW1mbGV4IGFjY2VudFxuICAweDhjOiAweGVhLFxuICAvLyBsb3dlcmNhc2UgZSwgY2lyY3VtZmxleCBhY2NlbnRcbiAgMHg4ZDogMHhlZSxcbiAgLy8gbG93ZXJjYXNlIGksIGNpcmN1bWZsZXggYWNjZW50XG4gIDB4OGU6IDB4ZjQsXG4gIC8vIGxvd2VyY2FzZSBvLCBjaXJjdW1mbGV4IGFjY2VudFxuICAweDhmOiAweGZiLFxuICAvLyBsb3dlcmNhc2UgdSwgY2lyY3VtZmxleCBhY2NlbnRcbiAgLy8gVEhJUyBCTE9DSyBJTkNMVURFUyBUSEUgMzIgRVhURU5ERUQgKFRXTy1CWVRFKSBMSU5FIDIxIENIQVJBQ1RFUlNcbiAgLy8gVEhBVCBDT01FIEZST00gSEkgQllURT0weDEyIEFORCBMT1cgQkVUV0VFTiAweDIwIEFORCAweDNGXG4gIDB4OTA6IDB4YzEsXG4gIC8vIGNhcGl0YWwgbGV0dGVyIEEgd2l0aCBhY3V0ZVxuICAweDkxOiAweGM5LFxuICAvLyBjYXBpdGFsIGxldHRlciBFIHdpdGggYWN1dGVcbiAgMHg5MjogMHhkMyxcbiAgLy8gY2FwaXRhbCBsZXR0ZXIgTyB3aXRoIGFjdXRlXG4gIDB4OTM6IDB4ZGEsXG4gIC8vIGNhcGl0YWwgbGV0dGVyIFUgd2l0aCBhY3V0ZVxuICAweDk0OiAweGRjLFxuICAvLyBjYXBpdGFsIGxldHRlciBVIHdpdGggZGlhcmVzaXNcbiAgMHg5NTogMHhmYyxcbiAgLy8gbG93ZXJjYXNlIGxldHRlciBVIHdpdGggZGlhZXJlc2lzXG4gIDB4OTY6IDB4MjAxOCxcbiAgLy8gb3BlbmluZyBzaW5nbGUgcXVvdGVcbiAgMHg5NzogMHhhMSxcbiAgLy8gaW52ZXJ0ZWQgZXhjbGFtYXRpb24gbWFya1xuICAweDk4OiAweDJhLFxuICAvLyBhc3Rlcmlza1xuICAweDk5OiAweDIwMTksXG4gIC8vIGNsb3Npbmcgc2luZ2xlIHF1b3RlXG4gIDB4OWE6IDB4MjUwMSxcbiAgLy8gYm94IGRyYXdpbmdzIGhlYXZ5IGhvcml6b250YWxcbiAgMHg5YjogMHhhOSxcbiAgLy8gY29weXJpZ2h0IHNpZ25cbiAgMHg5YzogMHgyMTIwLFxuICAvLyBTZXJ2aWNlIG1hcmtcbiAgMHg5ZDogMHgyMDIyLFxuICAvLyAocm91bmQpIGJ1bGxldFxuICAweDllOiAweDIwMWMsXG4gIC8vIExlZnQgZG91YmxlIHF1b3RhdGlvbiBtYXJrXG4gIDB4OWY6IDB4MjAxZCxcbiAgLy8gUmlnaHQgZG91YmxlIHF1b3RhdGlvbiBtYXJrXG4gIDB4YTA6IDB4YzAsXG4gIC8vIHVwcGVyY2FzZSBBLCBncmF2ZSBhY2NlbnRcbiAgMHhhMTogMHhjMixcbiAgLy8gdXBwZXJjYXNlIEEsIGNpcmN1bWZsZXhcbiAgMHhhMjogMHhjNyxcbiAgLy8gdXBwZXJjYXNlIEMgd2l0aCBjZWRpbGxhXG4gIDB4YTM6IDB4YzgsXG4gIC8vIHVwcGVyY2FzZSBFLCBncmF2ZSBhY2NlbnRcbiAgMHhhNDogMHhjYSxcbiAgLy8gdXBwZXJjYXNlIEUsIGNpcmN1bWZsZXhcbiAgMHhhNTogMHhjYixcbiAgLy8gY2FwaXRhbCBsZXR0ZXIgRSB3aXRoIGRpYXJlc2lzXG4gIDB4YTY6IDB4ZWIsXG4gIC8vIGxvd2VyY2FzZSBsZXR0ZXIgZSB3aXRoIGRpYXJlc2lzXG4gIDB4YTc6IDB4Y2UsXG4gIC8vIHVwcGVyY2FzZSBJLCBjaXJjdW1mbGV4XG4gIDB4YTg6IDB4Y2YsXG4gIC8vIHVwcGVyY2FzZSBJLCB3aXRoIGRpYXJlc2lzXG4gIDB4YTk6IDB4ZWYsXG4gIC8vIGxvd2VyY2FzZSBpLCB3aXRoIGRpYXJlc2lzXG4gIDB4YWE6IDB4ZDQsXG4gIC8vIHVwcGVyY2FzZSBPLCBjaXJjdW1mbGV4XG4gIDB4YWI6IDB4ZDksXG4gIC8vIHVwcGVyY2FzZSBVLCBncmF2ZSBhY2NlbnRcbiAgMHhhYzogMHhmOSxcbiAgLy8gbG93ZXJjYXNlIHUsIGdyYXZlIGFjY2VudFxuICAweGFkOiAweGRiLFxuICAvLyB1cHBlcmNhc2UgVSwgY2lyY3VtZmxleFxuICAweGFlOiAweGFiLFxuICAvLyBsZWZ0LXBvaW50aW5nIGRvdWJsZSBhbmdsZSBxdW90YXRpb24gbWFya1xuICAweGFmOiAweGJiLFxuICAvLyByaWdodC1wb2ludGluZyBkb3VibGUgYW5nbGUgcXVvdGF0aW9uIG1hcmtcbiAgLy8gVEhJUyBCTE9DSyBJTkNMVURFUyBUSEUgMzIgRVhURU5ERUQgKFRXTy1CWVRFKSBMSU5FIDIxIENIQVJBQ1RFUlNcbiAgLy8gVEhBVCBDT01FIEZST00gSEkgQllURT0weDEzIEFORCBMT1cgQkVUV0VFTiAweDIwIEFORCAweDNGXG4gIDB4YjA6IDB4YzMsXG4gIC8vIFVwcGVyY2FzZSBBLCB0aWxkZVxuICAweGIxOiAweGUzLFxuICAvLyBMb3dlcmNhc2UgYSwgdGlsZGVcbiAgMHhiMjogMHhjZCxcbiAgLy8gVXBwZXJjYXNlIEksIGFjdXRlIGFjY2VudFxuICAweGIzOiAweGNjLFxuICAvLyBVcHBlcmNhc2UgSSwgZ3JhdmUgYWNjZW50XG4gIDB4YjQ6IDB4ZWMsXG4gIC8vIExvd2VyY2FzZSBpLCBncmF2ZSBhY2NlbnRcbiAgMHhiNTogMHhkMixcbiAgLy8gVXBwZXJjYXNlIE8sIGdyYXZlIGFjY2VudFxuICAweGI2OiAweGYyLFxuICAvLyBMb3dlcmNhc2UgbywgZ3JhdmUgYWNjZW50XG4gIDB4Yjc6IDB4ZDUsXG4gIC8vIFVwcGVyY2FzZSBPLCB0aWxkZVxuICAweGI4OiAweGY1LFxuICAvLyBMb3dlcmNhc2UgbywgdGlsZGVcbiAgMHhiOTogMHg3YixcbiAgLy8gT3BlbiBjdXJseSBicmFjZVxuICAweGJhOiAweDdkLFxuICAvLyBDbG9zaW5nIGN1cmx5IGJyYWNlXG4gIDB4YmI6IDB4NWMsXG4gIC8vIEJhY2tzbGFzaFxuICAweGJjOiAweDVlLFxuICAvLyBDYXJldFxuICAweGJkOiAweDVmLFxuICAvLyBVbmRlcnNjb3JlXG4gIDB4YmU6IDB4N2MsXG4gIC8vIFBpcGUgKHZlcnRpY2FsIGxpbmUpXG4gIDB4YmY6IDB4MjIzYyxcbiAgLy8gVGlsZGUgb3BlcmF0b3JcbiAgMHhjMDogMHhjNCxcbiAgLy8gVXBwZXJjYXNlIEEsIHVtbGF1dFxuICAweGMxOiAweGU0LFxuICAvLyBMb3dlcmNhc2UgQSwgdW1sYXV0XG4gIDB4YzI6IDB4ZDYsXG4gIC8vIFVwcGVyY2FzZSBPLCB1bWxhdXRcbiAgMHhjMzogMHhmNixcbiAgLy8gTG93ZXJjYXNlIG8sIHVtbGF1dFxuICAweGM0OiAweGRmLFxuICAvLyBFc3N6ZXR0IChzaGFycCBTKVxuICAweGM1OiAweGE1LFxuICAvLyBZZW4gc3ltYm9sXG4gIDB4YzY6IDB4YTQsXG4gIC8vIEdlbmVyaWMgY3VycmVuY3kgc2lnblxuICAweGM3OiAweDI1MDMsXG4gIC8vIEJveCBkcmF3aW5ncyBoZWF2eSB2ZXJ0aWNhbFxuICAweGM4OiAweGM1LFxuICAvLyBVcHBlcmNhc2UgQSwgcmluZ1xuICAweGM5OiAweGU1LFxuICAvLyBMb3dlcmNhc2UgQSwgcmluZ1xuICAweGNhOiAweGQ4LFxuICAvLyBVcHBlcmNhc2UgTywgc3Ryb2tlXG4gIDB4Y2I6IDB4ZjgsXG4gIC8vIExvd2VyY2FzZSBvLCBzdHJva1xuICAweGNjOiAweDI1MGYsXG4gIC8vIEJveCBkcmF3aW5ncyBoZWF2eSBkb3duIGFuZCByaWdodFxuICAweGNkOiAweDI1MTMsXG4gIC8vIEJveCBkcmF3aW5ncyBoZWF2eSBkb3duIGFuZCBsZWZ0XG4gIDB4Y2U6IDB4MjUxNyxcbiAgLy8gQm94IGRyYXdpbmdzIGhlYXZ5IHVwIGFuZCByaWdodFxuICAweGNmOiAweDI1MWIgLy8gQm94IGRyYXdpbmdzIGhlYXZ5IHVwIGFuZCBsZWZ0XG59O1xuXG4vKipcbiAqIFV0aWxzXG4gKi9cbmNvbnN0IGdldENoYXJGb3JCeXRlID0gZnVuY3Rpb24gZ2V0Q2hhckZvckJ5dGUoYnl0ZSkge1xuICBsZXQgY2hhckNvZGUgPSBieXRlO1xuICBpZiAoc3BlY2lhbENlYTYwOENoYXJzQ29kZXMuaGFzT3duUHJvcGVydHkoYnl0ZSkpIHtcbiAgICBjaGFyQ29kZSA9IHNwZWNpYWxDZWE2MDhDaGFyc0NvZGVzW2J5dGVdO1xuICB9XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbn07XG5jb25zdCBOUl9ST1dTID0gMTU7XG5jb25zdCBOUl9DT0xTID0gMTAwO1xuLy8gVGFibGVzIHRvIGxvb2sgdXAgcm93IGZyb20gUEFDIGRhdGFcbmNvbnN0IHJvd3NMb3dDaDEgPSB7XG4gIDB4MTE6IDEsXG4gIDB4MTI6IDMsXG4gIDB4MTU6IDUsXG4gIDB4MTY6IDcsXG4gIDB4MTc6IDksXG4gIDB4MTA6IDExLFxuICAweDEzOiAxMixcbiAgMHgxNDogMTRcbn07XG5jb25zdCByb3dzSGlnaENoMSA9IHtcbiAgMHgxMTogMixcbiAgMHgxMjogNCxcbiAgMHgxNTogNixcbiAgMHgxNjogOCxcbiAgMHgxNzogMTAsXG4gIDB4MTM6IDEzLFxuICAweDE0OiAxNVxufTtcbmNvbnN0IHJvd3NMb3dDaDIgPSB7XG4gIDB4MTk6IDEsXG4gIDB4MWE6IDMsXG4gIDB4MWQ6IDUsXG4gIDB4MWU6IDcsXG4gIDB4MWY6IDksXG4gIDB4MTg6IDExLFxuICAweDFiOiAxMixcbiAgMHgxYzogMTRcbn07XG5jb25zdCByb3dzSGlnaENoMiA9IHtcbiAgMHgxOTogMixcbiAgMHgxYTogNCxcbiAgMHgxZDogNixcbiAgMHgxZTogOCxcbiAgMHgxZjogMTAsXG4gIDB4MWI6IDEzLFxuICAweDFjOiAxNVxufTtcbmNvbnN0IGJhY2tncm91bmRDb2xvcnMgPSBbJ3doaXRlJywgJ2dyZWVuJywgJ2JsdWUnLCAnY3lhbicsICdyZWQnLCAneWVsbG93JywgJ21hZ2VudGEnLCAnYmxhY2snLCAndHJhbnNwYXJlbnQnXTtcbmNsYXNzIENhcHRpb25zTG9nZ2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy50aW1lID0gbnVsbDtcbiAgICB0aGlzLnZlcmJvc2VMZXZlbCA9IDA7XG4gIH1cbiAgbG9nKHNldmVyaXR5LCBtc2cpIHtcbiAgICBpZiAodGhpcy52ZXJib3NlTGV2ZWwgPj0gc2V2ZXJpdHkpIHtcbiAgICAgIGNvbnN0IG0gPSB0eXBlb2YgbXNnID09PSAnZnVuY3Rpb24nID8gbXNnKCkgOiBtc2c7XG4gICAgICBsb2dnZXIubG9nKGAke3RoaXMudGltZX0gWyR7c2V2ZXJpdHl9XSAke219YCk7XG4gICAgfVxuICB9XG59XG5jb25zdCBudW1BcnJheVRvSGV4QXJyYXkgPSBmdW5jdGlvbiBudW1BcnJheVRvSGV4QXJyYXkobnVtQXJyYXkpIHtcbiAgY29uc3QgaGV4QXJyYXkgPSBbXTtcbiAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1BcnJheS5sZW5ndGg7IGorKykge1xuICAgIGhleEFycmF5LnB1c2gobnVtQXJyYXlbal0udG9TdHJpbmcoMTYpKTtcbiAgfVxuICByZXR1cm4gaGV4QXJyYXk7XG59O1xuY2xhc3MgUGVuU3RhdGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmZvcmVncm91bmQgPSAnd2hpdGUnO1xuICAgIHRoaXMudW5kZXJsaW5lID0gZmFsc2U7XG4gICAgdGhpcy5pdGFsaWNzID0gZmFsc2U7XG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gJ2JsYWNrJztcbiAgICB0aGlzLmZsYXNoID0gZmFsc2U7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gJ3doaXRlJztcbiAgICB0aGlzLnVuZGVybGluZSA9IGZhbHNlO1xuICAgIHRoaXMuaXRhbGljcyA9IGZhbHNlO1xuICAgIHRoaXMuYmFja2dyb3VuZCA9ICdibGFjayc7XG4gICAgdGhpcy5mbGFzaCA9IGZhbHNlO1xuICB9XG4gIHNldFN0eWxlcyhzdHlsZXMpIHtcbiAgICBjb25zdCBhdHRyaWJzID0gWydmb3JlZ3JvdW5kJywgJ3VuZGVybGluZScsICdpdGFsaWNzJywgJ2JhY2tncm91bmQnLCAnZmxhc2gnXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHJpYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHN0eWxlID0gYXR0cmlic1tpXTtcbiAgICAgIGlmIChzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGUpKSB7XG4gICAgICAgIHRoaXNbc3R5bGVdID0gc3R5bGVzW3N0eWxlXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaXNEZWZhdWx0KCkge1xuICAgIHJldHVybiB0aGlzLmZvcmVncm91bmQgPT09ICd3aGl0ZScgJiYgIXRoaXMudW5kZXJsaW5lICYmICF0aGlzLml0YWxpY3MgJiYgdGhpcy5iYWNrZ3JvdW5kID09PSAnYmxhY2snICYmICF0aGlzLmZsYXNoO1xuICB9XG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmZvcmVncm91bmQgPT09IG90aGVyLmZvcmVncm91bmQgJiYgdGhpcy51bmRlcmxpbmUgPT09IG90aGVyLnVuZGVybGluZSAmJiB0aGlzLml0YWxpY3MgPT09IG90aGVyLml0YWxpY3MgJiYgdGhpcy5iYWNrZ3JvdW5kID09PSBvdGhlci5iYWNrZ3JvdW5kICYmIHRoaXMuZmxhc2ggPT09IG90aGVyLmZsYXNoO1xuICB9XG4gIGNvcHkobmV3UGVuU3RhdGUpIHtcbiAgICB0aGlzLmZvcmVncm91bmQgPSBuZXdQZW5TdGF0ZS5mb3JlZ3JvdW5kO1xuICAgIHRoaXMudW5kZXJsaW5lID0gbmV3UGVuU3RhdGUudW5kZXJsaW5lO1xuICAgIHRoaXMuaXRhbGljcyA9IG5ld1BlblN0YXRlLml0YWxpY3M7XG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gbmV3UGVuU3RhdGUuYmFja2dyb3VuZDtcbiAgICB0aGlzLmZsYXNoID0gbmV3UGVuU3RhdGUuZmxhc2g7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdjb2xvcj0nICsgdGhpcy5mb3JlZ3JvdW5kICsgJywgdW5kZXJsaW5lPScgKyB0aGlzLnVuZGVybGluZSArICcsIGl0YWxpY3M9JyArIHRoaXMuaXRhbGljcyArICcsIGJhY2tncm91bmQ9JyArIHRoaXMuYmFja2dyb3VuZCArICcsIGZsYXNoPScgKyB0aGlzLmZsYXNoO1xuICB9XG59XG5cbi8qKlxuICogVW5pY29kZSBjaGFyYWN0ZXIgd2l0aCBzdHlsaW5nIGFuZCBiYWNrZ3JvdW5kLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIFN0eWxlZFVuaWNvZGVDaGFyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy51Y2hhciA9ICcgJztcbiAgICB0aGlzLnBlblN0YXRlID0gbmV3IFBlblN0YXRlKCk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy51Y2hhciA9ICcgJztcbiAgICB0aGlzLnBlblN0YXRlLnJlc2V0KCk7XG4gIH1cbiAgc2V0Q2hhcih1Y2hhciwgbmV3UGVuU3RhdGUpIHtcbiAgICB0aGlzLnVjaGFyID0gdWNoYXI7XG4gICAgdGhpcy5wZW5TdGF0ZS5jb3B5KG5ld1BlblN0YXRlKTtcbiAgfVxuICBzZXRQZW5TdGF0ZShuZXdQZW5TdGF0ZSkge1xuICAgIHRoaXMucGVuU3RhdGUuY29weShuZXdQZW5TdGF0ZSk7XG4gIH1cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMudWNoYXIgPT09IG90aGVyLnVjaGFyICYmIHRoaXMucGVuU3RhdGUuZXF1YWxzKG90aGVyLnBlblN0YXRlKTtcbiAgfVxuICBjb3B5KG5ld0NoYXIpIHtcbiAgICB0aGlzLnVjaGFyID0gbmV3Q2hhci51Y2hhcjtcbiAgICB0aGlzLnBlblN0YXRlLmNvcHkobmV3Q2hhci5wZW5TdGF0ZSk7XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy51Y2hhciA9PT0gJyAnICYmIHRoaXMucGVuU3RhdGUuaXNEZWZhdWx0KCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDRUEtNjA4IHJvdyBjb25zaXN0aW5nIG9mIE5SX0NPTFMgaW5zdGFuY2VzIG9mIFN0eWxlZFVuaWNvZGVDaGFyLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIFJvdyB7XG4gIGNvbnN0cnVjdG9yKGxvZ2dlcikge1xuICAgIHRoaXMuY2hhcnMgPSBbXTtcbiAgICB0aGlzLnBvcyA9IDA7XG4gICAgdGhpcy5jdXJyUGVuU3RhdGUgPSBuZXcgUGVuU3RhdGUoKTtcbiAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IG51bGw7XG4gICAgdGhpcy5sb2dnZXIgPSB2b2lkIDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgIHRoaXMuY2hhcnMucHVzaChuZXcgU3R5bGVkVW5pY29kZUNoYXIoKSk7XG4gICAgfVxuICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICB9XG4gIGVxdWFscyhvdGhlcikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfQ09MUzsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMuY2hhcnNbaV0uZXF1YWxzKG90aGVyLmNoYXJzW2ldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvcHkob3RoZXIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgdGhpcy5jaGFyc1tpXS5jb3B5KG90aGVyLmNoYXJzW2ldKTtcbiAgICB9XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICBsZXQgZW1wdHkgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfQ09MUzsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMuY2hhcnNbaV0uaXNFbXB0eSgpKSB7XG4gICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW1wdHk7XG4gIH1cblxuICAvKipcbiAgICogIFNldCB0aGUgY3Vyc29yIHRvIGEgdmFsaWQgY29sdW1uLlxuICAgKi9cbiAgc2V0Q3Vyc29yKGFic1Bvcykge1xuICAgIGlmICh0aGlzLnBvcyAhPT0gYWJzUG9zKSB7XG4gICAgICB0aGlzLnBvcyA9IGFic1BvcztcbiAgICB9XG4gICAgaWYgKHRoaXMucG9zIDwgMCkge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKDMsICdOZWdhdGl2ZSBjdXJzb3IgcG9zaXRpb24gJyArIHRoaXMucG9zKTtcbiAgICAgIHRoaXMucG9zID0gMDtcbiAgICB9IGVsc2UgaWYgKHRoaXMucG9zID4gTlJfQ09MUykge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKDMsICdUb28gbGFyZ2UgY3Vyc29yIHBvc2l0aW9uICcgKyB0aGlzLnBvcyk7XG4gICAgICB0aGlzLnBvcyA9IE5SX0NPTFM7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1vdmUgdGhlIGN1cnNvciByZWxhdGl2ZSB0byBjdXJyZW50IHBvc2l0aW9uLlxuICAgKi9cbiAgbW92ZUN1cnNvcihyZWxQb3MpIHtcbiAgICBjb25zdCBuZXdQb3MgPSB0aGlzLnBvcyArIHJlbFBvcztcbiAgICBpZiAocmVsUG9zID4gMSkge1xuICAgICAgZm9yIChsZXQgaSA9IHRoaXMucG9zICsgMTsgaSA8IG5ld1BvcyArIDE7IGkrKykge1xuICAgICAgICB0aGlzLmNoYXJzW2ldLnNldFBlblN0YXRlKHRoaXMuY3VyclBlblN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zZXRDdXJzb3IobmV3UG9zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCYWNrc3BhY2UsIG1vdmUgb25lIHN0ZXAgYmFjayBhbmQgY2xlYXIgY2hhcmFjdGVyLlxuICAgKi9cbiAgYmFja1NwYWNlKCkge1xuICAgIHRoaXMubW92ZUN1cnNvcigtMSk7XG4gICAgdGhpcy5jaGFyc1t0aGlzLnBvc10uc2V0Q2hhcignICcsIHRoaXMuY3VyclBlblN0YXRlKTtcbiAgfVxuICBpbnNlcnRDaGFyKGJ5dGUpIHtcbiAgICBpZiAoYnl0ZSA+PSAweDkwKSB7XG4gICAgICAvLyBFeHRlbmRlZCBjaGFyXG4gICAgICB0aGlzLmJhY2tTcGFjZSgpO1xuICAgIH1cbiAgICBjb25zdCBjaGFyID0gZ2V0Q2hhckZvckJ5dGUoYnl0ZSk7XG4gICAgaWYgKHRoaXMucG9zID49IE5SX0NPTFMpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygwLCAoKSA9PiAnQ2Fubm90IGluc2VydCAnICsgYnl0ZS50b1N0cmluZygxNikgKyAnICgnICsgY2hhciArICcpIGF0IHBvc2l0aW9uICcgKyB0aGlzLnBvcyArICcuIFNraXBwaW5nIGl0IScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNoYXJzW3RoaXMucG9zXS5zZXRDaGFyKGNoYXIsIHRoaXMuY3VyclBlblN0YXRlKTtcbiAgICB0aGlzLm1vdmVDdXJzb3IoMSk7XG4gIH1cbiAgY2xlYXJGcm9tUG9zKHN0YXJ0UG9zKSB7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gc3RhcnRQb3M7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgIHRoaXMuY2hhcnNbaV0ucmVzZXQoKTtcbiAgICB9XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5jbGVhckZyb21Qb3MoMCk7XG4gICAgdGhpcy5wb3MgPSAwO1xuICAgIHRoaXMuY3VyclBlblN0YXRlLnJlc2V0KCk7XG4gIH1cbiAgY2xlYXJUb0VuZE9mUm93KCkge1xuICAgIHRoaXMuY2xlYXJGcm9tUG9zKHRoaXMucG9zKTtcbiAgfVxuICBnZXRUZXh0U3RyaW5nKCkge1xuICAgIGNvbnN0IGNoYXJzID0gW107XG4gICAgbGV0IGVtcHR5ID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgY29uc3QgY2hhciA9IHRoaXMuY2hhcnNbaV0udWNoYXI7XG4gICAgICBpZiAoY2hhciAhPT0gJyAnKSB7XG4gICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBjaGFycy5wdXNoKGNoYXIpO1xuICAgIH1cbiAgICBpZiAoZW1wdHkpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpO1xuICAgIH1cbiAgfVxuICBzZXRQZW5TdHlsZXMoc3R5bGVzKSB7XG4gICAgdGhpcy5jdXJyUGVuU3RhdGUuc2V0U3R5bGVzKHN0eWxlcyk7XG4gICAgY29uc3QgY3VyckNoYXIgPSB0aGlzLmNoYXJzW3RoaXMucG9zXTtcbiAgICBjdXJyQ2hhci5zZXRQZW5TdGF0ZSh0aGlzLmN1cnJQZW5TdGF0ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBLZWVwIGEgQ0VBLTYwOCBzY3JlZW4gb2YgMzJ4MTUgc3R5bGVkIGNoYXJhY3RlcnNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBDYXB0aW9uU2NyZWVuIHtcbiAgY29uc3RydWN0b3IobG9nZ2VyKSB7XG4gICAgdGhpcy5yb3dzID0gW107XG4gICAgdGhpcy5jdXJyUm93ID0gTlJfUk9XUyAtIDE7XG4gICAgdGhpcy5uclJvbGxVcFJvd3MgPSBudWxsO1xuICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbiA9IG51bGw7XG4gICAgdGhpcy5sb2dnZXIgPSB2b2lkIDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgIHRoaXMucm93cy5wdXNoKG5ldyBSb3cobG9nZ2VyKSk7XG4gICAgfVxuICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICB0aGlzLnJvd3NbaV0uY2xlYXIoKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyUm93ID0gTlJfUk9XUyAtIDE7XG4gIH1cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgbGV0IGVxdWFsID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgaWYgKCF0aGlzLnJvd3NbaV0uZXF1YWxzKG90aGVyLnJvd3NbaV0pKSB7XG4gICAgICAgIGVxdWFsID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXF1YWw7XG4gIH1cbiAgY29weShvdGhlcikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICB0aGlzLnJvd3NbaV0uY29weShvdGhlci5yb3dzW2ldKTtcbiAgICB9XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICBsZXQgZW1wdHkgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMucm93c1tpXS5pc0VtcHR5KCkpIHtcbiAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbXB0eTtcbiAgfVxuICBiYWNrU3BhY2UoKSB7XG4gICAgY29uc3Qgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgcm93LmJhY2tTcGFjZSgpO1xuICB9XG4gIGNsZWFyVG9FbmRPZlJvdygpIHtcbiAgICBjb25zdCByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICByb3cuY2xlYXJUb0VuZE9mUm93KCk7XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0IGEgY2hhcmFjdGVyICh3aXRob3V0IHN0eWxpbmcpIGluIHRoZSBjdXJyZW50IHJvdy5cbiAgICovXG4gIGluc2VydENoYXIoY2hhcikge1xuICAgIGNvbnN0IHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgIHJvdy5pbnNlcnRDaGFyKGNoYXIpO1xuICB9XG4gIHNldFBlbihzdHlsZXMpIHtcbiAgICBjb25zdCByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICByb3cuc2V0UGVuU3R5bGVzKHN0eWxlcyk7XG4gIH1cbiAgbW92ZUN1cnNvcihyZWxQb3MpIHtcbiAgICBjb25zdCByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICByb3cubW92ZUN1cnNvcihyZWxQb3MpO1xuICB9XG4gIHNldEN1cnNvcihhYnNQb3MpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ3NldEN1cnNvcjogJyArIGFic1Bvcyk7XG4gICAgY29uc3Qgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgcm93LnNldEN1cnNvcihhYnNQb3MpO1xuICB9XG4gIHNldFBBQyhwYWNEYXRhKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nKDIsICgpID0+ICdwYWNEYXRhID0gJyArIEpTT04uc3RyaW5naWZ5KHBhY0RhdGEpKTtcbiAgICBsZXQgbmV3Um93ID0gcGFjRGF0YS5yb3cgLSAxO1xuICAgIGlmICh0aGlzLm5yUm9sbFVwUm93cyAmJiBuZXdSb3cgPCB0aGlzLm5yUm9sbFVwUm93cyAtIDEpIHtcbiAgICAgIG5ld1JvdyA9IHRoaXMubnJSb2xsVXBSb3dzIC0gMTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhpcyBvbmx5IGFmZmVjdHMgUm9sbC11cCBDYXB0aW9ucyBieSBjaGVja2luZyB0aGlzLm5yUm9sbFVwUm93c1xuICAgIGlmICh0aGlzLm5yUm9sbFVwUm93cyAmJiB0aGlzLmN1cnJSb3cgIT09IG5ld1Jvdykge1xuICAgICAgLy8gY2xlYXIgYWxsIHJvd3MgZmlyc3RcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICAgIHRoaXMucm93c1tpXS5jbGVhcigpO1xuICAgICAgfVxuXG4gICAgICAvLyBDb3B5IHRoaXMubnJSb2xsVXBSb3dzIHJvd3MgZnJvbSBsYXN0T3V0cHV0U2NyZWVuIGFuZCBwbGFjZSBpdCBpbiB0aGUgbmV3Um93IGxvY2F0aW9uXG4gICAgICAvLyB0b3BSb3dJbmRleCAtIHRoZSBzdGFydCBvZiByb3dzIHRvIGNvcHkgKGluY2x1c2l2ZSBpbmRleClcbiAgICAgIGNvbnN0IHRvcFJvd0luZGV4ID0gdGhpcy5jdXJyUm93ICsgMSAtIHRoaXMubnJSb2xsVXBSb3dzO1xuICAgICAgLy8gV2Ugb25seSBjb3B5IGlmIHRoZSBsYXN0IHBvc2l0aW9uIHdhcyBhbHJlYWR5IHNob3duLlxuICAgICAgLy8gV2UgdXNlIHRoZSBjdWVTdGFydFRpbWUgdmFsdWUgdG8gY2hlY2sgdGhpcy5cbiAgICAgIGNvbnN0IGxhc3RPdXRwdXRTY3JlZW4gPSB0aGlzLmxhc3RPdXRwdXRTY3JlZW47XG4gICAgICBpZiAobGFzdE91dHB1dFNjcmVlbikge1xuICAgICAgICBjb25zdCBwcmV2TGluZVRpbWUgPSBsYXN0T3V0cHV0U2NyZWVuLnJvd3NbdG9wUm93SW5kZXhdLmN1ZVN0YXJ0VGltZTtcbiAgICAgICAgY29uc3QgdGltZSA9IHRoaXMubG9nZ2VyLnRpbWU7XG4gICAgICAgIGlmIChwcmV2TGluZVRpbWUgIT09IG51bGwgJiYgdGltZSAhPT0gbnVsbCAmJiBwcmV2TGluZVRpbWUgPCB0aW1lKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm5yUm9sbFVwUm93czsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnJvd3NbbmV3Um93IC0gdGhpcy5uclJvbGxVcFJvd3MgKyBpICsgMV0uY29weShsYXN0T3V0cHV0U2NyZWVuLnJvd3NbdG9wUm93SW5kZXggKyBpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY3VyclJvdyA9IG5ld1JvdztcbiAgICBjb25zdCByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICBpZiAocGFjRGF0YS5pbmRlbnQgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGluZGVudCA9IHBhY0RhdGEuaW5kZW50O1xuICAgICAgY29uc3QgcHJldlBvcyA9IE1hdGgubWF4KGluZGVudCAtIDEsIDApO1xuICAgICAgcm93LnNldEN1cnNvcihwYWNEYXRhLmluZGVudCk7XG4gICAgICBwYWNEYXRhLmNvbG9yID0gcm93LmNoYXJzW3ByZXZQb3NdLnBlblN0YXRlLmZvcmVncm91bmQ7XG4gICAgfVxuICAgIGNvbnN0IHN0eWxlcyA9IHtcbiAgICAgIGZvcmVncm91bmQ6IHBhY0RhdGEuY29sb3IsXG4gICAgICB1bmRlcmxpbmU6IHBhY0RhdGEudW5kZXJsaW5lLFxuICAgICAgaXRhbGljczogcGFjRGF0YS5pdGFsaWNzLFxuICAgICAgYmFja2dyb3VuZDogJ2JsYWNrJyxcbiAgICAgIGZsYXNoOiBmYWxzZVxuICAgIH07XG4gICAgdGhpcy5zZXRQZW4oc3R5bGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYmFja2dyb3VuZC9leHRyYSBmb3JlZ3JvdW5kLCBidXQgZmlyc3QgZG8gYmFja19zcGFjZSwgYW5kIHRoZW4gaW5zZXJ0IHNwYWNlIChiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSkuXG4gICAqL1xuICBzZXRCa2dEYXRhKGJrZ0RhdGEpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgKCkgPT4gJ2JrZ0RhdGEgPSAnICsgSlNPTi5zdHJpbmdpZnkoYmtnRGF0YSkpO1xuICAgIHRoaXMuYmFja1NwYWNlKCk7XG4gICAgdGhpcy5zZXRQZW4oYmtnRGF0YSk7XG4gICAgdGhpcy5pbnNlcnRDaGFyKDB4MjApOyAvLyBTcGFjZVxuICB9XG4gIHNldFJvbGxVcFJvd3MobnJSb3dzKSB7XG4gICAgdGhpcy5uclJvbGxVcFJvd3MgPSBuclJvd3M7XG4gIH1cbiAgcm9sbFVwKCkge1xuICAgIGlmICh0aGlzLm5yUm9sbFVwUm93cyA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKDMsICdyb2xsX3VwIGJ1dCBuclJvbGxVcFJvd3Mgbm90IHNldCB5ZXQnKTtcbiAgICAgIHJldHVybjsgLy8gTm90IHByb3Blcmx5IHNldHVwXG4gICAgfVxuICAgIHRoaXMubG9nZ2VyLmxvZygxLCAoKSA9PiB0aGlzLmdldERpc3BsYXlUZXh0KCkpO1xuICAgIGNvbnN0IHRvcFJvd0luZGV4ID0gdGhpcy5jdXJyUm93ICsgMSAtIHRoaXMubnJSb2xsVXBSb3dzO1xuICAgIGNvbnN0IHRvcFJvdyA9IHRoaXMucm93cy5zcGxpY2UodG9wUm93SW5kZXgsIDEpWzBdO1xuICAgIHRvcFJvdy5jbGVhcigpO1xuICAgIHRoaXMucm93cy5zcGxpY2UodGhpcy5jdXJyUm93LCAwLCB0b3BSb3cpO1xuICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnUm9sbGluZyB1cCcpO1xuICAgIC8vIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuVEVYVCwgdGhpcy5nZXRfZGlzcGxheV90ZXh0KCkpXG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBub24tZW1wdHkgcm93cyB3aXRoIGFzIHVuaWNvZGUgdGV4dC5cbiAgICovXG4gIGdldERpc3BsYXlUZXh0KGFzT25lUm93KSB7XG4gICAgYXNPbmVSb3cgPSBhc09uZVJvdyB8fCBmYWxzZTtcbiAgICBjb25zdCBkaXNwbGF5VGV4dCA9IFtdO1xuICAgIGxldCB0ZXh0ID0gJyc7XG4gICAgbGV0IHJvd05yID0gLTE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgIGNvbnN0IHJvd1RleHQgPSB0aGlzLnJvd3NbaV0uZ2V0VGV4dFN0cmluZygpO1xuICAgICAgaWYgKHJvd1RleHQpIHtcbiAgICAgICAgcm93TnIgPSBpICsgMTtcbiAgICAgICAgaWYgKGFzT25lUm93KSB7XG4gICAgICAgICAgZGlzcGxheVRleHQucHVzaCgnUm93ICcgKyByb3dOciArIFwiOiAnXCIgKyByb3dUZXh0ICsgXCInXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpc3BsYXlUZXh0LnB1c2gocm93VGV4dC50cmltKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkaXNwbGF5VGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAoYXNPbmVSb3cpIHtcbiAgICAgICAgdGV4dCA9ICdbJyArIGRpc3BsYXlUZXh0LmpvaW4oJyB8ICcpICsgJ10nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dCA9IGRpc3BsYXlUZXh0LmpvaW4oJ1xcbicpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuICBnZXRUZXh0QW5kRm9ybWF0KCkge1xuICAgIHJldHVybiB0aGlzLnJvd3M7XG4gIH1cbn1cblxuLy8gdmFyIG1vZGVzID0gWydNT0RFX1JPTEwtVVAnLCAnTU9ERV9QT1AtT04nLCAnTU9ERV9QQUlOVC1PTicsICdNT0RFX1RFWFQnXTtcblxuY2xhc3MgQ2VhNjA4Q2hhbm5lbCB7XG4gIGNvbnN0cnVjdG9yKGNoYW5uZWxOdW1iZXIsIG91dHB1dEZpbHRlciwgbG9nZ2VyKSB7XG4gICAgdGhpcy5jaE5yID0gdm9pZCAwO1xuICAgIHRoaXMub3V0cHV0RmlsdGVyID0gdm9pZCAwO1xuICAgIHRoaXMubW9kZSA9IHZvaWQgMDtcbiAgICB0aGlzLnZlcmJvc2UgPSB2b2lkIDA7XG4gICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkgPSB2b2lkIDA7XG4gICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkgPSB2b2lkIDA7XG4gICAgdGhpcy5sYXN0T3V0cHV0U2NyZWVuID0gdm9pZCAwO1xuICAgIHRoaXMuY3VyclJvbGxVcFJvdyA9IHZvaWQgMDtcbiAgICB0aGlzLndyaXRlU2NyZWVuID0gdm9pZCAwO1xuICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gdm9pZCAwO1xuICAgIHRoaXMubG9nZ2VyID0gdm9pZCAwO1xuICAgIHRoaXMuY2hOciA9IGNoYW5uZWxOdW1iZXI7XG4gICAgdGhpcy5vdXRwdXRGaWx0ZXIgPSBvdXRwdXRGaWx0ZXI7XG4gICAgdGhpcy5tb2RlID0gbnVsbDtcbiAgICB0aGlzLnZlcmJvc2UgPSAwO1xuICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5ID0gbmV3IENhcHRpb25TY3JlZW4obG9nZ2VyKTtcbiAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeSA9IG5ldyBDYXB0aW9uU2NyZWVuKGxvZ2dlcik7XG4gICAgdGhpcy5sYXN0T3V0cHV0U2NyZWVuID0gbmV3IENhcHRpb25TY3JlZW4obG9nZ2VyKTtcbiAgICB0aGlzLmN1cnJSb2xsVXBSb3cgPSB0aGlzLmRpc3BsYXllZE1lbW9yeS5yb3dzW05SX1JPV1MgLSAxXTtcbiAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XG4gICAgdGhpcy5tb2RlID0gbnVsbDtcbiAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IG51bGw7IC8vIEtlZXBzIHRyYWNrIG9mIHdoZXJlIGEgY3VlIHN0YXJ0ZWQuXG4gICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5tb2RlID0gbnVsbDtcbiAgICB0aGlzLmRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5LnJlc2V0KCk7XG4gICAgdGhpcy5sYXN0T3V0cHV0U2NyZWVuLnJlc2V0KCk7XG4gICAgdGhpcy5vdXRwdXRGaWx0ZXIucmVzZXQoKTtcbiAgICB0aGlzLmN1cnJSb2xsVXBSb3cgPSB0aGlzLmRpc3BsYXllZE1lbW9yeS5yb3dzW05SX1JPV1MgLSAxXTtcbiAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XG4gICAgdGhpcy5tb2RlID0gbnVsbDtcbiAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IG51bGw7XG4gIH1cbiAgZ2V0SGFuZGxlcigpIHtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXRGaWx0ZXI7XG4gIH1cbiAgc2V0SGFuZGxlcihuZXdIYW5kbGVyKSB7XG4gICAgdGhpcy5vdXRwdXRGaWx0ZXIgPSBuZXdIYW5kbGVyO1xuICB9XG4gIHNldFBBQyhwYWNEYXRhKSB7XG4gICAgdGhpcy53cml0ZVNjcmVlbi5zZXRQQUMocGFjRGF0YSk7XG4gIH1cbiAgc2V0QmtnRGF0YShia2dEYXRhKSB7XG4gICAgdGhpcy53cml0ZVNjcmVlbi5zZXRCa2dEYXRhKGJrZ0RhdGEpO1xuICB9XG4gIHNldE1vZGUobmV3TW9kZSkge1xuICAgIGlmIChuZXdNb2RlID09PSB0aGlzLm1vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5tb2RlID0gbmV3TW9kZTtcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgKCkgPT4gJ01PREU9JyArIG5ld01vZGUpO1xuICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1BPUC1PTicpIHtcbiAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgICAgdGhpcy53cml0ZVNjcmVlbi5yZXNldCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tb2RlICE9PSAnTU9ERV9ST0xMLVVQJykge1xuICAgICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkubnJSb2xsVXBSb3dzID0gbnVsbDtcbiAgICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5Lm5yUm9sbFVwUm93cyA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMubW9kZSA9IG5ld01vZGU7XG4gIH1cbiAgaW5zZXJ0Q2hhcnMoY2hhcnMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndyaXRlU2NyZWVuLmluc2VydENoYXIoY2hhcnNbaV0pO1xuICAgIH1cbiAgICBjb25zdCBzY3JlZW4gPSB0aGlzLndyaXRlU2NyZWVuID09PSB0aGlzLmRpc3BsYXllZE1lbW9yeSA/ICdESVNQJyA6ICdOT05fRElTUCc7XG4gICAgdGhpcy5sb2dnZXIubG9nKDIsICgpID0+IHNjcmVlbiArICc6ICcgKyB0aGlzLndyaXRlU2NyZWVuLmdldERpc3BsYXlUZXh0KHRydWUpKTtcbiAgICBpZiAodGhpcy5tb2RlID09PSAnTU9ERV9QQUlOVC1PTicgfHwgdGhpcy5tb2RlID09PSAnTU9ERV9ST0xMLVVQJykge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKDEsICgpID0+ICdESVNQTEFZRUQ6ICcgKyB0aGlzLmRpc3BsYXllZE1lbW9yeS5nZXREaXNwbGF5VGV4dCh0cnVlKSk7XG4gICAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUoKTtcbiAgICB9XG4gIH1cbiAgY2NSQ0woKSB7XG4gICAgLy8gUmVzdW1lIENhcHRpb24gTG9hZGluZyAoc3dpdGNoIG1vZGUgdG8gUG9wIE9uKVxuICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnUkNMIC0gUmVzdW1lIENhcHRpb24gTG9hZGluZycpO1xuICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9QT1AtT04nKTtcbiAgfVxuICBjY0JTKCkge1xuICAgIC8vIEJhY2tTcGFjZVxuICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnQlMgLSBCYWNrU3BhY2UnKTtcbiAgICBpZiAodGhpcy5tb2RlID09PSAnTU9ERV9URVhUJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLndyaXRlU2NyZWVuLmJhY2tTcGFjZSgpO1xuICAgIGlmICh0aGlzLndyaXRlU2NyZWVuID09PSB0aGlzLmRpc3BsYXllZE1lbW9yeSkge1xuICAgICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gICAgfVxuICB9XG4gIGNjQU9GKCkge1xuICAgIC8vIFJlc2VydmVkIChmb3JtZXJseSBBbGFybSBPZmYpXG4gIH1cbiAgY2NBT04oKSB7XG4gICAgLy8gUmVzZXJ2ZWQgKGZvcm1lcmx5IEFsYXJtIE9uKVxuICB9XG4gIGNjREVSKCkge1xuICAgIC8vIERlbGV0ZSB0byBFbmQgb2YgUm93XG4gICAgdGhpcy5sb2dnZXIubG9nKDIsICdERVItIERlbGV0ZSB0byBFbmQgb2YgUm93Jyk7XG4gICAgdGhpcy53cml0ZVNjcmVlbi5jbGVhclRvRW5kT2ZSb3coKTtcbiAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUoKTtcbiAgfVxuICBjY1JVKG5yUm93cykge1xuICAgIC8vIFJvbGwtVXAgQ2FwdGlvbnMtMiwzLG9yIDQgUm93c1xuICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnUlUoJyArIG5yUm93cyArICcpIC0gUm9sbCBVcCcpO1xuICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICB0aGlzLnNldE1vZGUoJ01PREVfUk9MTC1VUCcpO1xuICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0Um9sbFVwUm93cyhuclJvd3MpO1xuICB9XG4gIGNjRk9OKCkge1xuICAgIC8vIEZsYXNoIE9uXG4gICAgdGhpcy5sb2dnZXIubG9nKDIsICdGT04gLSBGbGFzaCBPbicpO1xuICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0UGVuKHtcbiAgICAgIGZsYXNoOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgY2NSREMoKSB7XG4gICAgLy8gUmVzdW1lIERpcmVjdCBDYXB0aW9uaW5nIChzd2l0Y2ggbW9kZSB0byBQYWludE9uKVxuICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnUkRDIC0gUmVzdW1lIERpcmVjdCBDYXB0aW9uaW5nJyk7XG4gICAgdGhpcy5zZXRNb2RlKCdNT0RFX1BBSU5ULU9OJyk7XG4gIH1cbiAgY2NUUigpIHtcbiAgICAvLyBUZXh0IFJlc3RhcnQgaW4gdGV4dCBtb2RlIChub3Qgc3VwcG9ydGVkLCBob3dldmVyKVxuICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnVFInKTtcbiAgICB0aGlzLnNldE1vZGUoJ01PREVfVEVYVCcpO1xuICB9XG4gIGNjUlREKCkge1xuICAgIC8vIFJlc3VtZSBUZXh0IERpc3BsYXkgaW4gVGV4dCBtb2RlIChub3Qgc3VwcG9ydGVkLCBob3dldmVyKVxuICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnUlREJyk7XG4gICAgdGhpcy5zZXRNb2RlKCdNT0RFX1RFWFQnKTtcbiAgfVxuICBjY0VETSgpIHtcbiAgICAvLyBFcmFzZSBEaXNwbGF5ZWQgTWVtb3J5XG4gICAgdGhpcy5sb2dnZXIubG9nKDIsICdFRE0gLSBFcmFzZSBEaXNwbGF5ZWQgTWVtb3J5Jyk7XG4gICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkucmVzZXQoKTtcbiAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUodHJ1ZSk7XG4gIH1cbiAgY2NDUigpIHtcbiAgICAvLyBDYXJyaWFnZSBSZXR1cm5cbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ0NSIC0gQ2FycmlhZ2UgUmV0dXJuJyk7XG4gICAgdGhpcy53cml0ZVNjcmVlbi5yb2xsVXAoKTtcbiAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUodHJ1ZSk7XG4gIH1cbiAgY2NFTk0oKSB7XG4gICAgLy8gRXJhc2UgTm9uLURpc3BsYXllZCBNZW1vcnlcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ0VOTSAtIEVyYXNlIE5vbi1kaXNwbGF5ZWQgTWVtb3J5Jyk7XG4gICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkucmVzZXQoKTtcbiAgfVxuICBjY0VPQygpIHtcbiAgICAvLyBFbmQgb2YgQ2FwdGlvbiAoRmxpcCBNZW1vcmllcylcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ0VPQyAtIEVuZCBPZiBDYXB0aW9uJyk7XG4gICAgaWYgKHRoaXMubW9kZSA9PT0gJ01PREVfUE9QLU9OJykge1xuICAgICAgY29uc3QgdG1wID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XG4gICAgICB0aGlzLmRpc3BsYXllZE1lbW9yeSA9IHRoaXMubm9uRGlzcGxheWVkTWVtb3J5O1xuICAgICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkgPSB0bXA7XG4gICAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnk7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coMSwgKCkgPT4gJ0RJU1A6ICcgKyB0aGlzLmRpc3BsYXllZE1lbW9yeS5nZXREaXNwbGF5VGV4dCgpKTtcbiAgICB9XG4gICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKHRydWUpO1xuICB9XG4gIGNjVE8obnJDb2xzKSB7XG4gICAgLy8gVGFiIE9mZnNldCAxLDIsIG9yIDMgY29sdW1uc1xuICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnVE8oJyArIG5yQ29scyArICcpIC0gVGFiIE9mZnNldCcpO1xuICAgIHRoaXMud3JpdGVTY3JlZW4ubW92ZUN1cnNvcihuckNvbHMpO1xuICB9XG4gIGNjTUlEUk9XKHNlY29uZEJ5dGUpIHtcbiAgICAvLyBQYXJzZSBNSURST1cgY29tbWFuZFxuICAgIGNvbnN0IHN0eWxlcyA9IHtcbiAgICAgIGZsYXNoOiBmYWxzZVxuICAgIH07XG4gICAgc3R5bGVzLnVuZGVybGluZSA9IHNlY29uZEJ5dGUgJSAyID09PSAxO1xuICAgIHN0eWxlcy5pdGFsaWNzID0gc2Vjb25kQnl0ZSA+PSAweDJlO1xuICAgIGlmICghc3R5bGVzLml0YWxpY3MpIHtcbiAgICAgIGNvbnN0IGNvbG9ySW5kZXggPSBNYXRoLmZsb29yKHNlY29uZEJ5dGUgLyAyKSAtIDB4MTA7XG4gICAgICBjb25zdCBjb2xvcnMgPSBbJ3doaXRlJywgJ2dyZWVuJywgJ2JsdWUnLCAnY3lhbicsICdyZWQnLCAneWVsbG93JywgJ21hZ2VudGEnXTtcbiAgICAgIHN0eWxlcy5mb3JlZ3JvdW5kID0gY29sb3JzW2NvbG9ySW5kZXhdO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZXMuZm9yZWdyb3VuZCA9ICd3aGl0ZSc7XG4gICAgfVxuICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnTUlEUk9XOiAnICsgSlNPTi5zdHJpbmdpZnkoc3R5bGVzKSk7XG4gICAgdGhpcy53cml0ZVNjcmVlbi5zZXRQZW4oc3R5bGVzKTtcbiAgfVxuICBvdXRwdXREYXRhVXBkYXRlKGRpc3BhdGNoID0gZmFsc2UpIHtcbiAgICBjb25zdCB0aW1lID0gdGhpcy5sb2dnZXIudGltZTtcbiAgICBpZiAodGltZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5vdXRwdXRGaWx0ZXIpIHtcbiAgICAgIGlmICh0aGlzLmN1ZVN0YXJ0VGltZSA9PT0gbnVsbCAmJiAhdGhpcy5kaXNwbGF5ZWRNZW1vcnkuaXNFbXB0eSgpKSB7XG4gICAgICAgIC8vIFN0YXJ0IG9mIGEgbmV3IGN1ZVxuICAgICAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IHRpbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRoaXMuZGlzcGxheWVkTWVtb3J5LmVxdWFscyh0aGlzLmxhc3RPdXRwdXRTY3JlZW4pKSB7XG4gICAgICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIubmV3Q3VlKHRoaXMuY3VlU3RhcnRUaW1lLCB0aW1lLCB0aGlzLmxhc3RPdXRwdXRTY3JlZW4pO1xuICAgICAgICAgIGlmIChkaXNwYXRjaCAmJiB0aGlzLm91dHB1dEZpbHRlci5kaXNwYXRjaEN1ZSkge1xuICAgICAgICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIuZGlzcGF0Y2hDdWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSB0aGlzLmRpc3BsYXllZE1lbW9yeS5pc0VtcHR5KCkgPyBudWxsIDogdGltZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5sYXN0T3V0cHV0U2NyZWVuLmNvcHkodGhpcy5kaXNwbGF5ZWRNZW1vcnkpO1xuICAgIH1cbiAgfVxuICBjdWVTcGxpdEF0VGltZSh0KSB7XG4gICAgaWYgKHRoaXMub3V0cHV0RmlsdGVyKSB7XG4gICAgICBpZiAoIXRoaXMuZGlzcGxheWVkTWVtb3J5LmlzRW1wdHkoKSkge1xuICAgICAgICBpZiAodGhpcy5vdXRwdXRGaWx0ZXIubmV3Q3VlKSB7XG4gICAgICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIubmV3Q3VlKHRoaXMuY3VlU3RhcnRUaW1lLCB0LCB0aGlzLmRpc3BsYXllZE1lbW9yeSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSB0O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBXaWxsIGJlIDEgb3IgMiB3aGVuIHBhcnNpbmcgY2FwdGlvbnNcblxuY2xhc3MgQ2VhNjA4UGFyc2VyIHtcbiAgY29uc3RydWN0b3IoZmllbGQsIG91dDEsIG91dDIpIHtcbiAgICB0aGlzLmNoYW5uZWxzID0gdm9pZCAwO1xuICAgIHRoaXMuY3VycmVudENoYW5uZWwgPSAwO1xuICAgIHRoaXMuY21kSGlzdG9yeSA9IGNyZWF0ZUNtZEhpc3RvcnkoKTtcbiAgICB0aGlzLmxvZ2dlciA9IHZvaWQgMDtcbiAgICBjb25zdCBsb2dnZXIgPSB0aGlzLmxvZ2dlciA9IG5ldyBDYXB0aW9uc0xvZ2dlcigpO1xuICAgIHRoaXMuY2hhbm5lbHMgPSBbbnVsbCwgbmV3IENlYTYwOENoYW5uZWwoZmllbGQsIG91dDEsIGxvZ2dlciksIG5ldyBDZWE2MDhDaGFubmVsKGZpZWxkICsgMSwgb3V0MiwgbG9nZ2VyKV07XG4gIH1cbiAgZ2V0SGFuZGxlcihjaGFubmVsKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNbY2hhbm5lbF0uZ2V0SGFuZGxlcigpO1xuICB9XG4gIHNldEhhbmRsZXIoY2hhbm5lbCwgbmV3SGFuZGxlcikge1xuICAgIHRoaXMuY2hhbm5lbHNbY2hhbm5lbF0uc2V0SGFuZGxlcihuZXdIYW5kbGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgZGF0YSBmb3IgdGltZSB0IGluIGZvcm1zIG9mIGxpc3Qgb2YgYnl0ZXMgKHVuc2lnbmVkIGludHMpLiBUaGUgYnl0ZXMgYXJlIHRyZWF0ZWQgYXMgcGFpcnMuXG4gICAqL1xuICBhZGREYXRhKHRpbWUsIGJ5dGVMaXN0KSB7XG4gICAgbGV0IGNtZEZvdW5kO1xuICAgIGxldCBhO1xuICAgIGxldCBiO1xuICAgIGxldCBjaGFyc0ZvdW5kID0gZmFsc2U7XG4gICAgdGhpcy5sb2dnZXIudGltZSA9IHRpbWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlTGlzdC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgYSA9IGJ5dGVMaXN0W2ldICYgMHg3ZjtcbiAgICAgIGIgPSBieXRlTGlzdFtpICsgMV0gJiAweDdmO1xuICAgICAgaWYgKGEgPT09IDAgJiYgYiA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZygzLCAnWycgKyBudW1BcnJheVRvSGV4QXJyYXkoW2J5dGVMaXN0W2ldLCBieXRlTGlzdFtpICsgMV1dKSArICddIC0+ICgnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnKScpO1xuICAgICAgfVxuICAgICAgY21kRm91bmQgPSB0aGlzLnBhcnNlQ21kKGEsIGIpO1xuICAgICAgaWYgKCFjbWRGb3VuZCkge1xuICAgICAgICBjbWRGb3VuZCA9IHRoaXMucGFyc2VNaWRyb3coYSwgYik7XG4gICAgICB9XG4gICAgICBpZiAoIWNtZEZvdW5kKSB7XG4gICAgICAgIGNtZEZvdW5kID0gdGhpcy5wYXJzZVBBQyhhLCBiKTtcbiAgICAgIH1cbiAgICAgIGlmICghY21kRm91bmQpIHtcbiAgICAgICAgY21kRm91bmQgPSB0aGlzLnBhcnNlQmFja2dyb3VuZEF0dHJpYnV0ZXMoYSwgYik7XG4gICAgICB9XG4gICAgICBpZiAoIWNtZEZvdW5kKSB7XG4gICAgICAgIGNoYXJzRm91bmQgPSB0aGlzLnBhcnNlQ2hhcnMoYSwgYik7XG4gICAgICAgIGlmIChjaGFyc0ZvdW5kKSB7XG4gICAgICAgICAgY29uc3QgY3VyckNoTnIgPSB0aGlzLmN1cnJlbnRDaGFubmVsO1xuICAgICAgICAgIGlmIChjdXJyQ2hOciAmJiBjdXJyQ2hOciA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2N1cnJDaE5yXTtcbiAgICAgICAgICAgIGNoYW5uZWwuaW5zZXJ0Q2hhcnMoY2hhcnNGb3VuZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnTm8gY2hhbm5lbCBmb3VuZCB5ZXQuIFRFWFQtTU9ERT8nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghY21kRm91bmQgJiYgIWNoYXJzRm91bmQpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKDIsIFwiQ291bGRuJ3QgcGFyc2UgY2xlYW5lZCBkYXRhIFwiICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnIG9yaWc6ICcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2J5dGVMaXN0W2ldLCBieXRlTGlzdFtpICsgMV1dKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIENvbW1hbmQuXG4gICAqIEByZXR1cm5zIFRydWUgaWYgYSBjb21tYW5kIHdhcyBmb3VuZFxuICAgKi9cbiAgcGFyc2VDbWQoYSwgYikge1xuICAgIGNvbnN0IHtcbiAgICAgIGNtZEhpc3RvcnlcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBjb25kMSA9IChhID09PSAweDE0IHx8IGEgPT09IDB4MWMgfHwgYSA9PT0gMHgxNSB8fCBhID09PSAweDFkKSAmJiBiID49IDB4MjAgJiYgYiA8PSAweDJmO1xuICAgIGNvbnN0IGNvbmQyID0gKGEgPT09IDB4MTcgfHwgYSA9PT0gMHgxZikgJiYgYiA+PSAweDIxICYmIGIgPD0gMHgyMztcbiAgICBpZiAoIShjb25kMSB8fCBjb25kMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGhhc0NtZFJlcGVhdGVkKGEsIGIsIGNtZEhpc3RvcnkpKSB7XG4gICAgICBzZXRMYXN0Q21kKG51bGwsIG51bGwsIGNtZEhpc3RvcnkpO1xuICAgICAgdGhpcy5sb2dnZXIubG9nKDMsICdSZXBlYXRlZCBjb21tYW5kICgnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnKSBpcyBkcm9wcGVkJyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgY2hOciA9IGEgPT09IDB4MTQgfHwgYSA9PT0gMHgxNSB8fCBhID09PSAweDE3ID8gMSA6IDI7XG4gICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY2hOcl07XG4gICAgaWYgKGEgPT09IDB4MTQgfHwgYSA9PT0gMHgxNSB8fCBhID09PSAweDFjIHx8IGEgPT09IDB4MWQpIHtcbiAgICAgIGlmIChiID09PSAweDIwKSB7XG4gICAgICAgIGNoYW5uZWwuY2NSQ0woKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyMSkge1xuICAgICAgICBjaGFubmVsLmNjQlMoKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyMikge1xuICAgICAgICBjaGFubmVsLmNjQU9GKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjMpIHtcbiAgICAgICAgY2hhbm5lbC5jY0FPTigpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDI0KSB7XG4gICAgICAgIGNoYW5uZWwuY2NERVIoKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNSkge1xuICAgICAgICBjaGFubmVsLmNjUlUoMik7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjYpIHtcbiAgICAgICAgY2hhbm5lbC5jY1JVKDMpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDI3KSB7XG4gICAgICAgIGNoYW5uZWwuY2NSVSg0KTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyOCkge1xuICAgICAgICBjaGFubmVsLmNjRk9OKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjkpIHtcbiAgICAgICAgY2hhbm5lbC5jY1JEQygpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDJhKSB7XG4gICAgICAgIGNoYW5uZWwuY2NUUigpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDJiKSB7XG4gICAgICAgIGNoYW5uZWwuY2NSVEQoKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyYykge1xuICAgICAgICBjaGFubmVsLmNjRURNKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MmQpIHtcbiAgICAgICAgY2hhbm5lbC5jY0NSKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MmUpIHtcbiAgICAgICAgY2hhbm5lbC5jY0VOTSgpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDJmKSB7XG4gICAgICAgIGNoYW5uZWwuY2NFT0MoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYSA9PSAweDE3IHx8IGEgPT0gMHgxRlxuICAgICAgY2hhbm5lbC5jY1RPKGIgLSAweDIwKTtcbiAgICB9XG4gICAgc2V0TGFzdENtZChhLCBiLCBjbWRIaXN0b3J5KTtcbiAgICB0aGlzLmN1cnJlbnRDaGFubmVsID0gY2hOcjtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBtaWRyb3cgc3R5bGluZyBjb21tYW5kXG4gICAqL1xuICBwYXJzZU1pZHJvdyhhLCBiKSB7XG4gICAgbGV0IGNoTnIgPSAwO1xuICAgIGlmICgoYSA9PT0gMHgxMSB8fCBhID09PSAweDE5KSAmJiBiID49IDB4MjAgJiYgYiA8PSAweDJmKSB7XG4gICAgICBpZiAoYSA9PT0gMHgxMSkge1xuICAgICAgICBjaE5yID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoTnIgPSAyO1xuICAgICAgfVxuICAgICAgaWYgKGNoTnIgIT09IHRoaXMuY3VycmVudENoYW5uZWwpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKDAsICdNaXNtYXRjaCBjaGFubmVsIGluIG1pZHJvdyBwYXJzaW5nJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2NoTnJdO1xuICAgICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNoYW5uZWwuY2NNSURST1coYik7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coMywgJ01JRFJPVyAoJyArIG51bUFycmF5VG9IZXhBcnJheShbYSwgYl0pICsgJyknKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgUHJlYWJsZSBBY2Nlc3MgQ29kZXMgKFRhYmxlIDUzKS5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IFRlbGxzIGlmIFBBQyBmb3VuZFxuICAgKi9cbiAgcGFyc2VQQUMoYSwgYikge1xuICAgIGxldCByb3c7XG4gICAgY29uc3QgY21kSGlzdG9yeSA9IHRoaXMuY21kSGlzdG9yeTtcbiAgICBjb25zdCBjYXNlMSA9IChhID49IDB4MTEgJiYgYSA8PSAweDE3IHx8IGEgPj0gMHgxOSAmJiBhIDw9IDB4MWYpICYmIGIgPj0gMHg0MCAmJiBiIDw9IDB4N2Y7XG4gICAgY29uc3QgY2FzZTIgPSAoYSA9PT0gMHgxMCB8fCBhID09PSAweDE4KSAmJiBiID49IDB4NDAgJiYgYiA8PSAweDVmO1xuICAgIGlmICghKGNhc2UxIHx8IGNhc2UyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaGFzQ21kUmVwZWF0ZWQoYSwgYiwgY21kSGlzdG9yeSkpIHtcbiAgICAgIHNldExhc3RDbWQobnVsbCwgbnVsbCwgY21kSGlzdG9yeSk7XG4gICAgICByZXR1cm4gdHJ1ZTsgLy8gUmVwZWF0ZWQgY29tbWFuZHMgYXJlIGRyb3BwZWQgKG9uY2UpXG4gICAgfVxuICAgIGNvbnN0IGNoTnIgPSBhIDw9IDB4MTcgPyAxIDogMjtcbiAgICBpZiAoYiA+PSAweDQwICYmIGIgPD0gMHg1Zikge1xuICAgICAgcm93ID0gY2hOciA9PT0gMSA/IHJvd3NMb3dDaDFbYV0gOiByb3dzTG93Q2gyW2FdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyAweDYwIDw9IGIgPD0gMHg3RlxuICAgICAgcm93ID0gY2hOciA9PT0gMSA/IHJvd3NIaWdoQ2gxW2FdIDogcm93c0hpZ2hDaDJbYV07XG4gICAgfVxuICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2NoTnJdO1xuICAgIGlmICghY2hhbm5lbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjaGFubmVsLnNldFBBQyh0aGlzLmludGVycHJldFBBQyhyb3csIGIpKTtcbiAgICBzZXRMYXN0Q21kKGEsIGIsIGNtZEhpc3RvcnkpO1xuICAgIHRoaXMuY3VycmVudENoYW5uZWwgPSBjaE5yO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVycHJldCB0aGUgc2Vjb25kIGJ5dGUgb2YgdGhlIHBhYywgYW5kIHJldHVybiB0aGUgaW5mb3JtYXRpb24uXG4gICAqIEByZXR1cm5zIHBhY0RhdGEgd2l0aCBzdHlsZSBwYXJhbWV0ZXJzXG4gICAqL1xuICBpbnRlcnByZXRQQUMocm93LCBieXRlKSB7XG4gICAgbGV0IHBhY0luZGV4O1xuICAgIGNvbnN0IHBhY0RhdGEgPSB7XG4gICAgICBjb2xvcjogbnVsbCxcbiAgICAgIGl0YWxpY3M6IGZhbHNlLFxuICAgICAgaW5kZW50OiBudWxsLFxuICAgICAgdW5kZXJsaW5lOiBmYWxzZSxcbiAgICAgIHJvdzogcm93XG4gICAgfTtcbiAgICBpZiAoYnl0ZSA+IDB4NWYpIHtcbiAgICAgIHBhY0luZGV4ID0gYnl0ZSAtIDB4NjA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhY0luZGV4ID0gYnl0ZSAtIDB4NDA7XG4gICAgfVxuICAgIHBhY0RhdGEudW5kZXJsaW5lID0gKHBhY0luZGV4ICYgMSkgPT09IDE7XG4gICAgaWYgKHBhY0luZGV4IDw9IDB4ZCkge1xuICAgICAgcGFjRGF0YS5jb2xvciA9IFsnd2hpdGUnLCAnZ3JlZW4nLCAnYmx1ZScsICdjeWFuJywgJ3JlZCcsICd5ZWxsb3cnLCAnbWFnZW50YScsICd3aGl0ZSddW01hdGguZmxvb3IocGFjSW5kZXggLyAyKV07XG4gICAgfSBlbHNlIGlmIChwYWNJbmRleCA8PSAweGYpIHtcbiAgICAgIHBhY0RhdGEuaXRhbGljcyA9IHRydWU7XG4gICAgICBwYWNEYXRhLmNvbG9yID0gJ3doaXRlJztcbiAgICB9IGVsc2Uge1xuICAgICAgcGFjRGF0YS5pbmRlbnQgPSBNYXRoLmZsb29yKChwYWNJbmRleCAtIDB4MTApIC8gMikgKiA0O1xuICAgIH1cbiAgICByZXR1cm4gcGFjRGF0YTsgLy8gTm90ZSB0aGF0IHJvdyBoYXMgemVybyBvZmZzZXQuIFRoZSBzcGVjIHVzZXMgMS5cbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBjaGFyYWN0ZXJzLlxuICAgKiBAcmV0dXJucyBBbiBhcnJheSB3aXRoIDEgdG8gMiBjb2RlcyBjb3JyZXNwb25kaW5nIHRvIGNoYXJzLCBpZiBmb3VuZC4gbnVsbCBvdGhlcndpc2UuXG4gICAqL1xuICBwYXJzZUNoYXJzKGEsIGIpIHtcbiAgICBsZXQgY2hhbm5lbE5yO1xuICAgIGxldCBjaGFyQ29kZXMgPSBudWxsO1xuICAgIGxldCBjaGFyQ29kZTEgPSBudWxsO1xuICAgIGlmIChhID49IDB4MTkpIHtcbiAgICAgIGNoYW5uZWxOciA9IDI7XG4gICAgICBjaGFyQ29kZTEgPSBhIC0gODtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hhbm5lbE5yID0gMTtcbiAgICAgIGNoYXJDb2RlMSA9IGE7XG4gICAgfVxuICAgIGlmIChjaGFyQ29kZTEgPj0gMHgxMSAmJiBjaGFyQ29kZTEgPD0gMHgxMykge1xuICAgICAgLy8gU3BlY2lhbCBjaGFyYWN0ZXJcbiAgICAgIGxldCBvbmVDb2RlO1xuICAgICAgaWYgKGNoYXJDb2RlMSA9PT0gMHgxMSkge1xuICAgICAgICBvbmVDb2RlID0gYiArIDB4NTA7XG4gICAgICB9IGVsc2UgaWYgKGNoYXJDb2RlMSA9PT0gMHgxMikge1xuICAgICAgICBvbmVDb2RlID0gYiArIDB4NzA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbmVDb2RlID0gYiArIDB4OTA7XG4gICAgICB9XG4gICAgICB0aGlzLmxvZ2dlci5sb2coMiwgXCJTcGVjaWFsIGNoYXIgJ1wiICsgZ2V0Q2hhckZvckJ5dGUob25lQ29kZSkgKyBcIicgaW4gY2hhbm5lbCBcIiArIGNoYW5uZWxOcik7XG4gICAgICBjaGFyQ29kZXMgPSBbb25lQ29kZV07XG4gICAgfSBlbHNlIGlmIChhID49IDB4MjAgJiYgYSA8PSAweDdmKSB7XG4gICAgICBjaGFyQ29kZXMgPSBiID09PSAwID8gW2FdIDogW2EsIGJdO1xuICAgIH1cbiAgICBpZiAoY2hhckNvZGVzKSB7XG4gICAgICBjb25zdCBoZXhDb2RlcyA9IG51bUFycmF5VG9IZXhBcnJheShjaGFyQ29kZXMpO1xuICAgICAgdGhpcy5sb2dnZXIubG9nKDMsICdDaGFyIGNvZGVzID0gICcgKyBoZXhDb2Rlcy5qb2luKCcsJykpO1xuICAgICAgc2V0TGFzdENtZChhLCBiLCB0aGlzLmNtZEhpc3RvcnkpO1xuICAgIH1cbiAgICByZXR1cm4gY2hhckNvZGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGV4dGVuZGVkIGJhY2tncm91bmQgYXR0cmlidXRlcyBhcyB3ZWxsIGFzIG5ldyBmb3JlZ3JvdW5kIGNvbG9yIGJsYWNrLlxuICAgKiBAcmV0dXJucyBUcnVlIGlmIGJhY2tncm91bmQgYXR0cmlidXRlcyBhcmUgZm91bmRcbiAgICovXG4gIHBhcnNlQmFja2dyb3VuZEF0dHJpYnV0ZXMoYSwgYikge1xuICAgIGNvbnN0IGNhc2UxID0gKGEgPT09IDB4MTAgfHwgYSA9PT0gMHgxOCkgJiYgYiA+PSAweDIwICYmIGIgPD0gMHgyZjtcbiAgICBjb25zdCBjYXNlMiA9IChhID09PSAweDE3IHx8IGEgPT09IDB4MWYpICYmIGIgPj0gMHgyZCAmJiBiIDw9IDB4MmY7XG4gICAgaWYgKCEoY2FzZTEgfHwgY2FzZTIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBpbmRleDtcbiAgICBjb25zdCBia2dEYXRhID0ge307XG4gICAgaWYgKGEgPT09IDB4MTAgfHwgYSA9PT0gMHgxOCkge1xuICAgICAgaW5kZXggPSBNYXRoLmZsb29yKChiIC0gMHgyMCkgLyAyKTtcbiAgICAgIGJrZ0RhdGEuYmFja2dyb3VuZCA9IGJhY2tncm91bmRDb2xvcnNbaW5kZXhdO1xuICAgICAgaWYgKGIgJSAyID09PSAxKSB7XG4gICAgICAgIGJrZ0RhdGEuYmFja2dyb3VuZCA9IGJrZ0RhdGEuYmFja2dyb3VuZCArICdfc2VtaSc7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChiID09PSAweDJkKSB7XG4gICAgICBia2dEYXRhLmJhY2tncm91bmQgPSAndHJhbnNwYXJlbnQnO1xuICAgIH0gZWxzZSB7XG4gICAgICBia2dEYXRhLmZvcmVncm91bmQgPSAnYmxhY2snO1xuICAgICAgaWYgKGIgPT09IDB4MmYpIHtcbiAgICAgICAgYmtnRGF0YS51bmRlcmxpbmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjaE5yID0gYSA8PSAweDE3ID8gMSA6IDI7XG4gICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY2hOcl07XG4gICAgY2hhbm5lbC5zZXRCa2dEYXRhKGJrZ0RhdGEpO1xuICAgIHNldExhc3RDbWQoYSwgYiwgdGhpcy5jbWRIaXN0b3J5KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCBzdGF0ZSBvZiBwYXJzZXIgYW5kIGl0cyBjaGFubmVscy5cbiAgICovXG4gIHJlc2V0KCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgT2JqZWN0LmtleXModGhpcy5jaGFubmVscykubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2ldO1xuICAgICAgaWYgKGNoYW5uZWwpIHtcbiAgICAgICAgY2hhbm5lbC5yZXNldCgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNtZEhpc3RvcnkgPSBjcmVhdGVDbWRIaXN0b3J5KCk7XG4gIH1cblxuICAvKipcbiAgICogVHJpZ2dlciB0aGUgZ2VuZXJhdGlvbiBvZiBhIGN1ZSwgYW5kIHRoZSBzdGFydCBvZiBhIG5ldyBvbmUgaWYgZGlzcGxheVNjcmVlbnMgYXJlIG5vdCBlbXB0eS5cbiAgICovXG4gIGN1ZVNwbGl0QXRUaW1lKHQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hhbm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2ldO1xuICAgICAgaWYgKGNoYW5uZWwpIHtcbiAgICAgICAgY2hhbm5lbC5jdWVTcGxpdEF0VGltZSh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNldExhc3RDbWQoYSwgYiwgY21kSGlzdG9yeSkge1xuICBjbWRIaXN0b3J5LmEgPSBhO1xuICBjbWRIaXN0b3J5LmIgPSBiO1xufVxuZnVuY3Rpb24gaGFzQ21kUmVwZWF0ZWQoYSwgYiwgY21kSGlzdG9yeSkge1xuICByZXR1cm4gY21kSGlzdG9yeS5hID09PSBhICYmIGNtZEhpc3RvcnkuYiA9PT0gYjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNtZEhpc3RvcnkoKSB7XG4gIHJldHVybiB7XG4gICAgYTogbnVsbCxcbiAgICBiOiBudWxsXG4gIH07XG59XG5cbmNsYXNzIE91dHB1dEZpbHRlciB7XG4gIGNvbnN0cnVjdG9yKHRpbWVsaW5lQ29udHJvbGxlciwgdHJhY2tOYW1lKSB7XG4gICAgdGhpcy50aW1lbGluZUNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jdWVSYW5nZXMgPSBbXTtcbiAgICB0aGlzLnRyYWNrTmFtZSA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IG51bGw7XG4gICAgdGhpcy5lbmRUaW1lID0gbnVsbDtcbiAgICB0aGlzLnNjcmVlbiA9IG51bGw7XG4gICAgdGhpcy50aW1lbGluZUNvbnRyb2xsZXIgPSB0aW1lbGluZUNvbnRyb2xsZXI7XG4gICAgdGhpcy50cmFja05hbWUgPSB0cmFja05hbWU7XG4gIH1cbiAgZGlzcGF0Y2hDdWUoKSB7XG4gICAgaWYgKHRoaXMuc3RhcnRUaW1lID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudGltZWxpbmVDb250cm9sbGVyLmFkZEN1ZXModGhpcy50cmFja05hbWUsIHRoaXMuc3RhcnRUaW1lLCB0aGlzLmVuZFRpbWUsIHRoaXMuc2NyZWVuLCB0aGlzLmN1ZVJhbmdlcyk7XG4gICAgdGhpcy5zdGFydFRpbWUgPSBudWxsO1xuICB9XG4gIG5ld0N1ZShzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbikge1xuICAgIGlmICh0aGlzLnN0YXJ0VGltZSA9PT0gbnVsbCB8fCB0aGlzLnN0YXJ0VGltZSA+IHN0YXJ0VGltZSkge1xuICAgICAgdGhpcy5zdGFydFRpbWUgPSBzdGFydFRpbWU7XG4gICAgfVxuICAgIHRoaXMuZW5kVGltZSA9IGVuZFRpbWU7XG4gICAgdGhpcy5zY3JlZW4gPSBzY3JlZW47XG4gICAgdGhpcy50aW1lbGluZUNvbnRyb2xsZXIuY3JlYXRlQ2FwdGlvbnNUcmFjayh0aGlzLnRyYWNrTmFtZSk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5jdWVSYW5nZXMgPSBbXTtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMyB2dHQuanMgQ29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICdMaWNlbnNlJyk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbnZhciBWVFRDdWUgPSAoZnVuY3Rpb24gKCkge1xuICBpZiAob3B0aW9uYWxTZWxmICE9IG51bGwgJiYgb3B0aW9uYWxTZWxmLlZUVEN1ZSkge1xuICAgIHJldHVybiBzZWxmLlZUVEN1ZTtcbiAgfVxuICBjb25zdCBBbGxvd2VkRGlyZWN0aW9ucyA9IFsnJywgJ2xyJywgJ3JsJ107XG4gIGNvbnN0IEFsbG93ZWRBbGlnbm1lbnRzID0gWydzdGFydCcsICdtaWRkbGUnLCAnZW5kJywgJ2xlZnQnLCAncmlnaHQnXTtcbiAgZnVuY3Rpb24gaXNBbGxvd2VkVmFsdWUoYWxsb3dlZCwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBuZWNlc3NhcnkgZm9yIGFzc3VyaW5nIHRoZSBnZW5lcmljIGNvbmZvcm1zIHRvIHRoZSBBcnJheSBpbnRlcmZhY2VcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYWxsb3dlZCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gcmVzZXQgdGhlIHR5cGUgc28gdGhhdCB0aGUgbmV4dCBuYXJyb3dpbmcgd29ya3Mgd2VsbFxuICAgIGNvbnN0IGxjVmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgIC8vIHVzZSB0aGUgYWxsb3cgbGlzdCB0byBuYXJyb3cgdGhlIHR5cGUgdG8gYSBzcGVjaWZpYyBzdWJzZXQgb2Ygc3RyaW5nc1xuICAgIGlmICh+YWxsb3dlZC5pbmRleE9mKGxjVmFsdWUpKSB7XG4gICAgICByZXR1cm4gbGNWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIGZpbmREaXJlY3Rpb25TZXR0aW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzQWxsb3dlZFZhbHVlKEFsbG93ZWREaXJlY3Rpb25zLCB2YWx1ZSk7XG4gIH1cbiAgZnVuY3Rpb24gZmluZEFsaWduU2V0dGluZyh2YWx1ZSkge1xuICAgIHJldHVybiBpc0FsbG93ZWRWYWx1ZShBbGxvd2VkQWxpZ25tZW50cywgdmFsdWUpO1xuICB9XG4gIGZ1bmN0aW9uIGV4dGVuZChvYmosIC4uLnJlc3QpIHtcbiAgICBsZXQgaSA9IDE7XG4gICAgZm9yICg7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNvYmogPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKGNvbnN0IHAgaW4gY29iaikge1xuICAgICAgICBvYmpbcF0gPSBjb2JqW3BdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIGZ1bmN0aW9uIFZUVEN1ZShzdGFydFRpbWUsIGVuZFRpbWUsIHRleHQpIHtcbiAgICBjb25zdCBjdWUgPSB0aGlzO1xuICAgIGNvbnN0IGJhc2VPYmogPSB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTaGltIGltcGxlbWVudGF0aW9uIHNwZWNpZmljIHByb3BlcnRpZXMuIFRoZXNlIHByb3BlcnRpZXMgYXJlIG5vdCBpblxuICAgICAqIHRoZSBzcGVjLlxuICAgICAqL1xuXG4gICAgLy8gTGV0cyB1cyBrbm93IHdoZW4gdGhlIFZUVEN1ZSdzIGRhdGEgaGFzIGNoYW5nZWQgaW4gc3VjaCBhIHdheSB0aGF0IHdlIG5lZWRcbiAgICAvLyB0byByZWNvbXB1dGUgaXRzIGRpc3BsYXkgc3RhdGUuIFRoaXMgbGV0cyB1cyBjb21wdXRlIGl0cyBkaXNwbGF5IHN0YXRlXG4gICAgLy8gbGF6aWx5LlxuICAgIGN1ZS5oYXNCZWVuUmVzZXQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFZUVEN1ZSBhbmQgVGV4dFRyYWNrQ3VlIHByb3BlcnRpZXNcbiAgICAgKiBodHRwOi8vZGV2LnczLm9yZy9odG1sNS93ZWJ2dHQvI3Z0dGN1ZS1pbnRlcmZhY2VcbiAgICAgKi9cblxuICAgIGxldCBfaWQgPSAnJztcbiAgICBsZXQgX3BhdXNlT25FeGl0ID0gZmFsc2U7XG4gICAgbGV0IF9zdGFydFRpbWUgPSBzdGFydFRpbWU7XG4gICAgbGV0IF9lbmRUaW1lID0gZW5kVGltZTtcbiAgICBsZXQgX3RleHQgPSB0ZXh0O1xuICAgIGxldCBfcmVnaW9uID0gbnVsbDtcbiAgICBsZXQgX3ZlcnRpY2FsID0gJyc7XG4gICAgbGV0IF9zbmFwVG9MaW5lcyA9IHRydWU7XG4gICAgbGV0IF9saW5lID0gJ2F1dG8nO1xuICAgIGxldCBfbGluZUFsaWduID0gJ3N0YXJ0JztcbiAgICBsZXQgX3Bvc2l0aW9uID0gNTA7XG4gICAgbGV0IF9wb3NpdGlvbkFsaWduID0gJ21pZGRsZSc7XG4gICAgbGV0IF9zaXplID0gNTA7XG4gICAgbGV0IF9hbGlnbiA9ICdtaWRkbGUnO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdpZCcsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfaWQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgX2lkID0gJycgKyB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3BhdXNlT25FeGl0JywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9wYXVzZU9uRXhpdDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBfcGF1c2VPbkV4aXQgPSAhIXZhbHVlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnc3RhcnRUaW1lJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9zdGFydFRpbWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdGFydCB0aW1lIG11c3QgYmUgc2V0IHRvIGEgbnVtYmVyLicpO1xuICAgICAgICB9XG4gICAgICAgIF9zdGFydFRpbWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnZW5kVGltZScsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfZW5kVGltZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VuZCB0aW1lIG11c3QgYmUgc2V0IHRvIGEgbnVtYmVyLicpO1xuICAgICAgICB9XG4gICAgICAgIF9lbmRUaW1lID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3RleHQnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RleHQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgX3RleHQgPSAnJyArIHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgLy8gdG9kbzogaW1wbGVtZW50IFZUVFJlZ2lvbiBwb2x5ZmlsbD9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAncmVnaW9uJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdpb247XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgX3JlZ2lvbiA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICd2ZXJ0aWNhbCcsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdmVydGljYWw7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY29uc3Qgc2V0dGluZyA9IGZpbmREaXJlY3Rpb25TZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgLy8gSGF2ZSB0byBjaGVjayBmb3IgZmFsc2UgYmVjYXVzZSB0aGUgc2V0dGluZyBhbiBiZSBhbiBlbXB0eSBzdHJpbmcuXG4gICAgICAgIGlmIChzZXR0aW5nID09PSBmYWxzZSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG4gICAgICAgIF92ZXJ0aWNhbCA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3NuYXBUb0xpbmVzJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9zbmFwVG9MaW5lcztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBfc25hcFRvTGluZXMgPSAhIXZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdsaW5lJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9saW5lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInICYmIHZhbHVlICE9PSAnYXV0bycpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgbnVtYmVyIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX2xpbmUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnbGluZUFsaWduJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9saW5lQWxpZ247XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY29uc3Qgc2V0dGluZyA9IGZpbmRBbGlnblNldHRpbmcodmFsdWUpO1xuICAgICAgICBpZiAoIXNldHRpbmcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBfbGluZUFsaWduID0gc2V0dGluZztcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAncG9zaXRpb24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3Bvc2l0aW9uO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPiAxMDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bvc2l0aW9uIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMDAuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX3Bvc2l0aW9uID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3Bvc2l0aW9uQWxpZ24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3Bvc2l0aW9uQWxpZ247XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY29uc3Qgc2V0dGluZyA9IGZpbmRBbGlnblNldHRpbmcodmFsdWUpO1xuICAgICAgICBpZiAoIXNldHRpbmcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBfcG9zaXRpb25BbGlnbiA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3NpemUnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3NpemU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDEwMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2l6ZSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLicpO1xuICAgICAgICB9XG4gICAgICAgIF9zaXplID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2FsaWduJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9hbGlnbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBjb25zdCBzZXR0aW5nID0gZmluZEFsaWduU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgIGlmICghc2V0dGluZykge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG4gICAgICAgIF9hbGlnbiA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICAvKipcbiAgICAgKiBPdGhlciA8dHJhY2s+IHNwZWMgZGVmaW5lZCBwcm9wZXJ0aWVzXG4gICAgICovXG5cbiAgICAvLyBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtdmlkZW8tZWxlbWVudC5odG1sI3RleHQtdHJhY2stY3VlLWRpc3BsYXktc3RhdGVcbiAgICBjdWUuZGlzcGxheVN0YXRlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFZUVEN1ZSBtZXRob2RzXG4gICAqL1xuXG4gIFZUVEN1ZS5wcm90b3R5cGUuZ2V0Q3VlQXNIVE1MID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEFzc3VtZSBXZWJWVFQuY29udmVydEN1ZVRvRE9NVHJlZSBpcyBvbiB0aGUgZ2xvYmFsLlxuICAgIGNvbnN0IFdlYlZUVCA9IHNlbGYuV2ViVlRUO1xuICAgIHJldHVybiBXZWJWVFQuY29udmVydEN1ZVRvRE9NVHJlZShzZWxmLCB0aGlzLnRleHQpO1xuICB9O1xuICAvLyB0aGlzIGlzIGEgcG9seWZpbGwgaGFja1xuICByZXR1cm4gVlRUQ3VlO1xufSkoKTtcblxuLypcbiAqIFNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvdnR0LmpzL2Jsb2IvbWFzdGVyL2Rpc3QvdnR0LmpzXG4gKi9cblxuY2xhc3MgU3RyaW5nRGVjb2RlciB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgZGVjb2RlKGRhdGEsIG9wdGlvbnMpIHtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciAtIGV4cGVjdGVkIHN0cmluZyBkYXRhLicpO1xuICAgIH1cbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVuY29kZVVSSUNvbXBvbmVudChkYXRhKSk7XG4gIH1cbn1cblxuLy8gVHJ5IHRvIHBhcnNlIGlucHV0IGFzIGEgdGltZSBzdGFtcC5cbmZ1bmN0aW9uIHBhcnNlVGltZVN0YW1wKGlucHV0KSB7XG4gIGZ1bmN0aW9uIGNvbXB1dGVTZWNvbmRzKGgsIG0sIHMsIGYpIHtcbiAgICByZXR1cm4gKGggfCAwKSAqIDM2MDAgKyAobSB8IDApICogNjAgKyAocyB8IDApICsgcGFyc2VGbG9hdChmIHx8IDApO1xuICB9XG4gIGNvbnN0IG0gPSBpbnB1dC5tYXRjaCgvXig/OihcXGQrKTopPyhcXGR7Mn0pOihcXGR7Mn0pKFxcLlxcZCspPy8pO1xuICBpZiAoIW0pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAocGFyc2VGbG9hdChtWzJdKSA+IDU5KSB7XG4gICAgLy8gVGltZXN0YW1wIHRha2VzIHRoZSBmb3JtIG9mIFtob3Vyc106W21pbnV0ZXNdLlttaWxsaXNlY29uZHNdXG4gICAgLy8gRmlyc3QgcG9zaXRpb24gaXMgaG91cnMgYXMgaXQncyBvdmVyIDU5LlxuICAgIHJldHVybiBjb21wdXRlU2Vjb25kcyhtWzJdLCBtWzNdLCAwLCBtWzRdKTtcbiAgfVxuICAvLyBUaW1lc3RhbXAgdGFrZXMgdGhlIGZvcm0gb2YgW2hvdXJzIChvcHRpb25hbCldOlttaW51dGVzXTpbc2Vjb25kc10uW21pbGxpc2Vjb25kc11cbiAgcmV0dXJuIGNvbXB1dGVTZWNvbmRzKG1bMV0sIG1bMl0sIG1bM10sIG1bNF0pO1xufVxuXG4vLyBBIHNldHRpbmdzIG9iamVjdCBob2xkcyBrZXkvdmFsdWUgcGFpcnMgYW5kIHdpbGwgaWdub3JlIGFueXRoaW5nIGJ1dCB0aGUgZmlyc3Rcbi8vIGFzc2lnbm1lbnQgdG8gYSBzcGVjaWZpYyBrZXkuXG5jbGFzcyBTZXR0aW5ncyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudmFsdWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICAvLyBPbmx5IGFjY2VwdCB0aGUgZmlyc3QgYXNzaWdubWVudCB0byBhbnkga2V5LlxuICBzZXQoaywgdikge1xuICAgIGlmICghdGhpcy5nZXQoaykgJiYgdiAhPT0gJycpIHtcbiAgICAgIHRoaXMudmFsdWVzW2tdID0gdjtcbiAgICB9XG4gIH1cbiAgLy8gUmV0dXJuIHRoZSB2YWx1ZSBmb3IgYSBrZXksIG9yIGEgZGVmYXVsdCB2YWx1ZS5cbiAgLy8gSWYgJ2RlZmF1bHRLZXknIGlzIHBhc3NlZCB0aGVuICdkZmx0JyBpcyBhc3N1bWVkIHRvIGJlIGFuIG9iamVjdCB3aXRoXG4gIC8vIGEgbnVtYmVyIG9mIHBvc3NpYmxlIGRlZmF1bHQgdmFsdWVzIGFzIHByb3BlcnRpZXMgd2hlcmUgJ2RlZmF1bHRLZXknIGlzXG4gIC8vIHRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRoYXQgd2lsbCBiZSBjaG9zZW47IG90aGVyd2lzZSBpdCdzIGFzc3VtZWQgdG8gYmVcbiAgLy8gYSBzaW5nbGUgdmFsdWUuXG4gIGdldChrLCBkZmx0LCBkZWZhdWx0S2V5KSB7XG4gICAgaWYgKGRlZmF1bHRLZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhcyhrKSA/IHRoaXMudmFsdWVzW2tdIDogZGZsdFtkZWZhdWx0S2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaGFzKGspID8gdGhpcy52YWx1ZXNba10gOiBkZmx0O1xuICB9XG4gIC8vIENoZWNrIHdoZXRoZXIgd2UgaGF2ZSBhIHZhbHVlIGZvciBhIGtleS5cbiAgaGFzKGspIHtcbiAgICByZXR1cm4gayBpbiB0aGlzLnZhbHVlcztcbiAgfVxuICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBvbmUgb2YgdGhlIGdpdmVuIGFsdGVybmF0aXZlcy5cbiAgYWx0KGssIHYsIGEpIHtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IGEubGVuZ3RoOyArK24pIHtcbiAgICAgIGlmICh2ID09PSBhW25dKSB7XG4gICAgICAgIHRoaXMuc2V0KGssIHYpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gQWNjZXB0IGEgc2V0dGluZyBpZiBpdHMgYSB2YWxpZCAoc2lnbmVkKSBpbnRlZ2VyLlxuICBpbnRlZ2VyKGssIHYpIHtcbiAgICBpZiAoL14tP1xcZCskLy50ZXN0KHYpKSB7XG4gICAgICAvLyBpbnRlZ2VyXG4gICAgICB0aGlzLnNldChrLCBwYXJzZUludCh2LCAxMCkpO1xuICAgIH1cbiAgfVxuICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBhIHZhbGlkIHBlcmNlbnRhZ2UuXG4gIHBlcmNlbnQoaywgdikge1xuICAgIGlmICgvXihbXFxkXXsxLDN9KShcXC5bXFxkXSopPyUkLy50ZXN0KHYpKSB7XG4gICAgICBjb25zdCBwZXJjZW50ID0gcGFyc2VGbG9hdCh2KTtcbiAgICAgIGlmIChwZXJjZW50ID49IDAgJiYgcGVyY2VudCA8PSAxMDApIHtcbiAgICAgICAgdGhpcy5zZXQoaywgcGVyY2VudCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHBhcnNlIGlucHV0IGludG8gZ3JvdXBzIHNlcGFyYXRlZCBieSAnZ3JvdXBEZWxpbScsIGFuZFxuLy8gaW50ZXJwcmV0IGVhY2ggZ3JvdXAgYXMgYSBrZXkvdmFsdWUgcGFpciBzZXBhcmF0ZWQgYnkgJ2tleVZhbHVlRGVsaW0nLlxuZnVuY3Rpb24gcGFyc2VPcHRpb25zKGlucHV0LCBjYWxsYmFjaywga2V5VmFsdWVEZWxpbSwgZ3JvdXBEZWxpbSkge1xuICBjb25zdCBncm91cHMgPSBncm91cERlbGltID8gaW5wdXQuc3BsaXQoZ3JvdXBEZWxpbSkgOiBbaW5wdXRdO1xuICBmb3IgKGNvbnN0IGkgaW4gZ3JvdXBzKSB7XG4gICAgaWYgKHR5cGVvZiBncm91cHNbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3Qga3YgPSBncm91cHNbaV0uc3BsaXQoa2V5VmFsdWVEZWxpbSk7XG4gICAgaWYgKGt2Lmxlbmd0aCAhPT0gMikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGsgPSBrdlswXTtcbiAgICBjb25zdCB2ID0ga3ZbMV07XG4gICAgY2FsbGJhY2soaywgdik7XG4gIH1cbn1cbmNvbnN0IGRlZmF1bHRzID0gbmV3IFZUVEN1ZSgwLCAwLCAnJyk7XG4vLyAnbWlkZGxlJyB3YXMgY2hhbmdlZCB0byAnY2VudGVyJyBpbiB0aGUgc3BlYzogaHR0cHM6Ly9naXRodWIuY29tL3czYy93ZWJ2dHQvcHVsbC8yNDRcbi8vICBTYWZhcmkgZG9lc24ndCB5ZXQgc3VwcG9ydCB0aGlzIGNoYW5nZSwgYnV0IEZGIGFuZCBDaHJvbWUgZG8uXG5jb25zdCBjZW50ZXIgPSBkZWZhdWx0cy5hbGlnbiA9PT0gJ21pZGRsZScgPyAnbWlkZGxlJyA6ICdjZW50ZXInO1xuZnVuY3Rpb24gcGFyc2VDdWUoaW5wdXQsIGN1ZSwgcmVnaW9uTGlzdCkge1xuICAvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgaW5wdXQgaWYgd2UgbmVlZCB0byB0aHJvdyBhbiBlcnJvci5cbiAgY29uc3Qgb0lucHV0ID0gaW5wdXQ7XG4gIC8vIDQuMSBXZWJWVFQgdGltZXN0YW1wXG4gIGZ1bmN0aW9uIGNvbnN1bWVUaW1lU3RhbXAoKSB7XG4gICAgY29uc3QgdHMgPSBwYXJzZVRpbWVTdGFtcChpbnB1dCk7XG4gICAgaWYgKHRzID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCB0aW1lc3RhbXA6ICcgKyBvSW5wdXQpO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSB0aW1lIHN0YW1wIGZyb20gaW5wdXQuXG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9eW15cXHNhLXpBLVotXSsvLCAnJyk7XG4gICAgcmV0dXJuIHRzO1xuICB9XG5cbiAgLy8gNC40LjIgV2ViVlRUIGN1ZSBzZXR0aW5nc1xuICBmdW5jdGlvbiBjb25zdW1lQ3VlU2V0dGluZ3MoaW5wdXQsIGN1ZSkge1xuICAgIGNvbnN0IHNldHRpbmdzID0gbmV3IFNldHRpbmdzKCk7XG4gICAgcGFyc2VPcHRpb25zKGlucHV0LCBmdW5jdGlvbiAoaywgdikge1xuICAgICAgbGV0IHZhbHM7XG4gICAgICBzd2l0Y2ggKGspIHtcbiAgICAgICAgY2FzZSAncmVnaW9uJzpcbiAgICAgICAgICAvLyBGaW5kIHRoZSBsYXN0IHJlZ2lvbiB3ZSBwYXJzZWQgd2l0aCB0aGUgc2FtZSByZWdpb24gaWQuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IHJlZ2lvbkxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChyZWdpb25MaXN0W2ldLmlkID09PSB2KSB7XG4gICAgICAgICAgICAgIHNldHRpbmdzLnNldChrLCByZWdpb25MaXN0W2ldLnJlZ2lvbik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgICAgIHNldHRpbmdzLmFsdChrLCB2LCBbJ3JsJywgJ2xyJ10pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdsaW5lJzpcbiAgICAgICAgICB2YWxzID0gdi5zcGxpdCgnLCcpO1xuICAgICAgICAgIHNldHRpbmdzLmludGVnZXIoaywgdmFsc1swXSk7XG4gICAgICAgICAgaWYgKHNldHRpbmdzLnBlcmNlbnQoaywgdmFsc1swXSkpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLnNldCgnc25hcFRvTGluZXMnLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldHRpbmdzLmFsdChrLCB2YWxzWzBdLCBbJ2F1dG8nXSk7XG4gICAgICAgICAgaWYgKHZhbHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5hbHQoJ2xpbmVBbGlnbicsIHZhbHNbMV0sIFsnc3RhcnQnLCBjZW50ZXIsICdlbmQnXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdwb3NpdGlvbic6XG4gICAgICAgICAgdmFscyA9IHYuc3BsaXQoJywnKTtcbiAgICAgICAgICBzZXR0aW5ncy5wZXJjZW50KGssIHZhbHNbMF0pO1xuICAgICAgICAgIGlmICh2YWxzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgc2V0dGluZ3MuYWx0KCdwb3NpdGlvbkFsaWduJywgdmFsc1sxXSwgWydzdGFydCcsIGNlbnRlciwgJ2VuZCcsICdsaW5lLWxlZnQnLCAnbGluZS1yaWdodCcsICdhdXRvJ10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2l6ZSc6XG4gICAgICAgICAgc2V0dGluZ3MucGVyY2VudChrLCB2KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYWxpZ24nOlxuICAgICAgICAgIHNldHRpbmdzLmFsdChrLCB2LCBbJ3N0YXJ0JywgY2VudGVyLCAnZW5kJywgJ2xlZnQnLCAncmlnaHQnXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSwgLzovLCAvXFxzLyk7XG5cbiAgICAvLyBBcHBseSBkZWZhdWx0IHZhbHVlcyBmb3IgYW55IG1pc3NpbmcgZmllbGRzLlxuICAgIGN1ZS5yZWdpb24gPSBzZXR0aW5ncy5nZXQoJ3JlZ2lvbicsIG51bGwpO1xuICAgIGN1ZS52ZXJ0aWNhbCA9IHNldHRpbmdzLmdldCgndmVydGljYWwnLCAnJyk7XG4gICAgbGV0IGxpbmUgPSBzZXR0aW5ncy5nZXQoJ2xpbmUnLCAnYXV0bycpO1xuICAgIGlmIChsaW5lID09PSAnYXV0bycgJiYgZGVmYXVsdHMubGluZSA9PT0gLTEpIHtcbiAgICAgIC8vIHNldCBudW1lcmljIGxpbmUgbnVtYmVyIGZvciBTYWZhcmlcbiAgICAgIGxpbmUgPSAtMTtcbiAgICB9XG4gICAgY3VlLmxpbmUgPSBsaW5lO1xuICAgIGN1ZS5saW5lQWxpZ24gPSBzZXR0aW5ncy5nZXQoJ2xpbmVBbGlnbicsICdzdGFydCcpO1xuICAgIGN1ZS5zbmFwVG9MaW5lcyA9IHNldHRpbmdzLmdldCgnc25hcFRvTGluZXMnLCB0cnVlKTtcbiAgICBjdWUuc2l6ZSA9IHNldHRpbmdzLmdldCgnc2l6ZScsIDEwMCk7XG4gICAgY3VlLmFsaWduID0gc2V0dGluZ3MuZ2V0KCdhbGlnbicsIGNlbnRlcik7XG4gICAgbGV0IHBvc2l0aW9uID0gc2V0dGluZ3MuZ2V0KCdwb3NpdGlvbicsICdhdXRvJyk7XG4gICAgaWYgKHBvc2l0aW9uID09PSAnYXV0bycgJiYgZGVmYXVsdHMucG9zaXRpb24gPT09IDUwKSB7XG4gICAgICAvLyBzZXQgbnVtZXJpYyBwb3NpdGlvbiBmb3IgU2FmYXJpXG4gICAgICBwb3NpdGlvbiA9IGN1ZS5hbGlnbiA9PT0gJ3N0YXJ0JyB8fCBjdWUuYWxpZ24gPT09ICdsZWZ0JyA/IDAgOiBjdWUuYWxpZ24gPT09ICdlbmQnIHx8IGN1ZS5hbGlnbiA9PT0gJ3JpZ2h0JyA/IDEwMCA6IDUwO1xuICAgIH1cbiAgICBjdWUucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgfVxuICBmdW5jdGlvbiBza2lwV2hpdGVzcGFjZSgpIHtcbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL15cXHMrLywgJycpO1xuICB9XG5cbiAgLy8gNC4xIFdlYlZUVCBjdWUgdGltaW5ncy5cbiAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgY3VlLnN0YXJ0VGltZSA9IGNvbnN1bWVUaW1lU3RhbXAoKTsgLy8gKDEpIGNvbGxlY3QgY3VlIHN0YXJ0IHRpbWVcbiAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgaWYgKGlucHV0LnNsaWNlKDAsIDMpICE9PSAnLS0+Jykge1xuICAgIC8vICgzKSBuZXh0IGNoYXJhY3RlcnMgbXVzdCBtYXRjaCAnLS0+J1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1hbGZvcm1lZCB0aW1lIHN0YW1wICh0aW1lIHN0YW1wcyBtdXN0IGJlIHNlcGFyYXRlZCBieSAnLS0+Jyk6IFwiICsgb0lucHV0KTtcbiAgfVxuICBpbnB1dCA9IGlucHV0LnNsaWNlKDMpO1xuICBza2lwV2hpdGVzcGFjZSgpO1xuICBjdWUuZW5kVGltZSA9IGNvbnN1bWVUaW1lU3RhbXAoKTsgLy8gKDUpIGNvbGxlY3QgY3VlIGVuZCB0aW1lXG5cbiAgLy8gNC4xIFdlYlZUVCBjdWUgc2V0dGluZ3MgbGlzdC5cbiAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgY29uc3VtZUN1ZVNldHRpbmdzKGlucHV0LCBjdWUpO1xufVxuZnVuY3Rpb24gZml4TGluZUJyZWFrcyhpbnB1dCkge1xuICByZXR1cm4gaW5wdXQucmVwbGFjZSgvPGJyKD86IFxcLyk/Pi9naSwgJ1xcbicpO1xufVxuY2xhc3MgVlRUUGFyc2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zdGF0ZSA9ICdJTklUSUFMJztcbiAgICB0aGlzLmJ1ZmZlciA9ICcnO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKCk7XG4gICAgdGhpcy5yZWdpb25MaXN0ID0gW107XG4gICAgdGhpcy5jdWUgPSBudWxsO1xuICAgIHRoaXMub25jdWUgPSB2b2lkIDA7XG4gICAgdGhpcy5vbnBhcnNpbmdlcnJvciA9IHZvaWQgMDtcbiAgICB0aGlzLm9uZmx1c2ggPSB2b2lkIDA7XG4gIH1cbiAgcGFyc2UoZGF0YSkge1xuICAgIGNvbnN0IF90aGlzID0gdGhpcztcblxuICAgIC8vIElmIHRoZXJlIGlzIG5vIGRhdGEgdGhlbiB3ZSB3b24ndCBkZWNvZGUgaXQsIGJ1dCB3aWxsIGp1c3QgdHJ5IHRvIHBhcnNlXG4gICAgLy8gd2hhdGV2ZXIgaXMgaW4gYnVmZmVyIGFscmVhZHkuIFRoaXMgbWF5IG9jY3VyIGluIGNpcmN1bXN0YW5jZXMsIGZvclxuICAgIC8vIGV4YW1wbGUgd2hlbiBmbHVzaCgpIGlzIGNhbGxlZC5cbiAgICBpZiAoZGF0YSkge1xuICAgICAgLy8gVHJ5IHRvIGRlY29kZSB0aGUgZGF0YSB0aGF0IHdlIHJlY2VpdmVkLlxuICAgICAgX3RoaXMuYnVmZmVyICs9IF90aGlzLmRlY29kZXIuZGVjb2RlKGRhdGEsIHtcbiAgICAgICAgc3RyZWFtOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29sbGVjdE5leHRMaW5lKCkge1xuICAgICAgbGV0IGJ1ZmZlciA9IF90aGlzLmJ1ZmZlcjtcbiAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgYnVmZmVyID0gZml4TGluZUJyZWFrcyhidWZmZXIpO1xuICAgICAgd2hpbGUgKHBvcyA8IGJ1ZmZlci5sZW5ndGggJiYgYnVmZmVyW3Bvc10gIT09ICdcXHInICYmIGJ1ZmZlcltwb3NdICE9PSAnXFxuJykge1xuICAgICAgICArK3BvcztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxpbmUgPSBidWZmZXIuc2xpY2UoMCwgcG9zKTtcbiAgICAgIC8vIEFkdmFuY2UgdGhlIGJ1ZmZlciBlYXJseSBpbiBjYXNlIHdlIGZhaWwgYmVsb3cuXG4gICAgICBpZiAoYnVmZmVyW3Bvc10gPT09ICdcXHInKSB7XG4gICAgICAgICsrcG9zO1xuICAgICAgfVxuICAgICAgaWYgKGJ1ZmZlcltwb3NdID09PSAnXFxuJykge1xuICAgICAgICArK3BvcztcbiAgICAgIH1cbiAgICAgIF90aGlzLmJ1ZmZlciA9IGJ1ZmZlci5zbGljZShwb3MpO1xuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfVxuXG4gICAgLy8gMy4yIFdlYlZUVCBtZXRhZGF0YSBoZWFkZXIgc3ludGF4XG4gICAgZnVuY3Rpb24gcGFyc2VIZWFkZXIoaW5wdXQpIHtcbiAgICAgIHBhcnNlT3B0aW9ucyhpbnB1dCwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgICAgLy8gc3dpdGNoIChrKSB7XG4gICAgICAgIC8vIGNhc2UgJ3JlZ2lvbic6XG4gICAgICAgIC8vIDMuMyBXZWJWVFQgcmVnaW9uIG1ldGFkYXRhIGhlYWRlciBzeW50YXhcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3BhcnNlIHJlZ2lvbicsIHYpO1xuICAgICAgICAvLyBwYXJzZVJlZ2lvbih2KTtcbiAgICAgICAgLy8gYnJlYWs7XG4gICAgICAgIC8vIH1cbiAgICAgIH0sIC86Lyk7XG4gICAgfVxuXG4gICAgLy8gNS4xIFdlYlZUVCBmaWxlIHBhcnNpbmcuXG4gICAgdHJ5IHtcbiAgICAgIGxldCBsaW5lID0gJyc7XG4gICAgICBpZiAoX3RoaXMuc3RhdGUgPT09ICdJTklUSUFMJykge1xuICAgICAgICAvLyBXZSBjYW4ndCBzdGFydCBwYXJzaW5nIHVudGlsIHdlIGhhdmUgdGhlIGZpcnN0IGxpbmUuXG4gICAgICAgIGlmICghL1xcclxcbnxcXG4vLnRlc3QoX3RoaXMuYnVmZmVyKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGxpbmUgPSBjb2xsZWN0TmV4dExpbmUoKTtcbiAgICAgICAgLy8gc3RyaXAgb2YgVVRGLTggQk9NIGlmIGFueVxuICAgICAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CeXRlX29yZGVyX21hcmsjVVRGLThcbiAgICAgICAgY29uc3QgbSA9IGxpbmUubWF0Y2goL14ow6/Cu8K/KT9XRUJWVFQoWyBcXHRdLiopPyQvKTtcbiAgICAgICAgaWYgKCEobSAhPSBudWxsICYmIG1bMF0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgV2ViVlRUIHNpZ25hdHVyZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5zdGF0ZSA9ICdIRUFERVInO1xuICAgICAgfVxuICAgICAgbGV0IGFscmVhZHlDb2xsZWN0ZWRMaW5lID0gZmFsc2U7XG4gICAgICB3aGlsZSAoX3RoaXMuYnVmZmVyKSB7XG4gICAgICAgIC8vIFdlIGNhbid0IHBhcnNlIGEgbGluZSB1bnRpbCB3ZSBoYXZlIHRoZSBmdWxsIGxpbmUuXG4gICAgICAgIGlmICghL1xcclxcbnxcXG4vLnRlc3QoX3RoaXMuYnVmZmVyKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYWxyZWFkeUNvbGxlY3RlZExpbmUpIHtcbiAgICAgICAgICBsaW5lID0gY29sbGVjdE5leHRMaW5lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWxyZWFkeUNvbGxlY3RlZExpbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKF90aGlzLnN0YXRlKSB7XG4gICAgICAgICAgY2FzZSAnSEVBREVSJzpcbiAgICAgICAgICAgIC8vIDEzLTE4IC0gQWxsb3cgYSBoZWFkZXIgKG1ldGFkYXRhKSB1bmRlciB0aGUgV0VCVlRUIGxpbmUuXG4gICAgICAgICAgICBpZiAoLzovLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgcGFyc2VIZWFkZXIobGluZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAgIC8vIEFuIGVtcHR5IGxpbmUgdGVybWluYXRlcyB0aGUgaGVhZGVyIGFuZCBzdGFydHMgdGhlIGJvZHkgKGN1ZXMpLlxuICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlICdOT1RFJzpcbiAgICAgICAgICAgIC8vIElnbm9yZSBOT1RFIGJsb2Nrcy5cbiAgICAgICAgICAgIGlmICghbGluZSkge1xuICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlICdJRCc6XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgdGhlIHN0YXJ0IG9mIE5PVEUgYmxvY2tzLlxuICAgICAgICAgICAgaWYgKC9eTk9URSgkfFsgXFx0XSkvLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSAnTk9URSc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gMTktMjkgLSBBbGxvdyBhbnkgbnVtYmVyIG9mIGxpbmUgdGVybWluYXRvcnMsIHRoZW4gaW5pdGlhbGl6ZSBuZXcgY3VlIHZhbHVlcy5cbiAgICAgICAgICAgIGlmICghbGluZSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmN1ZSA9IG5ldyBWVFRDdWUoMCwgMCwgJycpO1xuICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSAnQ1VFJztcbiAgICAgICAgICAgIC8vIDMwLTM5IC0gQ2hlY2sgaWYgc2VsZiBsaW5lIGNvbnRhaW5zIGFuIG9wdGlvbmFsIGlkZW50aWZpZXIgb3IgdGltaW5nIGRhdGEuXG4gICAgICAgICAgICBpZiAobGluZS5pbmRleE9mKCctLT4nKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgX3RoaXMuY3VlLmlkID0gbGluZTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgLy8gUHJvY2VzcyBsaW5lIGFzIHN0YXJ0IG9mIGEgY3VlLlxuICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICBjYXNlICdDVUUnOlxuICAgICAgICAgICAgLy8gNDAgLSBDb2xsZWN0IGN1ZSB0aW1pbmdzIGFuZCBzZXR0aW5ncy5cbiAgICAgICAgICAgIGlmICghX3RoaXMuY3VlKSB7XG4gICAgICAgICAgICAgIF90aGlzLnN0YXRlID0gJ0JBRENVRSc7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcGFyc2VDdWUobGluZSwgX3RoaXMuY3VlLCBfdGhpcy5yZWdpb25MaXN0KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgLy8gSW4gY2FzZSBvZiBhbiBlcnJvciBpZ25vcmUgcmVzdCBvZiB0aGUgY3VlLlxuICAgICAgICAgICAgICBfdGhpcy5jdWUgPSBudWxsO1xuICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdCQURDVUUnO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnN0YXRlID0gJ0NVRVRFWFQnO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSAnQ1VFVEVYVCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IGhhc1N1YnN0cmluZyA9IGxpbmUuaW5kZXhPZignLS0+JykgIT09IC0xO1xuICAgICAgICAgICAgICAvLyAzNCAtIElmIHdlIGhhdmUgYW4gZW1wdHkgbGluZSB0aGVuIHJlcG9ydCB0aGUgY3VlLlxuICAgICAgICAgICAgICAvLyAzNSAtIElmIHdlIGhhdmUgdGhlIHNwZWNpYWwgc3Vic3RyaW5nICctLT4nIHRoZW4gcmVwb3J0IHRoZSBjdWUsXG4gICAgICAgICAgICAgIC8vIGJ1dCBkbyBub3QgY29sbGVjdCB0aGUgbGluZSBhcyB3ZSBuZWVkIHRvIHByb2Nlc3MgdGhlIGN1cnJlbnRcbiAgICAgICAgICAgICAgLy8gb25lIGFzIGEgbmV3IGN1ZS5cbiAgICAgICAgICAgICAgaWYgKCFsaW5lIHx8IGhhc1N1YnN0cmluZyAmJiAoYWxyZWFkeUNvbGxlY3RlZExpbmUgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBkb25lIHBhcnNpbmcgc2VsZiBjdWUuXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLm9uY3VlICYmIF90aGlzLmN1ZSkge1xuICAgICAgICAgICAgICAgICAgX3RoaXMub25jdWUoX3RoaXMuY3VlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuY3VlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKF90aGlzLmN1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChfdGhpcy5jdWUudGV4dCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmN1ZS50ZXh0ICs9ICdcXG4nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF90aGlzLmN1ZS50ZXh0ICs9IGxpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlICdCQURDVUUnOlxuICAgICAgICAgICAgLy8gNTQtNjIgLSBDb2xsZWN0IGFuZCBkaXNjYXJkIHRoZSByZW1haW5pbmcgY3VlLlxuICAgICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAgIF90aGlzLnN0YXRlID0gJ0lEJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgcGFyc2luZyBhIGN1ZSwgcmVwb3J0IHdoYXQgd2UgaGF2ZS5cbiAgICAgIGlmIChfdGhpcy5zdGF0ZSA9PT0gJ0NVRVRFWFQnICYmIF90aGlzLmN1ZSAmJiBfdGhpcy5vbmN1ZSkge1xuICAgICAgICBfdGhpcy5vbmN1ZShfdGhpcy5jdWUpO1xuICAgICAgfVxuICAgICAgX3RoaXMuY3VlID0gbnVsbDtcbiAgICAgIC8vIEVudGVyIEJBRFdFQlZUVCBzdGF0ZSBpZiBoZWFkZXIgd2FzIG5vdCBwYXJzZWQgY29ycmVjdGx5IG90aGVyd2lzZVxuICAgICAgLy8gYW5vdGhlciBleGNlcHRpb24gb2NjdXJyZWQgc28gZW50ZXIgQkFEQ1VFIHN0YXRlLlxuICAgICAgX3RoaXMuc3RhdGUgPSBfdGhpcy5zdGF0ZSA9PT0gJ0lOSVRJQUwnID8gJ0JBRFdFQlZUVCcgOiAnQkFEQ1VFJztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZmx1c2goKSB7XG4gICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgIHRyeSB7XG4gICAgICAvLyBGaW5pc2ggZGVjb2RpbmcgdGhlIHN0cmVhbS5cbiAgICAgIC8vIF90aGlzLmJ1ZmZlciArPSBfdGhpcy5kZWNvZGVyLmRlY29kZSgpO1xuICAgICAgLy8gU3ludGhlc2l6ZSB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGN1ZSBvciByZWdpb24uXG4gICAgICBpZiAoX3RoaXMuY3VlIHx8IF90aGlzLnN0YXRlID09PSAnSEVBREVSJykge1xuICAgICAgICBfdGhpcy5idWZmZXIgKz0gJ1xcblxcbic7XG4gICAgICAgIF90aGlzLnBhcnNlKCk7XG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSd2ZSBmbHVzaGVkLCBwYXJzZWQsIGFuZCB3ZSdyZSBzdGlsbCBvbiB0aGUgSU5JVElBTCBzdGF0ZSB0aGVuXG4gICAgICAvLyB0aGF0IG1lYW5zIHdlIGRvbid0IGhhdmUgZW5vdWdoIG9mIHRoZSBzdHJlYW0gdG8gcGFyc2UgdGhlIGZpcnN0XG4gICAgICAvLyBsaW5lLlxuICAgICAgaWYgKF90aGlzLnN0YXRlID09PSAnSU5JVElBTCcgfHwgX3RoaXMuc3RhdGUgPT09ICdCQURXRUJWVFQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIFdlYlZUVCBzaWduYXR1cmUuJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKF90aGlzLm9ucGFyc2luZ2Vycm9yKSB7XG4gICAgICAgIF90aGlzLm9ucGFyc2luZ2Vycm9yKGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoX3RoaXMub25mbHVzaCkge1xuICAgICAgX3RoaXMub25mbHVzaCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5jb25zdCBMSU5FQlJFQUtTID0gL1xcclxcbnxcXG5cXHJ8XFxufFxcci9nO1xuXG4vLyBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGggaXMgbm90IHN1cHBvcnRlZCBpbiBJRTExXG5jb25zdCBzdGFydHNXaXRoID0gZnVuY3Rpb24gc3RhcnRzV2l0aChpbnB1dFN0cmluZywgc2VhcmNoU3RyaW5nLCBwb3NpdGlvbiA9IDApIHtcbiAgcmV0dXJuIGlucHV0U3RyaW5nLnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIHNlYXJjaFN0cmluZy5sZW5ndGgpID09PSBzZWFyY2hTdHJpbmc7XG59O1xuY29uc3QgY3VlU3RyaW5nMm1pbGxpcyA9IGZ1bmN0aW9uIGN1ZVN0cmluZzJtaWxsaXModGltZVN0cmluZykge1xuICBsZXQgdHMgPSBwYXJzZUludCh0aW1lU3RyaW5nLnNsaWNlKC0zKSk7XG4gIGNvbnN0IHNlY3MgPSBwYXJzZUludCh0aW1lU3RyaW5nLnNsaWNlKC02LCAtNCkpO1xuICBjb25zdCBtaW5zID0gcGFyc2VJbnQodGltZVN0cmluZy5zbGljZSgtOSwgLTcpKTtcbiAgY29uc3QgaG91cnMgPSB0aW1lU3RyaW5nLmxlbmd0aCA+IDkgPyBwYXJzZUludCh0aW1lU3RyaW5nLnN1YnN0cmluZygwLCB0aW1lU3RyaW5nLmluZGV4T2YoJzonKSkpIDogMDtcbiAgaWYgKCFpc0Zpbml0ZU51bWJlcih0cykgfHwgIWlzRmluaXRlTnVtYmVyKHNlY3MpIHx8ICFpc0Zpbml0ZU51bWJlcihtaW5zKSB8fCAhaXNGaW5pdGVOdW1iZXIoaG91cnMpKSB7XG4gICAgdGhyb3cgRXJyb3IoYE1hbGZvcm1lZCBYLVRJTUVTVEFNUC1NQVA6IExvY2FsOiR7dGltZVN0cmluZ31gKTtcbiAgfVxuICB0cyArPSAxMDAwICogc2VjcztcbiAgdHMgKz0gNjAgKiAxMDAwICogbWlucztcbiAgdHMgKz0gNjAgKiA2MCAqIDEwMDAgKiBob3VycztcbiAgcmV0dXJuIHRzO1xufTtcblxuLy8gRnJvbSBodHRwczovL2dpdGh1Yi5jb20vZGFya3NreWFwcC9zdHJpbmctaGFzaFxuY29uc3QgaGFzaCA9IGZ1bmN0aW9uIGhhc2godGV4dCkge1xuICBsZXQgX2hhc2ggPSA1MzgxO1xuICBsZXQgaSA9IHRleHQubGVuZ3RoO1xuICB3aGlsZSAoaSkge1xuICAgIF9oYXNoID0gX2hhc2ggKiAzMyBeIHRleHQuY2hhckNvZGVBdCgtLWkpO1xuICB9XG4gIHJldHVybiAoX2hhc2ggPj4+IDApLnRvU3RyaW5nKCk7XG59O1xuXG4vLyBDcmVhdGUgYSB1bmlxdWUgaGFzaCBpZCBmb3IgYSBjdWUgYmFzZWQgb24gc3RhcnQvZW5kIHRpbWVzIGFuZCB0ZXh0LlxuLy8gVGhpcyBoZWxwcyB0aW1lbGluZS1jb250cm9sbGVyIHRvIGF2b2lkIHNob3dpbmcgcmVwZWF0ZWQgY2FwdGlvbnMuXG5mdW5jdGlvbiBnZW5lcmF0ZUN1ZUlkKHN0YXJ0VGltZSwgZW5kVGltZSwgdGV4dCkge1xuICByZXR1cm4gaGFzaChzdGFydFRpbWUudG9TdHJpbmcoKSkgKyBoYXNoKGVuZFRpbWUudG9TdHJpbmcoKSkgKyBoYXNoKHRleHQpO1xufVxuY29uc3QgY2FsY3VsYXRlT2Zmc2V0ID0gZnVuY3Rpb24gY2FsY3VsYXRlT2Zmc2V0KHZ0dENDcywgY2MsIHByZXNlbnRhdGlvblRpbWUpIHtcbiAgbGV0IGN1cnJDQyA9IHZ0dENDc1tjY107XG4gIGxldCBwcmV2Q0MgPSB2dHRDQ3NbY3VyckNDLnByZXZDQ107XG5cbiAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgZGlzY29udGludWl0eSBvciBjdWVzIGhhdmUgYmVlbiBwcm9jZXNzZWQgc2luY2UgdGhlIGxhc3QgZGlzY29udGludWl0eVxuICAvLyBPZmZzZXQgPSBjdXJyZW50IGRpc2NvbnRpbnVpdHkgdGltZVxuICBpZiAoIXByZXZDQyB8fCAhcHJldkNDLm5ldyAmJiBjdXJyQ0MubmV3KSB7XG4gICAgdnR0Q0NzLmNjT2Zmc2V0ID0gdnR0Q0NzLnByZXNlbnRhdGlvbk9mZnNldCA9IGN1cnJDQy5zdGFydDtcbiAgICBjdXJyQ0MubmV3ID0gZmFsc2U7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVGhlcmUgaGF2ZSBiZWVuIGRpc2NvbnRpbnVpdGllcyBzaW5jZSBjdWVzIHdlcmUgbGFzdCBwYXJzZWQuXG4gIC8vIE9mZnNldCA9IHRpbWUgZWxhcHNlZFxuICB3aGlsZSAoKF9wcmV2Q0MgPSBwcmV2Q0MpICE9IG51bGwgJiYgX3ByZXZDQy5uZXcpIHtcbiAgICB2YXIgX3ByZXZDQztcbiAgICB2dHRDQ3MuY2NPZmZzZXQgKz0gY3VyckNDLnN0YXJ0IC0gcHJldkNDLnN0YXJ0O1xuICAgIGN1cnJDQy5uZXcgPSBmYWxzZTtcbiAgICBjdXJyQ0MgPSBwcmV2Q0M7XG4gICAgcHJldkNDID0gdnR0Q0NzW2N1cnJDQy5wcmV2Q0NdO1xuICB9XG4gIHZ0dENDcy5wcmVzZW50YXRpb25PZmZzZXQgPSBwcmVzZW50YXRpb25UaW1lO1xufTtcbmZ1bmN0aW9uIHBhcnNlV2ViVlRUKHZ0dEJ5dGVBcnJheSwgaW5pdFBUUywgdnR0Q0NzLCBjYywgdGltZU9mZnNldCwgY2FsbEJhY2ssIGVycm9yQ2FsbEJhY2spIHtcbiAgY29uc3QgcGFyc2VyID0gbmV3IFZUVFBhcnNlcigpO1xuICAvLyBDb252ZXJ0IGJ5dGVBcnJheSBpbnRvIHN0cmluZywgcmVwbGFjaW5nIGFueSBzb21ld2hhdCBleG90aWMgbGluZWZlZWRzIHdpdGggXCJcXG5cIiwgdGhlbiBzcGxpdCBvbiB0aGF0IGNoYXJhY3Rlci5cbiAgLy8gVWludDhBcnJheS5wcm90b3R5cGUucmVkdWNlIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiBJRTExXG4gIGNvbnN0IHZ0dExpbmVzID0gdXRmOEFycmF5VG9TdHIobmV3IFVpbnQ4QXJyYXkodnR0Qnl0ZUFycmF5KSkudHJpbSgpLnJlcGxhY2UoTElORUJSRUFLUywgJ1xcbicpLnNwbGl0KCdcXG4nKTtcbiAgY29uc3QgY3VlcyA9IFtdO1xuICBjb25zdCBpbml0OTBrSHogPSBpbml0UFRTID8gdG9NcGVnVHNDbG9ja0Zyb21UaW1lc2NhbGUoaW5pdFBUUy5iYXNlVGltZSwgaW5pdFBUUy50aW1lc2NhbGUpIDogMDtcbiAgbGV0IGN1ZVRpbWUgPSAnMDA6MDAuMDAwJztcbiAgbGV0IHRpbWVzdGFtcE1hcE1QRUdUUyA9IDA7XG4gIGxldCB0aW1lc3RhbXBNYXBMT0NBTCA9IDA7XG4gIGxldCBwYXJzaW5nRXJyb3I7XG4gIGxldCBpbkhlYWRlciA9IHRydWU7XG4gIHBhcnNlci5vbmN1ZSA9IGZ1bmN0aW9uIChjdWUpIHtcbiAgICAvLyBBZGp1c3QgY3VlIHRpbWluZzsgY2xhbXAgY3VlcyB0byBzdGFydCBubyBlYXJsaWVyIHRoYW4gLSBhbmQgZHJvcCBjdWVzIHRoYXQgZG9uJ3QgZW5kIGFmdGVyIC0gMCBvbiB0aW1lbGluZS5cbiAgICBjb25zdCBjdXJyQ0MgPSB2dHRDQ3NbY2NdO1xuICAgIGxldCBjdWVPZmZzZXQgPSB2dHRDQ3MuY2NPZmZzZXQ7XG5cbiAgICAvLyBDYWxjdWxhdGUgc3VidGl0bGUgUFRTIG9mZnNldFxuICAgIGNvbnN0IHdlYlZ0dE1wZWdUc01hcE9mZnNldCA9ICh0aW1lc3RhbXBNYXBNUEVHVFMgLSBpbml0OTBrSHopIC8gOTAwMDA7XG5cbiAgICAvLyBVcGRhdGUgb2Zmc2V0cyBmb3IgbmV3IGRpc2NvbnRpbnVpdGllc1xuICAgIGlmIChjdXJyQ0MgIT0gbnVsbCAmJiBjdXJyQ0MubmV3KSB7XG4gICAgICBpZiAodGltZXN0YW1wTWFwTE9DQUwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBXaGVuIGxvY2FsIHRpbWUgaXMgcHJvdmlkZWQsIG9mZnNldCA9IGRpc2NvbnRpbnVpdHkgc3RhcnQgdGltZSAtIGxvY2FsIHRpbWVcbiAgICAgICAgY3VlT2Zmc2V0ID0gdnR0Q0NzLmNjT2Zmc2V0ID0gY3VyckNDLnN0YXJ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsY3VsYXRlT2Zmc2V0KHZ0dENDcywgY2MsIHdlYlZ0dE1wZWdUc01hcE9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh3ZWJWdHRNcGVnVHNNYXBPZmZzZXQpIHtcbiAgICAgIGlmICghaW5pdFBUUykge1xuICAgICAgICBwYXJzaW5nRXJyb3IgPSBuZXcgRXJyb3IoJ01pc3NpbmcgaW5pdFBUUyBmb3IgVlRUIE1QRUdUUycpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSBoYXZlIE1QRUdUUywgb2Zmc2V0ID0gcHJlc2VudGF0aW9uIHRpbWUgKyBkaXNjb250aW51aXR5IG9mZnNldFxuICAgICAgY3VlT2Zmc2V0ID0gd2ViVnR0TXBlZ1RzTWFwT2Zmc2V0IC0gdnR0Q0NzLnByZXNlbnRhdGlvbk9mZnNldDtcbiAgICB9XG4gICAgY29uc3QgZHVyYXRpb24gPSBjdWUuZW5kVGltZSAtIGN1ZS5zdGFydFRpbWU7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gbm9ybWFsaXplUHRzKChjdWUuc3RhcnRUaW1lICsgY3VlT2Zmc2V0IC0gdGltZXN0YW1wTWFwTE9DQUwpICogOTAwMDAsIHRpbWVPZmZzZXQgKiA5MDAwMCkgLyA5MDAwMDtcbiAgICBjdWUuc3RhcnRUaW1lID0gTWF0aC5tYXgoc3RhcnRUaW1lLCAwKTtcbiAgICBjdWUuZW5kVGltZSA9IE1hdGgubWF4KHN0YXJ0VGltZSArIGR1cmF0aW9uLCAwKTtcblxuICAgIC8vdHJpbSB0cmFpbGluZyB3ZWJ2dHQgYmxvY2sgd2hpdGVzcGFjZXNcbiAgICBjb25zdCB0ZXh0ID0gY3VlLnRleHQudHJpbSgpO1xuXG4gICAgLy8gRml4IGVuY29kaW5nIG9mIHNwZWNpYWwgY2hhcmFjdGVyc1xuICAgIGN1ZS50ZXh0ID0gZGVjb2RlVVJJQ29tcG9uZW50KGVuY29kZVVSSUNvbXBvbmVudCh0ZXh0KSk7XG5cbiAgICAvLyBJZiB0aGUgY3VlIHdhcyBub3QgYXNzaWduZWQgYW4gaWQgZnJvbSB0aGUgVlRUIGZpbGUgKGxpbmUgYWJvdmUgdGhlIGNvbnRlbnQpLCBjcmVhdGUgb25lLlxuICAgIGlmICghY3VlLmlkKSB7XG4gICAgICBjdWUuaWQgPSBnZW5lcmF0ZUN1ZUlkKGN1ZS5zdGFydFRpbWUsIGN1ZS5lbmRUaW1lLCB0ZXh0KTtcbiAgICB9XG4gICAgaWYgKGN1ZS5lbmRUaW1lID4gMCkge1xuICAgICAgY3Vlcy5wdXNoKGN1ZSk7XG4gICAgfVxuICB9O1xuICBwYXJzZXIub25wYXJzaW5nZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICBwYXJzaW5nRXJyb3IgPSBlcnJvcjtcbiAgfTtcbiAgcGFyc2VyLm9uZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHBhcnNpbmdFcnJvcikge1xuICAgICAgZXJyb3JDYWxsQmFjayhwYXJzaW5nRXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsQmFjayhjdWVzKTtcbiAgfTtcblxuICAvLyBHbyB0aHJvdWdoIGNvbnRlbnRzIGxpbmUgYnkgbGluZS5cbiAgdnR0TGluZXMuZm9yRWFjaChsaW5lID0+IHtcbiAgICBpZiAoaW5IZWFkZXIpIHtcbiAgICAgIC8vIExvb2sgZm9yIFgtVElNRVNUQU1QLU1BUCBpbiBoZWFkZXIuXG4gICAgICBpZiAoc3RhcnRzV2l0aChsaW5lLCAnWC1USU1FU1RBTVAtTUFQPScpKSB7XG4gICAgICAgIC8vIE9uY2UgZm91bmQsIG5vIG1vcmUgYXJlIGFsbG93ZWQgYW55d2F5LCBzbyBzdG9wIHNlYXJjaGluZy5cbiAgICAgICAgaW5IZWFkZXIgPSBmYWxzZTtcbiAgICAgICAgLy8gRXh0cmFjdCBMT0NBTCBhbmQgTVBFR1RTLlxuICAgICAgICBsaW5lLnNsaWNlKDE2KS5zcGxpdCgnLCcpLmZvckVhY2godGltZXN0YW1wID0+IHtcbiAgICAgICAgICBpZiAoc3RhcnRzV2l0aCh0aW1lc3RhbXAsICdMT0NBTDonKSkge1xuICAgICAgICAgICAgY3VlVGltZSA9IHRpbWVzdGFtcC5zbGljZSg2KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0c1dpdGgodGltZXN0YW1wLCAnTVBFR1RTOicpKSB7XG4gICAgICAgICAgICB0aW1lc3RhbXBNYXBNUEVHVFMgPSBwYXJzZUludCh0aW1lc3RhbXAuc2xpY2UoNykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gQ29udmVydCBjdWUgdGltZSB0byBzZWNvbmRzXG4gICAgICAgICAgdGltZXN0YW1wTWFwTE9DQUwgPSBjdWVTdHJpbmcybWlsbGlzKGN1ZVRpbWUpIC8gMTAwMDtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBwYXJzaW5nRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gd2l0aG91dCBwYXJzaW5nIFgtVElNRVNUQU1QLU1BUCBsaW5lLlxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKGxpbmUgPT09ICcnKSB7XG4gICAgICAgIGluSGVhZGVyID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFBhcnNlIGxpbmUgYnkgZGVmYXVsdC5cbiAgICBwYXJzZXIucGFyc2UobGluZSArICdcXG4nKTtcbiAgfSk7XG4gIHBhcnNlci5mbHVzaCgpO1xufVxuXG5jb25zdCBJTVNDMV9DT0RFQyA9ICdzdHBwLnR0bWwuaW0xdCc7XG5cbi8vIFRpbWUgZm9ybWF0OiBoOm06czpmcmFtZXMoLnN1YmZyYW1lcylcbmNvbnN0IEhNU0ZfUkVHRVggPSAvXihcXGR7Mix9KTooXFxkezJ9KTooXFxkezJ9KTooXFxkezJ9KVxcLj8oXFxkKyk/JC87XG5cbi8vIFRpbWUgZm9ybWF0OiBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBmcmFtZXMsIHRpY2tzXG5jb25zdCBUSU1FX1VOSVRfUkVHRVggPSAvXihcXGQqKD86XFwuXFxkKik/KShofG18c3xtc3xmfHQpJC87XG5jb25zdCB0ZXh0QWxpZ25Ub0xpbmVBbGlnbiA9IHtcbiAgbGVmdDogJ3N0YXJ0JyxcbiAgY2VudGVyOiAnY2VudGVyJyxcbiAgcmlnaHQ6ICdlbmQnLFxuICBzdGFydDogJ3N0YXJ0JyxcbiAgZW5kOiAnZW5kJ1xufTtcbmZ1bmN0aW9uIHBhcnNlSU1TQzEocGF5bG9hZCwgaW5pdFBUUywgY2FsbEJhY2ssIGVycm9yQ2FsbEJhY2spIHtcbiAgY29uc3QgcmVzdWx0cyA9IGZpbmRCb3gobmV3IFVpbnQ4QXJyYXkocGF5bG9hZCksIFsnbWRhdCddKTtcbiAgaWYgKHJlc3VsdHMubGVuZ3RoID09PSAwKSB7XG4gICAgZXJyb3JDYWxsQmFjayhuZXcgRXJyb3IoJ0NvdWxkIG5vdCBwYXJzZSBJTVNDMSBtZGF0JykpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0dG1sTGlzdCA9IHJlc3VsdHMubWFwKG1kYXQgPT4gdXRmOEFycmF5VG9TdHIobWRhdCkpO1xuICBjb25zdCBzeW5jVGltZSA9IHRvVGltZXNjYWxlRnJvbVNjYWxlKGluaXRQVFMuYmFzZVRpbWUsIDEsIGluaXRQVFMudGltZXNjYWxlKTtcbiAgdHJ5IHtcbiAgICB0dG1sTGlzdC5mb3JFYWNoKHR0bWwgPT4gY2FsbEJhY2socGFyc2VUVE1MKHR0bWwsIHN5bmNUaW1lKSkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGVycm9yQ2FsbEJhY2soZXJyb3IpO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZVRUTUwodHRtbCwgc3luY1RpbWUpIHtcbiAgY29uc3QgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICBjb25zdCB4bWxEb2MgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHR0bWwsICd0ZXh0L3htbCcpO1xuICBjb25zdCB0dCA9IHhtbERvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgndHQnKVswXTtcbiAgaWYgKCF0dCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0dG1sJyk7XG4gIH1cbiAgY29uc3QgZGVmYXVsdFJhdGVJbmZvID0ge1xuICAgIGZyYW1lUmF0ZTogMzAsXG4gICAgc3ViRnJhbWVSYXRlOiAxLFxuICAgIGZyYW1lUmF0ZU11bHRpcGxpZXI6IDAsXG4gICAgdGlja1JhdGU6IDBcbiAgfTtcbiAgY29uc3QgcmF0ZUluZm8gPSBPYmplY3Qua2V5cyhkZWZhdWx0UmF0ZUluZm8pLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IHtcbiAgICByZXN1bHRba2V5XSA9IHR0LmdldEF0dHJpYnV0ZShgdHRwOiR7a2V5fWApIHx8IGRlZmF1bHRSYXRlSW5mb1trZXldO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIHt9KTtcbiAgY29uc3QgdHJpbSA9IHR0LmdldEF0dHJpYnV0ZSgneG1sOnNwYWNlJykgIT09ICdwcmVzZXJ2ZSc7XG4gIGNvbnN0IHN0eWxlRWxlbWVudHMgPSBjb2xsZWN0aW9uVG9EaWN0aW9uYXJ5KGdldEVsZW1lbnRDb2xsZWN0aW9uKHR0LCAnc3R5bGluZycsICdzdHlsZScpKTtcbiAgY29uc3QgcmVnaW9uRWxlbWVudHMgPSBjb2xsZWN0aW9uVG9EaWN0aW9uYXJ5KGdldEVsZW1lbnRDb2xsZWN0aW9uKHR0LCAnbGF5b3V0JywgJ3JlZ2lvbicpKTtcbiAgY29uc3QgY3VlRWxlbWVudHMgPSBnZXRFbGVtZW50Q29sbGVjdGlvbih0dCwgJ2JvZHknLCAnW2JlZ2luXScpO1xuICByZXR1cm4gW10ubWFwLmNhbGwoY3VlRWxlbWVudHMsIGN1ZUVsZW1lbnQgPT4ge1xuICAgIGNvbnN0IGN1ZVRleHQgPSBnZXRUZXh0Q29udGVudChjdWVFbGVtZW50LCB0cmltKTtcbiAgICBpZiAoIWN1ZVRleHQgfHwgIWN1ZUVsZW1lbnQuaGFzQXR0cmlidXRlKCdiZWdpbicpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gcGFyc2VUdG1sVGltZShjdWVFbGVtZW50LmdldEF0dHJpYnV0ZSgnYmVnaW4nKSwgcmF0ZUluZm8pO1xuICAgIGNvbnN0IGR1cmF0aW9uID0gcGFyc2VUdG1sVGltZShjdWVFbGVtZW50LmdldEF0dHJpYnV0ZSgnZHVyJyksIHJhdGVJbmZvKTtcbiAgICBsZXQgZW5kVGltZSA9IHBhcnNlVHRtbFRpbWUoY3VlRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2VuZCcpLCByYXRlSW5mbyk7XG4gICAgaWYgKHN0YXJ0VGltZSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgdGltZXN0YW1wUGFyc2luZ0Vycm9yKGN1ZUVsZW1lbnQpO1xuICAgIH1cbiAgICBpZiAoZW5kVGltZSA9PT0gbnVsbCkge1xuICAgICAgaWYgKGR1cmF0aW9uID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IHRpbWVzdGFtcFBhcnNpbmdFcnJvcihjdWVFbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIGVuZFRpbWUgPSBzdGFydFRpbWUgKyBkdXJhdGlvbjtcbiAgICB9XG4gICAgY29uc3QgY3VlID0gbmV3IFZUVEN1ZShzdGFydFRpbWUgLSBzeW5jVGltZSwgZW5kVGltZSAtIHN5bmNUaW1lLCBjdWVUZXh0KTtcbiAgICBjdWUuaWQgPSBnZW5lcmF0ZUN1ZUlkKGN1ZS5zdGFydFRpbWUsIGN1ZS5lbmRUaW1lLCBjdWUudGV4dCk7XG4gICAgY29uc3QgcmVnaW9uID0gcmVnaW9uRWxlbWVudHNbY3VlRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JlZ2lvbicpXTtcbiAgICBjb25zdCBzdHlsZSA9IHN0eWxlRWxlbWVudHNbY3VlRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyldO1xuXG4gICAgLy8gQXBwbHkgc3R5bGVzIHRvIGN1ZVxuICAgIGNvbnN0IHN0eWxlcyA9IGdldFR0bWxTdHlsZXMocmVnaW9uLCBzdHlsZSwgc3R5bGVFbGVtZW50cyk7XG4gICAgY29uc3Qge1xuICAgICAgdGV4dEFsaWduXG4gICAgfSA9IHN0eWxlcztcbiAgICBpZiAodGV4dEFsaWduKSB7XG4gICAgICAvLyBjdWUucG9zaXRpb25BbGlnbiBub3Qgc2V0dGFibGUgaW4gRkZ+MjAxNlxuICAgICAgY29uc3QgbGluZUFsaWduID0gdGV4dEFsaWduVG9MaW5lQWxpZ25bdGV4dEFsaWduXTtcbiAgICAgIGlmIChsaW5lQWxpZ24pIHtcbiAgICAgICAgY3VlLmxpbmVBbGlnbiA9IGxpbmVBbGlnbjtcbiAgICAgIH1cbiAgICAgIGN1ZS5hbGlnbiA9IHRleHRBbGlnbjtcbiAgICB9XG4gICAgX2V4dGVuZHMoY3VlLCBzdHlsZXMpO1xuICAgIHJldHVybiBjdWU7XG4gIH0pLmZpbHRlcihjdWUgPT4gY3VlICE9PSBudWxsKTtcbn1cbmZ1bmN0aW9uIGdldEVsZW1lbnRDb2xsZWN0aW9uKGZyb21FbGVtZW50LCBwYXJlbnROYW1lLCBjaGlsZE5hbWUpIHtcbiAgY29uc3QgcGFyZW50ID0gZnJvbUVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUocGFyZW50TmFtZSlbMF07XG4gIGlmIChwYXJlbnQpIHtcbiAgICByZXR1cm4gW10uc2xpY2UuY2FsbChwYXJlbnQucXVlcnlTZWxlY3RvckFsbChjaGlsZE5hbWUpKTtcbiAgfVxuICByZXR1cm4gW107XG59XG5mdW5jdGlvbiBjb2xsZWN0aW9uVG9EaWN0aW9uYXJ5KGVsZW1lbnRzV2l0aElkKSB7XG4gIHJldHVybiBlbGVtZW50c1dpdGhJZC5yZWR1Y2UoKGRpY3QsIGVsZW1lbnQpID0+IHtcbiAgICBjb25zdCBpZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd4bWw6aWQnKTtcbiAgICBpZiAoaWQpIHtcbiAgICAgIGRpY3RbaWRdID0gZWxlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIGRpY3Q7XG4gIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIGdldFRleHRDb250ZW50KGVsZW1lbnQsIHRyaW0pIHtcbiAgcmV0dXJuIFtdLnNsaWNlLmNhbGwoZWxlbWVudC5jaGlsZE5vZGVzKS5yZWR1Y2UoKHN0ciwgbm9kZSwgaSkgPT4ge1xuICAgIHZhciBfbm9kZSRjaGlsZE5vZGVzO1xuICAgIGlmIChub2RlLm5vZGVOYW1lID09PSAnYnInICYmIGkpIHtcbiAgICAgIHJldHVybiBzdHIgKyAnXFxuJztcbiAgICB9XG4gICAgaWYgKChfbm9kZSRjaGlsZE5vZGVzID0gbm9kZS5jaGlsZE5vZGVzKSAhPSBudWxsICYmIF9ub2RlJGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZ2V0VGV4dENvbnRlbnQobm9kZSwgdHJpbSk7XG4gICAgfSBlbHNlIGlmICh0cmltKSB7XG4gICAgICByZXR1cm4gc3RyICsgbm9kZS50ZXh0Q29udGVudC50cmltKCkucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyICsgbm9kZS50ZXh0Q29udGVudDtcbiAgfSwgJycpO1xufVxuZnVuY3Rpb24gZ2V0VHRtbFN0eWxlcyhyZWdpb24sIHN0eWxlLCBzdHlsZUVsZW1lbnRzKSB7XG4gIGNvbnN0IHR0c05zID0gJ2h0dHA6Ly93d3cudzMub3JnL25zL3R0bWwjc3R5bGluZyc7XG4gIGxldCByZWdpb25TdHlsZSA9IG51bGw7XG4gIGNvbnN0IHN0eWxlQXR0cmlidXRlcyA9IFsnZGlzcGxheUFsaWduJywgJ3RleHRBbGlnbicsICdjb2xvcicsICdiYWNrZ3JvdW5kQ29sb3InLCAnZm9udFNpemUnLCAnZm9udEZhbWlseSdcbiAgLy8gJ2ZvbnRXZWlnaHQnLFxuICAvLyAnbGluZUhlaWdodCcsXG4gIC8vICd3cmFwT3B0aW9uJyxcbiAgLy8gJ2ZvbnRTdHlsZScsXG4gIC8vICdkaXJlY3Rpb24nLFxuICAvLyAnd3JpdGluZ01vZGUnXG4gIF07XG4gIGNvbnN0IHJlZ2lvblN0eWxlTmFtZSA9IHJlZ2lvbiAhPSBudWxsICYmIHJlZ2lvbi5oYXNBdHRyaWJ1dGUoJ3N0eWxlJykgPyByZWdpb24uZ2V0QXR0cmlidXRlKCdzdHlsZScpIDogbnVsbDtcbiAgaWYgKHJlZ2lvblN0eWxlTmFtZSAmJiBzdHlsZUVsZW1lbnRzLmhhc093blByb3BlcnR5KHJlZ2lvblN0eWxlTmFtZSkpIHtcbiAgICByZWdpb25TdHlsZSA9IHN0eWxlRWxlbWVudHNbcmVnaW9uU3R5bGVOYW1lXTtcbiAgfVxuICByZXR1cm4gc3R5bGVBdHRyaWJ1dGVzLnJlZHVjZSgoc3R5bGVzLCBuYW1lKSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRBdHRyaWJ1dGVOUyhzdHlsZSwgdHRzTnMsIG5hbWUpIHx8IGdldEF0dHJpYnV0ZU5TKHJlZ2lvbiwgdHRzTnMsIG5hbWUpIHx8IGdldEF0dHJpYnV0ZU5TKHJlZ2lvblN0eWxlLCB0dHNOcywgbmFtZSk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBzdHlsZXNbbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlcztcbiAgfSwge30pO1xufVxuZnVuY3Rpb24gZ2V0QXR0cmlidXRlTlMoZWxlbWVudCwgbnMsIG5hbWUpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQuaGFzQXR0cmlidXRlTlMobnMsIG5hbWUpID8gZWxlbWVudC5nZXRBdHRyaWJ1dGVOUyhucywgbmFtZSkgOiBudWxsO1xufVxuZnVuY3Rpb24gdGltZXN0YW1wUGFyc2luZ0Vycm9yKG5vZGUpIHtcbiAgcmV0dXJuIG5ldyBFcnJvcihgQ291bGQgbm90IHBhcnNlIHR0bWwgdGltZXN0YW1wICR7bm9kZX1gKTtcbn1cbmZ1bmN0aW9uIHBhcnNlVHRtbFRpbWUodGltZUF0dHJpYnV0ZVZhbHVlLCByYXRlSW5mbykge1xuICBpZiAoIXRpbWVBdHRyaWJ1dGVWYWx1ZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxldCBzZWNvbmRzID0gcGFyc2VUaW1lU3RhbXAodGltZUF0dHJpYnV0ZVZhbHVlKTtcbiAgaWYgKHNlY29uZHMgPT09IG51bGwpIHtcbiAgICBpZiAoSE1TRl9SRUdFWC50ZXN0KHRpbWVBdHRyaWJ1dGVWYWx1ZSkpIHtcbiAgICAgIHNlY29uZHMgPSBwYXJzZUhvdXJzTWludXRlc1NlY29uZHNGcmFtZXModGltZUF0dHJpYnV0ZVZhbHVlLCByYXRlSW5mbyk7XG4gICAgfSBlbHNlIGlmIChUSU1FX1VOSVRfUkVHRVgudGVzdCh0aW1lQXR0cmlidXRlVmFsdWUpKSB7XG4gICAgICBzZWNvbmRzID0gcGFyc2VUaW1lVW5pdHModGltZUF0dHJpYnV0ZVZhbHVlLCByYXRlSW5mbyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZWNvbmRzO1xufVxuZnVuY3Rpb24gcGFyc2VIb3Vyc01pbnV0ZXNTZWNvbmRzRnJhbWVzKHRpbWVBdHRyaWJ1dGVWYWx1ZSwgcmF0ZUluZm8pIHtcbiAgY29uc3QgbSA9IEhNU0ZfUkVHRVguZXhlYyh0aW1lQXR0cmlidXRlVmFsdWUpO1xuICBjb25zdCBmcmFtZXMgPSAobVs0XSB8IDApICsgKG1bNV0gfCAwKSAvIHJhdGVJbmZvLnN1YkZyYW1lUmF0ZTtcbiAgcmV0dXJuIChtWzFdIHwgMCkgKiAzNjAwICsgKG1bMl0gfCAwKSAqIDYwICsgKG1bM10gfCAwKSArIGZyYW1lcyAvIHJhdGVJbmZvLmZyYW1lUmF0ZTtcbn1cbmZ1bmN0aW9uIHBhcnNlVGltZVVuaXRzKHRpbWVBdHRyaWJ1dGVWYWx1ZSwgcmF0ZUluZm8pIHtcbiAgY29uc3QgbSA9IFRJTUVfVU5JVF9SRUdFWC5leGVjKHRpbWVBdHRyaWJ1dGVWYWx1ZSk7XG4gIGNvbnN0IHZhbHVlID0gTnVtYmVyKG1bMV0pO1xuICBjb25zdCB1bml0ID0gbVsyXTtcbiAgc3dpdGNoICh1bml0KSB7XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gdmFsdWUgKiAzNjAwO1xuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIHZhbHVlICogNjA7XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIHZhbHVlICogMTAwMDtcbiAgICBjYXNlICdmJzpcbiAgICAgIHJldHVybiB2YWx1ZSAvIHJhdGVJbmZvLmZyYW1lUmF0ZTtcbiAgICBjYXNlICd0JzpcbiAgICAgIHJldHVybiB2YWx1ZSAvIHJhdGVJbmZvLnRpY2tSYXRlO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuY2xhc3MgVGltZWxpbmVDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLkN1ZXMgPSB2b2lkIDA7XG4gICAgdGhpcy50ZXh0VHJhY2tzID0gW107XG4gICAgdGhpcy50cmFja3MgPSBbXTtcbiAgICB0aGlzLmluaXRQVFMgPSBbXTtcbiAgICB0aGlzLnVucGFyc2VkVnR0RnJhZ3MgPSBbXTtcbiAgICB0aGlzLmNhcHRpb25zVHJhY2tzID0ge307XG4gICAgdGhpcy5ub25OYXRpdmVDYXB0aW9uc1RyYWNrcyA9IHt9O1xuICAgIHRoaXMuY2VhNjA4UGFyc2VyMSA9IHZvaWQgMDtcbiAgICB0aGlzLmNlYTYwOFBhcnNlcjIgPSB2b2lkIDA7XG4gICAgdGhpcy5sYXN0Q2MgPSAtMTtcbiAgICAvLyBMYXN0IHZpZGVvIChDRUEtNjA4KSBmcmFnbWVudCBDQ1xuICAgIHRoaXMubGFzdFNuID0gLTE7XG4gICAgLy8gTGFzdCB2aWRlbyAoQ0VBLTYwOCkgZnJhZ21lbnQgTVNOXG4gICAgdGhpcy5sYXN0UGFydEluZGV4ID0gLTE7XG4gICAgLy8gTGFzdCB2aWRlbyAoQ0VBLTYwOCkgZnJhZ21lbnQgUGFydCBJbmRleFxuICAgIHRoaXMucHJldkNDID0gLTE7XG4gICAgLy8gTGFzdCBzdWJ0aXRsZSBmcmFnbWVudCBDQ1xuICAgIHRoaXMudnR0Q0NzID0gbmV3VlRUQ0NzKCk7XG4gICAgdGhpcy5jYXB0aW9uc1Byb3BlcnRpZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgIHRoaXMuQ3VlcyA9IGhscy5jb25maWcuY3VlSGFuZGxlcjtcbiAgICB0aGlzLmNhcHRpb25zUHJvcGVydGllcyA9IHtcbiAgICAgIHRleHRUcmFjazE6IHtcbiAgICAgICAgbGFiZWw6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMUxhYmVsLFxuICAgICAgICBsYW5ndWFnZUNvZGU6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMUxhbmd1YWdlQ29kZVxuICAgICAgfSxcbiAgICAgIHRleHRUcmFjazI6IHtcbiAgICAgICAgbGFiZWw6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMkxhYmVsLFxuICAgICAgICBsYW5ndWFnZUNvZGU6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMkxhbmd1YWdlQ29kZVxuICAgICAgfSxcbiAgICAgIHRleHRUcmFjazM6IHtcbiAgICAgICAgbGFiZWw6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrM0xhYmVsLFxuICAgICAgICBsYW5ndWFnZUNvZGU6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrM0xhbmd1YWdlQ29kZVxuICAgICAgfSxcbiAgICAgIHRleHRUcmFjazQ6IHtcbiAgICAgICAgbGFiZWw6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrNExhYmVsLFxuICAgICAgICBsYW5ndWFnZUNvZGU6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrNExhbmd1YWdlQ29kZVxuICAgICAgfVxuICAgIH07XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURFRCwgdGhpcy5vbk1hbmlmZXN0TG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLlNVQlRJVExFX1RSQUNLU19VUERBVEVELCB0aGlzLm9uU3VidGl0bGVUcmFja3NVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfTE9BRElORywgdGhpcy5vbkZyYWdMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfTE9BREVELCB0aGlzLm9uRnJhZ0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIHRoaXMub25GcmFnUGFyc2luZ1VzZXJkYXRhLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfREVDUllQVEVELCB0aGlzLm9uRnJhZ0RlY3J5cHRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5JTklUX1BUU19GT1VORCwgdGhpcy5vbkluaXRQdHNGb3VuZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5TVUJUSVRMRV9UUkFDS1NfQ0xFQVJFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tzQ2xlYXJlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURFRCwgdGhpcy5vbk1hbmlmZXN0TG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5TVUJUSVRMRV9UUkFDS1NfVVBEQVRFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19MT0FESU5HLCB0aGlzLm9uRnJhZ0xvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfTE9BREVELCB0aGlzLm9uRnJhZ0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19QQVJTSU5HX1VTRVJEQVRBLCB0aGlzLm9uRnJhZ1BhcnNpbmdVc2VyZGF0YSwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19ERUNSWVBURUQsIHRoaXMub25GcmFnRGVjcnlwdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5JTklUX1BUU19GT1VORCwgdGhpcy5vbkluaXRQdHNGb3VuZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuU1VCVElUTEVfVFJBQ0tTX0NMRUFSRUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrc0NsZWFyZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSB0aGlzLmNvbmZpZyA9IG51bGw7XG4gICAgdGhpcy5jZWE2MDhQYXJzZXIxID0gdGhpcy5jZWE2MDhQYXJzZXIyID0gdW5kZWZpbmVkO1xuICB9XG4gIGluaXRDZWE2MDhQYXJzZXJzKCkge1xuICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVDRUE3MDhDYXB0aW9ucyAmJiAoIXRoaXMuY2VhNjA4UGFyc2VyMSB8fCAhdGhpcy5jZWE2MDhQYXJzZXIyKSkge1xuICAgICAgY29uc3QgY2hhbm5lbDEgPSBuZXcgT3V0cHV0RmlsdGVyKHRoaXMsICd0ZXh0VHJhY2sxJyk7XG4gICAgICBjb25zdCBjaGFubmVsMiA9IG5ldyBPdXRwdXRGaWx0ZXIodGhpcywgJ3RleHRUcmFjazInKTtcbiAgICAgIGNvbnN0IGNoYW5uZWwzID0gbmV3IE91dHB1dEZpbHRlcih0aGlzLCAndGV4dFRyYWNrMycpO1xuICAgICAgY29uc3QgY2hhbm5lbDQgPSBuZXcgT3V0cHV0RmlsdGVyKHRoaXMsICd0ZXh0VHJhY2s0Jyk7XG4gICAgICB0aGlzLmNlYTYwOFBhcnNlcjEgPSBuZXcgQ2VhNjA4UGFyc2VyKDEsIGNoYW5uZWwxLCBjaGFubmVsMik7XG4gICAgICB0aGlzLmNlYTYwOFBhcnNlcjIgPSBuZXcgQ2VhNjA4UGFyc2VyKDMsIGNoYW5uZWwzLCBjaGFubmVsNCk7XG4gICAgfVxuICB9XG4gIGFkZEN1ZXModHJhY2tOYW1lLCBzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbiwgY3VlUmFuZ2VzKSB7XG4gICAgLy8gc2tpcCBjdWVzIHdoaWNoIG92ZXJsYXAgbW9yZSB0aGFuIDUwJSB3aXRoIHByZXZpb3VzbHkgcGFyc2VkIHRpbWUgcmFuZ2VzXG4gICAgbGV0IG1lcmdlZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSBjdWVSYW5nZXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICBjb25zdCBjdWVSYW5nZSA9IGN1ZVJhbmdlc1tpXTtcbiAgICAgIGNvbnN0IG92ZXJsYXAgPSBpbnRlcnNlY3Rpb24oY3VlUmFuZ2VbMF0sIGN1ZVJhbmdlWzFdLCBzdGFydFRpbWUsIGVuZFRpbWUpO1xuICAgICAgaWYgKG92ZXJsYXAgPj0gMCkge1xuICAgICAgICBjdWVSYW5nZVswXSA9IE1hdGgubWluKGN1ZVJhbmdlWzBdLCBzdGFydFRpbWUpO1xuICAgICAgICBjdWVSYW5nZVsxXSA9IE1hdGgubWF4KGN1ZVJhbmdlWzFdLCBlbmRUaW1lKTtcbiAgICAgICAgbWVyZ2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKG92ZXJsYXAgLyAoZW5kVGltZSAtIHN0YXJ0VGltZSkgPiAwLjUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFtZXJnZWQpIHtcbiAgICAgIGN1ZVJhbmdlcy5wdXNoKFtzdGFydFRpbWUsIGVuZFRpbWVdKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29uZmlnLnJlbmRlclRleHRUcmFja3NOYXRpdmVseSkge1xuICAgICAgY29uc3QgdHJhY2sgPSB0aGlzLmNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV07XG4gICAgICB0aGlzLkN1ZXMubmV3Q3VlKHRyYWNrLCBzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGN1ZXMgPSB0aGlzLkN1ZXMubmV3Q3VlKG51bGwsIHN0YXJ0VGltZSwgZW5kVGltZSwgc2NyZWVuKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkNVRVNfUEFSU0VELCB7XG4gICAgICAgIHR5cGU6ICdjYXB0aW9ucycsXG4gICAgICAgIGN1ZXMsXG4gICAgICAgIHRyYWNrOiB0cmFja05hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRyaWdnZXJlZCB3aGVuIGFuIGluaXRpYWwgUFRTIGlzIGZvdW5kOyB1c2VkIGZvciBzeW5jaHJvbmlzYXRpb24gb2YgV2ViVlRULlxuICBvbkluaXRQdHNGb3VuZChldmVudCwge1xuICAgIGZyYWcsXG4gICAgaWQsXG4gICAgaW5pdFBUUyxcbiAgICB0aW1lc2NhbGVcbiAgfSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHVucGFyc2VkVnR0RnJhZ3NcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoaWQgPT09ICdtYWluJykge1xuICAgICAgdGhpcy5pbml0UFRTW2ZyYWcuY2NdID0ge1xuICAgICAgICBiYXNlVGltZTogaW5pdFBUUyxcbiAgICAgICAgdGltZXNjYWxlXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIER1ZSB0byBhc3luY2hyb25vdXMgcHJvY2Vzc2luZywgaW5pdGlhbCBQVFMgbWF5IGFycml2ZSBsYXRlciB0aGFuIHRoZSBmaXJzdCBWVFQgZnJhZ21lbnRzIGFyZSBsb2FkZWQuXG4gICAgLy8gUGFyc2UgYW55IHVucGFyc2VkIGZyYWdtZW50cyB1cG9uIHJlY2VpdmluZyB0aGUgaW5pdGlhbCBQVFMuXG4gICAgaWYgKHVucGFyc2VkVnR0RnJhZ3MubGVuZ3RoKSB7XG4gICAgICB0aGlzLnVucGFyc2VkVnR0RnJhZ3MgPSBbXTtcbiAgICAgIHVucGFyc2VkVnR0RnJhZ3MuZm9yRWFjaChmcmFnID0+IHtcbiAgICAgICAgdGhpcy5vbkZyYWdMb2FkZWQoRXZlbnRzLkZSQUdfTE9BREVELCBmcmFnKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXRFeGlzdGluZ1RyYWNrKGxhYmVsLCBsYW5ndWFnZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lZGlhXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lZGlhLnRleHRUcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdGV4dFRyYWNrID0gbWVkaWEudGV4dFRyYWNrc1tpXTtcbiAgICAgICAgaWYgKGNhblJldXNlVnR0VGV4dFRyYWNrKHRleHRUcmFjaywge1xuICAgICAgICAgIG5hbWU6IGxhYmVsLFxuICAgICAgICAgIGxhbmc6IGxhbmd1YWdlLFxuICAgICAgICAgIGF0dHJzOiB7fVxuICAgICAgICB9KSkge1xuICAgICAgICAgIHJldHVybiB0ZXh0VHJhY2s7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY3JlYXRlQ2FwdGlvbnNUcmFjayh0cmFja05hbWUpIHtcbiAgICBpZiAodGhpcy5jb25maWcucmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5KSB7XG4gICAgICB0aGlzLmNyZWF0ZU5hdGl2ZVRyYWNrKHRyYWNrTmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3JlYXRlTm9uTmF0aXZlVHJhY2sodHJhY2tOYW1lKTtcbiAgICB9XG4gIH1cbiAgY3JlYXRlTmF0aXZlVHJhY2sodHJhY2tOYW1lKSB7XG4gICAgaWYgKHRoaXMuY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjYXB0aW9uc1Byb3BlcnRpZXMsXG4gICAgICBjYXB0aW9uc1RyYWNrcyxcbiAgICAgIG1lZGlhXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgbGFiZWwsXG4gICAgICBsYW5ndWFnZUNvZGVcbiAgICB9ID0gY2FwdGlvbnNQcm9wZXJ0aWVzW3RyYWNrTmFtZV07XG4gICAgLy8gRW5hYmxlIHJldXNlIG9mIGV4aXN0aW5nIHRleHQgdHJhY2suXG4gICAgY29uc3QgZXhpc3RpbmdUcmFjayA9IHRoaXMuZ2V0RXhpc3RpbmdUcmFjayhsYWJlbCwgbGFuZ3VhZ2VDb2RlKTtcbiAgICBpZiAoIWV4aXN0aW5nVHJhY2spIHtcbiAgICAgIGNvbnN0IHRleHRUcmFjayA9IHRoaXMuY3JlYXRlVGV4dFRyYWNrKCdjYXB0aW9ucycsIGxhYmVsLCBsYW5ndWFnZUNvZGUpO1xuICAgICAgaWYgKHRleHRUcmFjaykge1xuICAgICAgICAvLyBTZXQgYSBzcGVjaWFsIHByb3BlcnR5IG9uIHRoZSB0cmFjayBzbyB3ZSBrbm93IGl0J3MgbWFuYWdlZCBieSBIbHMuanNcbiAgICAgICAgdGV4dFRyYWNrW3RyYWNrTmFtZV0gPSB0cnVlO1xuICAgICAgICBjYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdID0gdGV4dFRyYWNrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdID0gZXhpc3RpbmdUcmFjaztcbiAgICAgIGNsZWFyQ3VycmVudEN1ZXMoY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSk7XG4gICAgICBzZW5kQWRkVHJhY2tFdmVudChjYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdLCBtZWRpYSk7XG4gICAgfVxuICB9XG4gIGNyZWF0ZU5vbk5hdGl2ZVRyYWNrKHRyYWNrTmFtZSkge1xuICAgIGlmICh0aGlzLm5vbk5hdGl2ZUNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQ3JlYXRlIGEgbGlzdCBvZiBhIHNpbmdsZSB0cmFjayBmb3IgdGhlIHByb3ZpZGVyIHRvIGNvbnN1bWVcbiAgICBjb25zdCB0cmFja1Byb3BlcnRpZXMgPSB0aGlzLmNhcHRpb25zUHJvcGVydGllc1t0cmFja05hbWVdO1xuICAgIGlmICghdHJhY2tQcm9wZXJ0aWVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxhYmVsID0gdHJhY2tQcm9wZXJ0aWVzLmxhYmVsO1xuICAgIGNvbnN0IHRyYWNrID0ge1xuICAgICAgX2lkOiB0cmFja05hbWUsXG4gICAgICBsYWJlbCxcbiAgICAgIGtpbmQ6ICdjYXB0aW9ucycsXG4gICAgICBkZWZhdWx0OiB0cmFja1Byb3BlcnRpZXMubWVkaWEgPyAhIXRyYWNrUHJvcGVydGllcy5tZWRpYS5kZWZhdWx0IDogZmFsc2UsXG4gICAgICBjbG9zZWRDYXB0aW9uczogdHJhY2tQcm9wZXJ0aWVzLm1lZGlhXG4gICAgfTtcbiAgICB0aGlzLm5vbk5hdGl2ZUNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0gPSB0cmFjaztcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5OT05fTkFUSVZFX1RFWFRfVFJBQ0tTX0ZPVU5ELCB7XG4gICAgICB0cmFja3M6IFt0cmFja11cbiAgICB9KTtcbiAgfVxuICBjcmVhdGVUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmcpIHtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gbWVkaWEuYWRkVGV4dFRyYWNrKGtpbmQsIGxhYmVsLCBsYW5nKTtcbiAgfVxuICBvbk1lZGlhQXR0YWNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgdGhpcy5fY2xlYW5UcmFja3MoKTtcbiAgfVxuICBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNhcHRpb25zVHJhY2tzXG4gICAgfSA9IHRoaXM7XG4gICAgT2JqZWN0LmtleXMoY2FwdGlvbnNUcmFja3MpLmZvckVhY2godHJhY2tOYW1lID0+IHtcbiAgICAgIGNsZWFyQ3VycmVudEN1ZXMoY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSk7XG4gICAgICBkZWxldGUgY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXTtcbiAgICB9KTtcbiAgICB0aGlzLm5vbk5hdGl2ZUNhcHRpb25zVHJhY2tzID0ge307XG4gIH1cbiAgb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgLy8gRGV0ZWN0IGRpc2NvbnRpbnVpdHkgaW4gdmlkZW8gZnJhZ21lbnQgKENFQS02MDgpIHBhcnNpbmdcbiAgICB0aGlzLmxhc3RDYyA9IC0xO1xuICAgIHRoaXMubGFzdFNuID0gLTE7XG4gICAgdGhpcy5sYXN0UGFydEluZGV4ID0gLTE7XG4gICAgLy8gRGV0ZWN0IGRpc2NvbnRpbnVpdHkgaW4gc3VidGl0bGUgbWFuaWZlc3RzXG4gICAgdGhpcy5wcmV2Q0MgPSAtMTtcbiAgICB0aGlzLnZ0dENDcyA9IG5ld1ZUVENDcygpO1xuICAgIC8vIFJlc2V0IHRyYWNrc1xuICAgIHRoaXMuX2NsZWFuVHJhY2tzKCk7XG4gICAgdGhpcy50cmFja3MgPSBbXTtcbiAgICB0aGlzLmNhcHRpb25zVHJhY2tzID0ge307XG4gICAgdGhpcy5ub25OYXRpdmVDYXB0aW9uc1RyYWNrcyA9IHt9O1xuICAgIHRoaXMudGV4dFRyYWNrcyA9IFtdO1xuICAgIHRoaXMudW5wYXJzZWRWdHRGcmFncyA9IFtdO1xuICAgIHRoaXMuaW5pdFBUUyA9IFtdO1xuICAgIGlmICh0aGlzLmNlYTYwOFBhcnNlcjEgJiYgdGhpcy5jZWE2MDhQYXJzZXIyKSB7XG4gICAgICB0aGlzLmNlYTYwOFBhcnNlcjEucmVzZXQoKTtcbiAgICAgIHRoaXMuY2VhNjA4UGFyc2VyMi5yZXNldCgpO1xuICAgIH1cbiAgfVxuICBfY2xlYW5UcmFja3MoKSB7XG4gICAgLy8gY2xlYXIgb3V0ZGF0ZWQgc3VidGl0bGVzXG4gICAgY29uc3Qge1xuICAgICAgbWVkaWFcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIW1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRleHRUcmFja3MgPSBtZWRpYS50ZXh0VHJhY2tzO1xuICAgIGlmICh0ZXh0VHJhY2tzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHRUcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2xlYXJDdXJyZW50Q3Vlcyh0ZXh0VHJhY2tzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgb25TdWJ0aXRsZVRyYWNrc1VwZGF0ZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB0cmFja3MgPSBkYXRhLnN1YnRpdGxlVHJhY2tzIHx8IFtdO1xuICAgIGNvbnN0IGhhc0lNU0MxID0gdHJhY2tzLnNvbWUodHJhY2sgPT4gdHJhY2sudGV4dENvZGVjID09PSBJTVNDMV9DT0RFQyk7XG4gICAgaWYgKHRoaXMuY29uZmlnLmVuYWJsZVdlYlZUVCB8fCBoYXNJTVNDMSAmJiB0aGlzLmNvbmZpZy5lbmFibGVJTVNDMSkge1xuICAgICAgY29uc3QgbGlzdElzSWRlbnRpY2FsID0gc3VidGl0bGVPcHRpb25zSWRlbnRpY2FsKHRoaXMudHJhY2tzLCB0cmFja3MpO1xuICAgICAgaWYgKGxpc3RJc0lkZW50aWNhbCkge1xuICAgICAgICB0aGlzLnRyYWNrcyA9IHRyYWNrcztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy50ZXh0VHJhY2tzID0gW107XG4gICAgICB0aGlzLnRyYWNrcyA9IHRyYWNrcztcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5yZW5kZXJUZXh0VHJhY2tzTmF0aXZlbHkpIHtcbiAgICAgICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgICBjb25zdCBpblVzZVRyYWNrcyA9IG1lZGlhID8gZmlsdGVyU3VidGl0bGVUcmFja3MobWVkaWEudGV4dFRyYWNrcykgOiBudWxsO1xuICAgICAgICB0aGlzLnRyYWNrcy5mb3JFYWNoKCh0cmFjaywgaW5kZXgpID0+IHtcbiAgICAgICAgICAvLyBSZXVzZSB0cmFja3Mgd2l0aCB0aGUgc2FtZSBsYWJlbCBhbmQgbGFuZywgYnV0IGRvIG5vdCByZXVzZSA2MDgvNzA4IHRyYWNrc1xuICAgICAgICAgIGxldCB0ZXh0VHJhY2s7XG4gICAgICAgICAgaWYgKGluVXNlVHJhY2tzKSB7XG4gICAgICAgICAgICBsZXQgaW5Vc2VUcmFjayA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluVXNlVHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmIChpblVzZVRyYWNrc1tpXSAmJiBjYW5SZXVzZVZ0dFRleHRUcmFjayhpblVzZVRyYWNrc1tpXSwgdHJhY2spKSB7XG4gICAgICAgICAgICAgICAgaW5Vc2VUcmFjayA9IGluVXNlVHJhY2tzW2ldO1xuICAgICAgICAgICAgICAgIGluVXNlVHJhY2tzW2ldID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluVXNlVHJhY2spIHtcbiAgICAgICAgICAgICAgdGV4dFRyYWNrID0gaW5Vc2VUcmFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRleHRUcmFjaykge1xuICAgICAgICAgICAgY2xlYXJDdXJyZW50Q3Vlcyh0ZXh0VHJhY2spO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0VHJhY2tLaW5kID0gY2FwdGlvbnNPclN1YnRpdGxlc0Zyb21DaGFyYWN0ZXJpc3RpY3ModHJhY2spO1xuICAgICAgICAgICAgdGV4dFRyYWNrID0gdGhpcy5jcmVhdGVUZXh0VHJhY2sodGV4dFRyYWNrS2luZCwgdHJhY2submFtZSwgdHJhY2subGFuZyk7XG4gICAgICAgICAgICBpZiAodGV4dFRyYWNrKSB7XG4gICAgICAgICAgICAgIHRleHRUcmFjay5tb2RlID0gJ2Rpc2FibGVkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRleHRUcmFjaykge1xuICAgICAgICAgICAgdGhpcy50ZXh0VHJhY2tzLnB1c2godGV4dFRyYWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXYXJuIHdoZW4gdmlkZW8gZWxlbWVudCBoYXMgY2FwdGlvbnMgb3Igc3VidGl0bGUgVGV4dFRyYWNrcyBjYXJyaWVkIG92ZXIgZnJvbSBhbm90aGVyIHNvdXJjZVxuICAgICAgICBpZiAoaW5Vc2VUcmFja3MgIT0gbnVsbCAmJiBpblVzZVRyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCB1bnVzZWRUZXh0VHJhY2tzID0gaW5Vc2VUcmFja3MuZmlsdGVyKHQgPT4gdCAhPT0gbnVsbCkubWFwKHQgPT4gdC5sYWJlbCk7XG4gICAgICAgICAgaWYgKHVudXNlZFRleHRUcmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihgTWVkaWEgZWxlbWVudCBjb250YWlucyB1bnVzZWQgc3VidGl0bGUgdHJhY2tzOiAke3VudXNlZFRleHRUcmFja3Muam9pbignLCAnKX0uIFJlcGxhY2UgbWVkaWEgZWxlbWVudCBmb3IgZWFjaCBzb3VyY2UgdG8gY2xlYXIgVGV4dFRyYWNrcyBhbmQgY2FwdGlvbnMgbWVudS5gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy50cmFja3MubGVuZ3RoKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIGxpc3Qgb2YgdHJhY2tzIGZvciB0aGUgcHJvdmlkZXIgdG8gY29uc3VtZVxuICAgICAgICBjb25zdCB0cmFja3NMaXN0ID0gdGhpcy50cmFja3MubWFwKHRyYWNrID0+IHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGFiZWw6IHRyYWNrLm5hbWUsXG4gICAgICAgICAgICBraW5kOiB0cmFjay50eXBlLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICBkZWZhdWx0OiB0cmFjay5kZWZhdWx0LFxuICAgICAgICAgICAgc3VidGl0bGVUcmFjazogdHJhY2tcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTk9OX05BVElWRV9URVhUX1RSQUNLU19GT1VORCwge1xuICAgICAgICAgIHRyYWNrczogdHJhY2tzTGlzdFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgb25NYW5pZmVzdExvYWRlZChldmVudCwgZGF0YSkge1xuICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVDRUE3MDhDYXB0aW9ucyAmJiBkYXRhLmNhcHRpb25zKSB7XG4gICAgICBkYXRhLmNhcHRpb25zLmZvckVhY2goY2FwdGlvbnNUcmFjayA9PiB7XG4gICAgICAgIGNvbnN0IGluc3RyZWFtSWRNYXRjaCA9IC8oPzpDQ3xTRVJWSUNFKShbMS00XSkvLmV4ZWMoY2FwdGlvbnNUcmFjay5pbnN0cmVhbUlkKTtcbiAgICAgICAgaWYgKCFpbnN0cmVhbUlkTWF0Y2gpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhY2tOYW1lID0gYHRleHRUcmFjayR7aW5zdHJlYW1JZE1hdGNoWzFdfWA7XG4gICAgICAgIGNvbnN0IHRyYWNrUHJvcGVydGllcyA9IHRoaXMuY2FwdGlvbnNQcm9wZXJ0aWVzW3RyYWNrTmFtZV07XG4gICAgICAgIGlmICghdHJhY2tQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNrUHJvcGVydGllcy5sYWJlbCA9IGNhcHRpb25zVHJhY2submFtZTtcbiAgICAgICAgaWYgKGNhcHRpb25zVHJhY2subGFuZykge1xuICAgICAgICAgIC8vIG9wdGlvbmFsIGF0dHJpYnV0ZVxuICAgICAgICAgIHRyYWNrUHJvcGVydGllcy5sYW5ndWFnZUNvZGUgPSBjYXB0aW9uc1RyYWNrLmxhbmc7XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2tQcm9wZXJ0aWVzLm1lZGlhID0gY2FwdGlvbnNUcmFjaztcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBjbG9zZWRDYXB0aW9uc0ZvckxldmVsKGZyYWcpIHtcbiAgICBjb25zdCBsZXZlbCA9IHRoaXMuaGxzLmxldmVsc1tmcmFnLmxldmVsXTtcbiAgICByZXR1cm4gbGV2ZWwgPT0gbnVsbCA/IHZvaWQgMCA6IGxldmVsLmF0dHJzWydDTE9TRUQtQ0FQVElPTlMnXTtcbiAgfVxuICBvbkZyYWdMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5pbml0Q2VhNjA4UGFyc2VycygpO1xuICAgIGNvbnN0IHtcbiAgICAgIGNlYTYwOFBhcnNlcjEsXG4gICAgICBjZWE2MDhQYXJzZXIyLFxuICAgICAgbGFzdENjLFxuICAgICAgbGFzdFNuLFxuICAgICAgbGFzdFBhcnRJbmRleFxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghdGhpcy5lbmFibGVkIHx8ICFjZWE2MDhQYXJzZXIxIHx8ICFjZWE2MDhQYXJzZXIyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGlmIHRoaXMgZnJhZyBpc24ndCBjb250aWd1b3VzLCBjbGVhciB0aGUgcGFyc2VyIHNvIGN1ZXMgd2l0aCBiYWQgc3RhcnQvZW5kIHRpbWVzIGFyZW4ndCBhZGRlZCB0byB0aGUgdGV4dFRyYWNrXG4gICAgaWYgKGRhdGEuZnJhZy50eXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOKSB7XG4gICAgICB2YXIgX2RhdGEkcGFydCRpbmRleCwgX2RhdGEkcGFydDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2MsXG4gICAgICAgIHNuXG4gICAgICB9ID0gZGF0YS5mcmFnO1xuICAgICAgY29uc3QgcGFydEluZGV4ID0gKF9kYXRhJHBhcnQkaW5kZXggPSBkYXRhID09IG51bGwgPyB2b2lkIDAgOiAoX2RhdGEkcGFydCA9IGRhdGEucGFydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhJHBhcnQuaW5kZXgpICE9IG51bGwgPyBfZGF0YSRwYXJ0JGluZGV4IDogLTE7XG4gICAgICBpZiAoIShzbiA9PT0gbGFzdFNuICsgMSB8fCBzbiA9PT0gbGFzdFNuICYmIHBhcnRJbmRleCA9PT0gbGFzdFBhcnRJbmRleCArIDEgfHwgY2MgPT09IGxhc3RDYykpIHtcbiAgICAgICAgY2VhNjA4UGFyc2VyMS5yZXNldCgpO1xuICAgICAgICBjZWE2MDhQYXJzZXIyLnJlc2V0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLmxhc3RDYyA9IGNjO1xuICAgICAgdGhpcy5sYXN0U24gPSBzbjtcbiAgICAgIHRoaXMubGFzdFBhcnRJbmRleCA9IHBhcnRJbmRleDtcbiAgICB9XG4gIH1cbiAgb25GcmFnTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIHBheWxvYWRcbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoZnJhZy50eXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5TVUJUSVRMRSkge1xuICAgICAgLy8gSWYgZnJhZ21lbnQgaXMgc3VidGl0bGUgdHlwZSwgcGFyc2UgYXMgV2ViVlRULlxuICAgICAgaWYgKHBheWxvYWQuYnl0ZUxlbmd0aCkge1xuICAgICAgICBjb25zdCBkZWNyeXB0RGF0YSA9IGZyYWcuZGVjcnlwdGRhdGE7XG4gICAgICAgIC8vIGZyYWdtZW50IGFmdGVyIGRlY3J5cHRpb24gaGFzIGEgc3RhdHMgb2JqZWN0XG4gICAgICAgIGNvbnN0IGRlY3J5cHRlZCA9ICgnc3RhdHMnIGluIGRhdGEpO1xuICAgICAgICAvLyBJZiB0aGUgc3VidGl0bGVzIGFyZSBub3QgZW5jcnlwdGVkLCBwYXJzZSBWVFRzIG5vdy4gT3RoZXJ3aXNlLCB3ZSBuZWVkIHRvIHdhaXQuXG4gICAgICAgIGlmIChkZWNyeXB0RGF0YSA9PSBudWxsIHx8ICFkZWNyeXB0RGF0YS5lbmNyeXB0ZWQgfHwgZGVjcnlwdGVkKSB7XG4gICAgICAgICAgY29uc3QgdHJhY2tQbGF5bGlzdE1lZGlhID0gdGhpcy50cmFja3NbZnJhZy5sZXZlbF07XG4gICAgICAgICAgY29uc3QgdnR0Q0NzID0gdGhpcy52dHRDQ3M7XG4gICAgICAgICAgaWYgKCF2dHRDQ3NbZnJhZy5jY10pIHtcbiAgICAgICAgICAgIHZ0dENDc1tmcmFnLmNjXSA9IHtcbiAgICAgICAgICAgICAgc3RhcnQ6IGZyYWcuc3RhcnQsXG4gICAgICAgICAgICAgIHByZXZDQzogdGhpcy5wcmV2Q0MsXG4gICAgICAgICAgICAgIG5ldzogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucHJldkNDID0gZnJhZy5jYztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRyYWNrUGxheWxpc3RNZWRpYSAmJiB0cmFja1BsYXlsaXN0TWVkaWEudGV4dENvZGVjID09PSBJTVNDMV9DT0RFQykge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VJTVNDMShmcmFnLCBwYXlsb2FkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VWVFRzKGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSW4gY2FzZSB0aGVyZSBpcyBubyBwYXlsb2FkLCBmaW5pc2ggdW5zdWNjZXNzZnVsbHkuXG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZnJhZyxcbiAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKCdFbXB0eSBzdWJ0aXRsZSBwYXlsb2FkJylcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9wYXJzZUlNU0MxKGZyYWcsIHBheWxvYWQpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBwYXJzZUlNU0MxKHBheWxvYWQsIHRoaXMuaW5pdFBUU1tmcmFnLmNjXSwgY3VlcyA9PiB7XG4gICAgICB0aGlzLl9hcHBlbmRDdWVzKGN1ZXMsIGZyYWcubGV2ZWwpO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGZyYWc6IGZyYWdcbiAgICAgIH0pO1xuICAgIH0sIGVycm9yID0+IHtcbiAgICAgIGxvZ2dlci5sb2coYEZhaWxlZCB0byBwYXJzZSBJTVNDMTogJHtlcnJvcn1gKTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgZXJyb3JcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIF9wYXJzZVZUVHMoZGF0YSkge1xuICAgIHZhciBfZnJhZyRpbml0U2VnbWVudDtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnLFxuICAgICAgcGF5bG9hZFxuICAgIH0gPSBkYXRhO1xuICAgIC8vIFdlIG5lZWQgYW4gaW5pdGlhbCBzeW5jaHJvbmlzYXRpb24gUFRTLiBTdG9yZSBmcmFnbWVudHMgYXMgbG9uZyBhcyBub25lIGhhcyBhcnJpdmVkXG4gICAgY29uc3Qge1xuICAgICAgaW5pdFBUUyxcbiAgICAgIHVucGFyc2VkVnR0RnJhZ3NcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBtYXhBdkNDID0gaW5pdFBUUy5sZW5ndGggLSAxO1xuICAgIGlmICghaW5pdFBUU1tmcmFnLmNjXSAmJiBtYXhBdkNDID09PSAtMSkge1xuICAgICAgdW5wYXJzZWRWdHRGcmFncy5wdXNoKGRhdGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICAvLyBQYXJzZSB0aGUgV2ViVlRUIGZpbGUgY29udGVudHMuXG4gICAgY29uc3QgcGF5bG9hZFdlYlZUVCA9IChfZnJhZyRpbml0U2VnbWVudCA9IGZyYWcuaW5pdFNlZ21lbnQpICE9IG51bGwgJiYgX2ZyYWckaW5pdFNlZ21lbnQuZGF0YSA/IGFwcGVuZFVpbnQ4QXJyYXkoZnJhZy5pbml0U2VnbWVudC5kYXRhLCBuZXcgVWludDhBcnJheShwYXlsb2FkKSkgOiBwYXlsb2FkO1xuICAgIHBhcnNlV2ViVlRUKHBheWxvYWRXZWJWVFQsIHRoaXMuaW5pdFBUU1tmcmFnLmNjXSwgdGhpcy52dHRDQ3MsIGZyYWcuY2MsIGZyYWcuc3RhcnQsIGN1ZXMgPT4ge1xuICAgICAgdGhpcy5fYXBwZW5kQ3VlcyhjdWVzLCBmcmFnLmxldmVsKTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBmcmFnOiBmcmFnXG4gICAgICB9KTtcbiAgICB9LCBlcnJvciA9PiB7XG4gICAgICBjb25zdCBtaXNzaW5nSW5pdFBUUyA9IGVycm9yLm1lc3NhZ2UgPT09ICdNaXNzaW5nIGluaXRQVFMgZm9yIFZUVCBNUEVHVFMnO1xuICAgICAgaWYgKG1pc3NpbmdJbml0UFRTKSB7XG4gICAgICAgIHVucGFyc2VkVnR0RnJhZ3MucHVzaChkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2ZhbGxiYWNrVG9JTVNDMShmcmFnLCBwYXlsb2FkKTtcbiAgICAgIH1cbiAgICAgIC8vIFNvbWV0aGluZyB3ZW50IHdyb25nIHdoaWxlIHBhcnNpbmcuIFRyaWdnZXIgZXZlbnQgd2l0aCBzdWNjZXNzIGZhbHNlLlxuICAgICAgbG9nZ2VyLmxvZyhgRmFpbGVkIHRvIHBhcnNlIFZUVCBjdWU6ICR7ZXJyb3J9YCk7XG4gICAgICBpZiAobWlzc2luZ0luaXRQVFMgJiYgbWF4QXZDQyA+IGZyYWcuY2MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICBlcnJvclxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX2ZhbGxiYWNrVG9JTVNDMShmcmFnLCBwYXlsb2FkKSB7XG4gICAgLy8gSWYgdGV4dENvZGVjIGlzIHVua25vd24sIHRyeSBwYXJzaW5nIGFzIElNU0MxLiBTZXQgdGV4dENvZGVjIGJhc2VkIG9uIHRoZSByZXN1bHRcbiAgICBjb25zdCB0cmFja1BsYXlsaXN0TWVkaWEgPSB0aGlzLnRyYWNrc1tmcmFnLmxldmVsXTtcbiAgICBpZiAoIXRyYWNrUGxheWxpc3RNZWRpYS50ZXh0Q29kZWMpIHtcbiAgICAgIHBhcnNlSU1TQzEocGF5bG9hZCwgdGhpcy5pbml0UFRTW2ZyYWcuY2NdLCAoKSA9PiB7XG4gICAgICAgIHRyYWNrUGxheWxpc3RNZWRpYS50ZXh0Q29kZWMgPSBJTVNDMV9DT0RFQztcbiAgICAgICAgdGhpcy5fcGFyc2VJTVNDMShmcmFnLCBwYXlsb2FkKTtcbiAgICAgIH0sICgpID0+IHtcbiAgICAgICAgdHJhY2tQbGF5bGlzdE1lZGlhLnRleHRDb2RlYyA9ICd3dnR0JztcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBfYXBwZW5kQ3VlcyhjdWVzLCBmcmFnTGV2ZWwpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBpZiAodGhpcy5jb25maWcucmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5KSB7XG4gICAgICBjb25zdCB0ZXh0VHJhY2sgPSB0aGlzLnRleHRUcmFja3NbZnJhZ0xldmVsXTtcbiAgICAgIC8vIFdlYlZUVFBhcnNlci5wYXJzZSBpcyBhbiBhc3luYyBtZXRob2QgYW5kIGlmIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdGV4dCB0cmFjayBtb2RlIGlzIHNldCB0byBcImRpc2FibGVkXCJcbiAgICAgIC8vIGJlZm9yZSBwYXJzaW5nIGlzIGRvbmUgdGhlbiBkb24ndCB0cnkgdG8gYWNjZXNzIGN1cnJlbnRUcmFjay5jdWVzLmdldEN1ZUJ5SWQgYXMgY3VlcyB3aWxsIGJlIG51bGxcbiAgICAgIC8vIGFuZCB0cnlpbmcgdG8gYWNjZXNzIGdldEN1ZUJ5SWQgbWV0aG9kIG9mIGN1ZXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb25cbiAgICAgIC8vIEJlY2F1c2Ugd2UgY2hlY2sgaWYgdGhlIG1vZGUgaXMgZGlzYWJsZWQsIHdlIGNhbiBmb3JjZSBjaGVjayBgY3Vlc2AgYmVsb3cuIFRoZXkgY2FuJ3QgYmUgbnVsbC5cbiAgICAgIGlmICghdGV4dFRyYWNrIHx8IHRleHRUcmFjay5tb2RlID09PSAnZGlzYWJsZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN1ZXMuZm9yRWFjaChjdWUgPT4gYWRkQ3VlVG9UcmFjayh0ZXh0VHJhY2ssIGN1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjdXJyZW50VHJhY2sgPSB0aGlzLnRyYWNrc1tmcmFnTGV2ZWxdO1xuICAgICAgaWYgKCFjdXJyZW50VHJhY2spIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdHJhY2sgPSBjdXJyZW50VHJhY2suZGVmYXVsdCA/ICdkZWZhdWx0JyA6ICdzdWJ0aXRsZXMnICsgZnJhZ0xldmVsO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkNVRVNfUEFSU0VELCB7XG4gICAgICAgIHR5cGU6ICdzdWJ0aXRsZXMnLFxuICAgICAgICBjdWVzLFxuICAgICAgICB0cmFja1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIG9uRnJhZ0RlY3J5cHRlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWdcbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoZnJhZy50eXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5TVUJUSVRMRSkge1xuICAgICAgdGhpcy5vbkZyYWdMb2FkZWQoRXZlbnRzLkZSQUdfTE9BREVELCBkYXRhKTtcbiAgICB9XG4gIH1cbiAgb25TdWJ0aXRsZVRyYWNrc0NsZWFyZWQoKSB7XG4gICAgdGhpcy50cmFja3MgPSBbXTtcbiAgICB0aGlzLmNhcHRpb25zVHJhY2tzID0ge307XG4gIH1cbiAgb25GcmFnUGFyc2luZ1VzZXJkYXRhKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5pbml0Q2VhNjA4UGFyc2VycygpO1xuICAgIGNvbnN0IHtcbiAgICAgIGNlYTYwOFBhcnNlcjEsXG4gICAgICBjZWE2MDhQYXJzZXIyXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQgfHwgIWNlYTYwOFBhcnNlcjEgfHwgIWNlYTYwOFBhcnNlcjIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIHNhbXBsZXNcbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoZnJhZy50eXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOICYmIHRoaXMuY2xvc2VkQ2FwdGlvbnNGb3JMZXZlbChmcmFnKSA9PT0gJ05PTkUnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIElmIHRoZSBldmVudCBjb250YWlucyBjYXB0aW9ucyAoZm91bmQgaW4gdGhlIGJ5dGVzIHByb3BlcnR5KSwgcHVzaCBhbGwgYnl0ZXMgaW50byB0aGUgcGFyc2VyIGltbWVkaWF0ZWx5XG4gICAgLy8gSXQgd2lsbCBjcmVhdGUgdGhlIHByb3BlciB0aW1lc3RhbXBzIGJhc2VkIG9uIHRoZSBQVFMgdmFsdWVcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNjQnl0ZXMgPSBzYW1wbGVzW2ldLmJ5dGVzO1xuICAgICAgaWYgKGNjQnl0ZXMpIHtcbiAgICAgICAgY29uc3QgY2NkYXRhcyA9IHRoaXMuZXh0cmFjdENlYTYwOERhdGEoY2NCeXRlcyk7XG4gICAgICAgIGNlYTYwOFBhcnNlcjEuYWRkRGF0YShzYW1wbGVzW2ldLnB0cywgY2NkYXRhc1swXSk7XG4gICAgICAgIGNlYTYwOFBhcnNlcjIuYWRkRGF0YShzYW1wbGVzW2ldLnB0cywgY2NkYXRhc1sxXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG9uQnVmZmVyRmx1c2hpbmcoZXZlbnQsIHtcbiAgICBzdGFydE9mZnNldCxcbiAgICBlbmRPZmZzZXQsXG4gICAgZW5kT2Zmc2V0U3VidGl0bGVzLFxuICAgIHR5cGVcbiAgfSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lZGlhXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFtZWRpYSB8fCBtZWRpYS5jdXJyZW50VGltZSA8IGVuZE9mZnNldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBDbGVhciA2MDggY2FwdGlvbiBjdWVzIGZyb20gdGhlIGNhcHRpb25zIFRleHRUcmFja3Mgd2hlbiB0aGUgdmlkZW8gYmFjayBidWZmZXIgaXMgZmx1c2hlZFxuICAgIC8vIEZvcndhcmQgY3VlcyBhcmUgbmV2ZXIgcmVtb3ZlZCBiZWNhdXNlIHdlIGNhbiBsb29zZSBzdHJlYW1lZCA2MDggY29udGVudCBmcm9tIHJlY2VudCBmcmFnbWVudHNcbiAgICBpZiAoIXR5cGUgfHwgdHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjYXB0aW9uc1RyYWNrc1xuICAgICAgfSA9IHRoaXM7XG4gICAgICBPYmplY3Qua2V5cyhjYXB0aW9uc1RyYWNrcykuZm9yRWFjaCh0cmFja05hbWUgPT4gcmVtb3ZlQ3Vlc0luUmFuZ2UoY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb25maWcucmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5KSB7XG4gICAgICAvLyBDbGVhciBWVFQvSU1TQzEgc3VidGl0bGUgY3VlcyBmcm9tIHRoZSBzdWJ0aXRsZSBUZXh0VHJhY2tzIHdoZW4gdGhlIGJhY2sgYnVmZmVyIGlzIGZsdXNoZWRcbiAgICAgIGlmIChzdGFydE9mZnNldCA9PT0gMCAmJiBlbmRPZmZzZXRTdWJ0aXRsZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgdGV4dFRyYWNrc1xuICAgICAgICB9ID0gdGhpcztcbiAgICAgICAgT2JqZWN0LmtleXModGV4dFRyYWNrcykuZm9yRWFjaCh0cmFja05hbWUgPT4gcmVtb3ZlQ3Vlc0luUmFuZ2UodGV4dFRyYWNrc1t0cmFja05hbWVdLCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0U3VidGl0bGVzKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGV4dHJhY3RDZWE2MDhEYXRhKGJ5dGVBcnJheSkge1xuICAgIGNvbnN0IGFjdHVhbENDQnl0ZXMgPSBbW10sIFtdXTtcbiAgICBjb25zdCBjb3VudCA9IGJ5dGVBcnJheVswXSAmIDB4MWY7XG4gICAgbGV0IHBvc2l0aW9uID0gMjtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvdW50OyBqKyspIHtcbiAgICAgIGNvbnN0IHRtcEJ5dGUgPSBieXRlQXJyYXlbcG9zaXRpb24rK107XG4gICAgICBjb25zdCBjY2J5dGUxID0gMHg3ZiAmIGJ5dGVBcnJheVtwb3NpdGlvbisrXTtcbiAgICAgIGNvbnN0IGNjYnl0ZTIgPSAweDdmICYgYnl0ZUFycmF5W3Bvc2l0aW9uKytdO1xuICAgICAgaWYgKGNjYnl0ZTEgPT09IDAgJiYgY2NieXRlMiA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNjVmFsaWQgPSAoMHgwNCAmIHRtcEJ5dGUpICE9PSAwOyAvLyBTdXBwb3J0IGFsbCBmb3VyIGNoYW5uZWxzXG4gICAgICBpZiAoY2NWYWxpZCkge1xuICAgICAgICBjb25zdCBjY1R5cGUgPSAweDAzICYgdG1wQnl0ZTtcbiAgICAgICAgaWYgKDB4MDAgLyogQ0VBNjA4IGZpZWxkMSovID09PSBjY1R5cGUgfHwgMHgwMSAvKiBDRUE2MDggZmllbGQyKi8gPT09IGNjVHlwZSkge1xuICAgICAgICAgIC8vIEV4Y2x1ZGUgQ0VBNzA4IENDIGRhdGEuXG4gICAgICAgICAgYWN0dWFsQ0NCeXRlc1tjY1R5cGVdLnB1c2goY2NieXRlMSk7XG4gICAgICAgICAgYWN0dWFsQ0NCeXRlc1tjY1R5cGVdLnB1c2goY2NieXRlMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFjdHVhbENDQnl0ZXM7XG4gIH1cbn1cbmZ1bmN0aW9uIGNhcHRpb25zT3JTdWJ0aXRsZXNGcm9tQ2hhcmFjdGVyaXN0aWNzKHRyYWNrKSB7XG4gIGlmICh0cmFjay5jaGFyYWN0ZXJpc3RpY3MpIHtcbiAgICBpZiAoL3RyYW5zY3JpYmVzLXNwb2tlbi1kaWFsb2cvZ2kudGVzdCh0cmFjay5jaGFyYWN0ZXJpc3RpY3MpICYmIC9kZXNjcmliZXMtbXVzaWMtYW5kLXNvdW5kL2dpLnRlc3QodHJhY2suY2hhcmFjdGVyaXN0aWNzKSkge1xuICAgICAgcmV0dXJuICdjYXB0aW9ucyc7XG4gICAgfVxuICB9XG4gIHJldHVybiAnc3VidGl0bGVzJztcbn1cbmZ1bmN0aW9uIGNhblJldXNlVnR0VGV4dFRyYWNrKGluVXNlVHJhY2ssIG1hbmlmZXN0VHJhY2spIHtcbiAgcmV0dXJuICEhaW5Vc2VUcmFjayAmJiBpblVzZVRyYWNrLmtpbmQgPT09IGNhcHRpb25zT3JTdWJ0aXRsZXNGcm9tQ2hhcmFjdGVyaXN0aWNzKG1hbmlmZXN0VHJhY2spICYmIHN1YnRpdGxlVHJhY2tNYXRjaGVzVGV4dFRyYWNrKG1hbmlmZXN0VHJhY2ssIGluVXNlVHJhY2spO1xufVxuZnVuY3Rpb24gaW50ZXJzZWN0aW9uKHgxLCB4MiwgeTEsIHkyKSB7XG4gIHJldHVybiBNYXRoLm1pbih4MiwgeTIpIC0gTWF0aC5tYXgoeDEsIHkxKTtcbn1cbmZ1bmN0aW9uIG5ld1ZUVENDcygpIHtcbiAgcmV0dXJuIHtcbiAgICBjY09mZnNldDogMCxcbiAgICBwcmVzZW50YXRpb25PZmZzZXQ6IDAsXG4gICAgMDoge1xuICAgICAgc3RhcnQ6IDAsXG4gICAgICBwcmV2Q0M6IC0xLFxuICAgICAgbmV3OiB0cnVlXG4gICAgfVxuICB9O1xufVxuXG5jbGFzcyBDYXBMZXZlbENvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSB2b2lkIDA7XG4gICAgdGhpcy5maXJzdExldmVsID0gdm9pZCAwO1xuICAgIHRoaXMubWVkaWEgPSB2b2lkIDA7XG4gICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzID0gdm9pZCAwO1xuICAgIHRoaXMudGltZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jbGllbnRSZWN0ID0gdm9pZCAwO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgdGhpcy5maXJzdExldmVsID0gLTE7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzID0gW107XG4gICAgdGhpcy50aW1lciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNsaWVudFJlY3QgPSBudWxsO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICBzZXRTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIpIHtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSBzdHJlYW1Db250cm9sbGVyO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuaGxzKSB7XG4gICAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcigpO1xuICAgIH1cbiAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgdGhpcy5zdG9wQ2FwcGluZygpO1xuICAgIH1cbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLmNsaWVudFJlY3QgPSBudWxsO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmhscyA9IHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IG51bGw7XG4gIH1cbiAgcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9uKEV2ZW50cy5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HLCB0aGlzLm9uRnBzRHJvcExldmVsQ2FwcGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTFNfVVBEQVRFRCwgdGhpcy5vbkxldmVsc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0NPREVDUywgdGhpcy5vbkJ1ZmZlckNvZGVjcywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gIH1cbiAgdW5yZWdpc3Rlckxpc3RlbmVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vZmYoRXZlbnRzLkZQU19EUk9QX0xFVkVMX0NBUFBJTkcsIHRoaXMub25GcHNEcm9wTGV2ZWxDYXBwaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMU19VUERBVEVELCB0aGlzLm9uTGV2ZWxzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0NPREVDUywgdGhpcy5vbkJ1ZmZlckNvZGVjcywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICB9XG4gIG9uRnBzRHJvcExldmVsQ2FwcGluZyhldmVudCwgZGF0YSkge1xuICAgIC8vIERvbid0IGFkZCBhIHJlc3RyaWN0ZWQgbGV2ZWwgbW9yZSB0aGFuIG9uY2VcbiAgICBjb25zdCBsZXZlbCA9IHRoaXMuaGxzLmxldmVsc1tkYXRhLmRyb3BwZWRMZXZlbF07XG4gICAgaWYgKHRoaXMuaXNMZXZlbEFsbG93ZWQobGV2ZWwpKSB7XG4gICAgICB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMucHVzaCh7XG4gICAgICAgIGJpdHJhdGU6IGxldmVsLmJpdHJhdGUsXG4gICAgICAgIGhlaWdodDogbGV2ZWwuaGVpZ2h0LFxuICAgICAgICB3aWR0aDogbGV2ZWwud2lkdGhcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBvbk1lZGlhQXR0YWNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWEgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50ID8gZGF0YS5tZWRpYSA6IG51bGw7XG4gICAgdGhpcy5jbGllbnRSZWN0ID0gbnVsbDtcbiAgICBpZiAodGhpcy50aW1lciAmJiB0aGlzLmhscy5sZXZlbHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmRldGVjdFBsYXllclNpemUoKTtcbiAgICB9XG4gIH1cbiAgb25NYW5pZmVzdFBhcnNlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIHRoaXMucmVzdHJpY3RlZExldmVscyA9IFtdO1xuICAgIHRoaXMuZmlyc3RMZXZlbCA9IGRhdGEuZmlyc3RMZXZlbDtcbiAgICBpZiAoaGxzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSAmJiBkYXRhLnZpZGVvKSB7XG4gICAgICAvLyBTdGFydCBjYXBwaW5nIGltbWVkaWF0ZWx5IGlmIHRoZSBtYW5pZmVzdCBoYXMgc2lnbmFsZWQgdmlkZW8gY29kZWNzXG4gICAgICB0aGlzLnN0YXJ0Q2FwcGluZygpO1xuICAgIH1cbiAgfVxuICBvbkxldmVsc1VwZGF0ZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBpZiAodGhpcy50aW1lciAmJiBpc0Zpbml0ZU51bWJlcih0aGlzLmF1dG9MZXZlbENhcHBpbmcpKSB7XG4gICAgICB0aGlzLmRldGVjdFBsYXllclNpemUoKTtcbiAgICB9XG4gIH1cblxuICAvLyBPbmx5IGFjdGl2YXRlIGNhcHBpbmcgd2hlbiBwbGF5aW5nIGEgdmlkZW8gc3RyZWFtOyBvdGhlcndpc2UsIG11bHRpLWJpdHJhdGUgYXVkaW8tb25seSBzdHJlYW1zIHdpbGwgYmUgcmVzdHJpY3RlZFxuICAvLyB0byB0aGUgZmlyc3QgbGV2ZWxcbiAgb25CdWZmZXJDb2RlY3MoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBpZiAoaGxzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSAmJiBkYXRhLnZpZGVvKSB7XG4gICAgICAvLyBJZiB0aGUgbWFuaWZlc3QgZGlkIG5vdCBzaWduYWwgYSB2aWRlbyBjb2RlYyBjYXBwaW5nIGhhcyBiZWVuIGRlZmVycmVkIHVudGlsIHdlJ3JlIGNlcnRhaW4gdmlkZW8gaXMgcHJlc2VudFxuICAgICAgdGhpcy5zdGFydENhcHBpbmcoKTtcbiAgICB9XG4gIH1cbiAgb25NZWRpYURldGFjaGluZygpIHtcbiAgICB0aGlzLnN0b3BDYXBwaW5nKCk7XG4gIH1cbiAgZGV0ZWN0UGxheWVyU2l6ZSgpIHtcbiAgICBpZiAodGhpcy5tZWRpYSkge1xuICAgICAgaWYgKHRoaXMubWVkaWFIZWlnaHQgPD0gMCB8fCB0aGlzLm1lZGlhV2lkdGggPD0gMCkge1xuICAgICAgICB0aGlzLmNsaWVudFJlY3QgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBsZXZlbHMgPSB0aGlzLmhscy5sZXZlbHM7XG4gICAgICBpZiAobGV2ZWxzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICAgICAgY29uc3QgbWF4TGV2ZWwgPSB0aGlzLmdldE1heExldmVsKGxldmVscy5sZW5ndGggLSAxKTtcbiAgICAgICAgaWYgKG1heExldmVsICE9PSB0aGlzLmF1dG9MZXZlbENhcHBpbmcpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKGBTZXR0aW5nIGF1dG9MZXZlbENhcHBpbmcgdG8gJHttYXhMZXZlbH06ICR7bGV2ZWxzW21heExldmVsXS5oZWlnaHR9cEAke2xldmVsc1ttYXhMZXZlbF0uYml0cmF0ZX0gZm9yIG1lZGlhICR7dGhpcy5tZWRpYVdpZHRofXgke3RoaXMubWVkaWFIZWlnaHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaGxzLmF1dG9MZXZlbENhcHBpbmcgPSBtYXhMZXZlbDtcbiAgICAgICAgaWYgKGhscy5hdXRvTGV2ZWxDYXBwaW5nID4gdGhpcy5hdXRvTGV2ZWxDYXBwaW5nICYmIHRoaXMuc3RyZWFtQ29udHJvbGxlcikge1xuICAgICAgICAgIC8vIGlmIGF1dG8gbGV2ZWwgY2FwcGluZyBoYXMgYSBoaWdoZXIgdmFsdWUgZm9yIHRoZSBwcmV2aW91cyBvbmUsIGZsdXNoIHRoZSBidWZmZXIgdXNpbmcgbmV4dExldmVsU3dpdGNoXG4gICAgICAgICAgLy8gdXN1YWxseSBoYXBwZW4gd2hlbiB0aGUgdXNlciBnbyB0byB0aGUgZnVsbHNjcmVlbiBtb2RlLlxuICAgICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWxTd2l0Y2goKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSBobHMuYXV0b0xldmVsQ2FwcGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKlxuICAgKiByZXR1cm5zIGxldmVsIHNob3VsZCBiZSB0aGUgb25lIHdpdGggdGhlIGRpbWVuc2lvbnMgZXF1YWwgb3IgZ3JlYXRlciB0aGFuIHRoZSBtZWRpYSAocGxheWVyKSBkaW1lbnNpb25zIChzbyB0aGUgdmlkZW8gd2lsbCBiZSBkb3duc2NhbGVkKVxuICAgKi9cbiAgZ2V0TWF4TGV2ZWwoY2FwTGV2ZWxJbmRleCkge1xuICAgIGNvbnN0IGxldmVscyA9IHRoaXMuaGxzLmxldmVscztcbiAgICBpZiAoIWxldmVscy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgY29uc3QgdmFsaWRMZXZlbHMgPSBsZXZlbHMuZmlsdGVyKChsZXZlbCwgaW5kZXgpID0+IHRoaXMuaXNMZXZlbEFsbG93ZWQobGV2ZWwpICYmIGluZGV4IDw9IGNhcExldmVsSW5kZXgpO1xuICAgIHRoaXMuY2xpZW50UmVjdCA9IG51bGw7XG4gICAgcmV0dXJuIENhcExldmVsQ29udHJvbGxlci5nZXRNYXhMZXZlbEJ5TWVkaWFTaXplKHZhbGlkTGV2ZWxzLCB0aGlzLm1lZGlhV2lkdGgsIHRoaXMubWVkaWFIZWlnaHQpO1xuICB9XG4gIHN0YXJ0Q2FwcGluZygpIHtcbiAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgLy8gRG9uJ3QgcmVzZXQgY2FwcGluZyBpZiBzdGFydGVkIHR3aWNlOyB0aGlzIGNhbiBoYXBwZW4gaWYgdGhlIG1hbmlmZXN0IHNpZ25hbHMgYSB2aWRlbyBjb2RlY1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgc2VsZi5jbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgIHRoaXMudGltZXIgPSBzZWxmLnNldEludGVydmFsKHRoaXMuZGV0ZWN0UGxheWVyU2l6ZS5iaW5kKHRoaXMpLCAxMDAwKTtcbiAgICB0aGlzLmRldGVjdFBsYXllclNpemUoKTtcbiAgfVxuICBzdG9wQ2FwcGluZygpIHtcbiAgICB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMgPSBbXTtcbiAgICB0aGlzLmZpcnN0TGV2ZWwgPSAtMTtcbiAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgIHRoaXMudGltZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIGdldERpbWVuc2lvbnMoKSB7XG4gICAgaWYgKHRoaXMuY2xpZW50UmVjdCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2xpZW50UmVjdDtcbiAgICB9XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGNvbnN0IGJvdW5kc1JlY3QgPSB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH07XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICBjb25zdCBjbGllbnRSZWN0ID0gbWVkaWEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBib3VuZHNSZWN0LndpZHRoID0gY2xpZW50UmVjdC53aWR0aDtcbiAgICAgIGJvdW5kc1JlY3QuaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQ7XG4gICAgICBpZiAoIWJvdW5kc1JlY3Qud2lkdGggJiYgIWJvdW5kc1JlY3QuaGVpZ2h0KSB7XG4gICAgICAgIC8vIFdoZW4gdGhlIG1lZGlhIGVsZW1lbnQgaGFzIG5vIHdpZHRoIG9yIGhlaWdodCAoZXF1aXZhbGVudCB0byBub3QgYmVpbmcgaW4gdGhlIERPTSksXG4gICAgICAgIC8vIHRoZW4gdXNlIGl0cyB3aWR0aCBhbmQgaGVpZ2h0IGF0dHJpYnV0ZXMgKG1lZGlhLndpZHRoLCBtZWRpYS5oZWlnaHQpXG4gICAgICAgIGJvdW5kc1JlY3Qud2lkdGggPSBjbGllbnRSZWN0LnJpZ2h0IC0gY2xpZW50UmVjdC5sZWZ0IHx8IG1lZGlhLndpZHRoIHx8IDA7XG4gICAgICAgIGJvdW5kc1JlY3QuaGVpZ2h0ID0gY2xpZW50UmVjdC5ib3R0b20gLSBjbGllbnRSZWN0LnRvcCB8fCBtZWRpYS5oZWlnaHQgfHwgMDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jbGllbnRSZWN0ID0gYm91bmRzUmVjdDtcbiAgICByZXR1cm4gYm91bmRzUmVjdDtcbiAgfVxuICBnZXQgbWVkaWFXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXREaW1lbnNpb25zKCkud2lkdGggKiB0aGlzLmNvbnRlbnRTY2FsZUZhY3RvcjtcbiAgfVxuICBnZXQgbWVkaWFIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGltZW5zaW9ucygpLmhlaWdodCAqIHRoaXMuY29udGVudFNjYWxlRmFjdG9yO1xuICB9XG4gIGdldCBjb250ZW50U2NhbGVGYWN0b3IoKSB7XG4gICAgbGV0IHBpeGVsUmF0aW8gPSAxO1xuICAgIGlmICghdGhpcy5obHMuY29uZmlnLmlnbm9yZURldmljZVBpeGVsUmF0aW8pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBpeGVsUmF0aW8gPSBzZWxmLmRldmljZVBpeGVsUmF0aW87XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8qIG5vLW9wICovXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwaXhlbFJhdGlvO1xuICB9XG4gIGlzTGV2ZWxBbGxvd2VkKGxldmVsKSB7XG4gICAgY29uc3QgcmVzdHJpY3RlZExldmVscyA9IHRoaXMucmVzdHJpY3RlZExldmVscztcbiAgICByZXR1cm4gIXJlc3RyaWN0ZWRMZXZlbHMuc29tZShyZXN0cmljdGVkTGV2ZWwgPT4ge1xuICAgICAgcmV0dXJuIGxldmVsLmJpdHJhdGUgPT09IHJlc3RyaWN0ZWRMZXZlbC5iaXRyYXRlICYmIGxldmVsLndpZHRoID09PSByZXN0cmljdGVkTGV2ZWwud2lkdGggJiYgbGV2ZWwuaGVpZ2h0ID09PSByZXN0cmljdGVkTGV2ZWwuaGVpZ2h0O1xuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXRNYXhMZXZlbEJ5TWVkaWFTaXplKGxldmVscywgd2lkdGgsIGhlaWdodCkge1xuICAgIGlmICghKGxldmVscyAhPSBudWxsICYmIGxldmVscy5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLy8gTGV2ZWxzIGNhbiBoYXZlIHRoZSBzYW1lIGRpbWVuc2lvbnMgYnV0IGRpZmZlcmluZyBiYW5kd2lkdGhzIC0gc2luY2UgbGV2ZWxzIGFyZSBvcmRlcmVkLCB3ZSBjYW4gbG9vayB0byB0aGUgbmV4dFxuICAgIC8vIHRvIGRldGVybWluZSB3aGV0aGVyIHdlJ3ZlIGNob3NlbiB0aGUgZ3JlYXRlc3QgYmFuZHdpZHRoIGZvciB0aGUgbWVkaWEncyBkaW1lbnNpb25zXG4gICAgY29uc3QgYXRHcmVhdGVzdEJhbmR3aWR0aCA9IChjdXJMZXZlbCwgbmV4dExldmVsKSA9PiB7XG4gICAgICBpZiAoIW5leHRMZXZlbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXJMZXZlbC53aWR0aCAhPT0gbmV4dExldmVsLndpZHRoIHx8IGN1ckxldmVsLmhlaWdodCAhPT0gbmV4dExldmVsLmhlaWdodDtcbiAgICB9O1xuXG4gICAgLy8gSWYgd2UgcnVuIHRocm91Z2ggdGhlIGxvb3Agd2l0aG91dCBicmVha2luZywgdGhlIG1lZGlhJ3MgZGltZW5zaW9ucyBhcmUgZ3JlYXRlciB0aGFuIGV2ZXJ5IGxldmVsLCBzbyBkZWZhdWx0IHRvXG4gICAgLy8gdGhlIG1heCBsZXZlbFxuICAgIGxldCBtYXhMZXZlbEluZGV4ID0gbGV2ZWxzLmxlbmd0aCAtIDE7XG4gICAgLy8gUHJldmVudCBjaGFuZ2VzIGluIGFzcGVjdC1yYXRpbyBmcm9tIGNhdXNpbmcgY2FwcGluZyB0byB0b2dnbGUgYmFjayBhbmQgZm9ydGhcbiAgICBjb25zdCBzcXVhcmVTaXplID0gTWF0aC5tYXgod2lkdGgsIGhlaWdodCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IGxldmVsID0gbGV2ZWxzW2ldO1xuICAgICAgaWYgKChsZXZlbC53aWR0aCA+PSBzcXVhcmVTaXplIHx8IGxldmVsLmhlaWdodCA+PSBzcXVhcmVTaXplKSAmJiBhdEdyZWF0ZXN0QmFuZHdpZHRoKGxldmVsLCBsZXZlbHNbaSArIDFdKSkge1xuICAgICAgICBtYXhMZXZlbEluZGV4ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXhMZXZlbEluZGV4O1xuICB9XG59XG5cbmNsYXNzIEZQU0NvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLnRpbWVyID0gdm9pZCAwO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMubGFzdFRpbWUgPSB2b2lkIDA7XG4gICAgdGhpcy5sYXN0RHJvcHBlZEZyYW1lcyA9IDA7XG4gICAgdGhpcy5sYXN0RGVjb2RlZEZyYW1lcyA9IDA7XG4gICAgLy8gc3RyZWFtIGNvbnRyb2xsZXIgbXVzdCBiZSBwcm92aWRlZCBhcyBhIGRlcGVuZGVuY3khXG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICBzZXRTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIpIHtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSBzdHJlYW1Db250cm9sbGVyO1xuICB9XG4gIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHRoaXMuaGxzLm9uKEV2ZW50cy5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyk7XG4gIH1cbiAgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB0aGlzLmhscy5vZmYoRXZlbnRzLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgIH1cbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgfVxuICBvbk1lZGlhQXR0YWNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuICAgIGlmIChjb25maWcuY2FwTGV2ZWxPbkZQU0Ryb3ApIHtcbiAgICAgIGNvbnN0IG1lZGlhID0gZGF0YS5tZWRpYSBpbnN0YW5jZW9mIHNlbGYuSFRNTFZpZGVvRWxlbWVudCA/IGRhdGEubWVkaWEgOiBudWxsO1xuICAgICAgdGhpcy5tZWRpYSA9IG1lZGlhO1xuICAgICAgaWYgKG1lZGlhICYmIHR5cGVvZiBtZWRpYS5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgc2VsZi5jbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgdGhpcy50aW1lciA9IHNlbGYuc2V0SW50ZXJ2YWwodGhpcy5jaGVja0ZQU0ludGVydmFsLmJpbmQodGhpcyksIGNvbmZpZy5mcHNEcm9wcGVkTW9uaXRvcmluZ1BlcmlvZCk7XG4gICAgfVxuICB9XG4gIGNoZWNrRlBTKHZpZGVvLCBkZWNvZGVkRnJhbWVzLCBkcm9wcGVkRnJhbWVzKSB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBpZiAoZGVjb2RlZEZyYW1lcykge1xuICAgICAgaWYgKHRoaXMubGFzdFRpbWUpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFBlcmlvZCA9IGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0VGltZTtcbiAgICAgICAgY29uc3QgY3VycmVudERyb3BwZWQgPSBkcm9wcGVkRnJhbWVzIC0gdGhpcy5sYXN0RHJvcHBlZEZyYW1lcztcbiAgICAgICAgY29uc3QgY3VycmVudERlY29kZWQgPSBkZWNvZGVkRnJhbWVzIC0gdGhpcy5sYXN0RGVjb2RlZEZyYW1lcztcbiAgICAgICAgY29uc3QgZHJvcHBlZEZQUyA9IDEwMDAgKiBjdXJyZW50RHJvcHBlZCAvIGN1cnJlbnRQZXJpb2Q7XG4gICAgICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuRlBTX0RST1AsIHtcbiAgICAgICAgICBjdXJyZW50RHJvcHBlZDogY3VycmVudERyb3BwZWQsXG4gICAgICAgICAgY3VycmVudERlY29kZWQ6IGN1cnJlbnREZWNvZGVkLFxuICAgICAgICAgIHRvdGFsRHJvcHBlZEZyYW1lczogZHJvcHBlZEZyYW1lc1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGRyb3BwZWRGUFMgPiAwKSB7XG4gICAgICAgICAgLy8gbG9nZ2VyLmxvZygnY2hlY2tGUFMgOiBkcm9wcGVkRlBTL2RlY29kZWRGUFM6JyArIGRyb3BwZWRGUFMvKDEwMDAgKiBjdXJyZW50RGVjb2RlZCAvIGN1cnJlbnRQZXJpb2QpKTtcbiAgICAgICAgICBpZiAoY3VycmVudERyb3BwZWQgPiBobHMuY29uZmlnLmZwc0Ryb3BwZWRNb25pdG9yaW5nVGhyZXNob2xkICogY3VycmVudERlY29kZWQpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50TGV2ZWwgPSBobHMuY3VycmVudExldmVsO1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ2Ryb3AgRlBTIHJhdGlvIGdyZWF0ZXIgdGhhbiBtYXggYWxsb3dlZCB2YWx1ZSBmb3IgY3VycmVudExldmVsOiAnICsgY3VycmVudExldmVsKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50TGV2ZWwgPiAwICYmIChobHMuYXV0b0xldmVsQ2FwcGluZyA9PT0gLTEgfHwgaGxzLmF1dG9MZXZlbENhcHBpbmcgPj0gY3VycmVudExldmVsKSkge1xuICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBjdXJyZW50TGV2ZWwgLSAxO1xuICAgICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuRlBTX0RST1BfTEVWRUxfQ0FQUElORywge1xuICAgICAgICAgICAgICAgIGxldmVsOiBjdXJyZW50TGV2ZWwsXG4gICAgICAgICAgICAgICAgZHJvcHBlZExldmVsOiBobHMuY3VycmVudExldmVsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBobHMuYXV0b0xldmVsQ2FwcGluZyA9IGN1cnJlbnRMZXZlbDtcbiAgICAgICAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbFN3aXRjaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5sYXN0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgdGhpcy5sYXN0RHJvcHBlZEZyYW1lcyA9IGRyb3BwZWRGcmFtZXM7XG4gICAgICB0aGlzLmxhc3REZWNvZGVkRnJhbWVzID0gZGVjb2RlZEZyYW1lcztcbiAgICB9XG4gIH1cbiAgY2hlY2tGUFNJbnRlcnZhbCgpIHtcbiAgICBjb25zdCB2aWRlbyA9IHRoaXMubWVkaWE7XG4gICAgaWYgKHZpZGVvKSB7XG4gICAgICBpZiAodGhpcy5pc1ZpZGVvUGxheWJhY2tRdWFsaXR5QXZhaWxhYmxlKSB7XG4gICAgICAgIGNvbnN0IHZpZGVvUGxheWJhY2tRdWFsaXR5ID0gdmlkZW8uZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkoKTtcbiAgICAgICAgdGhpcy5jaGVja0ZQUyh2aWRlbywgdmlkZW9QbGF5YmFja1F1YWxpdHkudG90YWxWaWRlb0ZyYW1lcywgdmlkZW9QbGF5YmFja1F1YWxpdHkuZHJvcHBlZFZpZGVvRnJhbWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEhUTUxWaWRlb0VsZW1lbnQgZG9lc24ndCBpbmNsdWRlIHRoZSB3ZWJraXQgdHlwZXNcbiAgICAgICAgdGhpcy5jaGVja0ZQUyh2aWRlbywgdmlkZW8ud2Via2l0RGVjb2RlZEZyYW1lQ291bnQsIHZpZGVvLndlYmtpdERyb3BwZWRGcmFtZUNvdW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuY29uc3QgTE9HR0VSX1BSRUZJWCA9ICdbZW1lXSc7XG4vKipcbiAqIENvbnRyb2xsZXIgdG8gZGVhbCB3aXRoIGVuY3J5cHRlZCBtZWRpYSBleHRlbnNpb25zIChFTUUpXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbmNyeXB0ZWRfTWVkaWFfRXh0ZW5zaW9uc19BUElcbiAqXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBFTUVDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5rZXlGb3JtYXRQcm9taXNlID0gbnVsbDtcbiAgICB0aGlzLmtleVN5c3RlbUFjY2Vzc1Byb21pc2VzID0ge307XG4gICAgdGhpcy5fcmVxdWVzdExpY2Vuc2VGYWlsdXJlQ291bnQgPSAwO1xuICAgIHRoaXMubWVkaWFLZXlTZXNzaW9ucyA9IFtdO1xuICAgIHRoaXMua2V5SWRUb0tleVNlc3Npb25Qcm9taXNlID0ge307XG4gICAgdGhpcy5zZXRNZWRpYUtleXNRdWV1ZSA9IEVNRUNvbnRyb2xsZXIuQ0RNQ2xlYW51cFByb21pc2UgPyBbRU1FQ29udHJvbGxlci5DRE1DbGVhbnVwUHJvbWlzZV0gOiBbXTtcbiAgICB0aGlzLm9uTWVkaWFFbmNyeXB0ZWQgPSB0aGlzLl9vbk1lZGlhRW5jcnlwdGVkLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbldhaXRpbmdGb3JLZXkgPSB0aGlzLl9vbldhaXRpbmdGb3JLZXkuYmluZCh0aGlzKTtcbiAgICB0aGlzLmRlYnVnID0gbG9nZ2VyLmRlYnVnLmJpbmQobG9nZ2VyLCBMT0dHRVJfUFJFRklYKTtcbiAgICB0aGlzLmxvZyA9IGxvZ2dlci5sb2cuYmluZChsb2dnZXIsIExPR0dFUl9QUkVGSVgpO1xuICAgIHRoaXMud2FybiA9IGxvZ2dlci53YXJuLmJpbmQobG9nZ2VyLCBMT0dHRVJfUFJFRklYKTtcbiAgICB0aGlzLmVycm9yID0gbG9nZ2VyLmVycm9yLmJpbmQobG9nZ2VyLCBMT0dHRVJfUFJFRklYKTtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5vbk1lZGlhRGV0YWNoZWQoKTtcbiAgICAvLyBSZW1vdmUgYW55IHJlZmVyZW5jZXMgdGhhdCBjb3VsZCBiZSBoZWxkIGluIGNvbmZpZyBvcHRpb25zIG9yIGNhbGxiYWNrc1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGNvbmZpZy5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NGdW5jID0gbnVsbDtcbiAgICBjb25maWcubGljZW5zZVhoclNldHVwID0gY29uZmlnLmxpY2Vuc2VSZXNwb25zZUNhbGxiYWNrID0gdW5kZWZpbmVkO1xuICAgIGNvbmZpZy5kcm1TeXN0ZW1zID0gY29uZmlnLmRybVN5c3RlbU9wdGlvbnMgPSB7fTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSB0aGlzLm9uTWVkaWFFbmNyeXB0ZWQgPSB0aGlzLm9uV2FpdGluZ0ZvcktleSA9IHRoaXMua2V5SWRUb0tleVNlc3Npb25Qcm9taXNlID0gbnVsbDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5jb25maWcgPSBudWxsO1xuICB9XG4gIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHRoaXMuaGxzLm9uKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9uKEV2ZW50cy5NRURJQV9ERVRBQ0hFRCwgdGhpcy5vbk1lZGlhRGV0YWNoZWQsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICB9XG4gIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5obHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9mZihFdmVudHMuTUVESUFfREVUQUNIRUQsIHRoaXMub25NZWRpYURldGFjaGVkLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICB9XG4gIGdldExpY2Vuc2VTZXJ2ZXJVcmwoa2V5U3lzdGVtKSB7XG4gICAgY29uc3Qge1xuICAgICAgZHJtU3lzdGVtcyxcbiAgICAgIHdpZGV2aW5lTGljZW5zZVVybFxuICAgIH0gPSB0aGlzLmNvbmZpZztcbiAgICBjb25zdCBrZXlTeXN0ZW1Db25maWd1cmF0aW9uID0gZHJtU3lzdGVtc1trZXlTeXN0ZW1dO1xuICAgIGlmIChrZXlTeXN0ZW1Db25maWd1cmF0aW9uKSB7XG4gICAgICByZXR1cm4ga2V5U3lzdGVtQ29uZmlndXJhdGlvbi5saWNlbnNlVXJsO1xuICAgIH1cblxuICAgIC8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgaWYgKGtleVN5c3RlbSA9PT0gS2V5U3lzdGVtcy5XSURFVklORSAmJiB3aWRldmluZUxpY2Vuc2VVcmwpIHtcbiAgICAgIHJldHVybiB3aWRldmluZUxpY2Vuc2VVcmw7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgbm8gbGljZW5zZSBzZXJ2ZXIgVVJMIGNvbmZpZ3VyZWQgZm9yIGtleS1zeXN0ZW0gXCIke2tleVN5c3RlbX1cImApO1xuICB9XG4gIGdldFNlcnZlckNlcnRpZmljYXRlVXJsKGtleVN5c3RlbSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRybVN5c3RlbXNcbiAgICB9ID0gdGhpcy5jb25maWc7XG4gICAgY29uc3Qga2V5U3lzdGVtQ29uZmlndXJhdGlvbiA9IGRybVN5c3RlbXNba2V5U3lzdGVtXTtcbiAgICBpZiAoa2V5U3lzdGVtQ29uZmlndXJhdGlvbikge1xuICAgICAgcmV0dXJuIGtleVN5c3RlbUNvbmZpZ3VyYXRpb24uc2VydmVyQ2VydGlmaWNhdGVVcmw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nKGBObyBTZXJ2ZXIgQ2VydGlmaWNhdGUgaW4gY29uZmlnLmRybVN5c3RlbXNbXCIke2tleVN5c3RlbX1cIl1gKTtcbiAgICB9XG4gIH1cbiAgYXR0ZW1wdEtleVN5c3RlbUFjY2VzcyhrZXlTeXN0ZW1zVG9BdHRlbXB0KSB7XG4gICAgY29uc3QgbGV2ZWxzID0gdGhpcy5obHMubGV2ZWxzO1xuICAgIGNvbnN0IHVuaXF1ZUNvZGVjID0gKHZhbHVlLCBpLCBhKSA9PiAhIXZhbHVlICYmIGEuaW5kZXhPZih2YWx1ZSkgPT09IGk7XG4gICAgY29uc3QgYXVkaW9Db2RlY3MgPSBsZXZlbHMubWFwKGxldmVsID0+IGxldmVsLmF1ZGlvQ29kZWMpLmZpbHRlcih1bmlxdWVDb2RlYyk7XG4gICAgY29uc3QgdmlkZW9Db2RlY3MgPSBsZXZlbHMubWFwKGxldmVsID0+IGxldmVsLnZpZGVvQ29kZWMpLmZpbHRlcih1bmlxdWVDb2RlYyk7XG4gICAgaWYgKGF1ZGlvQ29kZWNzLmxlbmd0aCArIHZpZGVvQ29kZWNzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdmlkZW9Db2RlY3MucHVzaCgnYXZjMS40MmUwMWUnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGF0dGVtcHQgPSBrZXlTeXN0ZW1zID0+IHtcbiAgICAgICAgY29uc3Qga2V5U3lzdGVtID0ga2V5U3lzdGVtcy5zaGlmdCgpO1xuICAgICAgICB0aGlzLmdldE1lZGlhS2V5c1Byb21pc2Uoa2V5U3lzdGVtLCBhdWRpb0NvZGVjcywgdmlkZW9Db2RlY3MpLnRoZW4obWVkaWFLZXlzID0+IHJlc29sdmUoe1xuICAgICAgICAgIGtleVN5c3RlbSxcbiAgICAgICAgICBtZWRpYUtleXNcbiAgICAgICAgfSkpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICBpZiAoa2V5U3lzdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGF0dGVtcHQoa2V5U3lzdGVtcyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChlcnJvciBpbnN0YW5jZW9mIEVNRUtleUVycm9yKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVNRUtleUVycm9yKHtcbiAgICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9OT19BQ0NFU1MsXG4gICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgICAgICAgfSwgZXJyb3IubWVzc2FnZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgYXR0ZW1wdChrZXlTeXN0ZW1zVG9BdHRlbXB0KTtcbiAgICB9KTtcbiAgfVxuICByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3Moa2V5U3lzdGVtLCBzdXBwb3J0ZWRDb25maWd1cmF0aW9ucykge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc0Z1bmNcbiAgICB9ID0gdGhpcy5jb25maWc7XG4gICAgaWYgKCEodHlwZW9mIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc0Z1bmMgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICBsZXQgZXJyTWVzc2FnZSA9IGBDb25maWd1cmVkIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyBpcyBub3QgYSBmdW5jdGlvbiAke3JlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc0Z1bmN9YDtcbiAgICAgIGlmIChyZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgPT09IG51bGwgJiYgc2VsZi5sb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2h0dHA6Jykge1xuICAgICAgICBlcnJNZXNzYWdlID0gYG5hdmlnYXRvci5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgaXMgbm90IGF2YWlsYWJsZSBvdmVyIGluc2VjdXJlIHByb3RvY29sICR7bG9jYXRpb24ucHJvdG9jb2x9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoZXJyTWVzc2FnZSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzRnVuYyhrZXlTeXN0ZW0sIHN1cHBvcnRlZENvbmZpZ3VyYXRpb25zKTtcbiAgfVxuICBnZXRNZWRpYUtleXNQcm9taXNlKGtleVN5c3RlbSwgYXVkaW9Db2RlY3MsIHZpZGVvQ29kZWNzKSB7XG4gICAgLy8gVGhpcyBjYW4gdGhyb3csIGJ1dCBpcyBjYXVnaHQgaW4gZXZlbnQgaGFuZGxlciBjYWxscGF0aFxuICAgIGNvbnN0IG1lZGlhS2V5U3lzdGVtQ29uZmlncyA9IGdldFN1cHBvcnRlZE1lZGlhS2V5U3lzdGVtQ29uZmlndXJhdGlvbnMoa2V5U3lzdGVtLCBhdWRpb0NvZGVjcywgdmlkZW9Db2RlY3MsIHRoaXMuY29uZmlnLmRybVN5c3RlbU9wdGlvbnMpO1xuICAgIGNvbnN0IGtleVN5c3RlbUFjY2Vzc1Byb21pc2VzID0gdGhpcy5rZXlTeXN0ZW1BY2Nlc3NQcm9taXNlc1trZXlTeXN0ZW1dO1xuICAgIGxldCBrZXlTeXN0ZW1BY2Nlc3MgPSBrZXlTeXN0ZW1BY2Nlc3NQcm9taXNlcyA9PSBudWxsID8gdm9pZCAwIDoga2V5U3lzdGVtQWNjZXNzUHJvbWlzZXMua2V5U3lzdGVtQWNjZXNzO1xuICAgIGlmICgha2V5U3lzdGVtQWNjZXNzKSB7XG4gICAgICB0aGlzLmxvZyhgUmVxdWVzdGluZyBlbmNyeXB0ZWQgbWVkaWEgXCIke2tleVN5c3RlbX1cIiBrZXktc3lzdGVtIGFjY2VzcyB3aXRoIGNvbmZpZzogJHtKU09OLnN0cmluZ2lmeShtZWRpYUtleVN5c3RlbUNvbmZpZ3MpfWApO1xuICAgICAga2V5U3lzdGVtQWNjZXNzID0gdGhpcy5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3Moa2V5U3lzdGVtLCBtZWRpYUtleVN5c3RlbUNvbmZpZ3MpO1xuICAgICAgY29uc3QgX2tleVN5c3RlbUFjY2Vzc1Byb21pc2VzID0gdGhpcy5rZXlTeXN0ZW1BY2Nlc3NQcm9taXNlc1trZXlTeXN0ZW1dID0ge1xuICAgICAgICBrZXlTeXN0ZW1BY2Nlc3NcbiAgICAgIH07XG4gICAgICBrZXlTeXN0ZW1BY2Nlc3MuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICB0aGlzLmxvZyhgRmFpbGVkIHRvIG9idGFpbiBhY2Nlc3MgdG8ga2V5LXN5c3RlbSBcIiR7a2V5U3lzdGVtfVwiOiAke2Vycm9yfWApO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4ga2V5U3lzdGVtQWNjZXNzLnRoZW4obWVkaWFLZXlTeXN0ZW1BY2Nlc3MgPT4ge1xuICAgICAgICB0aGlzLmxvZyhgQWNjZXNzIGZvciBrZXktc3lzdGVtIFwiJHttZWRpYUtleVN5c3RlbUFjY2Vzcy5rZXlTeXN0ZW19XCIgb2J0YWluZWRgKTtcbiAgICAgICAgY29uc3QgY2VydGlmaWNhdGVSZXF1ZXN0ID0gdGhpcy5mZXRjaFNlcnZlckNlcnRpZmljYXRlKGtleVN5c3RlbSk7XG4gICAgICAgIHRoaXMubG9nKGBDcmVhdGUgbWVkaWEta2V5cyBmb3IgXCIke2tleVN5c3RlbX1cImApO1xuICAgICAgICBfa2V5U3lzdGVtQWNjZXNzUHJvbWlzZXMubWVkaWFLZXlzID0gbWVkaWFLZXlTeXN0ZW1BY2Nlc3MuY3JlYXRlTWVkaWFLZXlzKCkudGhlbihtZWRpYUtleXMgPT4ge1xuICAgICAgICAgIHRoaXMubG9nKGBNZWRpYS1rZXlzIGNyZWF0ZWQgZm9yIFwiJHtrZXlTeXN0ZW19XCJgKTtcbiAgICAgICAgICByZXR1cm4gY2VydGlmaWNhdGVSZXF1ZXN0LnRoZW4oY2VydGlmaWNhdGUgPT4ge1xuICAgICAgICAgICAgaWYgKGNlcnRpZmljYXRlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldE1lZGlhS2V5c1NlcnZlckNlcnRpZmljYXRlKG1lZGlhS2V5cywga2V5U3lzdGVtLCBjZXJ0aWZpY2F0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVkaWFLZXlzO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgX2tleVN5c3RlbUFjY2Vzc1Byb21pc2VzLm1lZGlhS2V5cy5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgdGhpcy5lcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBtZWRpYS1rZXlzIGZvciBcIiR7a2V5U3lzdGVtfVwifTogJHtlcnJvcn1gKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfa2V5U3lzdGVtQWNjZXNzUHJvbWlzZXMubWVkaWFLZXlzO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBrZXlTeXN0ZW1BY2Nlc3MudGhlbigoKSA9PiBrZXlTeXN0ZW1BY2Nlc3NQcm9taXNlcy5tZWRpYUtleXMpO1xuICB9XG4gIGNyZWF0ZU1lZGlhS2V5U2Vzc2lvbkNvbnRleHQoe1xuICAgIGRlY3J5cHRkYXRhLFxuICAgIGtleVN5c3RlbSxcbiAgICBtZWRpYUtleXNcbiAgfSkge1xuICAgIHRoaXMubG9nKGBDcmVhdGluZyBrZXktc3lzdGVtIHNlc3Npb24gXCIke2tleVN5c3RlbX1cIiBrZXlJZDogJHtIZXguaGV4RHVtcChkZWNyeXB0ZGF0YS5rZXlJZCB8fCBbXSl9YCk7XG4gICAgY29uc3QgbWVkaWFLZXlzU2Vzc2lvbiA9IG1lZGlhS2V5cy5jcmVhdGVTZXNzaW9uKCk7XG4gICAgY29uc3QgbWVkaWFLZXlTZXNzaW9uQ29udGV4dCA9IHtcbiAgICAgIGRlY3J5cHRkYXRhLFxuICAgICAga2V5U3lzdGVtLFxuICAgICAgbWVkaWFLZXlzLFxuICAgICAgbWVkaWFLZXlzU2Vzc2lvbixcbiAgICAgIGtleVN0YXR1czogJ3N0YXR1cy1wZW5kaW5nJ1xuICAgIH07XG4gICAgdGhpcy5tZWRpYUtleVNlc3Npb25zLnB1c2gobWVkaWFLZXlTZXNzaW9uQ29udGV4dCk7XG4gICAgcmV0dXJuIG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQ7XG4gIH1cbiAgcmVuZXdLZXlTZXNzaW9uKG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQpIHtcbiAgICBjb25zdCBkZWNyeXB0ZGF0YSA9IG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQuZGVjcnlwdGRhdGE7XG4gICAgaWYgKGRlY3J5cHRkYXRhLnBzc2gpIHtcbiAgICAgIGNvbnN0IGtleVNlc3Npb25Db250ZXh0ID0gdGhpcy5jcmVhdGVNZWRpYUtleVNlc3Npb25Db250ZXh0KG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQpO1xuICAgICAgY29uc3Qga2V5SWQgPSB0aGlzLmdldEtleUlkU3RyaW5nKGRlY3J5cHRkYXRhKTtcbiAgICAgIGNvbnN0IHNjaGVtZSA9ICdjZW5jJztcbiAgICAgIHRoaXMua2V5SWRUb0tleVNlc3Npb25Qcm9taXNlW2tleUlkXSA9IHRoaXMuZ2VuZXJhdGVSZXF1ZXN0V2l0aFByZWZlcnJlZEtleVNlc3Npb24oa2V5U2Vzc2lvbkNvbnRleHQsIHNjaGVtZSwgZGVjcnlwdGRhdGEucHNzaCwgJ2V4cGlyZWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53YXJuKGBDb3VsZCBub3QgcmVuZXcgZXhwaXJlZCBzZXNzaW9uLiBNaXNzaW5nIHBzc2ggaW5pdERhdGEuYCk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlU2Vzc2lvbihtZWRpYUtleVNlc3Npb25Db250ZXh0KTtcbiAgfVxuICBnZXRLZXlJZFN0cmluZyhkZWNyeXB0ZGF0YSkge1xuICAgIGlmICghZGVjcnlwdGRhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHJlYWQga2V5SWQgb2YgdW5kZWZpbmVkIGRlY3J5cHRkYXRhJyk7XG4gICAgfVxuICAgIGlmIChkZWNyeXB0ZGF0YS5rZXlJZCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdrZXlJZCBpcyBudWxsJyk7XG4gICAgfVxuICAgIHJldHVybiBIZXguaGV4RHVtcChkZWNyeXB0ZGF0YS5rZXlJZCk7XG4gIH1cbiAgdXBkYXRlS2V5U2Vzc2lvbihtZWRpYUtleVNlc3Npb25Db250ZXh0LCBkYXRhKSB7XG4gICAgdmFyIF9tZWRpYUtleVNlc3Npb25Db250ZTtcbiAgICBjb25zdCBrZXlTZXNzaW9uID0gbWVkaWFLZXlTZXNzaW9uQ29udGV4dC5tZWRpYUtleXNTZXNzaW9uO1xuICAgIHRoaXMubG9nKGBVcGRhdGluZyBrZXktc2Vzc2lvbiBcIiR7a2V5U2Vzc2lvbi5zZXNzaW9uSWR9XCIgZm9yIGtleUlEICR7SGV4LmhleER1bXAoKChfbWVkaWFLZXlTZXNzaW9uQ29udGUgPSBtZWRpYUtleVNlc3Npb25Db250ZXh0LmRlY3J5cHRkYXRhKSA9PSBudWxsID8gdm9pZCAwIDogX21lZGlhS2V5U2Vzc2lvbkNvbnRlLmtleUlkKSB8fCBbXSl9XG4gICAgICB9IChkYXRhIGxlbmd0aDogJHtkYXRhID8gZGF0YS5ieXRlTGVuZ3RoIDogZGF0YX0pYCk7XG4gICAgcmV0dXJuIGtleVNlc3Npb24udXBkYXRlKGRhdGEpO1xuICB9XG4gIHNlbGVjdEtleVN5c3RlbUZvcm1hdChmcmFnKSB7XG4gICAgY29uc3Qga2V5Rm9ybWF0cyA9IE9iamVjdC5rZXlzKGZyYWcubGV2ZWxrZXlzIHx8IHt9KTtcbiAgICBpZiAoIXRoaXMua2V5Rm9ybWF0UHJvbWlzZSkge1xuICAgICAgdGhpcy5sb2coYFNlbGVjdGluZyBrZXktc3lzdGVtIGZyb20gZnJhZ21lbnQgKHNuOiAke2ZyYWcuc259ICR7ZnJhZy50eXBlfTogJHtmcmFnLmxldmVsfSkga2V5IGZvcm1hdHMgJHtrZXlGb3JtYXRzLmpvaW4oJywgJyl9YCk7XG4gICAgICB0aGlzLmtleUZvcm1hdFByb21pc2UgPSB0aGlzLmdldEtleUZvcm1hdFByb21pc2Uoa2V5Rm9ybWF0cyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmtleUZvcm1hdFByb21pc2U7XG4gIH1cbiAgZ2V0S2V5Rm9ybWF0UHJvbWlzZShrZXlGb3JtYXRzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGtleVN5c3RlbXNJbkNvbmZpZyA9IGdldEtleVN5c3RlbXNGb3JDb25maWcodGhpcy5jb25maWcpO1xuICAgICAgY29uc3Qga2V5U3lzdGVtc1RvQXR0ZW1wdCA9IGtleUZvcm1hdHMubWFwKGtleVN5c3RlbUZvcm1hdFRvS2V5U3lzdGVtRG9tYWluKS5maWx0ZXIodmFsdWUgPT4gISF2YWx1ZSAmJiBrZXlTeXN0ZW1zSW5Db25maWcuaW5kZXhPZih2YWx1ZSkgIT09IC0xKTtcbiAgICAgIHJldHVybiB0aGlzLmdldEtleVN5c3RlbVNlbGVjdGlvblByb21pc2Uoa2V5U3lzdGVtc1RvQXR0ZW1wdCkudGhlbigoe1xuICAgICAgICBrZXlTeXN0ZW1cbiAgICAgIH0pID0+IHtcbiAgICAgICAgY29uc3Qga2V5U3lzdGVtRm9ybWF0ID0ga2V5U3lzdGVtRG9tYWluVG9LZXlTeXN0ZW1Gb3JtYXQoa2V5U3lzdGVtKTtcbiAgICAgICAgaWYgKGtleVN5c3RlbUZvcm1hdCkge1xuICAgICAgICAgIHJlc29sdmUoa2V5U3lzdGVtRm9ybWF0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBVbmFibGUgdG8gZmluZCBmb3JtYXQgZm9yIGtleS1zeXN0ZW0gXCIke2tleVN5c3RlbX1cImApKTtcbiAgICAgICAgfVxuICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcbiAgICB9KTtcbiAgfVxuICBsb2FkS2V5KGRhdGEpIHtcbiAgICBjb25zdCBkZWNyeXB0ZGF0YSA9IGRhdGEua2V5SW5mby5kZWNyeXB0ZGF0YTtcbiAgICBjb25zdCBrZXlJZCA9IHRoaXMuZ2V0S2V5SWRTdHJpbmcoZGVjcnlwdGRhdGEpO1xuICAgIGNvbnN0IGtleURldGFpbHMgPSBgKGtleUlkOiAke2tleUlkfSBmb3JtYXQ6IFwiJHtkZWNyeXB0ZGF0YS5rZXlGb3JtYXR9XCIgbWV0aG9kOiAke2RlY3J5cHRkYXRhLm1ldGhvZH0gdXJpOiAke2RlY3J5cHRkYXRhLnVyaX0pYDtcbiAgICB0aGlzLmxvZyhgU3RhcnRpbmcgc2Vzc2lvbiBmb3Iga2V5ICR7a2V5RGV0YWlsc31gKTtcbiAgICBsZXQga2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlID0gdGhpcy5rZXlJZFRvS2V5U2Vzc2lvblByb21pc2Vba2V5SWRdO1xuICAgIGlmICgha2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlKSB7XG4gICAgICBrZXlTZXNzaW9uQ29udGV4dFByb21pc2UgPSB0aGlzLmtleUlkVG9LZXlTZXNzaW9uUHJvbWlzZVtrZXlJZF0gPSB0aGlzLmdldEtleVN5c3RlbUZvcktleVByb21pc2UoZGVjcnlwdGRhdGEpLnRoZW4oKHtcbiAgICAgICAga2V5U3lzdGVtLFxuICAgICAgICBtZWRpYUtleXNcbiAgICAgIH0pID0+IHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgIHRoaXMubG9nKGBIYW5kbGUgZW5jcnlwdGVkIG1lZGlhIHNuOiAke2RhdGEuZnJhZy5zbn0gJHtkYXRhLmZyYWcudHlwZX06ICR7ZGF0YS5mcmFnLmxldmVsfSB1c2luZyBrZXkgJHtrZXlEZXRhaWxzfWApO1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRlbXB0U2V0TWVkaWFLZXlzKGtleVN5c3RlbSwgbWVkaWFLZXlzKS50aGVuKCgpID0+IHtcbiAgICAgICAgICB0aGlzLnRocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgICBjb25zdCBrZXlTZXNzaW9uQ29udGV4dCA9IHRoaXMuY3JlYXRlTWVkaWFLZXlTZXNzaW9uQ29udGV4dCh7XG4gICAgICAgICAgICBrZXlTeXN0ZW0sXG4gICAgICAgICAgICBtZWRpYUtleXMsXG4gICAgICAgICAgICBkZWNyeXB0ZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHNjaGVtZSA9ICdjZW5jJztcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZVJlcXVlc3RXaXRoUHJlZmVycmVkS2V5U2Vzc2lvbihrZXlTZXNzaW9uQ29udGV4dCwgc2NoZW1lLCBkZWNyeXB0ZGF0YS5wc3NoLCAncGxheWxpc3Qta2V5Jyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBrZXlTZXNzaW9uQ29udGV4dFByb21pc2UuY2F0Y2goZXJyb3IgPT4gdGhpcy5oYW5kbGVFcnJvcihlcnJvcikpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlO1xuICB9XG4gIHRocm93SWZEZXN0cm95ZWQobWVzc2FnZSA9ICdJbnZhbGlkIHN0YXRlJykge1xuICAgIGlmICghdGhpcy5obHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzdGF0ZScpO1xuICAgIH1cbiAgfVxuICBoYW5kbGVFcnJvcihlcnJvcikge1xuICAgIGlmICghdGhpcy5obHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFTUVLZXlFcnJvcikge1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIGVycm9yLmRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX05PX0tFWVMsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldEtleVN5c3RlbUZvcktleVByb21pc2UoZGVjcnlwdGRhdGEpIHtcbiAgICBjb25zdCBrZXlJZCA9IHRoaXMuZ2V0S2V5SWRTdHJpbmcoZGVjcnlwdGRhdGEpO1xuICAgIGNvbnN0IG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQgPSB0aGlzLmtleUlkVG9LZXlTZXNzaW9uUHJvbWlzZVtrZXlJZF07XG4gICAgaWYgKCFtZWRpYUtleVNlc3Npb25Db250ZXh0KSB7XG4gICAgICBjb25zdCBrZXlTeXN0ZW0gPSBrZXlTeXN0ZW1Gb3JtYXRUb0tleVN5c3RlbURvbWFpbihkZWNyeXB0ZGF0YS5rZXlGb3JtYXQpO1xuICAgICAgY29uc3Qga2V5U3lzdGVtc1RvQXR0ZW1wdCA9IGtleVN5c3RlbSA/IFtrZXlTeXN0ZW1dIDogZ2V0S2V5U3lzdGVtc0ZvckNvbmZpZyh0aGlzLmNvbmZpZyk7XG4gICAgICByZXR1cm4gdGhpcy5hdHRlbXB0S2V5U3lzdGVtQWNjZXNzKGtleVN5c3RlbXNUb0F0dGVtcHQpO1xuICAgIH1cbiAgICByZXR1cm4gbWVkaWFLZXlTZXNzaW9uQ29udGV4dDtcbiAgfVxuICBnZXRLZXlTeXN0ZW1TZWxlY3Rpb25Qcm9taXNlKGtleVN5c3RlbXNUb0F0dGVtcHQpIHtcbiAgICBpZiAoIWtleVN5c3RlbXNUb0F0dGVtcHQubGVuZ3RoKSB7XG4gICAgICBrZXlTeXN0ZW1zVG9BdHRlbXB0ID0gZ2V0S2V5U3lzdGVtc0ZvckNvbmZpZyh0aGlzLmNvbmZpZyk7XG4gICAgfVxuICAgIGlmIChrZXlTeXN0ZW1zVG9BdHRlbXB0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVNRUtleUVycm9yKHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9OT19DT05GSUdVUkVEX0xJQ0VOU0UsXG4gICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICB9LCBgTWlzc2luZyBrZXktc3lzdGVtIGxpY2Vuc2UgY29uZmlndXJhdGlvbiBvcHRpb25zICR7SlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBkcm1TeXN0ZW1zOiB0aGlzLmNvbmZpZy5kcm1TeXN0ZW1zXG4gICAgICB9KX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYXR0ZW1wdEtleVN5c3RlbUFjY2VzcyhrZXlTeXN0ZW1zVG9BdHRlbXB0KTtcbiAgfVxuICBfb25NZWRpYUVuY3J5cHRlZChldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGluaXREYXRhVHlwZSxcbiAgICAgIGluaXREYXRhXG4gICAgfSA9IGV2ZW50O1xuICAgIHRoaXMuZGVidWcoYFwiJHtldmVudC50eXBlfVwiIGV2ZW50OiBpbml0IGRhdGEgdHlwZTogXCIke2luaXREYXRhVHlwZX1cImApO1xuXG4gICAgLy8gSWdub3JlIGV2ZW50IHdoZW4gaW5pdERhdGEgaXMgbnVsbFxuICAgIGlmIChpbml0RGF0YSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQga2V5SWQ7XG4gICAgbGV0IGtleVN5c3RlbURvbWFpbjtcbiAgICBpZiAoaW5pdERhdGFUeXBlID09PSAnc2luZicgJiYgdGhpcy5jb25maWcuZHJtU3lzdGVtc1tLZXlTeXN0ZW1zLkZBSVJQTEFZXSkge1xuICAgICAgLy8gTWF0Y2ggc2luZiBrZXlJZCB0byBwbGF5bGlzdCBza2Q6Ly9rZXlJZD1cbiAgICAgIGNvbnN0IGpzb24gPSBiaW4yc3RyKG5ldyBVaW50OEFycmF5KGluaXREYXRhKSk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzaW5mID0gYmFzZTY0RGVjb2RlKEpTT04ucGFyc2UoanNvbikuc2luZik7XG4gICAgICAgIGNvbnN0IHRlbmMgPSBwYXJzZVNpbmYobmV3IFVpbnQ4QXJyYXkoc2luZikpO1xuICAgICAgICBpZiAoIXRlbmMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAga2V5SWQgPSB0ZW5jLnN1YmFycmF5KDgsIDI0KTtcbiAgICAgICAga2V5U3lzdGVtRG9tYWluID0gS2V5U3lzdGVtcy5GQUlSUExBWTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRoaXMud2FybignRmFpbGVkIHRvIHBhcnNlIHNpbmYgXCJlbmNyeXB0ZWRcIiBldmVudCBtZXNzYWdlIGluaXREYXRhJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3VwcG9ydCBjbGVhci1sZWFkIGtleS1zZXNzaW9uIGNyZWF0aW9uIChvdGhlcndpc2UgZGVwZW5kIG9uIHBsYXlsaXN0IGtleXMpXG4gICAgICBjb25zdCBwc3NoSW5mbyA9IHBhcnNlUHNzaChpbml0RGF0YSk7XG4gICAgICBpZiAocHNzaEluZm8gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHBzc2hJbmZvLnZlcnNpb24gPT09IDAgJiYgcHNzaEluZm8uc3lzdGVtSWQgPT09IEtleVN5c3RlbUlkcy5XSURFVklORSAmJiBwc3NoSW5mby5kYXRhKSB7XG4gICAgICAgIGtleUlkID0gcHNzaEluZm8uZGF0YS5zdWJhcnJheSg4LCAyNCk7XG4gICAgICB9XG4gICAgICBrZXlTeXN0ZW1Eb21haW4gPSBrZXlTeXN0ZW1JZFRvS2V5U3lzdGVtRG9tYWluKHBzc2hJbmZvLnN5c3RlbUlkKTtcbiAgICB9XG4gICAgaWYgKCFrZXlTeXN0ZW1Eb21haW4gfHwgIWtleUlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGtleUlkSGV4ID0gSGV4LmhleER1bXAoa2V5SWQpO1xuICAgIGNvbnN0IHtcbiAgICAgIGtleUlkVG9LZXlTZXNzaW9uUHJvbWlzZSxcbiAgICAgIG1lZGlhS2V5U2Vzc2lvbnNcbiAgICB9ID0gdGhpcztcbiAgICBsZXQga2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlID0ga2V5SWRUb0tleVNlc3Npb25Qcm9taXNlW2tleUlkSGV4XTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lZGlhS2V5U2Vzc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIE1hdGNoIHBsYXlsaXN0IGtleVxuICAgICAgY29uc3Qga2V5Q29udGV4dCA9IG1lZGlhS2V5U2Vzc2lvbnNbaV07XG4gICAgICBjb25zdCBkZWNyeXB0ZGF0YSA9IGtleUNvbnRleHQuZGVjcnlwdGRhdGE7XG4gICAgICBpZiAoZGVjcnlwdGRhdGEucHNzaCB8fCAhZGVjcnlwdGRhdGEua2V5SWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBvbGRLZXlJZEhleCA9IEhleC5oZXhEdW1wKGRlY3J5cHRkYXRhLmtleUlkKTtcbiAgICAgIGlmIChrZXlJZEhleCA9PT0gb2xkS2V5SWRIZXggfHwgZGVjcnlwdGRhdGEudXJpLnJlcGxhY2UoLy0vZywgJycpLmluZGV4T2Yoa2V5SWRIZXgpICE9PSAtMSkge1xuICAgICAgICBrZXlTZXNzaW9uQ29udGV4dFByb21pc2UgPSBrZXlJZFRvS2V5U2Vzc2lvblByb21pc2Vbb2xkS2V5SWRIZXhdO1xuICAgICAgICBkZWxldGUga2V5SWRUb0tleVNlc3Npb25Qcm9taXNlW29sZEtleUlkSGV4XTtcbiAgICAgICAgZGVjcnlwdGRhdGEucHNzaCA9IG5ldyBVaW50OEFycmF5KGluaXREYXRhKTtcbiAgICAgICAgZGVjcnlwdGRhdGEua2V5SWQgPSBrZXlJZDtcbiAgICAgICAga2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlID0ga2V5SWRUb0tleVNlc3Npb25Qcm9taXNlW2tleUlkSGV4XSA9IGtleVNlc3Npb25Db250ZXh0UHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZVJlcXVlc3RXaXRoUHJlZmVycmVkS2V5U2Vzc2lvbihrZXlDb250ZXh0LCBpbml0RGF0YVR5cGUsIGluaXREYXRhLCAnZW5jcnlwdGVkLWV2ZW50LWtleS1tYXRjaCcpO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgha2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlKSB7XG4gICAgICAvLyBDbGVhci1sZWFkIGtleSAobm90IGVuY291bnRlcmVkIGluIHBsYXlsaXN0KVxuICAgICAga2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlID0ga2V5SWRUb0tleVNlc3Npb25Qcm9taXNlW2tleUlkSGV4XSA9IHRoaXMuZ2V0S2V5U3lzdGVtU2VsZWN0aW9uUHJvbWlzZShba2V5U3lzdGVtRG9tYWluXSkudGhlbigoe1xuICAgICAgICBrZXlTeXN0ZW0sXG4gICAgICAgIG1lZGlhS2V5c1xuICAgICAgfSkgPT4ge1xuICAgICAgICB2YXIgX2tleVN5c3RlbVRvS2V5U3lzdGVtO1xuICAgICAgICB0aGlzLnRocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgY29uc3QgZGVjcnlwdGRhdGEgPSBuZXcgTGV2ZWxLZXkoJ0lTTy0yMzAwMS03Jywga2V5SWRIZXgsIChfa2V5U3lzdGVtVG9LZXlTeXN0ZW0gPSBrZXlTeXN0ZW1Eb21haW5Ub0tleVN5c3RlbUZvcm1hdChrZXlTeXN0ZW0pKSAhPSBudWxsID8gX2tleVN5c3RlbVRvS2V5U3lzdGVtIDogJycpO1xuICAgICAgICBkZWNyeXB0ZGF0YS5wc3NoID0gbmV3IFVpbnQ4QXJyYXkoaW5pdERhdGEpO1xuICAgICAgICBkZWNyeXB0ZGF0YS5rZXlJZCA9IGtleUlkO1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRlbXB0U2V0TWVkaWFLZXlzKGtleVN5c3RlbSwgbWVkaWFLZXlzKS50aGVuKCgpID0+IHtcbiAgICAgICAgICB0aGlzLnRocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgICBjb25zdCBrZXlTZXNzaW9uQ29udGV4dCA9IHRoaXMuY3JlYXRlTWVkaWFLZXlTZXNzaW9uQ29udGV4dCh7XG4gICAgICAgICAgICBkZWNyeXB0ZGF0YSxcbiAgICAgICAgICAgIGtleVN5c3RlbSxcbiAgICAgICAgICAgIG1lZGlhS2V5c1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlUmVxdWVzdFdpdGhQcmVmZXJyZWRLZXlTZXNzaW9uKGtleVNlc3Npb25Db250ZXh0LCBpbml0RGF0YVR5cGUsIGluaXREYXRhLCAnZW5jcnlwdGVkLWV2ZW50LW5vLW1hdGNoJyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGtleVNlc3Npb25Db250ZXh0UHJvbWlzZS5jYXRjaChlcnJvciA9PiB0aGlzLmhhbmRsZUVycm9yKGVycm9yKSk7XG4gIH1cbiAgX29uV2FpdGluZ0ZvcktleShldmVudCkge1xuICAgIHRoaXMubG9nKGBcIiR7ZXZlbnQudHlwZX1cIiBldmVudGApO1xuICB9XG4gIGF0dGVtcHRTZXRNZWRpYUtleXMoa2V5U3lzdGVtLCBtZWRpYUtleXMpIHtcbiAgICBjb25zdCBxdWV1ZSA9IHRoaXMuc2V0TWVkaWFLZXlzUXVldWUuc2xpY2UoKTtcbiAgICB0aGlzLmxvZyhgU2V0dGluZyBtZWRpYS1rZXlzIGZvciBcIiR7a2V5U3lzdGVtfVwiYCk7XG4gICAgLy8gT25seSBvbmUgc2V0TWVkaWFLZXlzKCkgY2FuIHJ1biBhdCBvbmUgdGltZSwgYW5kIG11bHRpcGxlIHNldE1lZGlhS2V5cygpIG9wZXJhdGlvbnNcbiAgICAvLyBjYW4gYmUgcXVldWVkIGZvciBleGVjdXRpb24gZm9yIG11bHRpcGxlIGtleSBzZXNzaW9ucy5cbiAgICBjb25zdCBzZXRNZWRpYUtleXNQcm9taXNlID0gUHJvbWlzZS5hbGwocXVldWUpLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIHNldCBtZWRpYUtleXMgd2l0aG91dCBtZWRpYSBlbGVtZW50IGF0dGFjaGVkJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5tZWRpYS5zZXRNZWRpYUtleXMobWVkaWFLZXlzKTtcbiAgICB9KTtcbiAgICB0aGlzLnNldE1lZGlhS2V5c1F1ZXVlLnB1c2goc2V0TWVkaWFLZXlzUHJvbWlzZSk7XG4gICAgcmV0dXJuIHNldE1lZGlhS2V5c1Byb21pc2UudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLmxvZyhgTWVkaWEta2V5cyBzZXQgZm9yIFwiJHtrZXlTeXN0ZW19XCJgKTtcbiAgICAgIHF1ZXVlLnB1c2goc2V0TWVkaWFLZXlzUHJvbWlzZSk7XG4gICAgICB0aGlzLnNldE1lZGlhS2V5c1F1ZXVlID0gdGhpcy5zZXRNZWRpYUtleXNRdWV1ZS5maWx0ZXIocCA9PiBxdWV1ZS5pbmRleE9mKHApID09PSAtMSk7XG4gICAgfSk7XG4gIH1cbiAgZ2VuZXJhdGVSZXF1ZXN0V2l0aFByZWZlcnJlZEtleVNlc3Npb24oY29udGV4dCwgaW5pdERhdGFUeXBlLCBpbml0RGF0YSwgcmVhc29uKSB7XG4gICAgdmFyIF90aGlzJGNvbmZpZyRkcm1TeXN0ZSwgX3RoaXMkY29uZmlnJGRybVN5c3RlMjtcbiAgICBjb25zdCBnZW5lcmF0ZVJlcXVlc3RGaWx0ZXIgPSAoX3RoaXMkY29uZmlnJGRybVN5c3RlID0gdGhpcy5jb25maWcuZHJtU3lzdGVtcykgPT0gbnVsbCA/IHZvaWQgMCA6IChfdGhpcyRjb25maWckZHJtU3lzdGUyID0gX3RoaXMkY29uZmlnJGRybVN5c3RlW2NvbnRleHQua2V5U3lzdGVtXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGNvbmZpZyRkcm1TeXN0ZTIuZ2VuZXJhdGVSZXF1ZXN0O1xuICAgIGlmIChnZW5lcmF0ZVJlcXVlc3RGaWx0ZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG1hcHBlZEluaXREYXRhID0gZ2VuZXJhdGVSZXF1ZXN0RmlsdGVyLmNhbGwodGhpcy5obHMsIGluaXREYXRhVHlwZSwgaW5pdERhdGEsIGNvbnRleHQpO1xuICAgICAgICBpZiAoIW1hcHBlZEluaXREYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJlc3BvbnNlIGZyb20gY29uZmlndXJlZCBnZW5lcmF0ZVJlcXVlc3QgZmlsdGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaW5pdERhdGFUeXBlID0gbWFwcGVkSW5pdERhdGEuaW5pdERhdGFUeXBlO1xuICAgICAgICBpbml0RGF0YSA9IGNvbnRleHQuZGVjcnlwdGRhdGEucHNzaCA9IG1hcHBlZEluaXREYXRhLmluaXREYXRhID8gbmV3IFVpbnQ4QXJyYXkobWFwcGVkSW5pdERhdGEuaW5pdERhdGEpIDogbnVsbDtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHZhciBfdGhpcyRobHM7XG4gICAgICAgIHRoaXMud2FybihlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgaWYgKChfdGhpcyRobHMgPSB0aGlzLmhscykgIT0gbnVsbCAmJiBfdGhpcyRobHMuY29uZmlnLmRlYnVnKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluaXREYXRhID09PSBudWxsKSB7XG4gICAgICB0aGlzLmxvZyhgU2tpcHBpbmcga2V5LXNlc3Npb24gcmVxdWVzdCBmb3IgXCIke3JlYXNvbn1cIiAobm8gaW5pdERhdGEpYCk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNvbnRleHQpO1xuICAgIH1cbiAgICBjb25zdCBrZXlJZCA9IHRoaXMuZ2V0S2V5SWRTdHJpbmcoY29udGV4dC5kZWNyeXB0ZGF0YSk7XG4gICAgdGhpcy5sb2coYEdlbmVyYXRpbmcga2V5LXNlc3Npb24gcmVxdWVzdCBmb3IgXCIke3JlYXNvbn1cIjogJHtrZXlJZH0gKGluaXQgZGF0YSB0eXBlOiAke2luaXREYXRhVHlwZX0gbGVuZ3RoOiAke2luaXREYXRhID8gaW5pdERhdGEuYnl0ZUxlbmd0aCA6IG51bGx9KWApO1xuICAgIGNvbnN0IGxpY2Vuc2VTdGF0dXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgY29uc3Qgb25tZXNzYWdlID0gY29udGV4dC5fb25tZXNzYWdlID0gZXZlbnQgPT4ge1xuICAgICAgY29uc3Qga2V5U2Vzc2lvbiA9IGNvbnRleHQubWVkaWFLZXlzU2Vzc2lvbjtcbiAgICAgIGlmICgha2V5U2Vzc2lvbikge1xuICAgICAgICBsaWNlbnNlU3RhdHVzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdpbnZhbGlkIHN0YXRlJykpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1lc3NhZ2VUeXBlLFxuICAgICAgICBtZXNzYWdlXG4gICAgICB9ID0gZXZlbnQ7XG4gICAgICB0aGlzLmxvZyhgXCIke21lc3NhZ2VUeXBlfVwiIG1lc3NhZ2UgZXZlbnQgZm9yIHNlc3Npb24gXCIke2tleVNlc3Npb24uc2Vzc2lvbklkfVwiIG1lc3NhZ2Ugc2l6ZTogJHttZXNzYWdlLmJ5dGVMZW5ndGh9YCk7XG4gICAgICBpZiAobWVzc2FnZVR5cGUgPT09ICdsaWNlbnNlLXJlcXVlc3QnIHx8IG1lc3NhZ2VUeXBlID09PSAnbGljZW5zZS1yZW5ld2FsJykge1xuICAgICAgICB0aGlzLnJlbmV3TGljZW5zZShjb250ZXh0LCBtZXNzYWdlKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihlcnJvcik7XG4gICAgICAgICAgbGljZW5zZVN0YXR1cy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKG1lc3NhZ2VUeXBlID09PSAnbGljZW5zZS1yZWxlYXNlJykge1xuICAgICAgICBpZiAoY29udGV4dC5rZXlTeXN0ZW0gPT09IEtleVN5c3RlbXMuRkFJUlBMQVkpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUtleVNlc3Npb24oY29udGV4dCwgc3RyVG9VdGY4YXJyYXkoJ2Fja25vd2xlZGdlZCcpKTtcbiAgICAgICAgICB0aGlzLnJlbW92ZVNlc3Npb24oY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud2FybihgdW5oYW5kbGVkIG1lZGlhIGtleSBtZXNzYWdlIHR5cGUgXCIke21lc3NhZ2VUeXBlfVwiYCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBvbmtleXN0YXR1c2VzY2hhbmdlID0gY29udGV4dC5fb25rZXlzdGF0dXNlc2NoYW5nZSA9IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGtleVNlc3Npb24gPSBjb250ZXh0Lm1lZGlhS2V5c1Nlc3Npb247XG4gICAgICBpZiAoIWtleVNlc3Npb24pIHtcbiAgICAgICAgbGljZW5zZVN0YXR1cy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignaW52YWxpZCBzdGF0ZScpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5vbktleVN0YXR1c0NoYW5nZShjb250ZXh0KTtcbiAgICAgIGNvbnN0IGtleVN0YXR1cyA9IGNvbnRleHQua2V5U3RhdHVzO1xuICAgICAgbGljZW5zZVN0YXR1cy5lbWl0KCdrZXlTdGF0dXMnLCBrZXlTdGF0dXMpO1xuICAgICAgaWYgKGtleVN0YXR1cyA9PT0gJ2V4cGlyZWQnKSB7XG4gICAgICAgIHRoaXMud2FybihgJHtjb250ZXh0LmtleVN5c3RlbX0gZXhwaXJlZCBmb3Iga2V5ICR7a2V5SWR9YCk7XG4gICAgICAgIHRoaXMucmVuZXdLZXlTZXNzaW9uKGNvbnRleHQpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29udGV4dC5tZWRpYUtleXNTZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBvbm1lc3NhZ2UpO1xuICAgIGNvbnRleHQubWVkaWFLZXlzU2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKCdrZXlzdGF0dXNlc2NoYW5nZScsIG9ua2V5c3RhdHVzZXNjaGFuZ2UpO1xuICAgIGNvbnN0IGtleVVzYWJsZVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsaWNlbnNlU3RhdHVzLm9uKCdlcnJvcicsIHJlamVjdCk7XG4gICAgICBsaWNlbnNlU3RhdHVzLm9uKCdrZXlTdGF0dXMnLCBrZXlTdGF0dXMgPT4ge1xuICAgICAgICBpZiAoa2V5U3RhdHVzLnN0YXJ0c1dpdGgoJ3VzYWJsZScpKSB7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGtleVN0YXR1cyA9PT0gJ291dHB1dC1yZXN0cmljdGVkJykge1xuICAgICAgICAgIHJlamVjdChuZXcgRU1FS2V5RXJyb3Ioe1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fU1RBVFVTX09VVFBVVF9SRVNUUklDVEVELFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlXG4gICAgICAgICAgfSwgJ0hEQ1AgbGV2ZWwgb3V0cHV0IHJlc3RyaWN0ZWQnKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5U3RhdHVzID09PSAnaW50ZXJuYWwtZXJyb3InKSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFTUVLZXlFcnJvcih7XG4gICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9TVEFUVVNfSU5URVJOQUxfRVJST1IsXG4gICAgICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgICAgIH0sIGBrZXkgc3RhdHVzIGNoYW5nZWQgdG8gXCIke2tleVN0YXR1c31cImApKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXlTdGF0dXMgPT09ICdleHBpcmVkJykge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ2tleSBleHBpcmVkIHdoaWxlIGdlbmVyYXRpbmcgcmVxdWVzdCcpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLndhcm4oYHVuaGFuZGxlZCBrZXkgc3RhdHVzIGNoYW5nZSBcIiR7a2V5U3RhdHVzfVwiYCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBjb250ZXh0Lm1lZGlhS2V5c1Nlc3Npb24uZ2VuZXJhdGVSZXF1ZXN0KGluaXREYXRhVHlwZSwgaW5pdERhdGEpLnRoZW4oKCkgPT4ge1xuICAgICAgdmFyIF9jb250ZXh0JG1lZGlhS2V5c1NlcztcbiAgICAgIHRoaXMubG9nKGBSZXF1ZXN0IGdlbmVyYXRlZCBmb3Iga2V5LXNlc3Npb24gXCIkeyhfY29udGV4dCRtZWRpYUtleXNTZXMgPSBjb250ZXh0Lm1lZGlhS2V5c1Nlc3Npb24pID09IG51bGwgPyB2b2lkIDAgOiBfY29udGV4dCRtZWRpYUtleXNTZXMuc2Vzc2lvbklkfVwiIGtleUlkOiAke2tleUlkfWApO1xuICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgIHRocm93IG5ldyBFTUVLZXlFcnJvcih7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fTk9fU0VTU0lPTixcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGZhdGFsOiBmYWxzZVxuICAgICAgfSwgYEVycm9yIGdlbmVyYXRpbmcga2V5LXNlc3Npb24gcmVxdWVzdDogJHtlcnJvcn1gKTtcbiAgICB9KS50aGVuKCgpID0+IGtleVVzYWJsZVByb21pc2UpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgIGxpY2Vuc2VTdGF0dXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLnJlbW92ZVNlc3Npb24oY29udGV4dCk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgIGxpY2Vuc2VTdGF0dXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9KTtcbiAgfVxuICBvbktleVN0YXR1c0NoYW5nZShtZWRpYUtleVNlc3Npb25Db250ZXh0KSB7XG4gICAgbWVkaWFLZXlTZXNzaW9uQ29udGV4dC5tZWRpYUtleXNTZXNzaW9uLmtleVN0YXR1c2VzLmZvckVhY2goKHN0YXR1cywga2V5SWQpID0+IHtcbiAgICAgIHRoaXMubG9nKGBrZXkgc3RhdHVzIGNoYW5nZSBcIiR7c3RhdHVzfVwiIGZvciBrZXlTdGF0dXNlcyBrZXlJZDogJHtIZXguaGV4RHVtcCgnYnVmZmVyJyBpbiBrZXlJZCA/IG5ldyBVaW50OEFycmF5KGtleUlkLmJ1ZmZlciwga2V5SWQuYnl0ZU9mZnNldCwga2V5SWQuYnl0ZUxlbmd0aCkgOiBuZXcgVWludDhBcnJheShrZXlJZCkpfSBzZXNzaW9uIGtleUlkOiAke0hleC5oZXhEdW1wKG5ldyBVaW50OEFycmF5KG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQuZGVjcnlwdGRhdGEua2V5SWQgfHwgW10pKX0gdXJpOiAke21lZGlhS2V5U2Vzc2lvbkNvbnRleHQuZGVjcnlwdGRhdGEudXJpfWApO1xuICAgICAgbWVkaWFLZXlTZXNzaW9uQ29udGV4dC5rZXlTdGF0dXMgPSBzdGF0dXM7XG4gICAgfSk7XG4gIH1cbiAgZmV0Y2hTZXJ2ZXJDZXJ0aWZpY2F0ZShrZXlTeXN0ZW0pIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBjb25zdCBMb2FkZXIgPSBjb25maWcubG9hZGVyO1xuICAgIGNvbnN0IGNlcnRMb2FkZXIgPSBuZXcgTG9hZGVyKGNvbmZpZyk7XG4gICAgY29uc3QgdXJsID0gdGhpcy5nZXRTZXJ2ZXJDZXJ0aWZpY2F0ZVVybChrZXlTeXN0ZW0pO1xuICAgIGlmICghdXJsKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHRoaXMubG9nKGBGZXRjaGluZyBzZXJ2ZXIgY2VydGlmaWNhdGUgZm9yIFwiJHtrZXlTeXN0ZW19XCJgKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgbG9hZGVyQ29udGV4dCA9IHtcbiAgICAgICAgcmVzcG9uc2VUeXBlOiAnYXJyYXlidWZmZXInLFxuICAgICAgICB1cmxcbiAgICAgIH07XG4gICAgICBjb25zdCBsb2FkUG9saWN5ID0gY29uZmlnLmNlcnRMb2FkUG9saWN5LmRlZmF1bHQ7XG4gICAgICBjb25zdCBsb2FkZXJDb25maWcgPSB7XG4gICAgICAgIGxvYWRQb2xpY3ksXG4gICAgICAgIHRpbWVvdXQ6IGxvYWRQb2xpY3kubWF4TG9hZFRpbWVNcyxcbiAgICAgICAgbWF4UmV0cnk6IDAsXG4gICAgICAgIHJldHJ5RGVsYXk6IDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXk6IDBcbiAgICAgIH07XG4gICAgICBjb25zdCBsb2FkZXJDYWxsYmFja3MgPSB7XG4gICAgICAgIG9uU3VjY2VzczogKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpID0+IHtcbiAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlLmRhdGEpO1xuICAgICAgICB9LFxuICAgICAgICBvbkVycm9yOiAocmVzcG9uc2UsIGNvbnRleCwgbmV0d29ya0RldGFpbHMsIHN0YXRzKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFTUVLZXlFcnJvcih7XG4gICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9TRVJWRVJfQ0VSVElGSUNBVEVfUkVRVUVTVF9GQUlMRUQsXG4gICAgICAgICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgcmVzcG9uc2U6IF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgICAgICAgdXJsOiBsb2FkZXJDb250ZXh0LnVybCxcbiAgICAgICAgICAgICAgZGF0YTogdW5kZWZpbmVkXG4gICAgICAgICAgICB9LCByZXNwb25zZSlcbiAgICAgICAgICB9LCBgXCIke2tleVN5c3RlbX1cIiBjZXJ0aWZpY2F0ZSByZXF1ZXN0IGZhaWxlZCAoJHt1cmx9KS4gU3RhdHVzOiAke3Jlc3BvbnNlLmNvZGV9ICgke3Jlc3BvbnNlLnRleHR9KWApKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25UaW1lb3V0OiAoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFTUVLZXlFcnJvcih7XG4gICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9TRVJWRVJfQ0VSVElGSUNBVEVfUkVRVUVTVF9GQUlMRUQsXG4gICAgICAgICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgdXJsOiBsb2FkZXJDb250ZXh0LnVybCxcbiAgICAgICAgICAgICAgZGF0YTogdW5kZWZpbmVkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgYFwiJHtrZXlTeXN0ZW19XCIgY2VydGlmaWNhdGUgcmVxdWVzdCB0aW1lZCBvdXQgKCR7dXJsfSlgKSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQWJvcnQ6IChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpID0+IHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdhYm9ydGVkJykpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY2VydExvYWRlci5sb2FkKGxvYWRlckNvbnRleHQsIGxvYWRlckNvbmZpZywgbG9hZGVyQ2FsbGJhY2tzKTtcbiAgICB9KTtcbiAgfVxuICBzZXRNZWRpYUtleXNTZXJ2ZXJDZXJ0aWZpY2F0ZShtZWRpYUtleXMsIGtleVN5c3RlbSwgY2VydCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBtZWRpYUtleXMuc2V0U2VydmVyQ2VydGlmaWNhdGUoY2VydCkudGhlbihzdWNjZXNzID0+IHtcbiAgICAgICAgdGhpcy5sb2coYHNldFNlcnZlckNlcnRpZmljYXRlICR7c3VjY2VzcyA/ICdzdWNjZXNzJyA6ICdub3Qgc3VwcG9ydGVkIGJ5IENETSd9ICgke2NlcnQgPT0gbnVsbCA/IHZvaWQgMCA6IGNlcnQuYnl0ZUxlbmd0aH0pIG9uIFwiJHtrZXlTeXN0ZW19XCJgKTtcbiAgICAgICAgcmVzb2x2ZShtZWRpYUtleXMpO1xuICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICByZWplY3QobmV3IEVNRUtleUVycm9yKHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fU0VSVkVSX0NFUlRJRklDQVRFX1VQREFURV9GQUlMRUQsXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgICAgfSwgZXJyb3IubWVzc2FnZSkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmVuZXdMaWNlbnNlKGNvbnRleHQsIGtleU1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0TGljZW5zZShjb250ZXh0LCBuZXcgVWludDhBcnJheShrZXlNZXNzYWdlKSkudGhlbihkYXRhID0+IHtcbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUtleVNlc3Npb24oY29udGV4dCwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVNRUtleUVycm9yKHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fU0VTU0lPTl9VUERBVEVfRkFJTEVELFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgIH0sIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgdW5wYWNrUGxheVJlYWR5S2V5TWVzc2FnZSh4aHIsIGxpY2Vuc2VDaGFsbGVuZ2UpIHtcbiAgICAvLyBPbiBFZGdlLCB0aGUgcmF3IGxpY2Vuc2UgbWVzc2FnZSBpcyBVVEYtMTYtZW5jb2RlZCBYTUwuICBXZSBuZWVkXG4gICAgLy8gdG8gdW5wYWNrIHRoZSBDaGFsbGVuZ2UgZWxlbWVudCAoYmFzZTY0LWVuY29kZWQgc3RyaW5nIGNvbnRhaW5pbmcgdGhlXG4gICAgLy8gYWN0dWFsIGxpY2Vuc2UgcmVxdWVzdCkgYW5kIGFueSBIdHRwSGVhZGVyIGVsZW1lbnRzIChzZW50IGFzIHJlcXVlc3RcbiAgICAvLyBoZWFkZXJzKS5cbiAgICAvLyBGb3IgUGxheVJlYWR5IENETXMsIHdlIG5lZWQgdG8gZGlnIHRoZSBDaGFsbGVuZ2Ugb3V0IG9mIHRoZSBYTUwuXG4gICAgY29uc3QgeG1sU3RyaW5nID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDE2QXJyYXkobGljZW5zZUNoYWxsZW5nZS5idWZmZXIpKTtcbiAgICBpZiAoIXhtbFN0cmluZy5pbmNsdWRlcygnUGxheVJlYWR5S2V5TWVzc2FnZScpKSB7XG4gICAgICAvLyBUaGlzIGRvZXMgbm90IGFwcGVhciB0byBiZSBhIHdyYXBwZWQgbWVzc2FnZSBhcyBvbiBFZGdlLiAgU29tZVxuICAgICAgLy8gY2xpZW50cyBkbyBub3QgbmVlZCB0aGlzIHVud3JhcHBpbmcsIHNvIHdlIHdpbGwgYXNzdW1lIHRoaXMgaXMgb25lIG9mXG4gICAgICAvLyB0aGVtLiAgTm90ZSB0aGF0IFwieG1sXCIgYXQgdGhpcyBwb2ludCBwcm9iYWJseSBsb29rcyBsaWtlIHJhbmRvbVxuICAgICAgLy8gZ2FyYmFnZSwgc2luY2Ugd2UgaW50ZXJwcmV0ZWQgVVRGLTggYXMgVVRGLTE2LlxuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICd0ZXh0L3htbDsgY2hhcnNldD11dGYtOCcpO1xuICAgICAgcmV0dXJuIGxpY2Vuc2VDaGFsbGVuZ2U7XG4gICAgfVxuICAgIGNvbnN0IGtleU1lc3NhZ2VYbWwgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHhtbFN0cmluZywgJ2FwcGxpY2F0aW9uL3htbCcpO1xuICAgIC8vIFNldCByZXF1ZXN0IGhlYWRlcnMuXG4gICAgY29uc3QgaGVhZGVycyA9IGtleU1lc3NhZ2VYbWwucXVlcnlTZWxlY3RvckFsbCgnSHR0cEhlYWRlcicpO1xuICAgIGlmIChoZWFkZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIGxldCBoZWFkZXI7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gaGVhZGVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgX2hlYWRlciRxdWVyeVNlbGVjdG9yLCBfaGVhZGVyJHF1ZXJ5U2VsZWN0b3IyO1xuICAgICAgICBoZWFkZXIgPSBoZWFkZXJzW2ldO1xuICAgICAgICBjb25zdCBuYW1lID0gKF9oZWFkZXIkcXVlcnlTZWxlY3RvciA9IGhlYWRlci5xdWVyeVNlbGVjdG9yKCduYW1lJykpID09IG51bGwgPyB2b2lkIDAgOiBfaGVhZGVyJHF1ZXJ5U2VsZWN0b3IudGV4dENvbnRlbnQ7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gKF9oZWFkZXIkcXVlcnlTZWxlY3RvcjIgPSBoZWFkZXIucXVlcnlTZWxlY3RvcigndmFsdWUnKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9oZWFkZXIkcXVlcnlTZWxlY3RvcjIudGV4dENvbnRlbnQ7XG4gICAgICAgIGlmIChuYW1lICYmIHZhbHVlKSB7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNoYWxsZW5nZUVsZW1lbnQgPSBrZXlNZXNzYWdlWG1sLnF1ZXJ5U2VsZWN0b3IoJ0NoYWxsZW5nZScpO1xuICAgIGNvbnN0IGNoYWxsZW5nZVRleHQgPSBjaGFsbGVuZ2VFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBjaGFsbGVuZ2VFbGVtZW50LnRleHRDb250ZW50O1xuICAgIGlmICghY2hhbGxlbmdlVGV4dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZmluZCA8Q2hhbGxlbmdlPiBpbiBrZXkgbWVzc2FnZWApO1xuICAgIH1cbiAgICByZXR1cm4gc3RyVG9VdGY4YXJyYXkoYXRvYihjaGFsbGVuZ2VUZXh0KSk7XG4gIH1cbiAgc2V0dXBMaWNlbnNlWEhSKHhociwgdXJsLCBrZXlzTGlzdEl0ZW0sIGxpY2Vuc2VDaGFsbGVuZ2UpIHtcbiAgICBjb25zdCBsaWNlbnNlWGhyU2V0dXAgPSB0aGlzLmNvbmZpZy5saWNlbnNlWGhyU2V0dXA7XG4gICAgaWYgKCFsaWNlbnNlWGhyU2V0dXApIHtcbiAgICAgIHhoci5vcGVuKCdQT1NUJywgdXJsLCB0cnVlKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICB4aHIsXG4gICAgICAgIGxpY2Vuc2VDaGFsbGVuZ2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICBpZiAoIWtleXNMaXN0SXRlbS5kZWNyeXB0ZGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleSByZW1vdmVkJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGljZW5zZVhoclNldHVwLmNhbGwodGhpcy5obHMsIHhociwgdXJsLCBrZXlzTGlzdEl0ZW0sIGxpY2Vuc2VDaGFsbGVuZ2UpO1xuICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgIGlmICgha2V5c0xpc3RJdGVtLmRlY3J5cHRkYXRhKSB7XG4gICAgICAgIC8vIEtleSBzZXNzaW9uIHJlbW92ZWQuIENhbmNlbCBsaWNlbnNlIHJlcXVlc3QuXG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgLy8gbGV0J3MgdHJ5IHRvIG9wZW4gYmVmb3JlIHJ1bm5pbmcgc2V0dXBcbiAgICAgIHhoci5vcGVuKCdQT1NUJywgdXJsLCB0cnVlKTtcbiAgICAgIHJldHVybiBsaWNlbnNlWGhyU2V0dXAuY2FsbCh0aGlzLmhscywgeGhyLCB1cmwsIGtleXNMaXN0SXRlbSwgbGljZW5zZUNoYWxsZW5nZSk7XG4gICAgfSkudGhlbihsaWNlbnNlWGhyU2V0dXBSZXN1bHQgPT4ge1xuICAgICAgLy8gaWYgbGljZW5zZVhoclNldHVwIGRpZCBub3QgeWV0IGNhbGwgb3BlbiwgbGV0J3MgZG8gaXQgbm93XG4gICAgICBpZiAoIXhoci5yZWFkeVN0YXRlKSB7XG4gICAgICAgIHhoci5vcGVuKCdQT1NUJywgdXJsLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZpbmFsTGljZW5zZUNoYWxsZW5nZSA9IGxpY2Vuc2VYaHJTZXR1cFJlc3VsdCA/IGxpY2Vuc2VYaHJTZXR1cFJlc3VsdCA6IGxpY2Vuc2VDaGFsbGVuZ2U7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4aHIsXG4gICAgICAgIGxpY2Vuc2VDaGFsbGVuZ2U6IGZpbmFsTGljZW5zZUNoYWxsZW5nZVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICByZXF1ZXN0TGljZW5zZShrZXlTZXNzaW9uQ29udGV4dCwgbGljZW5zZUNoYWxsZW5nZSkge1xuICAgIGNvbnN0IGtleUxvYWRQb2xpY3kgPSB0aGlzLmNvbmZpZy5rZXlMb2FkUG9saWN5LmRlZmF1bHQ7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHVybCA9IHRoaXMuZ2V0TGljZW5zZVNlcnZlclVybChrZXlTZXNzaW9uQ29udGV4dC5rZXlTeXN0ZW0pO1xuICAgICAgdGhpcy5sb2coYFNlbmRpbmcgbGljZW5zZSByZXF1ZXN0IHRvIFVSTDogJHt1cmx9YCk7XG4gICAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLmhscyB8fCAha2V5U2Vzc2lvbkNvbnRleHQubWVkaWFLZXlzU2Vzc2lvbikge1xuICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdpbnZhbGlkIHN0YXRlJykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgIGlmICh4aHIuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50ID0gMDtcbiAgICAgICAgICAgIGxldCBkYXRhID0geGhyLnJlc3BvbnNlO1xuICAgICAgICAgICAgdGhpcy5sb2coYExpY2Vuc2UgcmVjZWl2ZWQgJHtkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBkYXRhLmJ5dGVMZW5ndGggOiBkYXRhfWApO1xuICAgICAgICAgICAgY29uc3QgbGljZW5zZVJlc3BvbnNlQ2FsbGJhY2sgPSB0aGlzLmNvbmZpZy5saWNlbnNlUmVzcG9uc2VDYWxsYmFjaztcbiAgICAgICAgICAgIGlmIChsaWNlbnNlUmVzcG9uc2VDYWxsYmFjaykge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBsaWNlbnNlUmVzcG9uc2VDYWxsYmFjay5jYWxsKHRoaXMuaGxzLCB4aHIsIHVybCwga2V5U2Vzc2lvbkNvbnRleHQpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByZXRyeUNvbmZpZyA9IGtleUxvYWRQb2xpY3kuZXJyb3JSZXRyeTtcbiAgICAgICAgICAgIGNvbnN0IG1heE51bVJldHJ5ID0gcmV0cnlDb25maWcgPyByZXRyeUNvbmZpZy5tYXhOdW1SZXRyeSA6IDA7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCsrO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50ID4gbWF4TnVtUmV0cnkgfHwgeGhyLnN0YXR1cyA+PSA0MDAgJiYgeGhyLnN0YXR1cyA8IDUwMCkge1xuICAgICAgICAgICAgICByZWplY3QobmV3IEVNRUtleUVycm9yKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fTElDRU5TRV9SRVFVRVNUX0ZBSUxFRCxcbiAgICAgICAgICAgICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogeGhyLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICBjb2RlOiB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgdGV4dDogeGhyLnN0YXR1c1RleHRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sIGBMaWNlbnNlIFJlcXVlc3QgWEhSIGZhaWxlZCAoJHt1cmx9KS4gU3RhdHVzOiAke3hoci5zdGF0dXN9ICgke3hoci5zdGF0dXNUZXh0fSlgKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCBhdHRlbXB0c0xlZnQgPSBtYXhOdW1SZXRyeSAtIHRoaXMuX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50ICsgMTtcbiAgICAgICAgICAgICAgdGhpcy53YXJuKGBSZXRyeWluZyBsaWNlbnNlIHJlcXVlc3QsICR7YXR0ZW1wdHNMZWZ0fSBhdHRlbXB0cyBsZWZ0YCk7XG4gICAgICAgICAgICAgIHRoaXMucmVxdWVzdExpY2Vuc2Uoa2V5U2Vzc2lvbkNvbnRleHQsIGxpY2Vuc2VDaGFsbGVuZ2UpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoa2V5U2Vzc2lvbkNvbnRleHQubGljZW5zZVhociAmJiBrZXlTZXNzaW9uQ29udGV4dC5saWNlbnNlWGhyLnJlYWR5U3RhdGUgIT09IFhNTEh0dHBSZXF1ZXN0LkRPTkUpIHtcbiAgICAgICAga2V5U2Vzc2lvbkNvbnRleHQubGljZW5zZVhoci5hYm9ydCgpO1xuICAgICAgfVxuICAgICAga2V5U2Vzc2lvbkNvbnRleHQubGljZW5zZVhociA9IHhocjtcbiAgICAgIHRoaXMuc2V0dXBMaWNlbnNlWEhSKHhociwgdXJsLCBrZXlTZXNzaW9uQ29udGV4dCwgbGljZW5zZUNoYWxsZW5nZSkudGhlbigoe1xuICAgICAgICB4aHIsXG4gICAgICAgIGxpY2Vuc2VDaGFsbGVuZ2VcbiAgICAgIH0pID0+IHtcbiAgICAgICAgaWYgKGtleVNlc3Npb25Db250ZXh0LmtleVN5c3RlbSA9PSBLZXlTeXN0ZW1zLlBMQVlSRUFEWSkge1xuICAgICAgICAgIGxpY2Vuc2VDaGFsbGVuZ2UgPSB0aGlzLnVucGFja1BsYXlSZWFkeUtleU1lc3NhZ2UoeGhyLCBsaWNlbnNlQ2hhbGxlbmdlKTtcbiAgICAgICAgfVxuICAgICAgICB4aHIuc2VuZChsaWNlbnNlQ2hhbGxlbmdlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIG9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSkge1xuICAgIGlmICghdGhpcy5jb25maWcuZW1lRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtZWRpYSA9IGRhdGEubWVkaWE7XG5cbiAgICAvLyBrZWVwIHJlZmVyZW5jZSBvZiBtZWRpYVxuICAgIHRoaXMubWVkaWEgPSBtZWRpYTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdlbmNyeXB0ZWQnLCB0aGlzLm9uTWVkaWFFbmNyeXB0ZWQpO1xuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3dhaXRpbmdmb3JrZXknLCB0aGlzLm9uV2FpdGluZ0ZvcktleSk7XG4gIH1cbiAgb25NZWRpYURldGFjaGVkKCkge1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBjb25zdCBtZWRpYUtleXNMaXN0ID0gdGhpcy5tZWRpYUtleVNlc3Npb25zO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5jcnlwdGVkJywgdGhpcy5vbk1lZGlhRW5jcnlwdGVkKTtcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dhaXRpbmdmb3JrZXknLCB0aGlzLm9uV2FpdGluZ0ZvcktleSk7XG4gICAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdExpY2Vuc2VGYWlsdXJlQ291bnQgPSAwO1xuICAgIHRoaXMuc2V0TWVkaWFLZXlzUXVldWUgPSBbXTtcbiAgICB0aGlzLm1lZGlhS2V5U2Vzc2lvbnMgPSBbXTtcbiAgICB0aGlzLmtleUlkVG9LZXlTZXNzaW9uUHJvbWlzZSA9IHt9O1xuICAgIExldmVsS2V5LmNsZWFyS2V5VXJpVG9LZXlJZE1hcCgpO1xuXG4gICAgLy8gQ2xvc2UgYWxsIHNlc3Npb25zIGFuZCByZW1vdmUgbWVkaWEga2V5cyBmcm9tIHRoZSB2aWRlbyBlbGVtZW50LlxuICAgIGNvbnN0IGtleVNlc3Npb25Db3VudCA9IG1lZGlhS2V5c0xpc3QubGVuZ3RoO1xuICAgIEVNRUNvbnRyb2xsZXIuQ0RNQ2xlYW51cFByb21pc2UgPSBQcm9taXNlLmFsbChtZWRpYUtleXNMaXN0Lm1hcChtZWRpYUtleVNlc3Npb25Db250ZXh0ID0+IHRoaXMucmVtb3ZlU2Vzc2lvbihtZWRpYUtleVNlc3Npb25Db250ZXh0KSkuY29uY2F0KG1lZGlhID09IG51bGwgPyB2b2lkIDAgOiBtZWRpYS5zZXRNZWRpYUtleXMobnVsbCkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgdGhpcy5sb2coYENvdWxkIG5vdCBjbGVhciBtZWRpYSBrZXlzOiAke2Vycm9yfWApO1xuICAgIH0pKSkudGhlbigoKSA9PiB7XG4gICAgICBpZiAoa2V5U2Vzc2lvbkNvdW50KSB7XG4gICAgICAgIHRoaXMubG9nKCdmaW5pc2hlZCBjbG9zaW5nIGtleSBzZXNzaW9ucyBhbmQgY2xlYXJpbmcgbWVkaWEga2V5cycpO1xuICAgICAgICBtZWRpYUtleXNMaXN0Lmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgdGhpcy5sb2coYENvdWxkIG5vdCBjbG9zZSBzZXNzaW9ucyBhbmQgY2xlYXIgbWVkaWEga2V5czogJHtlcnJvcn1gKTtcbiAgICB9KTtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLmtleUZvcm1hdFByb21pc2UgPSBudWxsO1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkZWQoZXZlbnQsIHtcbiAgICBzZXNzaW9uS2V5c1xuICB9KSB7XG4gICAgaWYgKCFzZXNzaW9uS2V5cyB8fCAhdGhpcy5jb25maWcuZW1lRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMua2V5Rm9ybWF0UHJvbWlzZSkge1xuICAgICAgY29uc3Qga2V5Rm9ybWF0cyA9IHNlc3Npb25LZXlzLnJlZHVjZSgoZm9ybWF0cywgc2Vzc2lvbktleSkgPT4ge1xuICAgICAgICBpZiAoZm9ybWF0cy5pbmRleE9mKHNlc3Npb25LZXkua2V5Rm9ybWF0KSA9PT0gLTEpIHtcbiAgICAgICAgICBmb3JtYXRzLnB1c2goc2Vzc2lvbktleS5rZXlGb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXRzO1xuICAgICAgfSwgW10pO1xuICAgICAgdGhpcy5sb2coYFNlbGVjdGluZyBrZXktc3lzdGVtIGZyb20gc2Vzc2lvbi1rZXlzICR7a2V5Rm9ybWF0cy5qb2luKCcsICcpfWApO1xuICAgICAgdGhpcy5rZXlGb3JtYXRQcm9taXNlID0gdGhpcy5nZXRLZXlGb3JtYXRQcm9taXNlKGtleUZvcm1hdHMpO1xuICAgIH1cbiAgfVxuICByZW1vdmVTZXNzaW9uKG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZWRpYUtleXNTZXNzaW9uLFxuICAgICAgbGljZW5zZVhoclxuICAgIH0gPSBtZWRpYUtleVNlc3Npb25Db250ZXh0O1xuICAgIGlmIChtZWRpYUtleXNTZXNzaW9uKSB7XG4gICAgICB0aGlzLmxvZyhgUmVtb3ZlIGxpY2Vuc2VzIGFuZCBrZXlzIGFuZCBjbG9zZSBzZXNzaW9uICR7bWVkaWFLZXlzU2Vzc2lvbi5zZXNzaW9uSWR9YCk7XG4gICAgICBpZiAobWVkaWFLZXlTZXNzaW9uQ29udGV4dC5fb25tZXNzYWdlKSB7XG4gICAgICAgIG1lZGlhS2V5c1Nlc3Npb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQuX29ubWVzc2FnZSk7XG4gICAgICAgIG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQuX29ubWVzc2FnZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChtZWRpYUtleVNlc3Npb25Db250ZXh0Ll9vbmtleXN0YXR1c2VzY2hhbmdlKSB7XG4gICAgICAgIG1lZGlhS2V5c1Nlc3Npb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5c3RhdHVzZXNjaGFuZ2UnLCBtZWRpYUtleVNlc3Npb25Db250ZXh0Ll9vbmtleXN0YXR1c2VzY2hhbmdlKTtcbiAgICAgICAgbWVkaWFLZXlTZXNzaW9uQ29udGV4dC5fb25rZXlzdGF0dXNlc2NoYW5nZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChsaWNlbnNlWGhyICYmIGxpY2Vuc2VYaHIucmVhZHlTdGF0ZSAhPT0gWE1MSHR0cFJlcXVlc3QuRE9ORSkge1xuICAgICAgICBsaWNlbnNlWGhyLmFib3J0KCk7XG4gICAgICB9XG4gICAgICBtZWRpYUtleVNlc3Npb25Db250ZXh0Lm1lZGlhS2V5c1Nlc3Npb24gPSBtZWRpYUtleVNlc3Npb25Db250ZXh0LmRlY3J5cHRkYXRhID0gbWVkaWFLZXlTZXNzaW9uQ29udGV4dC5saWNlbnNlWGhyID0gdW5kZWZpbmVkO1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLm1lZGlhS2V5U2Vzc2lvbnMuaW5kZXhPZihtZWRpYUtleVNlc3Npb25Db250ZXh0KTtcbiAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgIHRoaXMubWVkaWFLZXlTZXNzaW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lZGlhS2V5c1Nlc3Npb24ucmVtb3ZlKCkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICB0aGlzLmxvZyhgQ291bGQgbm90IHJlbW92ZSBzZXNzaW9uOiAke2Vycm9yfWApO1xuICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgIHJldHVybiBtZWRpYUtleXNTZXNzaW9uLmNsb3NlKCk7XG4gICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIHRoaXMubG9nKGBDb3VsZCBub3QgY2xvc2Ugc2Vzc2lvbjogJHtlcnJvcn1gKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuRU1FQ29udHJvbGxlci5DRE1DbGVhbnVwUHJvbWlzZSA9IHZvaWQgMDtcbmNsYXNzIEVNRUtleUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihkYXRhLCBtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5kYXRhID0gdm9pZCAwO1xuICAgIGRhdGEuZXJyb3IgfHwgKGRhdGEuZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSkpO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgZGF0YS5lcnIgPSBkYXRhLmVycm9yO1xuICB9XG59XG5cbi8qKlxuICogQ29tbW9uIE1lZGlhIE9iamVjdCBUeXBlXG4gKlxuICogQGdyb3VwIENNQ0RcbiAqIEBncm91cCBDTVNEXG4gKlxuICogQGJldGFcbiAqL1xudmFyIENtT2JqZWN0VHlwZTtcbihmdW5jdGlvbiAoQ21PYmplY3RUeXBlKSB7XG4gIC8qKlxuICAgKiB0ZXh0IGZpbGUsIHN1Y2ggYXMgYSBtYW5pZmVzdCBvciBwbGF5bGlzdFxuICAgKi9cbiAgQ21PYmplY3RUeXBlW1wiTUFOSUZFU1RcIl0gPSBcIm1cIjtcbiAgLyoqXG4gICAqIGF1ZGlvIG9ubHlcbiAgICovXG4gIENtT2JqZWN0VHlwZVtcIkFVRElPXCJdID0gXCJhXCI7XG4gIC8qKlxuICAgKiB2aWRlbyBvbmx5XG4gICAqL1xuICBDbU9iamVjdFR5cGVbXCJWSURFT1wiXSA9IFwidlwiO1xuICAvKipcbiAgICogbXV4ZWQgYXVkaW8gYW5kIHZpZGVvXG4gICAqL1xuICBDbU9iamVjdFR5cGVbXCJNVVhFRFwiXSA9IFwiYXZcIjtcbiAgLyoqXG4gICAqIGluaXQgc2VnbWVudFxuICAgKi9cbiAgQ21PYmplY3RUeXBlW1wiSU5JVFwiXSA9IFwiaVwiO1xuICAvKipcbiAgICogY2FwdGlvbiBvciBzdWJ0aXRsZVxuICAgKi9cbiAgQ21PYmplY3RUeXBlW1wiQ0FQVElPTlwiXSA9IFwiY1wiO1xuICAvKipcbiAgICogSVNPQk1GRiB0aW1lZCB0ZXh0IHRyYWNrXG4gICAqL1xuICBDbU9iamVjdFR5cGVbXCJUSU1FRF9URVhUXCJdID0gXCJ0dFwiO1xuICAvKipcbiAgICogY3J5cHRvZ3JhcGhpYyBrZXksIGxpY2Vuc2Ugb3IgY2VydGlmaWNhdGUuXG4gICAqL1xuICBDbU9iamVjdFR5cGVbXCJLRVlcIl0gPSBcImtcIjtcbiAgLyoqXG4gICAqIG90aGVyXG4gICAqL1xuICBDbU9iamVjdFR5cGVbXCJPVEhFUlwiXSA9IFwib1wiO1xufSkoQ21PYmplY3RUeXBlIHx8IChDbU9iamVjdFR5cGUgPSB7fSkpO1xuXG4vKipcbiAqIENvbW1vbiBNZWRpYSBTdHJlYW1pbmcgRm9ybWF0XG4gKlxuICogQGdyb3VwIENNQ0RcbiAqIEBncm91cCBDTVNEXG4gKlxuICogQGJldGFcbiAqL1xudmFyIENtU3RyZWFtaW5nRm9ybWF0O1xuKGZ1bmN0aW9uIChDbVN0cmVhbWluZ0Zvcm1hdCkge1xuICAvKipcbiAgICogTVBFRyBEQVNIXG4gICAqL1xuICBDbVN0cmVhbWluZ0Zvcm1hdFtcIkRBU0hcIl0gPSBcImRcIjtcbiAgLyoqXG4gICAqIEhUVFAgTGl2ZSBTdHJlYW1pbmcgKEhMUylcbiAgICovXG4gIENtU3RyZWFtaW5nRm9ybWF0W1wiSExTXCJdID0gXCJoXCI7XG4gIC8qKlxuICAgKiBTbW9vdGggU3RyZWFtaW5nXG4gICAqL1xuICBDbVN0cmVhbWluZ0Zvcm1hdFtcIlNNT09USFwiXSA9IFwic1wiO1xuICAvKipcbiAgICogT3RoZXJcbiAgICovXG4gIENtU3RyZWFtaW5nRm9ybWF0W1wiT1RIRVJcIl0gPSBcIm9cIjtcbn0pKENtU3RyZWFtaW5nRm9ybWF0IHx8IChDbVN0cmVhbWluZ0Zvcm1hdCA9IHt9KSk7XG5cbi8qKlxuICogQ01DRCBoZWFkZXIgZmllbGRzLlxuICpcbiAqIEBncm91cCBDTUNEXG4gKlxuICogQGJldGFcbiAqL1xudmFyIENtY2RIZWFkZXJGaWVsZDtcbihmdW5jdGlvbiAoQ21jZEhlYWRlckZpZWxkKSB7XG4gIC8qKlxuICAgKiBrZXlzIHdob3NlIHZhbHVlcyB2YXJ5IHdpdGggdGhlIG9iamVjdCBiZWluZyByZXF1ZXN0ZWQuXG4gICAqL1xuICBDbWNkSGVhZGVyRmllbGRbXCJPQkpFQ1RcIl0gPSBcIkNNQ0QtT2JqZWN0XCI7XG4gIC8qKlxuICAgKiBrZXlzIHdob3NlIHZhbHVlcyB2YXJ5IHdpdGggZWFjaCByZXF1ZXN0LlxuICAgKi9cbiAgQ21jZEhlYWRlckZpZWxkW1wiUkVRVUVTVFwiXSA9IFwiQ01DRC1SZXF1ZXN0XCI7XG4gIC8qKlxuICAgKiBrZXlzIHdob3NlIHZhbHVlcyBhcmUgZXhwZWN0ZWQgdG8gYmUgaW52YXJpYW50IG92ZXIgdGhlIGxpZmUgb2YgdGhlIHNlc3Npb24uXG4gICAqL1xuICBDbWNkSGVhZGVyRmllbGRbXCJTRVNTSU9OXCJdID0gXCJDTUNELVNlc3Npb25cIjtcbiAgLyoqXG4gICAqIGtleXMgd2hvc2UgdmFsdWVzIGRvIG5vdCB2YXJ5IHdpdGggZXZlcnkgcmVxdWVzdCBvciBvYmplY3QuXG4gICAqL1xuICBDbWNkSGVhZGVyRmllbGRbXCJTVEFUVVNcIl0gPSBcIkNNQ0QtU3RhdHVzXCI7XG59KShDbWNkSGVhZGVyRmllbGQgfHwgKENtY2RIZWFkZXJGaWVsZCA9IHt9KSk7XG5cbi8qKlxuICogVGhlIG1hcCBvZiBDTUNEIGhlYWRlciBmaWVsZHMgdG8gb2ZmaWNpYWwgQ01DRCBrZXlzLlxuICpcbiAqIEBpbnRlcm5hbFxuICpcbiAqIEBncm91cCBDTUNEXG4gKi9cbmNvbnN0IENtY2RIZWFkZXJNYXAgPSB7XG4gIFtDbWNkSGVhZGVyRmllbGQuT0JKRUNUXTogWydicicsICdkJywgJ290JywgJ3RiJ10sXG4gIFtDbWNkSGVhZGVyRmllbGQuUkVRVUVTVF06IFsnYmwnLCAnZGwnLCAnbXRwJywgJ25vcicsICducnInLCAnc3UnXSxcbiAgW0NtY2RIZWFkZXJGaWVsZC5TRVNTSU9OXTogWydjaWQnLCAncHInLCAnc2YnLCAnc2lkJywgJ3N0JywgJ3YnXSxcbiAgW0NtY2RIZWFkZXJGaWVsZC5TVEFUVVNdOiBbJ2JzJywgJ3J0cCddXG59O1xuXG4vKipcbiAqIFN0cnVjdHVyZWQgRmllbGQgSXRlbVxuICpcbiAqIEBncm91cCBTdHJ1Y3R1cmVkIEZpZWxkXG4gKlxuICogQGJldGFcbiAqL1xuY2xhc3MgU2ZJdGVtIHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHBhcmFtcykge1xuICAgIHRoaXMudmFsdWUgPSB2b2lkIDA7XG4gICAgdGhpcy5wYXJhbXMgPSB2b2lkIDA7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLm1hcCh2ID0+IHYgaW5zdGFuY2VvZiBTZkl0ZW0gPyB2IDogbmV3IFNmSXRlbSh2KSk7XG4gICAgfVxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgfVxufVxuXG4vKipcbiAqIEEgY2xhc3MgdG8gcmVwcmVzZW50IHN0cnVjdHVyZWQgZmllbGQgdG9rZW5zIHdoZW4gYFN5bWJvbGAgaXMgbm90IGF2YWlsYWJsZS5cbiAqXG4gKiBAZ3JvdXAgU3RydWN0dXJlZCBGaWVsZFxuICpcbiAqIEBiZXRhXG4gKi9cbmNsYXNzIFNmVG9rZW4ge1xuICBjb25zdHJ1Y3RvcihkZXNjcmlwdGlvbikge1xuICAgIHRoaXMuZGVzY3JpcHRpb24gPSB2b2lkIDA7XG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICB9XG59XG5cbmNvbnN0IERJQ1QgPSAnRGljdCc7XG5cbmZ1bmN0aW9uIGZvcm1hdCh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICB9XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCkge1xuICAgIHJldHVybiAnTWFwe30nO1xuICB9XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgIHJldHVybiAnU2V0e30nO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgfVxuICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHRocm93RXJyb3IoYWN0aW9uLCBzcmMsIHR5cGUsIGNhdXNlKSB7XG4gIHJldHVybiBuZXcgRXJyb3IoYGZhaWxlZCB0byAke2FjdGlvbn0gXCIke2Zvcm1hdChzcmMpfVwiIGFzICR7dHlwZX1gLCB7XG4gICAgY2F1c2VcbiAgfSk7XG59XG5cbmNvbnN0IEJBUkVfSVRFTSA9ICdCYXJlIEl0ZW0nO1xuXG5jb25zdCBCT09MRUFOID0gJ0Jvb2xlYW4nO1xuXG5jb25zdCBCWVRFUyA9ICdCeXRlIFNlcXVlbmNlJztcblxuY29uc3QgREVDSU1BTCA9ICdEZWNpbWFsJztcblxuY29uc3QgSU5URUdFUiA9ICdJbnRlZ2VyJztcblxuZnVuY3Rpb24gaXNJbnZhbGlkSW50KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA8IC05OTk5OTk5OTk5OTk5OTkgfHwgOTk5OTk5OTk5OTk5OTk5IDwgdmFsdWU7XG59XG5cbmNvbnN0IFNUUklOR19SRUdFWCA9IC9bXFx4MDAtXFx4MWZcXHg3Zl0rLzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb250cm9sLXJlZ2V4XG5cbmNvbnN0IFRPS0VOID0gJ1Rva2VuJztcblxuY29uc3QgS0VZID0gJ0tleSc7XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZUVycm9yKHNyYywgdHlwZSwgY2F1c2UpIHtcbiAgcmV0dXJuIHRocm93RXJyb3IoJ3NlcmlhbGl6ZScsIHNyYywgdHlwZSwgY2F1c2UpO1xufVxuXG4vLyA0LjEuOS4gIFNlcmlhbGl6aW5nIGEgQm9vbGVhblxuLy9cbi8vIEdpdmVuIGEgQm9vbGVhbiBhcyBpbnB1dF9ib29sZWFuLCByZXR1cm4gYW4gQVNDSUkgc3RyaW5nIHN1aXRhYmxlIGZvclxuLy8gdXNlIGluIGEgSFRUUCBmaWVsZCB2YWx1ZS5cbi8vXG4vLyAxLiAgSWYgaW5wdXRfYm9vbGVhbiBpcyBub3QgYSBib29sZWFuLCBmYWlsIHNlcmlhbGl6YXRpb24uXG4vL1xuLy8gMi4gIExldCBvdXRwdXQgYmUgYW4gZW1wdHkgc3RyaW5nLlxuLy9cbi8vIDMuICBBcHBlbmQgXCI/XCIgdG8gb3V0cHV0LlxuLy9cbi8vIDQuICBJZiBpbnB1dF9ib29sZWFuIGlzIHRydWUsIGFwcGVuZCBcIjFcIiB0byBvdXRwdXQuXG4vL1xuLy8gNS4gIElmIGlucHV0X2Jvb2xlYW4gaXMgZmFsc2UsIGFwcGVuZCBcIjBcIiB0byBvdXRwdXQuXG4vL1xuLy8gNi4gIFJldHVybiBvdXRwdXQuXG5mdW5jdGlvbiBzZXJpYWxpemVCb29sZWFuKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJykge1xuICAgIHRocm93IHNlcmlhbGl6ZUVycm9yKHZhbHVlLCBCT09MRUFOKTtcbiAgfVxuICByZXR1cm4gdmFsdWUgPyAnPzEnIDogJz8wJztcbn1cblxuLyoqXG4gKiBFbmNvZGVzIGJpbmFyeSBkYXRhIHRvIGJhc2U2NFxuICpcbiAqIEBwYXJhbSBiaW5hcnkgLSBUaGUgYmluYXJ5IGRhdGEgdG8gZW5jb2RlXG4gKiBAcmV0dXJucyBUaGUgYmFzZTY0IGVuY29kZWQgc3RyaW5nXG4gKlxuICogQGdyb3VwIFV0aWxzXG4gKlxuICogQGJldGFcbiAqL1xuZnVuY3Rpb24gYmFzZTY0ZW5jb2RlKGJpbmFyeSkge1xuICByZXR1cm4gYnRvYShTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLmJpbmFyeSkpO1xufVxuXG4vLyA0LjEuOC4gIFNlcmlhbGl6aW5nIGEgQnl0ZSBTZXF1ZW5jZVxuLy9cbi8vIEdpdmVuIGEgQnl0ZSBTZXF1ZW5jZSBhcyBpbnB1dF9ieXRlcywgcmV0dXJuIGFuIEFTQ0lJIHN0cmluZyBzdWl0YWJsZVxuLy8gZm9yIHVzZSBpbiBhIEhUVFAgZmllbGQgdmFsdWUuXG4vL1xuLy8gMS4gIElmIGlucHV0X2J5dGVzIGlzIG5vdCBhIHNlcXVlbmNlIG9mIGJ5dGVzLCBmYWlsIHNlcmlhbGl6YXRpb24uXG4vL1xuLy8gMi4gIExldCBvdXRwdXQgYmUgYW4gZW1wdHkgc3RyaW5nLlxuLy9cbi8vIDMuICBBcHBlbmQgXCI6XCIgdG8gb3V0cHV0LlxuLy9cbi8vIDQuICBBcHBlbmQgdGhlIHJlc3VsdCBvZiBiYXNlNjQtZW5jb2RpbmcgaW5wdXRfYnl0ZXMgYXMgcGVyXG4vLyAgICAgW1JGQzQ2NDhdLCBTZWN0aW9uIDQsIHRha2luZyBhY2NvdW50IG9mIHRoZSByZXF1aXJlbWVudHMgYmVsb3cuXG4vL1xuLy8gNS4gIEFwcGVuZCBcIjpcIiB0byBvdXRwdXQuXG4vL1xuLy8gNi4gIFJldHVybiBvdXRwdXQuXG4vL1xuLy8gVGhlIGVuY29kZWQgZGF0YSBpcyByZXF1aXJlZCB0byBiZSBwYWRkZWQgd2l0aCBcIj1cIiwgYXMgcGVyIFtSRkM0NjQ4XSxcbi8vIFNlY3Rpb24gMy4yLlxuLy9cbi8vIExpa2V3aXNlLCBlbmNvZGVkIGRhdGEgU0hPVUxEIGhhdmUgcGFkIGJpdHMgc2V0IHRvIHplcm8sIGFzIHBlclxuLy8gW1JGQzQ2NDhdLCBTZWN0aW9uIDMuNSwgdW5sZXNzIGl0IGlzIG5vdCBwb3NzaWJsZSB0byBkbyBzbyBkdWUgdG9cbi8vIGltcGxlbWVudGF0aW9uIGNvbnN0cmFpbnRzLlxuZnVuY3Rpb24gc2VyaWFsaXplQnl0ZVNlcXVlbmNlKHZhbHVlKSB7XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpID09PSBmYWxzZSkge1xuICAgIHRocm93IHNlcmlhbGl6ZUVycm9yKHZhbHVlLCBCWVRFUyk7XG4gIH1cbiAgcmV0dXJuIGA6JHtiYXNlNjRlbmNvZGUodmFsdWUpfTpgO1xufVxuXG4vLyA0LjEuNC4gIFNlcmlhbGl6aW5nIGFuIEludGVnZXJcbi8vXG4vLyBHaXZlbiBhbiBJbnRlZ2VyIGFzIGlucHV0X2ludGVnZXIsIHJldHVybiBhbiBBU0NJSSBzdHJpbmcgc3VpdGFibGVcbi8vIGZvciB1c2UgaW4gYSBIVFRQIGZpZWxkIHZhbHVlLlxuLy9cbi8vIDEuICBJZiBpbnB1dF9pbnRlZ2VyIGlzIG5vdCBhbiBpbnRlZ2VyIGluIHRoZSByYW5nZSBvZlxuLy8gICAgIC05OTksOTk5LDk5OSw5OTksOTk5IHRvIDk5OSw5OTksOTk5LDk5OSw5OTkgaW5jbHVzaXZlLCBmYWlsXG4vLyAgICAgc2VyaWFsaXphdGlvbi5cbi8vXG4vLyAyLiAgTGV0IG91dHB1dCBiZSBhbiBlbXB0eSBzdHJpbmcuXG4vL1xuLy8gMy4gIElmIGlucHV0X2ludGVnZXIgaXMgbGVzcyB0aGFuIChidXQgbm90IGVxdWFsIHRvKSAwLCBhcHBlbmQgXCItXCIgdG9cbi8vICAgICBvdXRwdXQuXG4vL1xuLy8gNC4gIEFwcGVuZCBpbnB1dF9pbnRlZ2VyJ3MgbnVtZXJpYyB2YWx1ZSByZXByZXNlbnRlZCBpbiBiYXNlIDEwIHVzaW5nXG4vLyAgICAgb25seSBkZWNpbWFsIGRpZ2l0cyB0byBvdXRwdXQuXG4vL1xuLy8gNS4gIFJldHVybiBvdXRwdXQuXG5mdW5jdGlvbiBzZXJpYWxpemVJbnRlZ2VyKHZhbHVlKSB7XG4gIGlmIChpc0ludmFsaWRJbnQodmFsdWUpKSB7XG4gICAgdGhyb3cgc2VyaWFsaXplRXJyb3IodmFsdWUsIElOVEVHRVIpO1xuICB9XG4gIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xufVxuXG4vLyA0LjEuMTAuICBTZXJpYWxpemluZyBhIERhdGVcbi8vXG4vLyBHaXZlbiBhIERhdGUgYXMgaW5wdXRfaW50ZWdlciwgcmV0dXJuIGFuIEFTQ0lJIHN0cmluZyBzdWl0YWJsZSBmb3Jcbi8vIHVzZSBpbiBhbiBIVFRQIGZpZWxkIHZhbHVlLlxuLy8gMS4gIExldCBvdXRwdXQgYmUgXCJAXCIuXG4vLyAyLiAgQXBwZW5kIHRvIG91dHB1dCB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgU2VyaWFsaXppbmcgYW4gSW50ZWdlclxuLy8gICAgIHdpdGggaW5wdXRfZGF0ZSAoU2VjdGlvbiA0LjEuNCkuXG4vLyAzLiAgUmV0dXJuIG91dHB1dC5cbmZ1bmN0aW9uIHNlcmlhbGl6ZURhdGUodmFsdWUpIHtcbiAgcmV0dXJuIGBAJHtzZXJpYWxpemVJbnRlZ2VyKHZhbHVlLmdldFRpbWUoKSAvIDEwMDApfWA7XG59XG5cbi8qKlxuICogVGhpcyBpbXBsZW1lbnRzIHRoZSByb3VuZGluZyBwcm9jZWR1cmUgZGVzY3JpYmVkIGluIHN0ZXAgMiBvZiB0aGUgXCJTZXJpYWxpemluZyBhIERlY2ltYWxcIiBzcGVjaWZpY2F0aW9uLlxuICogVGhpcyByb3VuZGluZyBzdHlsZSBpcyBrbm93biBhcyBcImV2ZW4gcm91bmRpbmdcIiwgXCJiYW5rZXIncyByb3VuZGluZ1wiLCBvciBcImNvbW1lcmNpYWwgcm91bmRpbmdcIi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gcm91bmRcbiAqIEBwYXJhbSBwcmVjaXNpb24gLSBUaGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRvIHJvdW5kIHRvXG4gKiBAcmV0dXJucyBUaGUgcm91bmRlZCB2YWx1ZVxuICpcbiAqIEBncm91cCBVdGlsc1xuICpcbiAqIEBiZXRhXG4gKi9cbmZ1bmN0aW9uIHJvdW5kVG9FdmVuKHZhbHVlLCBwcmVjaXNpb24pIHtcbiAgaWYgKHZhbHVlIDwgMCkge1xuICAgIHJldHVybiAtcm91bmRUb0V2ZW4oLXZhbHVlLCBwcmVjaXNpb24pO1xuICB9XG4gIGNvbnN0IGRlY2ltYWxTaGlmdCA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24pO1xuICBjb25zdCBpc0VxdWlkaXN0YW50ID0gTWF0aC5hYnModmFsdWUgKiBkZWNpbWFsU2hpZnQgJSAxIC0gMC41KSA8IE51bWJlci5FUFNJTE9OO1xuICBpZiAoaXNFcXVpZGlzdGFudCkge1xuICAgIC8vIElmIHRoZSB0YWlsIG9mIHRoZSBkZWNpbWFsIHBsYWNlIGlzICdlcXVpZGlzdGFudCcgd2Ugcm91bmQgdG8gdGhlIG5lYXJlc3QgZXZlbiB2YWx1ZVxuICAgIGNvbnN0IGZsb29yZWRWYWx1ZSA9IE1hdGguZmxvb3IodmFsdWUgKiBkZWNpbWFsU2hpZnQpO1xuICAgIHJldHVybiAoZmxvb3JlZFZhbHVlICUgMiA9PT0gMCA/IGZsb29yZWRWYWx1ZSA6IGZsb29yZWRWYWx1ZSArIDEpIC8gZGVjaW1hbFNoaWZ0O1xuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZSwgcHJvY2VlZCBhcyBub3JtYWxcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIGRlY2ltYWxTaGlmdCkgLyBkZWNpbWFsU2hpZnQ7XG4gIH1cbn1cblxuLy8gNC4xLjUuICBTZXJpYWxpemluZyBhIERlY2ltYWxcbi8vXG4vLyBHaXZlbiBhIGRlY2ltYWwgbnVtYmVyIGFzIGlucHV0X2RlY2ltYWwsIHJldHVybiBhbiBBU0NJSSBzdHJpbmdcbi8vIHN1aXRhYmxlIGZvciB1c2UgaW4gYSBIVFRQIGZpZWxkIHZhbHVlLlxuLy9cbi8vIDEuICAgSWYgaW5wdXRfZGVjaW1hbCBpcyBub3QgYSBkZWNpbWFsIG51bWJlciwgZmFpbCBzZXJpYWxpemF0aW9uLlxuLy9cbi8vIDIuICAgSWYgaW5wdXRfZGVjaW1hbCBoYXMgbW9yZSB0aGFuIHRocmVlIHNpZ25pZmljYW50IGRpZ2l0cyB0byB0aGVcbi8vICAgICAgcmlnaHQgb2YgdGhlIGRlY2ltYWwgcG9pbnQsIHJvdW5kIGl0IHRvIHRocmVlIGRlY2ltYWwgcGxhY2VzLFxuLy8gICAgICByb3VuZGluZyB0aGUgZmluYWwgZGlnaXQgdG8gdGhlIG5lYXJlc3QgdmFsdWUsIG9yIHRvIHRoZSBldmVuXG4vLyAgICAgIHZhbHVlIGlmIGl0IGlzIGVxdWlkaXN0YW50LlxuLy9cbi8vIDMuICAgSWYgaW5wdXRfZGVjaW1hbCBoYXMgbW9yZSB0aGFuIDEyIHNpZ25pZmljYW50IGRpZ2l0cyB0byB0aGUgbGVmdFxuLy8gICAgICBvZiB0aGUgZGVjaW1hbCBwb2ludCBhZnRlciByb3VuZGluZywgZmFpbCBzZXJpYWxpemF0aW9uLlxuLy9cbi8vIDQuICAgTGV0IG91dHB1dCBiZSBhbiBlbXB0eSBzdHJpbmcuXG4vL1xuLy8gNS4gICBJZiBpbnB1dF9kZWNpbWFsIGlzIGxlc3MgdGhhbiAoYnV0IG5vdCBlcXVhbCB0bykgMCwgYXBwZW5kIFwiLVwiXG4vLyAgICAgIHRvIG91dHB1dC5cbi8vXG4vLyA2LiAgIEFwcGVuZCBpbnB1dF9kZWNpbWFsJ3MgaW50ZWdlciBjb21wb25lbnQgcmVwcmVzZW50ZWQgaW4gYmFzZSAxMFxuLy8gICAgICAodXNpbmcgb25seSBkZWNpbWFsIGRpZ2l0cykgdG8gb3V0cHV0OyBpZiBpdCBpcyB6ZXJvLCBhcHBlbmRcbi8vICAgICAgXCIwXCIuXG4vL1xuLy8gNy4gICBBcHBlbmQgXCIuXCIgdG8gb3V0cHV0LlxuLy9cbi8vIDguICAgSWYgaW5wdXRfZGVjaW1hbCdzIGZyYWN0aW9uYWwgY29tcG9uZW50IGlzIHplcm8sIGFwcGVuZCBcIjBcIiB0b1xuLy8gICAgICBvdXRwdXQuXG4vL1xuLy8gOS4gICBPdGhlcndpc2UsIGFwcGVuZCB0aGUgc2lnbmlmaWNhbnQgZGlnaXRzIG9mIGlucHV0X2RlY2ltYWwnc1xuLy8gICAgICBmcmFjdGlvbmFsIGNvbXBvbmVudCByZXByZXNlbnRlZCBpbiBiYXNlIDEwICh1c2luZyBvbmx5IGRlY2ltYWxcbi8vICAgICAgZGlnaXRzKSB0byBvdXRwdXQuXG4vL1xuLy8gMTAuICBSZXR1cm4gb3V0cHV0LlxuZnVuY3Rpb24gc2VyaWFsaXplRGVjaW1hbCh2YWx1ZSkge1xuICBjb25zdCByb3VuZGVkVmFsdWUgPSByb3VuZFRvRXZlbih2YWx1ZSwgMyk7IC8vIHJvdW5kIHRvIDMgZGVjaW1hbCBwbGFjZXNcbiAgaWYgKE1hdGguZmxvb3IoTWF0aC5hYnMocm91bmRlZFZhbHVlKSkudG9TdHJpbmcoKS5sZW5ndGggPiAxMikge1xuICAgIHRocm93IHNlcmlhbGl6ZUVycm9yKHZhbHVlLCBERUNJTUFMKTtcbiAgfVxuICBjb25zdCBzdHJpbmdWYWx1ZSA9IHJvdW5kZWRWYWx1ZS50b1N0cmluZygpO1xuICByZXR1cm4gc3RyaW5nVmFsdWUuaW5jbHVkZXMoJy4nKSA/IHN0cmluZ1ZhbHVlIDogYCR7c3RyaW5nVmFsdWV9LjBgO1xufVxuXG5jb25zdCBTVFJJTkcgPSAnU3RyaW5nJztcblxuLy8gNC4xLjYuICBTZXJpYWxpemluZyBhIFN0cmluZ1xuLy9cbi8vIEdpdmVuIGEgU3RyaW5nIGFzIGlucHV0X3N0cmluZywgcmV0dXJuIGFuIEFTQ0lJIHN0cmluZyBzdWl0YWJsZSBmb3Jcbi8vIHVzZSBpbiBhIEhUVFAgZmllbGQgdmFsdWUuXG4vL1xuLy8gMS4gIENvbnZlcnQgaW5wdXRfc3RyaW5nIGludG8gYSBzZXF1ZW5jZSBvZiBBU0NJSSBjaGFyYWN0ZXJzOyBpZlxuLy8gICAgIGNvbnZlcnNpb24gZmFpbHMsIGZhaWwgc2VyaWFsaXphdGlvbi5cbi8vXG4vLyAyLiAgSWYgaW5wdXRfc3RyaW5nIGNvbnRhaW5zIGNoYXJhY3RlcnMgaW4gdGhlIHJhbmdlICV4MDAtMWYgb3IgJXg3ZlxuLy8gICAgIChpLmUuLCBub3QgaW4gVkNIQVIgb3IgU1ApLCBmYWlsIHNlcmlhbGl6YXRpb24uXG4vL1xuLy8gMy4gIExldCBvdXRwdXQgYmUgdGhlIHN0cmluZyBEUVVPVEUuXG4vL1xuLy8gNC4gIEZvciBlYWNoIGNoYXJhY3RlciBjaGFyIGluIGlucHV0X3N0cmluZzpcbi8vXG4vLyAgICAgMS4gIElmIGNoYXIgaXMgXCJcXFwiIG9yIERRVU9URTpcbi8vXG4vLyAgICAgICAgIDEuICBBcHBlbmQgXCJcXFwiIHRvIG91dHB1dC5cbi8vXG4vLyAgICAgMi4gIEFwcGVuZCBjaGFyIHRvIG91dHB1dC5cbi8vXG4vLyA1LiAgQXBwZW5kIERRVU9URSB0byBvdXRwdXQuXG4vL1xuLy8gNi4gIFJldHVybiBvdXRwdXQuXG5mdW5jdGlvbiBzZXJpYWxpemVTdHJpbmcodmFsdWUpIHtcbiAgaWYgKFNUUklOR19SRUdFWC50ZXN0KHZhbHVlKSkge1xuICAgIHRocm93IHNlcmlhbGl6ZUVycm9yKHZhbHVlLCBTVFJJTkcpO1xuICB9XG4gIHJldHVybiBgXCIke3ZhbHVlLnJlcGxhY2UoL1xcXFwvZywgYFxcXFxcXFxcYCkucmVwbGFjZSgvXCIvZywgYFxcXFxcImApfVwiYDtcbn1cblxuZnVuY3Rpb24gc3ltYm9sVG9TdHIoc3ltYm9sKSB7XG4gIHJldHVybiBzeW1ib2wuZGVzY3JpcHRpb24gfHwgc3ltYm9sLnRvU3RyaW5nKCkuc2xpY2UoNywgLTEpO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVUb2tlbih0b2tlbikge1xuICBjb25zdCB2YWx1ZSA9IHN5bWJvbFRvU3RyKHRva2VuKTtcbiAgaWYgKC9eKFthLXpBLVoqXSkoWyEjJCUmJyorXFwtLl5fYHx+XFx3Oi9dKikkLy50ZXN0KHZhbHVlKSA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBzZXJpYWxpemVFcnJvcih2YWx1ZSwgVE9LRU4pO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gNC4xLjMuMS4gIFNlcmlhbGl6aW5nIGEgQmFyZSBJdGVtXG4vL1xuLy8gR2l2ZW4gYW4gSXRlbSBhcyBpbnB1dF9pdGVtLCByZXR1cm4gYW4gQVNDSUkgc3RyaW5nIHN1aXRhYmxlIGZvciB1c2Vcbi8vIGluIGEgSFRUUCBmaWVsZCB2YWx1ZS5cbi8vXG4vLyAxLiAgSWYgaW5wdXRfaXRlbSBpcyBhbiBJbnRlZ2VyLCByZXR1cm4gdGhlIHJlc3VsdCBvZiBydW5uaW5nXG4vLyAgICAgU2VyaWFsaXppbmcgYW4gSW50ZWdlciAoU2VjdGlvbiA0LjEuNCkgd2l0aCBpbnB1dF9pdGVtLlxuLy9cbi8vIDIuICBJZiBpbnB1dF9pdGVtIGlzIGEgRGVjaW1hbCwgcmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZ1xuLy8gICAgIFNlcmlhbGl6aW5nIGEgRGVjaW1hbCAoU2VjdGlvbiA0LjEuNSkgd2l0aCBpbnB1dF9pdGVtLlxuLy9cbi8vIDMuICBJZiBpbnB1dF9pdGVtIGlzIGEgU3RyaW5nLCByZXR1cm4gdGhlIHJlc3VsdCBvZiBydW5uaW5nXG4vLyAgICAgU2VyaWFsaXppbmcgYSBTdHJpbmcgKFNlY3Rpb24gNC4xLjYpIHdpdGggaW5wdXRfaXRlbS5cbi8vXG4vLyA0LiAgSWYgaW5wdXRfaXRlbSBpcyBhIFRva2VuLCByZXR1cm4gdGhlIHJlc3VsdCBvZiBydW5uaW5nXG4vLyAgICAgU2VyaWFsaXppbmcgYSBUb2tlbiAoU2VjdGlvbiA0LjEuNykgd2l0aCBpbnB1dF9pdGVtLlxuLy9cbi8vIDUuICBJZiBpbnB1dF9pdGVtIGlzIGEgQm9vbGVhbiwgcmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZ1xuLy8gICAgIFNlcmlhbGl6aW5nIGEgQm9vbGVhbiAoU2VjdGlvbiA0LjEuOSkgd2l0aCBpbnB1dF9pdGVtLlxuLy9cbi8vIDYuICBJZiBpbnB1dF9pdGVtIGlzIGEgQnl0ZSBTZXF1ZW5jZSwgcmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZ1xuLy8gICAgIFNlcmlhbGl6aW5nIGEgQnl0ZSBTZXF1ZW5jZSAoU2VjdGlvbiA0LjEuOCkgd2l0aCBpbnB1dF9pdGVtLlxuLy9cbi8vIDcuICBJZiBpbnB1dF9pdGVtIGlzIGEgRGF0ZSwgcmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZyBTZXJpYWxpemluZ1xuLy8gICAgIGEgRGF0ZSAoU2VjdGlvbiA0LjEuMTApIHdpdGggaW5wdXRfaXRlbS5cbi8vXG4vLyA4LiAgT3RoZXJ3aXNlLCBmYWlsIHNlcmlhbGl6YXRpb24uXG5mdW5jdGlvbiBzZXJpYWxpemVCYXJlSXRlbSh2YWx1ZSkge1xuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBpZiAoIWlzRmluaXRlTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBzZXJpYWxpemVFcnJvcih2YWx1ZSwgQkFSRV9JVEVNKTtcbiAgICAgIH1cbiAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplSW50ZWdlcih2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VyaWFsaXplRGVjaW1hbCh2YWx1ZSk7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiBzZXJpYWxpemVTdHJpbmcodmFsdWUpO1xuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICByZXR1cm4gc2VyaWFsaXplVG9rZW4odmFsdWUpO1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHNlcmlhbGl6ZUJvb2xlYW4odmFsdWUpO1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVEYXRlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZUJ5dGVTZXF1ZW5jZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTZlRva2VuKSB7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVUb2tlbih2YWx1ZSk7XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGZhaWxcbiAgICAgIHRocm93IHNlcmlhbGl6ZUVycm9yKHZhbHVlLCBCQVJFX0lURU0pO1xuICB9XG59XG5cbi8vIDQuMS4xLjMuICBTZXJpYWxpemluZyBhIEtleVxuLy9cbi8vIEdpdmVuIGEga2V5IGFzIGlucHV0X2tleSwgcmV0dXJuIGFuIEFTQ0lJIHN0cmluZyBzdWl0YWJsZSBmb3IgdXNlIGluXG4vLyBhIEhUVFAgZmllbGQgdmFsdWUuXG4vL1xuLy8gMS4gIENvbnZlcnQgaW5wdXRfa2V5IGludG8gYSBzZXF1ZW5jZSBvZiBBU0NJSSBjaGFyYWN0ZXJzOyBpZlxuLy8gICAgIGNvbnZlcnNpb24gZmFpbHMsIGZhaWwgc2VyaWFsaXphdGlvbi5cbi8vXG4vLyAyLiAgSWYgaW5wdXRfa2V5IGNvbnRhaW5zIGNoYXJhY3RlcnMgbm90IGluIGxjYWxwaGEsIERJR0lULCBcIl9cIiwgXCItXCIsXG4vLyAgICAgXCIuXCIsIG9yIFwiKlwiIGZhaWwgc2VyaWFsaXphdGlvbi5cbi8vXG4vLyAzLiAgSWYgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBpbnB1dF9rZXkgaXMgbm90IGxjYWxwaGEgb3IgXCIqXCIsIGZhaWxcbi8vICAgICBzZXJpYWxpemF0aW9uLlxuLy9cbi8vIDQuICBMZXQgb3V0cHV0IGJlIGFuIGVtcHR5IHN0cmluZy5cbi8vXG4vLyA1LiAgQXBwZW5kIGlucHV0X2tleSB0byBvdXRwdXQuXG4vL1xuLy8gNi4gIFJldHVybiBvdXRwdXQuXG5mdW5jdGlvbiBzZXJpYWxpemVLZXkodmFsdWUpIHtcbiAgaWYgKC9eW2EteipdW2EtejAtOVxcLV8uKl0qJC8udGVzdCh2YWx1ZSkgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgc2VyaWFsaXplRXJyb3IodmFsdWUsIEtFWSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vLyA0LjEuMS4yLiAgU2VyaWFsaXppbmcgUGFyYW1ldGVyc1xuLy9cbi8vIEdpdmVuIGFuIG9yZGVyZWQgRGljdGlvbmFyeSBhcyBpbnB1dF9wYXJhbWV0ZXJzIChlYWNoIG1lbWJlciBoYXZpbmcgYVxuLy8gcGFyYW1fbmFtZSBhbmQgYSBwYXJhbV92YWx1ZSksIHJldHVybiBhbiBBU0NJSSBzdHJpbmcgc3VpdGFibGUgZm9yXG4vLyB1c2UgaW4gYSBIVFRQIGZpZWxkIHZhbHVlLlxuLy9cbi8vIDEuICBMZXQgb3V0cHV0IGJlIGFuIGVtcHR5IHN0cmluZy5cbi8vXG4vLyAyLiAgRm9yIGVhY2ggcGFyYW1fbmFtZSB3aXRoIGEgdmFsdWUgb2YgcGFyYW1fdmFsdWUgaW5cbi8vICAgICBpbnB1dF9wYXJhbWV0ZXJzOlxuLy9cbi8vICAgICAxLiAgQXBwZW5kIFwiO1wiIHRvIG91dHB1dC5cbi8vXG4vLyAgICAgMi4gIEFwcGVuZCB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgU2VyaWFsaXppbmcgYSBLZXlcbi8vICAgICAgICAgKFNlY3Rpb24gNC4xLjEuMykgd2l0aCBwYXJhbV9uYW1lIHRvIG91dHB1dC5cbi8vXG4vLyAgICAgMy4gIElmIHBhcmFtX3ZhbHVlIGlzIG5vdCBCb29sZWFuIHRydWU6XG4vL1xuLy8gICAgICAgICAxLiAgQXBwZW5kIFwiPVwiIHRvIG91dHB1dC5cbi8vXG4vLyAgICAgICAgIDIuICBBcHBlbmQgdGhlIHJlc3VsdCBvZiBydW5uaW5nIFNlcmlhbGl6aW5nIGEgYmFyZSBJdGVtXG4vLyAgICAgICAgICAgICAoU2VjdGlvbiA0LjEuMy4xKSB3aXRoIHBhcmFtX3ZhbHVlIHRvIG91dHB1dC5cbi8vXG4vLyAzLiAgUmV0dXJuIG91dHB1dC5cbmZ1bmN0aW9uIHNlcmlhbGl6ZVBhcmFtcyhwYXJhbXMpIHtcbiAgaWYgKHBhcmFtcyA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhwYXJhbXMpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gYDske3NlcmlhbGl6ZUtleShrZXkpfWA7IC8vIG9taXQgdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gYDske3NlcmlhbGl6ZUtleShrZXkpfT0ke3NlcmlhbGl6ZUJhcmVJdGVtKHZhbHVlKX1gO1xuICB9KS5qb2luKCcnKTtcbn1cblxuLy8gNC4xLjMuICBTZXJpYWxpemluZyBhbiBJdGVtXG4vL1xuLy8gR2l2ZW4gYW4gSXRlbSBhcyBiYXJlX2l0ZW0gYW5kIFBhcmFtZXRlcnMgYXMgaXRlbV9wYXJhbWV0ZXJzLCByZXR1cm5cbi8vIGFuIEFTQ0lJIHN0cmluZyBzdWl0YWJsZSBmb3IgdXNlIGluIGEgSFRUUCBmaWVsZCB2YWx1ZS5cbi8vXG4vLyAxLiAgTGV0IG91dHB1dCBiZSBhbiBlbXB0eSBzdHJpbmcuXG4vL1xuLy8gMi4gIEFwcGVuZCB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgU2VyaWFsaXppbmcgYSBCYXJlIEl0ZW1cbi8vICAgICBTZWN0aW9uIDQuMS4zLjEgd2l0aCBiYXJlX2l0ZW0gdG8gb3V0cHV0LlxuLy9cbi8vIDMuICBBcHBlbmQgdGhlIHJlc3VsdCBvZiBydW5uaW5nIFNlcmlhbGl6aW5nIFBhcmFtZXRlcnNcbi8vICAgICBTZWN0aW9uIDQuMS4xLjIgd2l0aCBpdGVtX3BhcmFtZXRlcnMgdG8gb3V0cHV0LlxuLy9cbi8vIDQuICBSZXR1cm4gb3V0cHV0LlxuZnVuY3Rpb24gc2VyaWFsaXplSXRlbSh2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTZkl0ZW0pIHtcbiAgICByZXR1cm4gYCR7c2VyaWFsaXplQmFyZUl0ZW0odmFsdWUudmFsdWUpfSR7c2VyaWFsaXplUGFyYW1zKHZhbHVlLnBhcmFtcyl9YDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc2VyaWFsaXplQmFyZUl0ZW0odmFsdWUpO1xuICB9XG59XG5cbi8vIDQuMS4xLjEuICBTZXJpYWxpemluZyBhbiBJbm5lciBMaXN0XG4vL1xuLy8gR2l2ZW4gYW4gYXJyYXkgb2YgKG1lbWJlcl92YWx1ZSwgcGFyYW1ldGVycykgdHVwbGVzIGFzIGlubmVyX2xpc3QsXG4vLyBhbmQgcGFyYW1ldGVycyBhcyBsaXN0X3BhcmFtZXRlcnMsIHJldHVybiBhbiBBU0NJSSBzdHJpbmcgc3VpdGFibGVcbi8vIGZvciB1c2UgaW4gYSBIVFRQIGZpZWxkIHZhbHVlLlxuLy9cbi8vIDEuICBMZXQgb3V0cHV0IGJlIHRoZSBzdHJpbmcgXCIoXCIuXG4vL1xuLy8gMi4gIEZvciBlYWNoIChtZW1iZXJfdmFsdWUsIHBhcmFtZXRlcnMpIG9mIGlubmVyX2xpc3Q6XG4vL1xuLy8gICAgIDEuICBBcHBlbmQgdGhlIHJlc3VsdCBvZiBydW5uaW5nIFNlcmlhbGl6aW5nIGFuIEl0ZW1cbi8vICAgICAgICAgKFNlY3Rpb24gNC4xLjMpIHdpdGggKG1lbWJlcl92YWx1ZSwgcGFyYW1ldGVycykgdG8gb3V0cHV0LlxuLy9cbi8vICAgICAyLiAgSWYgbW9yZSB2YWx1ZXMgcmVtYWluIGluIGlubmVyX2xpc3QsIGFwcGVuZCBhIHNpbmdsZSBTUCB0b1xuLy8gICAgICAgICBvdXRwdXQuXG4vL1xuLy8gMy4gIEFwcGVuZCBcIilcIiB0byBvdXRwdXQuXG4vL1xuLy8gNC4gIEFwcGVuZCB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgU2VyaWFsaXppbmcgUGFyYW1ldGVyc1xuLy8gICAgIChTZWN0aW9uIDQuMS4xLjIpIHdpdGggbGlzdF9wYXJhbWV0ZXJzIHRvIG91dHB1dC5cbi8vXG4vLyA1LiAgUmV0dXJuIG91dHB1dC5cbmZ1bmN0aW9uIHNlcmlhbGl6ZUlubmVyTGlzdCh2YWx1ZSkge1xuICByZXR1cm4gYCgke3ZhbHVlLnZhbHVlLm1hcChzZXJpYWxpemVJdGVtKS5qb2luKCcgJyl9KSR7c2VyaWFsaXplUGFyYW1zKHZhbHVlLnBhcmFtcyl9YDtcbn1cblxuLy8gNC4xLjIuICBTZXJpYWxpemluZyBhIERpY3Rpb25hcnlcbi8vXG4vLyBHaXZlbiBhbiBvcmRlcmVkIERpY3Rpb25hcnkgYXMgaW5wdXRfZGljdGlvbmFyeSAoZWFjaCBtZW1iZXIgaGF2aW5nIGFcbi8vIG1lbWJlcl9uYW1lIGFuZCBhIHR1cGxlIHZhbHVlIG9mIChtZW1iZXJfdmFsdWUsIHBhcmFtZXRlcnMpKSwgcmV0dXJuXG4vLyBhbiBBU0NJSSBzdHJpbmcgc3VpdGFibGUgZm9yIHVzZSBpbiBhIEhUVFAgZmllbGQgdmFsdWUuXG4vL1xuLy8gMS4gIExldCBvdXRwdXQgYmUgYW4gZW1wdHkgc3RyaW5nLlxuLy9cbi8vIDIuICBGb3IgZWFjaCBtZW1iZXJfbmFtZSB3aXRoIGEgdmFsdWUgb2YgKG1lbWJlcl92YWx1ZSwgcGFyYW1ldGVycylcbi8vICAgICBpbiBpbnB1dF9kaWN0aW9uYXJ5OlxuLy9cbi8vICAgICAxLiAgQXBwZW5kIHRoZSByZXN1bHQgb2YgcnVubmluZyBTZXJpYWxpemluZyBhIEtleVxuLy8gICAgICAgICAoU2VjdGlvbiA0LjEuMS4zKSB3aXRoIG1lbWJlcidzIG1lbWJlcl9uYW1lIHRvIG91dHB1dC5cbi8vXG4vLyAgICAgMi4gIElmIG1lbWJlcl92YWx1ZSBpcyBCb29sZWFuIHRydWU6XG4vL1xuLy8gICAgICAgICAxLiAgQXBwZW5kIHRoZSByZXN1bHQgb2YgcnVubmluZyBTZXJpYWxpemluZyBQYXJhbWV0ZXJzXG4vLyAgICAgICAgICAgICAoU2VjdGlvbiA0LjEuMS4yKSB3aXRoIHBhcmFtZXRlcnMgdG8gb3V0cHV0LlxuLy9cbi8vICAgICAzLiAgT3RoZXJ3aXNlOlxuLy9cbi8vICAgICAgICAgMS4gIEFwcGVuZCBcIj1cIiB0byBvdXRwdXQuXG4vL1xuLy8gICAgICAgICAyLiAgSWYgbWVtYmVyX3ZhbHVlIGlzIGFuIGFycmF5LCBhcHBlbmQgdGhlIHJlc3VsdCBvZiBydW5uaW5nXG4vLyAgICAgICAgICAgICBTZXJpYWxpemluZyBhbiBJbm5lciBMaXN0IChTZWN0aW9uIDQuMS4xLjEpIHdpdGhcbi8vICAgICAgICAgICAgIChtZW1iZXJfdmFsdWUsIHBhcmFtZXRlcnMpIHRvIG91dHB1dC5cbi8vXG4vLyAgICAgICAgIDMuICBPdGhlcndpc2UsIGFwcGVuZCB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgU2VyaWFsaXppbmcgYW5cbi8vICAgICAgICAgICAgIEl0ZW0gKFNlY3Rpb24gNC4xLjMpIHdpdGggKG1lbWJlcl92YWx1ZSwgcGFyYW1ldGVycykgdG9cbi8vICAgICAgICAgICAgIG91dHB1dC5cbi8vXG4vLyAgICAgNC4gIElmIG1vcmUgbWVtYmVycyByZW1haW4gaW4gaW5wdXRfZGljdGlvbmFyeTpcbi8vXG4vLyAgICAgICAgIDEuICBBcHBlbmQgXCIsXCIgdG8gb3V0cHV0LlxuLy9cbi8vICAgICAgICAgMi4gIEFwcGVuZCBhIHNpbmdsZSBTUCB0byBvdXRwdXQuXG4vL1xuLy8gMy4gIFJldHVybiBvdXRwdXQuXG5mdW5jdGlvbiBzZXJpYWxpemVEaWN0KGRpY3QsIG9wdGlvbnMgPSB7XG4gIHdoaXRlc3BhY2U6IHRydWVcbn0pIHtcbiAgaWYgKHR5cGVvZiBkaWN0ICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IHNlcmlhbGl6ZUVycm9yKGRpY3QsIERJQ1QpO1xuICB9XG4gIGNvbnN0IGVudHJpZXMgPSBkaWN0IGluc3RhbmNlb2YgTWFwID8gZGljdC5lbnRyaWVzKCkgOiBPYmplY3QuZW50cmllcyhkaWN0KTtcbiAgY29uc3Qgb3B0aW9uYWxXaGl0ZVNwYWNlID0gb3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMud2hpdGVzcGFjZSA/ICcgJyA6ICcnO1xuICByZXR1cm4gQXJyYXkuZnJvbShlbnRyaWVzKS5tYXAoKFtrZXksIGl0ZW1dKSA9PiB7XG4gICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBTZkl0ZW0gPT09IGZhbHNlKSB7XG4gICAgICBpdGVtID0gbmV3IFNmSXRlbShpdGVtKTtcbiAgICB9XG4gICAgbGV0IG91dHB1dCA9IHNlcmlhbGl6ZUtleShrZXkpO1xuICAgIGlmIChpdGVtLnZhbHVlID09PSB0cnVlKSB7XG4gICAgICBvdXRwdXQgKz0gc2VyaWFsaXplUGFyYW1zKGl0ZW0ucGFyYW1zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0ICs9ICc9JztcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0udmFsdWUpKSB7XG4gICAgICAgIG91dHB1dCArPSBzZXJpYWxpemVJbm5lckxpc3QoaXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQgKz0gc2VyaWFsaXplSXRlbShpdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfSkuam9pbihgLCR7b3B0aW9uYWxXaGl0ZVNwYWNlfWApO1xufVxuXG4vKipcbiAqIEVuY29kZSBhbiBvYmplY3QgaW50byBhIHN0cnVjdHVyZWQgZmllbGQgZGljdGlvbmFyeVxuICpcbiAqIEBwYXJhbSBpbnB1dCAtIFRoZSBzdHJ1Y3R1cmVkIGZpZWxkIGRpY3Rpb25hcnkgdG8gZW5jb2RlXG4gKiBAcmV0dXJucyBUaGUgc3RydWN0dXJlZCBmaWVsZCBzdHJpbmdcbiAqXG4gKiBAZ3JvdXAgU3RydWN0dXJlZCBGaWVsZFxuICpcbiAqIEBiZXRhXG4gKi9cbmZ1bmN0aW9uIGVuY29kZVNmRGljdCh2YWx1ZSwgb3B0aW9ucykge1xuICByZXR1cm4gc2VyaWFsaXplRGljdCh2YWx1ZSwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBrZXkgaXMgYSB0b2tlbiBmaWVsZC5cbiAqXG4gKiBAcGFyYW0ga2V5IC0gVGhlIGtleSB0byBjaGVjay5cbiAqXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGtleSBpcyBhIHRva2VuIGZpZWxkLlxuICpcbiAqIEBpbnRlcm5hbFxuICpcbiAqIEBncm91cCBDTUNEXG4gKi9cbmNvbnN0IGlzVG9rZW5GaWVsZCA9IGtleSA9PiBrZXkgPT09ICdvdCcgfHwga2V5ID09PSAnc2YnIHx8IGtleSA9PT0gJ3N0JztcblxuY29uc3QgaXNWYWxpZCA9IHZhbHVlID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gaXNGaW5pdGVOdW1iZXIodmFsdWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSAnJyAmJiB2YWx1ZSAhPT0gZmFsc2U7XG59O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSByZWxhdGl2ZSBwYXRoIGZyb20gYSBVUkwuXG4gKlxuICogQHBhcmFtIHVybCAtIFRoZSBkZXN0aW5hdGlvbiBVUkxcbiAqIEBwYXJhbSBiYXNlIC0gVGhlIGJhc2UgVVJMXG4gKiBAcmV0dXJucyBUaGUgcmVsYXRpdmUgcGF0aFxuICpcbiAqIEBncm91cCBVdGlsc1xuICpcbiAqIEBiZXRhXG4gKi9cbmZ1bmN0aW9uIHVybFRvUmVsYXRpdmVQYXRoKHVybCwgYmFzZSkge1xuICBjb25zdCB0byA9IG5ldyBVUkwodXJsKTtcbiAgY29uc3QgZnJvbSA9IG5ldyBVUkwoYmFzZSk7XG4gIGlmICh0by5vcmlnaW4gIT09IGZyb20ub3JpZ2luKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICBjb25zdCB0b1BhdGggPSB0by5wYXRobmFtZS5zcGxpdCgnLycpLnNsaWNlKDEpO1xuICBjb25zdCBmcm9tUGF0aCA9IGZyb20ucGF0aG5hbWUuc3BsaXQoJy8nKS5zbGljZSgxLCAtMSk7XG4gIC8vIHJlbW92ZSBjb21tb24gcGFyZW50c1xuICB3aGlsZSAodG9QYXRoWzBdID09PSBmcm9tUGF0aFswXSkge1xuICAgIHRvUGF0aC5zaGlmdCgpO1xuICAgIGZyb21QYXRoLnNoaWZ0KCk7XG4gIH1cbiAgLy8gYWRkIGJhY2sgcGF0aHNcbiAgd2hpbGUgKGZyb21QYXRoLmxlbmd0aCkge1xuICAgIGZyb21QYXRoLnNoaWZ0KCk7XG4gICAgdG9QYXRoLnVuc2hpZnQoJy4uJyk7XG4gIH1cbiAgcmV0dXJuIHRvUGF0aC5qb2luKCcvJyk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSByYW5kb20gdjQgVVVJRFxuICpcbiAqIEByZXR1cm5zIEEgcmFuZG9tIHY0IFVVSURcbiAqXG4gKiBAZ3JvdXAgVXRpbHNcbiAqXG4gKiBAYmV0YVxuICovXG5mdW5jdGlvbiB1dWlkKCkge1xuICB0cnkge1xuICAgIHJldHVybiBjcnlwdG8ucmFuZG9tVVVJRCgpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKCkpO1xuICAgICAgY29uc3QgdXVpZCA9IHVybC50b1N0cmluZygpO1xuICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xuICAgICAgcmV0dXJuIHV1aWQuc2xpY2UodXVpZC5sYXN0SW5kZXhPZignLycpICsgMSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxldCBkdCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgY29uc3QgdXVpZCA9ICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgYyA9PiB7XG4gICAgICAgIGNvbnN0IHIgPSAoZHQgKyBNYXRoLnJhbmRvbSgpICogMTYpICUgMTYgfCAwO1xuICAgICAgICBkdCA9IE1hdGguZmxvb3IoZHQgLyAxNik7XG4gICAgICAgIHJldHVybiAoYyA9PSAneCcgPyByIDogciAmIDB4MyB8IDB4OCkudG9TdHJpbmcoMTYpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdXVpZDtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgdG9Sb3VuZGVkID0gdmFsdWUgPT4gTWF0aC5yb3VuZCh2YWx1ZSk7XG5jb25zdCB0b1VybFNhZmUgPSAodmFsdWUsIG9wdGlvbnMpID0+IHtcbiAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLmJhc2VVcmwpIHtcbiAgICB2YWx1ZSA9IHVybFRvUmVsYXRpdmVQYXRoKHZhbHVlLCBvcHRpb25zLmJhc2VVcmwpO1xuICB9XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xufTtcbmNvbnN0IHRvSHVuZHJlZCA9IHZhbHVlID0+IHRvUm91bmRlZCh2YWx1ZSAvIDEwMCkgKiAxMDA7XG4vKipcbiAqIFRoZSBkZWZhdWx0IGZvcm1hdHRlcnMgZm9yIENNQ0QgdmFsdWVzLlxuICpcbiAqIEBncm91cCBDTUNEXG4gKlxuICogQGJldGFcbiAqL1xuY29uc3QgQ21jZEZvcm1hdHRlcnMgPSB7XG4gIC8qKlxuICAgKiBCaXRyYXRlIChrYnBzKSByb3VuZGVkIGludGVnZXJcbiAgICovXG4gIGJyOiB0b1JvdW5kZWQsXG4gIC8qKlxuICAgKiBEdXJhdGlvbiAobWlsbGlzZWNvbmRzKSByb3VuZGVkIGludGVnZXJcbiAgICovXG4gIGQ6IHRvUm91bmRlZCxcbiAgLyoqXG4gICAqIEJ1ZmZlciBMZW5ndGggKG1pbGxpc2Vjb25kcykgcm91bmRlZCBuZWFyZXN0IDEwMG1zXG4gICAqL1xuICBibDogdG9IdW5kcmVkLFxuICAvKipcbiAgICogRGVhZGxpbmUgKG1pbGxpc2Vjb25kcykgcm91bmRlZCBuZWFyZXN0IDEwMG1zXG4gICAqL1xuICBkbDogdG9IdW5kcmVkLFxuICAvKipcbiAgICogTWVhc3VyZWQgVGhyb3VnaHB1dCAoa2Jwcykgcm91bmRlZCBuZWFyZXN0IDEwMGticHNcbiAgICovXG4gIG10cDogdG9IdW5kcmVkLFxuICAvKipcbiAgICogTmV4dCBPYmplY3QgUmVxdWVzdCBVUkwgZW5jb2RlZFxuICAgKi9cbiAgbm9yOiB0b1VybFNhZmUsXG4gIC8qKlxuICAgKiBSZXF1ZXN0ZWQgbWF4aW11bSB0aHJvdWdocHV0IChrYnBzKSByb3VuZGVkIG5lYXJlc3QgMTAwa2Jwc1xuICAgKi9cbiAgcnRwOiB0b0h1bmRyZWQsXG4gIC8qKlxuICAgKiBUb3AgQml0cmF0ZSAoa2Jwcykgcm91bmRlZCBpbnRlZ2VyXG4gICAqL1xuICB0YjogdG9Sb3VuZGVkXG59O1xuXG4vKipcbiAqIEludGVybmFsIENNQ0QgcHJvY2Vzc2luZyBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gb2JqIC0gVGhlIENNQ0Qgb2JqZWN0IHRvIHByb2Nlc3MuXG4gKiBAcGFyYW0gbWFwIC0gVGhlIG1hcHBpbmcgZnVuY3Rpb24gdG8gdXNlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciBlbmNvZGluZy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBAZ3JvdXAgQ01DRFxuICovXG5mdW5jdGlvbiBwcm9jZXNzQ21jZChvYmosIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzdWx0cyA9IHt9O1xuICBpZiAob2JqID09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKS5zb3J0KCk7XG4gIGNvbnN0IGZvcm1hdHRlcnMgPSBfZXh0ZW5kcyh7fSwgQ21jZEZvcm1hdHRlcnMsIG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZm9ybWF0dGVycyk7XG4gIGNvbnN0IGZpbHRlciA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZmlsdGVyO1xuICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICBpZiAoZmlsdGVyICE9IG51bGwgJiYgZmlsdGVyKGtleSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHZhbHVlID0gb2JqW2tleV07XG4gICAgY29uc3QgZm9ybWF0dGVyID0gZm9ybWF0dGVyc1trZXldO1xuICAgIGlmIChmb3JtYXR0ZXIpIHtcbiAgICAgIHZhbHVlID0gZm9ybWF0dGVyKHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gVmVyc2lvbiBzaG91bGQgb25seSBiZSByZXBvcnRlZCBpZiBub3QgZXF1YWwgdG8gMS5cbiAgICBpZiAoa2V5ID09PSAndicgJiYgdmFsdWUgPT09IDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gUGxheWJhY2sgcmF0ZSBzaG91bGQgb25seSBiZSBzZW50IGlmIG5vdCBlcXVhbCB0byAxLlxuICAgIGlmIChrZXkgPT0gJ3ByJyAmJiB2YWx1ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBpZ25vcmUgaW52YWxpZCB2YWx1ZXNcbiAgICBpZiAoIWlzVmFsaWQodmFsdWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc1Rva2VuRmllbGQoa2V5KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IG5ldyBTZlRva2VuKHZhbHVlKTtcbiAgICB9XG4gICAgcmVzdWx0c1trZXldID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0cztcbn1cblxuLyoqXG4gKiBFbmNvZGUgYSBDTUNEIG9iamVjdCB0byBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gY21jZCAtIFRoZSBDTUNEIG9iamVjdCB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIGVuY29kaW5nLlxuICpcbiAqIEByZXR1cm5zIFRoZSBlbmNvZGVkIENNQ0Qgc3RyaW5nLlxuICpcbiAqIEBncm91cCBDTUNEXG4gKlxuICogQGJldGFcbiAqL1xuZnVuY3Rpb24gZW5jb2RlQ21jZChjbWNkLCBvcHRpb25zID0ge30pIHtcbiAgaWYgKCFjbWNkKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiBlbmNvZGVTZkRpY3QocHJvY2Vzc0NtY2QoY21jZCwgb3B0aW9ucyksIF9leHRlbmRzKHtcbiAgICB3aGl0ZXNwYWNlOiBmYWxzZVxuICB9LCBvcHRpb25zKSk7XG59XG5cbi8qKlxuICogQ29udmVydCBhIENNQ0QgZGF0YSBvYmplY3QgdG8gcmVxdWVzdCBoZWFkZXJzXG4gKlxuICogQHBhcmFtIGNtY2QgLSBUaGUgQ01DRCBkYXRhIG9iamVjdCB0byBjb252ZXJ0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciBlbmNvZGluZyB0aGUgQ01DRCBvYmplY3QuXG4gKlxuICogQHJldHVybnMgVGhlIENNQ0QgaGVhZGVyIHNoYXJkcy5cbiAqXG4gKiBAZ3JvdXAgQ01DRFxuICpcbiAqIEBiZXRhXG4gKi9cbmZ1bmN0aW9uIHRvQ21jZEhlYWRlcnMoY21jZCwgb3B0aW9ucyA9IHt9KSB7XG4gIGlmICghY21jZCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoY21jZCk7XG4gIGNvbnN0IGhlYWRlck1hcCA9IE9iamVjdC5lbnRyaWVzKENtY2RIZWFkZXJNYXApLmNvbmNhdChPYmplY3QuZW50cmllcygob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5jdXN0b21IZWFkZXJNYXApIHx8IHt9KSk7XG4gIGNvbnN0IHNoYXJkcyA9IGVudHJpZXMucmVkdWNlKChhY2MsIGVudHJ5KSA9PiB7XG4gICAgdmFyIF9oZWFkZXJNYXAkZmluZCwgX2FjYyRmaWVsZDtcbiAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBlbnRyeTtcbiAgICBjb25zdCBmaWVsZCA9ICgoX2hlYWRlck1hcCRmaW5kID0gaGVhZGVyTWFwLmZpbmQoZW50cnkgPT4gZW50cnlbMV0uaW5jbHVkZXMoa2V5KSkpID09IG51bGwgPyB2b2lkIDAgOiBfaGVhZGVyTWFwJGZpbmRbMF0pIHx8IENtY2RIZWFkZXJGaWVsZC5SRVFVRVNUO1xuICAgIChfYWNjJGZpZWxkID0gYWNjW2ZpZWxkXSkgIT0gbnVsbCA/IF9hY2MkZmllbGQgOiBhY2NbZmllbGRdID0ge307XG4gICAgYWNjW2ZpZWxkXVtrZXldID0gdmFsdWU7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoc2hhcmRzKS5yZWR1Y2UoKGFjYywgW2ZpZWxkLCB2YWx1ZV0pID0+IHtcbiAgICBhY2NbZmllbGRdID0gZW5jb2RlQ21jZCh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufVxuXG4vKipcbiAqIEFwcGVuZCBDTUNEIHF1ZXJ5IGFyZ3MgdG8gYSBoZWFkZXIgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBoZWFkZXJzIC0gVGhlIGhlYWRlcnMgdG8gYXBwZW5kIHRvLlxuICogQHBhcmFtIGNtY2QgLSBUaGUgQ01DRCBvYmplY3QgdG8gYXBwZW5kLlxuICogQHBhcmFtIGN1c3RvbUhlYWRlck1hcCAtIEEgbWFwIG9mIGN1c3RvbSBDTUNEIGtleXMgdG8gaGVhZGVyIGZpZWxkcy5cbiAqXG4gKiBAcmV0dXJucyBUaGUgaGVhZGVycyB3aXRoIHRoZSBDTUNEIGhlYWRlciBzaGFyZHMgYXBwZW5kZWQuXG4gKlxuICogQGdyb3VwIENNQ0RcbiAqXG4gKiBAYmV0YVxuICovXG5mdW5jdGlvbiBhcHBlbmRDbWNkSGVhZGVycyhoZWFkZXJzLCBjbWNkLCBvcHRpb25zKSB7XG4gIHJldHVybiBfZXh0ZW5kcyhoZWFkZXJzLCB0b0NtY2RIZWFkZXJzKGNtY2QsIG9wdGlvbnMpKTtcbn1cblxuLyoqXG4gKiBDTUNEIHBhcmFtZXRlciBuYW1lLlxuICpcbiAqIEBncm91cCBDTUNEXG4gKlxuICogQGJldGFcbiAqL1xuY29uc3QgQ01DRF9QQVJBTSA9ICdDTUNEJztcblxuLyoqXG4gKiBDb252ZXJ0IGEgQ01DRCBkYXRhIG9iamVjdCB0byBhIHF1ZXJ5IGFyZy5cbiAqXG4gKiBAcGFyYW0gY21jZCAtIFRoZSBDTUNEIG9iamVjdCB0byBjb252ZXJ0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciBlbmNvZGluZyB0aGUgQ01DRCBvYmplY3QuXG4gKlxuICogQHJldHVybnMgVGhlIENNQ0QgcXVlcnkgYXJnLlxuICpcbiAqIEBncm91cCBDTUNEXG4gKlxuICogQGJldGFcbiAqL1xuZnVuY3Rpb24gdG9DbWNkUXVlcnkoY21jZCwgb3B0aW9ucyA9IHt9KSB7XG4gIGlmICghY21jZCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBjb25zdCBwYXJhbXMgPSBlbmNvZGVDbWNkKGNtY2QsIG9wdGlvbnMpO1xuICByZXR1cm4gYCR7Q01DRF9QQVJBTX09JHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zKX1gO1xufVxuXG5jb25zdCBSRUdFWCA9IC9DTUNEPVteJiNdKy87XG4vKipcbiAqIEFwcGVuZCBDTUNEIHF1ZXJ5IGFyZ3MgdG8gYSBVUkwuXG4gKlxuICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdG8gYXBwZW5kIHRvLlxuICogQHBhcmFtIGNtY2QgLSBUaGUgQ01DRCBvYmplY3QgdG8gYXBwZW5kLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciBlbmNvZGluZyB0aGUgQ01DRCBvYmplY3QuXG4gKlxuICogQHJldHVybnMgVGhlIFVSTCB3aXRoIHRoZSBDTUNEIHF1ZXJ5IGFyZ3MgYXBwZW5kZWQuXG4gKlxuICogQGdyb3VwIENNQ0RcbiAqXG4gKiBAYmV0YVxuICovXG5mdW5jdGlvbiBhcHBlbmRDbWNkUXVlcnkodXJsLCBjbWNkLCBvcHRpb25zKSB7XG4gIC8vIFRPRE86IFJlcGxhY2Ugd2l0aCBVUkxTZWFyY2hQYXJhbXMgb25jZSB3ZSBkcm9wIFNhZmFyaSA8IDEwLjEgJiBDaHJvbWUgPCA0OSBzdXBwb3J0LlxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVVJMU2VhcmNoUGFyYW1zXG4gIGNvbnN0IHF1ZXJ5ID0gdG9DbWNkUXVlcnkoY21jZCwgb3B0aW9ucyk7XG4gIGlmICghcXVlcnkpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIGlmIChSRUdFWC50ZXN0KHVybCkpIHtcbiAgICByZXR1cm4gdXJsLnJlcGxhY2UoUkVHRVgsIHF1ZXJ5KTtcbiAgfVxuICBjb25zdCBzZXBhcmF0b3IgPSB1cmwuaW5jbHVkZXMoJz8nKSA/ICcmJyA6ICc/JztcbiAgcmV0dXJuIGAke3VybH0ke3NlcGFyYXRvcn0ke3F1ZXJ5fWA7XG59XG5cbi8qKlxuICogQ29udHJvbGxlciB0byBkZWFsIHdpdGggQ29tbW9uIE1lZGlhIENsaWVudCBEYXRhIChDTUNEKVxuICogQHNlZSBodHRwczovL2Nkbi5jdGEudGVjaC9jdGEvbWVkaWEvbWVkaWEvcmVzb3VyY2VzL3N0YW5kYXJkcy9wZGZzL2N0YS01MDA0LWZpbmFsLnBkZlxuICovXG5jbGFzcyBDTUNEQ29udHJvbGxlciB7XG4gIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG5cbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy5tZWRpYSA9IHZvaWQgMDtcbiAgICB0aGlzLnNpZCA9IHZvaWQgMDtcbiAgICB0aGlzLmNpZCA9IHZvaWQgMDtcbiAgICB0aGlzLnVzZUhlYWRlcnMgPSBmYWxzZTtcbiAgICB0aGlzLmluY2x1ZGVLZXlzID0gdm9pZCAwO1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXJ2ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmJ1ZmZlcmluZyA9IHRydWU7XG4gICAgdGhpcy5hdWRpb0J1ZmZlciA9IHZvaWQgMDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuICAgIHRoaXMudmlkZW9CdWZmZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5vbldhaXRpbmcgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICB0aGlzLnN0YXJ2ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5idWZmZXJpbmcgPSB0cnVlO1xuICAgIH07XG4gICAgdGhpcy5vblBsYXlpbmcgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLmJ1ZmZlcmluZyA9IGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXBwbHkgQ01DRCBkYXRhIHRvIGEgbWFuaWZlc3QgcmVxdWVzdC5cbiAgICAgKi9cbiAgICB0aGlzLmFwcGx5UGxheWxpc3REYXRhID0gY29udGV4dCA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmFwcGx5KGNvbnRleHQsIHtcbiAgICAgICAgICBvdDogQ21PYmplY3RUeXBlLk1BTklGRVNULFxuICAgICAgICAgIHN1OiAhdGhpcy5pbml0aWFsaXplZFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKCdDb3VsZCBub3QgZ2VuZXJhdGUgbWFuaWZlc3QgQ01DRCBkYXRhLicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFwcGx5IENNQ0QgZGF0YSB0byBhIHNlZ21lbnQgcmVxdWVzdFxuICAgICAqL1xuICAgIHRoaXMuYXBwbHlGcmFnbWVudERhdGEgPSBjb250ZXh0ID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gY29udGV4dC5mcmFnO1xuICAgICAgICBjb25zdCBsZXZlbCA9IHRoaXMuaGxzLmxldmVsc1tmcmFnbWVudC5sZXZlbF07XG4gICAgICAgIGNvbnN0IG90ID0gdGhpcy5nZXRPYmplY3RUeXBlKGZyYWdtZW50KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICBkOiBmcmFnbWVudC5kdXJhdGlvbiAqIDEwMDAsXG4gICAgICAgICAgb3RcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG90ID09PSBDbU9iamVjdFR5cGUuVklERU8gfHwgb3QgPT09IENtT2JqZWN0VHlwZS5BVURJTyB8fCBvdCA9PSBDbU9iamVjdFR5cGUuTVVYRUQpIHtcbiAgICAgICAgICBkYXRhLmJyID0gbGV2ZWwuYml0cmF0ZSAvIDEwMDA7XG4gICAgICAgICAgZGF0YS50YiA9IHRoaXMuZ2V0VG9wQmFuZHdpZHRoKG90KSAvIDEwMDA7XG4gICAgICAgICAgZGF0YS5ibCA9IHRoaXMuZ2V0QnVmZmVyTGVuZ3RoKG90KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwcGx5KGNvbnRleHQsIGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oJ0NvdWxkIG5vdCBnZW5lcmF0ZSBzZWdtZW50IENNQ0QgZGF0YS4nLCBlcnJvcik7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgY29uc3Qge1xuICAgICAgY21jZFxuICAgIH0gPSBjb25maWc7XG4gICAgaWYgKGNtY2QgIT0gbnVsbCkge1xuICAgICAgY29uZmlnLnBMb2FkZXIgPSB0aGlzLmNyZWF0ZVBsYXlsaXN0TG9hZGVyKCk7XG4gICAgICBjb25maWcuZkxvYWRlciA9IHRoaXMuY3JlYXRlRnJhZ21lbnRMb2FkZXIoKTtcbiAgICAgIHRoaXMuc2lkID0gY21jZC5zZXNzaW9uSWQgfHwgdXVpZCgpO1xuICAgICAgdGhpcy5jaWQgPSBjbWNkLmNvbnRlbnRJZDtcbiAgICAgIHRoaXMudXNlSGVhZGVycyA9IGNtY2QudXNlSGVhZGVycyA9PT0gdHJ1ZTtcbiAgICAgIHRoaXMuaW5jbHVkZUtleXMgPSBjbWNkLmluY2x1ZGVLZXlzO1xuICAgICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIH1cbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9ERVRBQ0hFRCwgdGhpcy5vbk1lZGlhRGV0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0NSRUFURUQsIHRoaXMub25CdWZmZXJDcmVhdGVkLCB0aGlzKTtcbiAgfVxuICB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfREVUQUNIRUQsIHRoaXMub25NZWRpYURldGFjaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfQ1JFQVRFRCwgdGhpcy5vbkJ1ZmZlckNyZWF0ZWQsIHRoaXMpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5vbk1lZGlhRGV0YWNoZWQoKTtcblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmhscyA9IHRoaXMuY29uZmlnID0gdGhpcy5hdWRpb0J1ZmZlciA9IHRoaXMudmlkZW9CdWZmZXIgPSBudWxsO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLm9uV2FpdGluZyA9IHRoaXMub25QbGF5aW5nID0gbnVsbDtcbiAgfVxuICBvbk1lZGlhQXR0YWNoZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICB0aGlzLm1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3dhaXRpbmcnLCB0aGlzLm9uV2FpdGluZyk7XG4gICAgdGhpcy5tZWRpYS5hZGRFdmVudExpc3RlbmVyKCdwbGF5aW5nJywgdGhpcy5vblBsYXlpbmcpO1xuICB9XG4gIG9uTWVkaWFEZXRhY2hlZCgpIHtcbiAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5tZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCd3YWl0aW5nJywgdGhpcy5vbldhaXRpbmcpO1xuICAgIHRoaXMubWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGxheWluZycsIHRoaXMub25QbGF5aW5nKTtcblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgfVxuICBvbkJ1ZmZlckNyZWF0ZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgX2RhdGEkdHJhY2tzJGF1ZGlvLCBfZGF0YSR0cmFja3MkdmlkZW87XG4gICAgdGhpcy5hdWRpb0J1ZmZlciA9IChfZGF0YSR0cmFja3MkYXVkaW8gPSBkYXRhLnRyYWNrcy5hdWRpbykgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhJHRyYWNrcyRhdWRpby5idWZmZXI7XG4gICAgdGhpcy52aWRlb0J1ZmZlciA9IChfZGF0YSR0cmFja3MkdmlkZW8gPSBkYXRhLnRyYWNrcy52aWRlbykgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhJHRyYWNrcyR2aWRlby5idWZmZXI7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBiYXNlbGluZSBDTUNEIGRhdGFcbiAgICovXG4gIGNyZWF0ZURhdGEoKSB7XG4gICAgdmFyIF90aGlzJG1lZGlhO1xuICAgIHJldHVybiB7XG4gICAgICB2OiAxLFxuICAgICAgc2Y6IENtU3RyZWFtaW5nRm9ybWF0LkhMUyxcbiAgICAgIHNpZDogdGhpcy5zaWQsXG4gICAgICBjaWQ6IHRoaXMuY2lkLFxuICAgICAgcHI6IChfdGhpcyRtZWRpYSA9IHRoaXMubWVkaWEpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRtZWRpYS5wbGF5YmFja1JhdGUsXG4gICAgICBtdHA6IHRoaXMuaGxzLmJhbmR3aWR0aEVzdGltYXRlIC8gMTAwMFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQXBwbHkgQ01DRCBkYXRhIHRvIGEgcmVxdWVzdC5cbiAgICovXG4gIGFwcGx5KGNvbnRleHQsIGRhdGEgPSB7fSkge1xuICAgIC8vIGFwcGx5IGJhc2VsaW5lIGRhdGFcbiAgICBfZXh0ZW5kcyhkYXRhLCB0aGlzLmNyZWF0ZURhdGEoKSk7XG4gICAgY29uc3QgaXNWaWRlbyA9IGRhdGEub3QgPT09IENtT2JqZWN0VHlwZS5JTklUIHx8IGRhdGEub3QgPT09IENtT2JqZWN0VHlwZS5WSURFTyB8fCBkYXRhLm90ID09PSBDbU9iamVjdFR5cGUuTVVYRUQ7XG4gICAgaWYgKHRoaXMuc3RhcnZlZCAmJiBpc1ZpZGVvKSB7XG4gICAgICBkYXRhLmJzID0gdHJ1ZTtcbiAgICAgIGRhdGEuc3UgPSB0cnVlO1xuICAgICAgdGhpcy5zdGFydmVkID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkYXRhLnN1ID09IG51bGwpIHtcbiAgICAgIGRhdGEuc3UgPSB0aGlzLmJ1ZmZlcmluZztcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBJbXBsZW1lbnQgcnRwLCBucnIsIG5vciwgZGxcblxuICAgIGNvbnN0IHtcbiAgICAgIGluY2x1ZGVLZXlzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGluY2x1ZGVLZXlzKSB7XG4gICAgICBkYXRhID0gT2JqZWN0LmtleXMoZGF0YSkucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgICAgICBpbmNsdWRlS2V5cy5pbmNsdWRlcyhrZXkpICYmIChhY2Nba2V5XSA9IGRhdGFba2V5XSk7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCB7fSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnVzZUhlYWRlcnMpIHtcbiAgICAgIGlmICghY29udGV4dC5oZWFkZXJzKSB7XG4gICAgICAgIGNvbnRleHQuaGVhZGVycyA9IHt9O1xuICAgICAgfVxuICAgICAgYXBwZW5kQ21jZEhlYWRlcnMoY29udGV4dC5oZWFkZXJzLCBkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC51cmwgPSBhcHBlbmRDbWNkUXVlcnkoY29udGV4dC51cmwsIGRhdGEpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVGhlIENNQ0Qgb2JqZWN0IHR5cGUuXG4gICAqL1xuICBnZXRPYmplY3RUeXBlKGZyYWdtZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gPSBmcmFnbWVudDtcbiAgICBpZiAodHlwZSA9PT0gJ3N1YnRpdGxlJykge1xuICAgICAgcmV0dXJuIENtT2JqZWN0VHlwZS5USU1FRF9URVhUO1xuICAgIH1cbiAgICBpZiAoZnJhZ21lbnQuc24gPT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgIHJldHVybiBDbU9iamVjdFR5cGUuSU5JVDtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgIHJldHVybiBDbU9iamVjdFR5cGUuQVVESU87XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnbWFpbicpIHtcbiAgICAgIGlmICghdGhpcy5obHMuYXVkaW9UcmFja3MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBDbU9iamVjdFR5cGUuTVVYRUQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ21PYmplY3RUeXBlLlZJREVPO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaGlnaGVzdCBiaXRyYXRlLlxuICAgKi9cbiAgZ2V0VG9wQmFuZHdpZHRoKHR5cGUpIHtcbiAgICBsZXQgYml0cmF0ZSA9IDA7XG4gICAgbGV0IGxldmVscztcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBpZiAodHlwZSA9PT0gQ21PYmplY3RUeXBlLkFVRElPKSB7XG4gICAgICBsZXZlbHMgPSBobHMuYXVkaW9UcmFja3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1heCA9IGhscy5tYXhBdXRvTGV2ZWw7XG4gICAgICBjb25zdCBsZW4gPSBtYXggPiAtMSA/IG1heCArIDEgOiBobHMubGV2ZWxzLmxlbmd0aDtcbiAgICAgIGxldmVscyA9IGhscy5sZXZlbHMuc2xpY2UoMCwgbGVuKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBsZXZlbCBvZiBsZXZlbHMpIHtcbiAgICAgIGlmIChsZXZlbC5iaXRyYXRlID4gYml0cmF0ZSkge1xuICAgICAgICBiaXRyYXRlID0gbGV2ZWwuYml0cmF0ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJpdHJhdGUgPiAwID8gYml0cmF0ZSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGJ1ZmZlciBsZW5ndGggZm9yIGEgbWVkaWEgdHlwZSBpbiBtaWxsaXNlY29uZHNcbiAgICovXG4gIGdldEJ1ZmZlckxlbmd0aCh0eXBlKSB7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLmhscy5tZWRpYTtcbiAgICBjb25zdCBidWZmZXIgPSB0eXBlID09PSBDbU9iamVjdFR5cGUuQVVESU8gPyB0aGlzLmF1ZGlvQnVmZmVyIDogdGhpcy52aWRlb0J1ZmZlcjtcbiAgICBpZiAoIWJ1ZmZlciB8fCAhbWVkaWEpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIGNvbnN0IGluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhidWZmZXIsIG1lZGlhLmN1cnJlbnRUaW1lLCB0aGlzLmNvbmZpZy5tYXhCdWZmZXJIb2xlKTtcbiAgICByZXR1cm4gaW5mby5sZW4gKiAxMDAwO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHBsYXlsaXN0IGxvYWRlclxuICAgKi9cbiAgY3JlYXRlUGxheWxpc3RMb2FkZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgcExvYWRlclxuICAgIH0gPSB0aGlzLmNvbmZpZztcbiAgICBjb25zdCBhcHBseSA9IHRoaXMuYXBwbHlQbGF5bGlzdERhdGE7XG4gICAgY29uc3QgQ3RvciA9IHBMb2FkZXIgfHwgdGhpcy5jb25maWcubG9hZGVyO1xuICAgIHJldHVybiBjbGFzcyBDbWNkUGxheWxpc3RMb2FkZXIge1xuICAgICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHRoaXMubG9hZGVyID0gdm9pZCAwO1xuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBDdG9yKGNvbmZpZyk7XG4gICAgICB9XG4gICAgICBnZXQgc3RhdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRlci5zdGF0cztcbiAgICAgIH1cbiAgICAgIGdldCBjb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkZXIuY29udGV4dDtcbiAgICAgIH1cbiAgICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMubG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIGFib3J0KCkge1xuICAgICAgICB0aGlzLmxvYWRlci5hYm9ydCgpO1xuICAgICAgfVxuICAgICAgbG9hZChjb250ZXh0LCBjb25maWcsIGNhbGxiYWNrcykge1xuICAgICAgICBhcHBseShjb250ZXh0KTtcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZChjb250ZXh0LCBjb25maWcsIGNhbGxiYWNrcyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBwbGF5bGlzdCBsb2FkZXJcbiAgICovXG4gIGNyZWF0ZUZyYWdtZW50TG9hZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZMb2FkZXJcbiAgICB9ID0gdGhpcy5jb25maWc7XG4gICAgY29uc3QgYXBwbHkgPSB0aGlzLmFwcGx5RnJhZ21lbnREYXRhO1xuICAgIGNvbnN0IEN0b3IgPSBmTG9hZGVyIHx8IHRoaXMuY29uZmlnLmxvYWRlcjtcbiAgICByZXR1cm4gY2xhc3MgQ21jZEZyYWdtZW50TG9hZGVyIHtcbiAgICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICB0aGlzLmxvYWRlciA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgQ3Rvcihjb25maWcpO1xuICAgICAgfVxuICAgICAgZ2V0IHN0YXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkZXIuc3RhdHM7XG4gICAgICB9XG4gICAgICBnZXQgY29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZGVyLmNvbnRleHQ7XG4gICAgICB9XG4gICAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmxvYWRlci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgICBhYm9ydCgpIHtcbiAgICAgICAgdGhpcy5sb2FkZXIuYWJvcnQoKTtcbiAgICAgIH1cbiAgICAgIGxvYWQoY29udGV4dCwgY29uZmlnLCBjYWxsYmFja3MpIHtcbiAgICAgICAgYXBwbHkoY29udGV4dCk7XG4gICAgICAgIHRoaXMubG9hZGVyLmxvYWQoY29udGV4dCwgY29uZmlnLCBjYWxsYmFja3MpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxuY29uc3QgUEFUSFdBWV9QRU5BTFRZX0RVUkFUSU9OX01TID0gMzAwMDAwO1xuY2xhc3MgQ29udGVudFN0ZWVyaW5nQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMubG9nID0gdm9pZCAwO1xuICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgICB0aGlzLnVyaSA9IG51bGw7XG4gICAgdGhpcy5wYXRod2F5SWQgPSAnLic7XG4gICAgdGhpcy5wYXRod2F5UHJpb3JpdHkgPSBudWxsO1xuICAgIHRoaXMudGltZVRvTG9hZCA9IDMwMDtcbiAgICB0aGlzLnJlbG9hZFRpbWVyID0gLTE7XG4gICAgdGhpcy51cGRhdGVkID0gMDtcbiAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMubGV2ZWxzID0gbnVsbDtcbiAgICB0aGlzLmF1ZGlvVHJhY2tzID0gbnVsbDtcbiAgICB0aGlzLnN1YnRpdGxlVHJhY2tzID0gbnVsbDtcbiAgICB0aGlzLnBlbmFsaXplZFBhdGh3YXlzID0ge307XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5sb2cgPSBsb2dnZXIubG9nLmJpbmQobG9nZ2VyLCBgW2NvbnRlbnQtc3RlZXJpbmddOmApO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH1cbiAgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBpZiAoIWhscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FERUQsIHRoaXMub25NYW5pZmVzdExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9XG4gIHN0YXJ0TG9hZCgpIHtcbiAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG4gICAgaWYgKHRoaXMuZW5hYmxlZCAmJiB0aGlzLnVyaSkge1xuICAgICAgaWYgKHRoaXMudXBkYXRlZCkge1xuICAgICAgICBjb25zdCB0dGwgPSB0aGlzLnRpbWVUb0xvYWQgKiAxMDAwIC0gKHBlcmZvcm1hbmNlLm5vdygpIC0gdGhpcy51cGRhdGVkKTtcbiAgICAgICAgaWYgKHR0bCA+IDApIHtcbiAgICAgICAgICB0aGlzLnNjaGVkdWxlUmVmcmVzaCh0aGlzLnVyaSwgdHRsKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubG9hZFN0ZWVyaW5nTWFuaWZlc3QodGhpcy51cmkpO1xuICAgIH1cbiAgfVxuICBzdG9wTG9hZCgpIHtcbiAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5sb2FkZXIpIHtcbiAgICAgIHRoaXMubG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgfVxuICBjbGVhclRpbWVvdXQoKSB7XG4gICAgaWYgKHRoaXMucmVsb2FkVGltZXIgIT09IC0xKSB7XG4gICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlbG9hZFRpbWVyKTtcbiAgICAgIHRoaXMucmVsb2FkVGltZXIgPSAtMTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuaGxzID0gbnVsbDtcbiAgICB0aGlzLmxldmVscyA9IHRoaXMuYXVkaW9UcmFja3MgPSB0aGlzLnN1YnRpdGxlVHJhY2tzID0gbnVsbDtcbiAgfVxuICByZW1vdmVMZXZlbChsZXZlbFRvUmVtb3ZlKSB7XG4gICAgY29uc3QgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG4gICAgaWYgKGxldmVscykge1xuICAgICAgdGhpcy5sZXZlbHMgPSBsZXZlbHMuZmlsdGVyKGxldmVsID0+IGxldmVsICE9PSBsZXZlbFRvUmVtb3ZlKTtcbiAgICB9XG4gIH1cbiAgb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy50aW1lVG9Mb2FkID0gMzAwO1xuICAgIHRoaXMudXBkYXRlZCA9IDA7XG4gICAgdGhpcy51cmkgPSBudWxsO1xuICAgIHRoaXMucGF0aHdheUlkID0gJy4nO1xuICAgIHRoaXMubGV2ZWxzID0gdGhpcy5hdWRpb1RyYWNrcyA9IHRoaXMuc3VidGl0bGVUcmFja3MgPSBudWxsO1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250ZW50U3RlZXJpbmdcbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoY29udGVudFN0ZWVyaW5nID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGF0aHdheUlkID0gY29udGVudFN0ZWVyaW5nLnBhdGh3YXlJZDtcbiAgICB0aGlzLnVyaSA9IGNvbnRlbnRTdGVlcmluZy51cmk7XG4gICAgaWYgKHRoaXMuc3RhcnRlZCkge1xuICAgICAgdGhpcy5zdGFydExvYWQoKTtcbiAgICB9XG4gIH1cbiAgb25NYW5pZmVzdFBhcnNlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMuYXVkaW9UcmFja3MgPSBkYXRhLmF1ZGlvVHJhY2tzO1xuICAgIHRoaXMuc3VidGl0bGVUcmFja3MgPSBkYXRhLnN1YnRpdGxlVHJhY2tzO1xuICB9XG4gIG9uRXJyb3IoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBlcnJvckFjdGlvblxuICAgIH0gPSBkYXRhO1xuICAgIGlmICgoZXJyb3JBY3Rpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yQWN0aW9uLmFjdGlvbikgPT09IE5ldHdvcmtFcnJvckFjdGlvbi5TZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94ICYmIGVycm9yQWN0aW9uLmZsYWdzID09PSBFcnJvckFjdGlvbkZsYWdzLk1vdmVBbGxBbHRlcm5hdGVzTWF0Y2hpbmdIb3N0KSB7XG4gICAgICBjb25zdCBsZXZlbHMgPSB0aGlzLmxldmVscztcbiAgICAgIGxldCBwYXRod2F5UHJpb3JpdHkgPSB0aGlzLnBhdGh3YXlQcmlvcml0eTtcbiAgICAgIGxldCBlcnJvclBhdGh3YXkgPSB0aGlzLnBhdGh3YXlJZDtcbiAgICAgIGlmIChkYXRhLmNvbnRleHQpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGdyb3VwSWQsXG4gICAgICAgICAgcGF0aHdheUlkLFxuICAgICAgICAgIHR5cGVcbiAgICAgICAgfSA9IGRhdGEuY29udGV4dDtcbiAgICAgICAgaWYgKGdyb3VwSWQgJiYgbGV2ZWxzKSB7XG4gICAgICAgICAgZXJyb3JQYXRod2F5ID0gdGhpcy5nZXRQYXRod2F5Rm9yR3JvdXBJZChncm91cElkLCB0eXBlLCBlcnJvclBhdGh3YXkpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhdGh3YXlJZCkge1xuICAgICAgICAgIGVycm9yUGF0aHdheSA9IHBhdGh3YXlJZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCEoZXJyb3JQYXRod2F5IGluIHRoaXMucGVuYWxpemVkUGF0aHdheXMpKSB7XG4gICAgICAgIHRoaXMucGVuYWxpemVkUGF0aHdheXNbZXJyb3JQYXRod2F5XSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgfVxuICAgICAgaWYgKCFwYXRod2F5UHJpb3JpdHkgJiYgbGV2ZWxzKSB7XG4gICAgICAgIC8vIElmIFBBVEhXQVktUFJJT1JJVFkgd2FzIG5vdCBwcm92aWRlZCwgbGlzdCBwYXRod2F5cyBmb3IgZXJyb3IgaGFuZGxpbmdcbiAgICAgICAgcGF0aHdheVByaW9yaXR5ID0gbGV2ZWxzLnJlZHVjZSgocGF0aHdheXMsIGxldmVsKSA9PiB7XG4gICAgICAgICAgaWYgKHBhdGh3YXlzLmluZGV4T2YobGV2ZWwucGF0aHdheUlkKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHBhdGh3YXlzLnB1c2gobGV2ZWwucGF0aHdheUlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHBhdGh3YXlzO1xuICAgICAgICB9LCBbXSk7XG4gICAgICB9XG4gICAgICBpZiAocGF0aHdheVByaW9yaXR5ICYmIHBhdGh3YXlQcmlvcml0eS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRoaXMudXBkYXRlUGF0aHdheVByaW9yaXR5KHBhdGh3YXlQcmlvcml0eSk7XG4gICAgICAgIGVycm9yQWN0aW9uLnJlc29sdmVkID0gdGhpcy5wYXRod2F5SWQgIT09IGVycm9yUGF0aHdheTtcbiAgICAgIH1cbiAgICAgIGlmICghZXJyb3JBY3Rpb24ucmVzb2x2ZWQpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oYENvdWxkIG5vdCByZXNvbHZlICR7ZGF0YS5kZXRhaWxzfSAoXCIke2RhdGEuZXJyb3IubWVzc2FnZX1cIikgd2l0aCBjb250ZW50LXN0ZWVyaW5nIGZvciBQYXRod2F5OiAke2Vycm9yUGF0aHdheX0gbGV2ZWxzOiAke2xldmVscyA/IGxldmVscy5sZW5ndGggOiBsZXZlbHN9IHByaW9yaXRpZXM6ICR7SlNPTi5zdHJpbmdpZnkocGF0aHdheVByaW9yaXR5KX0gcGVuYWxpemVkOiAke0pTT04uc3RyaW5naWZ5KHRoaXMucGVuYWxpemVkUGF0aHdheXMpfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmaWx0ZXJQYXJzZWRMZXZlbHMobGV2ZWxzKSB7XG4gICAgLy8gRmlsdGVyIGxldmVscyB0byBvbmx5IGluY2x1ZGUgdGhvc2UgdGhhdCBhcmUgaW4gdGhlIGluaXRpYWwgcGF0aHdheVxuICAgIHRoaXMubGV2ZWxzID0gbGV2ZWxzO1xuICAgIGxldCBwYXRod2F5TGV2ZWxzID0gdGhpcy5nZXRMZXZlbHNGb3JQYXRod2F5KHRoaXMucGF0aHdheUlkKTtcbiAgICBpZiAocGF0aHdheUxldmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnN0IHBhdGh3YXlJZCA9IGxldmVsc1swXS5wYXRod2F5SWQ7XG4gICAgICB0aGlzLmxvZyhgTm8gbGV2ZWxzIGZvdW5kIGluIFBhdGh3YXkgJHt0aGlzLnBhdGh3YXlJZH0uIFNldHRpbmcgaW5pdGlhbCBQYXRod2F5IHRvIFwiJHtwYXRod2F5SWR9XCJgKTtcbiAgICAgIHBhdGh3YXlMZXZlbHMgPSB0aGlzLmdldExldmVsc0ZvclBhdGh3YXkocGF0aHdheUlkKTtcbiAgICAgIHRoaXMucGF0aHdheUlkID0gcGF0aHdheUlkO1xuICAgIH1cbiAgICBpZiAocGF0aHdheUxldmVscy5sZW5ndGggIT09IGxldmVscy5sZW5ndGgpIHtcbiAgICAgIHRoaXMubG9nKGBGb3VuZCAke3BhdGh3YXlMZXZlbHMubGVuZ3RofS8ke2xldmVscy5sZW5ndGh9IGxldmVscyBpbiBQYXRod2F5IFwiJHt0aGlzLnBhdGh3YXlJZH1cImApO1xuICAgICAgcmV0dXJuIHBhdGh3YXlMZXZlbHM7XG4gICAgfVxuICAgIHJldHVybiBsZXZlbHM7XG4gIH1cbiAgZ2V0TGV2ZWxzRm9yUGF0aHdheShwYXRod2F5SWQpIHtcbiAgICBpZiAodGhpcy5sZXZlbHMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxzLmZpbHRlcihsZXZlbCA9PiBwYXRod2F5SWQgPT09IGxldmVsLnBhdGh3YXlJZCk7XG4gIH1cbiAgdXBkYXRlUGF0aHdheVByaW9yaXR5KHBhdGh3YXlQcmlvcml0eSkge1xuICAgIHRoaXMucGF0aHdheVByaW9yaXR5ID0gcGF0aHdheVByaW9yaXR5O1xuICAgIGxldCBsZXZlbHM7XG5cbiAgICAvLyBFdmFsdWF0ZSBpZiB3ZSBzaG91bGQgcmVtb3ZlIHRoZSBwYXRod2F5IGZyb20gdGhlIHBlbmFsaXplZCBsaXN0XG4gICAgY29uc3QgcGVuYWxpemVkUGF0aHdheXMgPSB0aGlzLnBlbmFsaXplZFBhdGh3YXlzO1xuICAgIGNvbnN0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIE9iamVjdC5rZXlzKHBlbmFsaXplZFBhdGh3YXlzKS5mb3JFYWNoKHBhdGh3YXlJZCA9PiB7XG4gICAgICBpZiAobm93IC0gcGVuYWxpemVkUGF0aHdheXNbcGF0aHdheUlkXSA+IFBBVEhXQVlfUEVOQUxUWV9EVVJBVElPTl9NUykge1xuICAgICAgICBkZWxldGUgcGVuYWxpemVkUGF0aHdheXNbcGF0aHdheUlkXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGh3YXlQcmlvcml0eS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcGF0aHdheUlkID0gcGF0aHdheVByaW9yaXR5W2ldO1xuICAgICAgaWYgKHBhdGh3YXlJZCBpbiBwZW5hbGl6ZWRQYXRod2F5cykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXRod2F5SWQgPT09IHRoaXMucGF0aHdheUlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlbGVjdGVkSW5kZXggPSB0aGlzLmhscy5uZXh0TG9hZExldmVsO1xuICAgICAgY29uc3Qgc2VsZWN0ZWRMZXZlbCA9IHRoaXMuaGxzLmxldmVsc1tzZWxlY3RlZEluZGV4XTtcbiAgICAgIGxldmVscyA9IHRoaXMuZ2V0TGV2ZWxzRm9yUGF0aHdheShwYXRod2F5SWQpO1xuICAgICAgaWYgKGxldmVscy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMubG9nKGBTZXR0aW5nIFBhdGh3YXkgdG8gXCIke3BhdGh3YXlJZH1cImApO1xuICAgICAgICB0aGlzLnBhdGh3YXlJZCA9IHBhdGh3YXlJZDtcbiAgICAgICAgcmVhc3NpZ25GcmFnbWVudExldmVsSW5kZXhlcyhsZXZlbHMpO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5MRVZFTFNfVVBEQVRFRCwge1xuICAgICAgICAgIGxldmVsc1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gU2V0IExldmVsQ29udHJvbGxlcidzIGxldmVsIHRvIHRyaWdnZXIgTEVWRUxfU1dJVENISU5HIHdoaWNoIGxvYWRzIHBsYXlsaXN0IGlmIG5lZWRlZFxuICAgICAgICBjb25zdCBsZXZlbEFmdGVyQ2hhbmdlID0gdGhpcy5obHMubGV2ZWxzW3NlbGVjdGVkSW5kZXhdO1xuICAgICAgICBpZiAoc2VsZWN0ZWRMZXZlbCAmJiBsZXZlbEFmdGVyQ2hhbmdlICYmIHRoaXMubGV2ZWxzKSB7XG4gICAgICAgICAgaWYgKGxldmVsQWZ0ZXJDaGFuZ2UuYXR0cnNbJ1NUQUJMRS1WQVJJQU5ULUlEJ10gIT09IHNlbGVjdGVkTGV2ZWwuYXR0cnNbJ1NUQUJMRS1WQVJJQU5ULUlEJ10gJiYgbGV2ZWxBZnRlckNoYW5nZS5iaXRyYXRlICE9PSBzZWxlY3RlZExldmVsLmJpdHJhdGUpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKGBVbnN0YWJsZSBQYXRod2F5cyBjaGFuZ2UgZnJvbSBiaXRyYXRlICR7c2VsZWN0ZWRMZXZlbC5iaXRyYXRlfSB0byAke2xldmVsQWZ0ZXJDaGFuZ2UuYml0cmF0ZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5obHMubmV4dExvYWRMZXZlbCA9IHNlbGVjdGVkSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldFBhdGh3YXlGb3JHcm91cElkKGdyb3VwSWQsIHR5cGUsIGRlZmF1bHRQYXRod2F5KSB7XG4gICAgY29uc3QgbGV2ZWxzID0gdGhpcy5nZXRMZXZlbHNGb3JQYXRod2F5KGRlZmF1bHRQYXRod2F5KS5jb25jYXQodGhpcy5sZXZlbHMgfHwgW10pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSyAmJiBsZXZlbHNbaV0uaGFzQXVkaW9Hcm91cChncm91cElkKSB8fCB0eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLICYmIGxldmVsc1tpXS5oYXNTdWJ0aXRsZUdyb3VwKGdyb3VwSWQpKSB7XG4gICAgICAgIHJldHVybiBsZXZlbHNbaV0ucGF0aHdheUlkO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFBhdGh3YXk7XG4gIH1cbiAgY2xvbmVQYXRod2F5cyhwYXRod2F5Q2xvbmVzKSB7XG4gICAgY29uc3QgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG4gICAgaWYgKCFsZXZlbHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYXVkaW9Hcm91cENsb25lTWFwID0ge307XG4gICAgY29uc3Qgc3VidGl0bGVHcm91cENsb25lTWFwID0ge307XG4gICAgcGF0aHdheUNsb25lcy5mb3JFYWNoKHBhdGh3YXlDbG9uZSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIElEOiBjbG9uZUlkLFxuICAgICAgICAnQkFTRS1JRCc6IGJhc2VJZCxcbiAgICAgICAgJ1VSSS1SRVBMQUNFTUVOVCc6IHVyaVJlcGxhY2VtZW50XG4gICAgICB9ID0gcGF0aHdheUNsb25lO1xuICAgICAgaWYgKGxldmVscy5zb21lKGxldmVsID0+IGxldmVsLnBhdGh3YXlJZCA9PT0gY2xvbmVJZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY2xvbmVkVmFyaWFudHMgPSB0aGlzLmdldExldmVsc0ZvclBhdGh3YXkoYmFzZUlkKS5tYXAoYmFzZUxldmVsID0+IHtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IG5ldyBBdHRyTGlzdChiYXNlTGV2ZWwuYXR0cnMpO1xuICAgICAgICBhdHRyaWJ1dGVzWydQQVRIV0FZLUlEJ10gPSBjbG9uZUlkO1xuICAgICAgICBjb25zdCBjbG9uZWRBdWRpb0dyb3VwSWQgPSBhdHRyaWJ1dGVzLkFVRElPICYmIGAke2F0dHJpYnV0ZXMuQVVESU99X2Nsb25lXyR7Y2xvbmVJZH1gO1xuICAgICAgICBjb25zdCBjbG9uZWRTdWJ0aXRsZUdyb3VwSWQgPSBhdHRyaWJ1dGVzLlNVQlRJVExFUyAmJiBgJHthdHRyaWJ1dGVzLlNVQlRJVExFU31fY2xvbmVfJHtjbG9uZUlkfWA7XG4gICAgICAgIGlmIChjbG9uZWRBdWRpb0dyb3VwSWQpIHtcbiAgICAgICAgICBhdWRpb0dyb3VwQ2xvbmVNYXBbYXR0cmlidXRlcy5BVURJT10gPSBjbG9uZWRBdWRpb0dyb3VwSWQ7XG4gICAgICAgICAgYXR0cmlidXRlcy5BVURJTyA9IGNsb25lZEF1ZGlvR3JvdXBJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xvbmVkU3VidGl0bGVHcm91cElkKSB7XG4gICAgICAgICAgc3VidGl0bGVHcm91cENsb25lTWFwW2F0dHJpYnV0ZXMuU1VCVElUTEVTXSA9IGNsb25lZFN1YnRpdGxlR3JvdXBJZDtcbiAgICAgICAgICBhdHRyaWJ1dGVzLlNVQlRJVExFUyA9IGNsb25lZFN1YnRpdGxlR3JvdXBJZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmwgPSBwZXJmb3JtVXJpUmVwbGFjZW1lbnQoYmFzZUxldmVsLnVyaSwgYXR0cmlidXRlc1snU1RBQkxFLVZBUklBTlQtSUQnXSwgJ1BFUi1WQVJJQU5ULVVSSVMnLCB1cmlSZXBsYWNlbWVudCk7XG4gICAgICAgIGNvbnN0IGNsb25lZExldmVsID0gbmV3IExldmVsKHtcbiAgICAgICAgICBhdHRyczogYXR0cmlidXRlcyxcbiAgICAgICAgICBhdWRpb0NvZGVjOiBiYXNlTGV2ZWwuYXVkaW9Db2RlYyxcbiAgICAgICAgICBiaXRyYXRlOiBiYXNlTGV2ZWwuYml0cmF0ZSxcbiAgICAgICAgICBoZWlnaHQ6IGJhc2VMZXZlbC5oZWlnaHQsXG4gICAgICAgICAgbmFtZTogYmFzZUxldmVsLm5hbWUsXG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIHZpZGVvQ29kZWM6IGJhc2VMZXZlbC52aWRlb0NvZGVjLFxuICAgICAgICAgIHdpZHRoOiBiYXNlTGV2ZWwud2lkdGhcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChiYXNlTGV2ZWwuYXVkaW9Hcm91cHMpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGJhc2VMZXZlbC5hdWRpb0dyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2xvbmVkTGV2ZWwuYWRkR3JvdXBJZCgnYXVkaW8nLCBgJHtiYXNlTGV2ZWwuYXVkaW9Hcm91cHNbaV19X2Nsb25lXyR7Y2xvbmVJZH1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhc2VMZXZlbC5zdWJ0aXRsZUdyb3Vwcykge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYmFzZUxldmVsLnN1YnRpdGxlR3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjbG9uZWRMZXZlbC5hZGRHcm91cElkKCd0ZXh0JywgYCR7YmFzZUxldmVsLnN1YnRpdGxlR3JvdXBzW2ldfV9jbG9uZV8ke2Nsb25lSWR9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbG9uZWRMZXZlbDtcbiAgICAgIH0pO1xuICAgICAgbGV2ZWxzLnB1c2goLi4uY2xvbmVkVmFyaWFudHMpO1xuICAgICAgY2xvbmVSZW5kaXRpb25Hcm91cHModGhpcy5hdWRpb1RyYWNrcywgYXVkaW9Hcm91cENsb25lTWFwLCB1cmlSZXBsYWNlbWVudCwgY2xvbmVJZCk7XG4gICAgICBjbG9uZVJlbmRpdGlvbkdyb3Vwcyh0aGlzLnN1YnRpdGxlVHJhY2tzLCBzdWJ0aXRsZUdyb3VwQ2xvbmVNYXAsIHVyaVJlcGxhY2VtZW50LCBjbG9uZUlkKTtcbiAgICB9KTtcbiAgfVxuICBsb2FkU3RlZXJpbmdNYW5pZmVzdCh1cmkpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG4gICAgY29uc3QgTG9hZGVyID0gY29uZmlnLmxvYWRlcjtcbiAgICBpZiAodGhpcy5sb2FkZXIpIHtcbiAgICAgIHRoaXMubG9hZGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5sb2FkZXIgPSBuZXcgTG9hZGVyKGNvbmZpZyk7XG4gICAgbGV0IHVybDtcbiAgICB0cnkge1xuICAgICAgdXJsID0gbmV3IHNlbGYuVVJMKHVyaSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5sb2coYEZhaWxlZCB0byBwYXJzZSBTdGVlcmluZyBNYW5pZmVzdCBVUkk6ICR7dXJpfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodXJsLnByb3RvY29sICE9PSAnZGF0YTonKSB7XG4gICAgICBjb25zdCB0aHJvdWdocHV0ID0gKHRoaXMuaGxzLmJhbmR3aWR0aEVzdGltYXRlIHx8IGNvbmZpZy5hYnJFd21hRGVmYXVsdEVzdGltYXRlKSB8IDA7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnX0hMU19wYXRod2F5JywgdGhpcy5wYXRod2F5SWQpO1xuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ19ITFNfdGhyb3VnaHB1dCcsICcnICsgdGhyb3VnaHB1dCk7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcbiAgICAgIHVybDogdXJsLmhyZWZcbiAgICB9O1xuICAgIGNvbnN0IGxvYWRQb2xpY3kgPSBjb25maWcuc3RlZXJpbmdNYW5pZmVzdExvYWRQb2xpY3kuZGVmYXVsdDtcbiAgICBjb25zdCBsZWdhY3lSZXRyeUNvbXBhdGliaWxpdHkgPSBsb2FkUG9saWN5LmVycm9yUmV0cnkgfHwgbG9hZFBvbGljeS50aW1lb3V0UmV0cnkgfHwge307XG4gICAgY29uc3QgbG9hZGVyQ29uZmlnID0ge1xuICAgICAgbG9hZFBvbGljeSxcbiAgICAgIHRpbWVvdXQ6IGxvYWRQb2xpY3kubWF4TG9hZFRpbWVNcyxcbiAgICAgIG1heFJldHJ5OiBsZWdhY3lSZXRyeUNvbXBhdGliaWxpdHkubWF4TnVtUmV0cnkgfHwgMCxcbiAgICAgIHJldHJ5RGVsYXk6IGxlZ2FjeVJldHJ5Q29tcGF0aWJpbGl0eS5yZXRyeURlbGF5TXMgfHwgMCxcbiAgICAgIG1heFJldHJ5RGVsYXk6IGxlZ2FjeVJldHJ5Q29tcGF0aWJpbGl0eS5tYXhSZXRyeURlbGF5TXMgfHwgMFxuICAgIH07XG4gICAgY29uc3QgY2FsbGJhY2tzID0ge1xuICAgICAgb25TdWNjZXNzOiAocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICB0aGlzLmxvZyhgTG9hZGVkIHN0ZWVyaW5nIG1hbmlmZXN0OiBcIiR7dXJsfVwiYCk7XG4gICAgICAgIGNvbnN0IHN0ZWVyaW5nRGF0YSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgIGlmIChzdGVlcmluZ0RhdGEuVkVSU0lPTiAhPT0gMSkge1xuICAgICAgICAgIHRoaXMubG9nKGBTdGVlcmluZyBWRVJTSU9OICR7c3RlZXJpbmdEYXRhLlZFUlNJT059IG5vdCBzdXBwb3J0ZWQhYCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB0aGlzLnRpbWVUb0xvYWQgPSBzdGVlcmluZ0RhdGEuVFRMO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgJ1JFTE9BRC1VUkknOiByZWxvYWRVcmksXG4gICAgICAgICAgJ1BBVEhXQVktQ0xPTkVTJzogcGF0aHdheUNsb25lcyxcbiAgICAgICAgICAnUEFUSFdBWS1QUklPUklUWSc6IHBhdGh3YXlQcmlvcml0eVxuICAgICAgICB9ID0gc3RlZXJpbmdEYXRhO1xuICAgICAgICBpZiAocmVsb2FkVXJpKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMudXJpID0gbmV3IHNlbGYuVVJMKHJlbG9hZFVyaSwgdXJsKS5ocmVmO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubG9nKGBGYWlsZWQgdG8gcGFyc2UgU3RlZXJpbmcgTWFuaWZlc3QgUkVMT0FELVVSSTogJHtyZWxvYWRVcml9YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2NoZWR1bGVSZWZyZXNoKHRoaXMudXJpIHx8IGNvbnRleHQudXJsKTtcbiAgICAgICAgaWYgKHBhdGh3YXlDbG9uZXMpIHtcbiAgICAgICAgICB0aGlzLmNsb25lUGF0aHdheXMocGF0aHdheUNsb25lcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG9hZGVkU3RlZXJpbmdEYXRhID0ge1xuICAgICAgICAgIHN0ZWVyaW5nTWFuaWZlc3Q6IHN0ZWVyaW5nRGF0YSxcbiAgICAgICAgICB1cmw6IHVybC50b1N0cmluZygpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLlNURUVSSU5HX01BTklGRVNUX0xPQURFRCwgbG9hZGVkU3RlZXJpbmdEYXRhKTtcbiAgICAgICAgaWYgKHBhdGh3YXlQcmlvcml0eSkge1xuICAgICAgICAgIHRoaXMudXBkYXRlUGF0aHdheVByaW9yaXR5KHBhdGh3YXlQcmlvcml0eSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkVycm9yOiAoZXJyb3IsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCBzdGF0cykgPT4ge1xuICAgICAgICB0aGlzLmxvZyhgRXJyb3IgbG9hZGluZyBzdGVlcmluZyBtYW5pZmVzdDogJHtlcnJvci5jb2RlfSAke2Vycm9yLnRleHR9ICgke2NvbnRleHQudXJsfSlgKTtcbiAgICAgICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gNDEwKSB7XG4gICAgICAgICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5sb2coYFN0ZWVyaW5nIG1hbmlmZXN0ICR7Y29udGV4dC51cmx9IG5vIGxvbmdlciBhdmFpbGFibGVgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHR0bCA9IHRoaXMudGltZVRvTG9hZCAqIDEwMDA7XG4gICAgICAgIGlmIChlcnJvci5jb2RlID09PSA0MjkpIHtcbiAgICAgICAgICBjb25zdCBsb2FkZXIgPSB0aGlzLmxvYWRlcjtcbiAgICAgICAgICBpZiAodHlwZW9mIChsb2FkZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGxvYWRlci5nZXRSZXNwb25zZUhlYWRlcikgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldHJ5QWZ0ZXIgPSBsb2FkZXIuZ2V0UmVzcG9uc2VIZWFkZXIoJ1JldHJ5LUFmdGVyJyk7XG4gICAgICAgICAgICBpZiAocmV0cnlBZnRlcikge1xuICAgICAgICAgICAgICB0dGwgPSBwYXJzZUZsb2F0KHJldHJ5QWZ0ZXIpICogMTAwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5sb2coYFN0ZWVyaW5nIG1hbmlmZXN0ICR7Y29udGV4dC51cmx9IHJhdGUgbGltaXRlZGApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjaGVkdWxlUmVmcmVzaCh0aGlzLnVyaSB8fCBjb250ZXh0LnVybCwgdHRsKTtcbiAgICAgIH0sXG4gICAgICBvblRpbWVvdXQ6IChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpID0+IHtcbiAgICAgICAgdGhpcy5sb2coYFRpbWVvdXQgbG9hZGluZyBzdGVlcmluZyBtYW5pZmVzdCAoJHtjb250ZXh0LnVybH0pYCk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVSZWZyZXNoKHRoaXMudXJpIHx8IGNvbnRleHQudXJsKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMubG9nKGBSZXF1ZXN0aW5nIHN0ZWVyaW5nIG1hbmlmZXN0OiAke3VybH1gKTtcbiAgICB0aGlzLmxvYWRlci5sb2FkKGNvbnRleHQsIGxvYWRlckNvbmZpZywgY2FsbGJhY2tzKTtcbiAgfVxuICBzY2hlZHVsZVJlZnJlc2godXJpLCB0dGxNcyA9IHRoaXMudGltZVRvTG9hZCAqIDEwMDApIHtcbiAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICAgIHRoaXMucmVsb2FkVGltZXIgPSBzZWxmLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdmFyIF90aGlzJGhscztcbiAgICAgIGNvbnN0IG1lZGlhID0gKF90aGlzJGhscyA9IHRoaXMuaGxzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkaGxzLm1lZGlhO1xuICAgICAgaWYgKG1lZGlhICYmICFtZWRpYS5lbmRlZCkge1xuICAgICAgICB0aGlzLmxvYWRTdGVlcmluZ01hbmlmZXN0KHVyaSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2NoZWR1bGVSZWZyZXNoKHVyaSwgdGhpcy50aW1lVG9Mb2FkICogMTAwMCk7XG4gICAgfSwgdHRsTXMpO1xuICB9XG59XG5mdW5jdGlvbiBjbG9uZVJlbmRpdGlvbkdyb3Vwcyh0cmFja3MsIGdyb3VwQ2xvbmVNYXAsIHVyaVJlcGxhY2VtZW50LCBjbG9uZUlkKSB7XG4gIGlmICghdHJhY2tzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIE9iamVjdC5rZXlzKGdyb3VwQ2xvbmVNYXApLmZvckVhY2goYXVkaW9Hcm91cElkID0+IHtcbiAgICBjb25zdCBjbG9uZWRUcmFja3MgPSB0cmFja3MuZmlsdGVyKHRyYWNrID0+IHRyYWNrLmdyb3VwSWQgPT09IGF1ZGlvR3JvdXBJZCkubWFwKHRyYWNrID0+IHtcbiAgICAgIGNvbnN0IGNsb25lZFRyYWNrID0gX2V4dGVuZHMoe30sIHRyYWNrKTtcbiAgICAgIGNsb25lZFRyYWNrLmRldGFpbHMgPSB1bmRlZmluZWQ7XG4gICAgICBjbG9uZWRUcmFjay5hdHRycyA9IG5ldyBBdHRyTGlzdChjbG9uZWRUcmFjay5hdHRycyk7XG4gICAgICBjbG9uZWRUcmFjay51cmwgPSBjbG9uZWRUcmFjay5hdHRycy5VUkkgPSBwZXJmb3JtVXJpUmVwbGFjZW1lbnQodHJhY2sudXJsLCB0cmFjay5hdHRyc1snU1RBQkxFLVJFTkRJVElPTi1JRCddLCAnUEVSLVJFTkRJVElPTi1VUklTJywgdXJpUmVwbGFjZW1lbnQpO1xuICAgICAgY2xvbmVkVHJhY2suZ3JvdXBJZCA9IGNsb25lZFRyYWNrLmF0dHJzWydHUk9VUC1JRCddID0gZ3JvdXBDbG9uZU1hcFthdWRpb0dyb3VwSWRdO1xuICAgICAgY2xvbmVkVHJhY2suYXR0cnNbJ1BBVEhXQVktSUQnXSA9IGNsb25lSWQ7XG4gICAgICByZXR1cm4gY2xvbmVkVHJhY2s7XG4gICAgfSk7XG4gICAgdHJhY2tzLnB1c2goLi4uY2xvbmVkVHJhY2tzKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBwZXJmb3JtVXJpUmVwbGFjZW1lbnQodXJpLCBzdGFibGVJZCwgcGVyT3B0aW9uS2V5LCB1cmlSZXBsYWNlbWVudCkge1xuICBjb25zdCB7XG4gICAgSE9TVDogaG9zdCxcbiAgICBQQVJBTVM6IHBhcmFtcyxcbiAgICBbcGVyT3B0aW9uS2V5XTogcGVyT3B0aW9uVXJpc1xuICB9ID0gdXJpUmVwbGFjZW1lbnQ7XG4gIGxldCBwZXJWYXJpYW50VXJpO1xuICBpZiAoc3RhYmxlSWQpIHtcbiAgICBwZXJWYXJpYW50VXJpID0gcGVyT3B0aW9uVXJpcyA9PSBudWxsID8gdm9pZCAwIDogcGVyT3B0aW9uVXJpc1tzdGFibGVJZF07XG4gICAgaWYgKHBlclZhcmlhbnRVcmkpIHtcbiAgICAgIHVyaSA9IHBlclZhcmlhbnRVcmk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHVybCA9IG5ldyBzZWxmLlVSTCh1cmkpO1xuICBpZiAoaG9zdCAmJiAhcGVyVmFyaWFudFVyaSkge1xuICAgIHVybC5ob3N0ID0gaG9zdDtcbiAgfVxuICBpZiAocGFyYW1zKSB7XG4gICAgT2JqZWN0LmtleXMocGFyYW1zKS5zb3J0KCkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKGtleSkge1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChrZXksIHBhcmFtc1trZXldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdXJsLmhyZWY7XG59XG5cbmNvbnN0IEFHRV9IRUFERVJfTElORV9SRUdFWCA9IC9eYWdlOlxccypbXFxkLl0rXFxzKiQvaW07XG5jbGFzcyBYaHJMb2FkZXIge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLnhoclNldHVwID0gdm9pZCAwO1xuICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSB2b2lkIDA7XG4gICAgdGhpcy5yZXRyeVRpbWVvdXQgPSB2b2lkIDA7XG4gICAgdGhpcy5yZXRyeURlbGF5ID0gdm9pZCAwO1xuICAgIHRoaXMuY29uZmlnID0gbnVsbDtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IG51bGw7XG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgdGhpcy5zdGF0cyA9IHZvaWQgMDtcbiAgICB0aGlzLnhoclNldHVwID0gY29uZmlnID8gY29uZmlnLnhoclNldHVwIHx8IG51bGwgOiBudWxsO1xuICAgIHRoaXMuc3RhdHMgPSBuZXcgTG9hZFN0YXRzKCk7XG4gICAgdGhpcy5yZXRyeURlbGF5ID0gMDtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuY2FsbGJhY2tzID0gbnVsbDtcbiAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgdGhpcy5jb25maWcgPSBudWxsO1xuICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgdGhpcy54aHJTZXR1cCA9IG51bGw7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuc3RhdHMgPSBudWxsO1xuICB9XG4gIGFib3J0SW50ZXJuYWwoKSB7XG4gICAgY29uc3QgbG9hZGVyID0gdGhpcy5sb2FkZXI7XG4gICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXRyeVRpbWVvdXQpO1xuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGxvYWRlci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgbG9hZGVyLm9ucHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgaWYgKGxvYWRlci5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICAgIHRoaXMuc3RhdHMuYWJvcnRlZCA9IHRydWU7XG4gICAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhYm9ydCgpIHtcbiAgICB2YXIgX3RoaXMkY2FsbGJhY2tzO1xuICAgIHRoaXMuYWJvcnRJbnRlcm5hbCgpO1xuICAgIGlmICgoX3RoaXMkY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3MpICE9IG51bGwgJiYgX3RoaXMkY2FsbGJhY2tzLm9uQWJvcnQpIHtcbiAgICAgIHRoaXMuY2FsbGJhY2tzLm9uQWJvcnQodGhpcy5zdGF0cywgdGhpcy5jb250ZXh0LCB0aGlzLmxvYWRlcik7XG4gICAgfVxuICB9XG4gIGxvYWQoY29udGV4dCwgY29uZmlnLCBjYWxsYmFja3MpIHtcbiAgICBpZiAodGhpcy5zdGF0cy5sb2FkaW5nLnN0YXJ0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvYWRlciBjYW4gb25seSBiZSB1c2VkIG9uY2UuJyk7XG4gICAgfVxuICAgIHRoaXMuc3RhdHMubG9hZGluZy5zdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiAgICB0aGlzLmxvYWRJbnRlcm5hbCgpO1xuICB9XG4gIGxvYWRJbnRlcm5hbCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb25maWcsXG4gICAgICBjb250ZXh0XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFjb25maWcgfHwgIWNvbnRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeGhyID0gdGhpcy5sb2FkZXIgPSBuZXcgc2VsZi5YTUxIdHRwUmVxdWVzdCgpO1xuICAgIGNvbnN0IHN0YXRzID0gdGhpcy5zdGF0cztcbiAgICBzdGF0cy5sb2FkaW5nLmZpcnN0ID0gMDtcbiAgICBzdGF0cy5sb2FkZWQgPSAwO1xuICAgIHN0YXRzLmFib3J0ZWQgPSBmYWxzZTtcbiAgICBjb25zdCB4aHJTZXR1cCA9IHRoaXMueGhyU2V0dXA7XG4gICAgaWYgKHhoclNldHVwKSB7XG4gICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHMuYWJvcnRlZCkgcmV0dXJuO1xuICAgICAgICByZXR1cm4geGhyU2V0dXAoeGhyLCBjb250ZXh0LnVybCk7XG4gICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIHhoci5vcGVuKCdHRVQnLCBjb250ZXh0LnVybCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB4aHJTZXR1cCh4aHIsIGNvbnRleHQudXJsKTtcbiAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5zdGF0cy5hYm9ydGVkKSByZXR1cm47XG4gICAgICAgIHRoaXMub3BlbkFuZFNlbmRYaHIoeGhyLCBjb250ZXh0LCBjb25maWcpO1xuICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAvLyBJRTExIHRocm93cyBhbiBleGNlcHRpb24gb24geGhyLm9wZW4gaWYgYXR0ZW1wdGluZyB0byBhY2Nlc3MgYW4gSFRUUCByZXNvdXJjZSBvdmVyIEhUVFBTXG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLm9uRXJyb3Ioe1xuICAgICAgICAgIGNvZGU6IHhoci5zdGF0dXMsXG4gICAgICAgICAgdGV4dDogZXJyb3IubWVzc2FnZVxuICAgICAgICB9LCBjb250ZXh0LCB4aHIsIHN0YXRzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3BlbkFuZFNlbmRYaHIoeGhyLCBjb250ZXh0LCBjb25maWcpO1xuICAgIH1cbiAgfVxuICBvcGVuQW5kU2VuZFhocih4aHIsIGNvbnRleHQsIGNvbmZpZykge1xuICAgIGlmICgheGhyLnJlYWR5U3RhdGUpIHtcbiAgICAgIHhoci5vcGVuKCdHRVQnLCBjb250ZXh0LnVybCwgdHJ1ZSk7XG4gICAgfVxuICAgIGNvbnN0IGhlYWRlcnMgPSBjb250ZXh0LmhlYWRlcnM7XG4gICAgY29uc3Qge1xuICAgICAgbWF4VGltZVRvRmlyc3RCeXRlTXMsXG4gICAgICBtYXhMb2FkVGltZU1zXG4gICAgfSA9IGNvbmZpZy5sb2FkUG9saWN5O1xuICAgIGlmIChoZWFkZXJzKSB7XG4gICAgICBmb3IgKGNvbnN0IGhlYWRlciBpbiBoZWFkZXJzKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlciwgaGVhZGVyc1toZWFkZXJdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbnRleHQucmFuZ2VFbmQpIHtcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdSYW5nZScsICdieXRlcz0nICsgY29udGV4dC5yYW5nZVN0YXJ0ICsgJy0nICsgKGNvbnRleHQucmFuZ2VFbmQgLSAxKSk7XG4gICAgfVxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSB0aGlzLnJlYWR5c3RhdGVjaGFuZ2UuYmluZCh0aGlzKTtcbiAgICB4aHIub25wcm9ncmVzcyA9IHRoaXMubG9hZHByb2dyZXNzLmJpbmQodGhpcyk7XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9IGNvbnRleHQucmVzcG9uc2VUeXBlO1xuICAgIC8vIHNldHVwIHRpbWVvdXQgYmVmb3JlIHdlIHBlcmZvcm0gcmVxdWVzdFxuICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgIGNvbmZpZy50aW1lb3V0ID0gbWF4VGltZVRvRmlyc3RCeXRlTXMgJiYgaXNGaW5pdGVOdW1iZXIobWF4VGltZVRvRmlyc3RCeXRlTXMpID8gbWF4VGltZVRvRmlyc3RCeXRlTXMgOiBtYXhMb2FkVGltZU1zO1xuICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBzZWxmLnNldFRpbWVvdXQodGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpLCBjb25maWcudGltZW91dCk7XG4gICAgeGhyLnNlbmQoKTtcbiAgfVxuICByZWFkeXN0YXRlY2hhbmdlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRleHQsXG4gICAgICBsb2FkZXI6IHhocixcbiAgICAgIHN0YXRzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFjb250ZXh0IHx8ICF4aHIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVhZHlTdGF0ZSA9IHhoci5yZWFkeVN0YXRlO1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuXG4gICAgLy8gZG9uJ3QgcHJvY2VlZCBpZiB4aHIgaGFzIGJlZW4gYWJvcnRlZFxuICAgIGlmIChzdGF0cy5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gPj0gSEVBREVSU19SRUNFSVZFRFxuICAgIGlmIChyZWFkeVN0YXRlID49IDIpIHtcbiAgICAgIGlmIChzdGF0cy5sb2FkaW5nLmZpcnN0ID09PSAwKSB7XG4gICAgICAgIHN0YXRzLmxvYWRpbmcuZmlyc3QgPSBNYXRoLm1heChzZWxmLnBlcmZvcm1hbmNlLm5vdygpLCBzdGF0cy5sb2FkaW5nLnN0YXJ0KTtcbiAgICAgICAgLy8gcmVhZHlTdGF0ZSA+PSAyIEFORCByZWFkeVN0YXRlICE9PTQgKHJlYWR5U3RhdGUgPSBIRUFERVJTX1JFQ0VJVkVEIHx8IExPQURJTkcpIHJlYXJtIHRpbWVvdXQgYXMgeGhyIG5vdCBmaW5pc2hlZCB5ZXRcbiAgICAgICAgaWYgKGNvbmZpZy50aW1lb3V0ICE9PSBjb25maWcubG9hZFBvbGljeS5tYXhMb2FkVGltZU1zKSB7XG4gICAgICAgICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgICAgICAgY29uZmlnLnRpbWVvdXQgPSBjb25maWcubG9hZFBvbGljeS5tYXhMb2FkVGltZU1zO1xuICAgICAgICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBzZWxmLnNldFRpbWVvdXQodGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpLCBjb25maWcubG9hZFBvbGljeS5tYXhMb2FkVGltZU1zIC0gKHN0YXRzLmxvYWRpbmcuZmlyc3QgLSBzdGF0cy5sb2FkaW5nLnN0YXJ0KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgeGhyLm9ucHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICBjb25zdCBzdGF0dXMgPSB4aHIuc3RhdHVzO1xuICAgICAgICAvLyBodHRwIHN0YXR1cyBiZXR3ZWVuIDIwMCB0byAyOTkgYXJlIGFsbCBzdWNjZXNzZnVsXG4gICAgICAgIGNvbnN0IHVzZVJlc3BvbnNlID0geGhyLnJlc3BvbnNlVHlwZSAhPT0gJ3RleHQnO1xuICAgICAgICBpZiAoc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgJiYgKHVzZVJlc3BvbnNlICYmIHhoci5yZXNwb25zZSB8fCB4aHIucmVzcG9uc2VUZXh0ICE9PSBudWxsKSkge1xuICAgICAgICAgIHN0YXRzLmxvYWRpbmcuZW5kID0gTWF0aC5tYXgoc2VsZi5wZXJmb3JtYW5jZS5ub3coKSwgc3RhdHMubG9hZGluZy5maXJzdCk7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IHVzZVJlc3BvbnNlID8geGhyLnJlc3BvbnNlIDogeGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICBjb25zdCBsZW4gPSB4aHIucmVzcG9uc2VUeXBlID09PSAnYXJyYXlidWZmZXInID8gZGF0YS5ieXRlTGVuZ3RoIDogZGF0YS5sZW5ndGg7XG4gICAgICAgICAgc3RhdHMubG9hZGVkID0gc3RhdHMudG90YWwgPSBsZW47XG4gICAgICAgICAgc3RhdHMuYndFc3RpbWF0ZSA9IHN0YXRzLnRvdGFsICogODAwMCAvIChzdGF0cy5sb2FkaW5nLmVuZCAtIHN0YXRzLmxvYWRpbmcuZmlyc3QpO1xuICAgICAgICAgIGlmICghdGhpcy5jYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgb25Qcm9ncmVzcyA9IHRoaXMuY2FsbGJhY2tzLm9uUHJvZ3Jlc3M7XG4gICAgICAgICAgaWYgKG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIG9uUHJvZ3Jlc3Moc3RhdHMsIGNvbnRleHQsIGRhdGEsIHhocik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy5jYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICB1cmw6IHhoci5yZXNwb25zZVVSTCxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICBjb2RlOiBzdGF0dXNcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLm9uU3VjY2VzcyhyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIHhocik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcmV0cnlDb25maWcgPSBjb25maWcubG9hZFBvbGljeS5lcnJvclJldHJ5O1xuICAgICAgICAgIGNvbnN0IHJldHJ5Q291bnQgPSBzdGF0cy5yZXRyeTtcbiAgICAgICAgICAvLyBpZiBtYXggbmIgb2YgcmV0cmllcyByZWFjaGVkIG9yIGlmIGh0dHAgc3RhdHVzIGJldHdlZW4gNDAwIGFuZCA0OTkgKHN1Y2ggZXJyb3IgY2Fubm90IGJlIHJlY292ZXJlZCwgcmV0cnlpbmcgaXMgdXNlbGVzcyksIHJldHVybiBlcnJvclxuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgdXJsOiBjb250ZXh0LnVybCxcbiAgICAgICAgICAgIGRhdGE6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvZGU6IHN0YXR1c1xuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKHNob3VsZFJldHJ5KHJldHJ5Q29uZmlnLCByZXRyeUNvdW50LCBmYWxzZSwgcmVzcG9uc2UpKSB7XG4gICAgICAgICAgICB0aGlzLnJldHJ5KHJldHJ5Q29uZmlnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGAke3N0YXR1c30gd2hpbGUgbG9hZGluZyAke2NvbnRleHQudXJsfWApO1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFja3Mub25FcnJvcih7XG4gICAgICAgICAgICAgIGNvZGU6IHN0YXR1cyxcbiAgICAgICAgICAgICAgdGV4dDogeGhyLnN0YXR1c1RleHRcbiAgICAgICAgICAgIH0sIGNvbnRleHQsIHhociwgc3RhdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBsb2FkdGltZW91dCgpIHtcbiAgICB2YXIgX3RoaXMkY29uZmlnO1xuICAgIGNvbnN0IHJldHJ5Q29uZmlnID0gKF90aGlzJGNvbmZpZyA9IHRoaXMuY29uZmlnKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkY29uZmlnLmxvYWRQb2xpY3kudGltZW91dFJldHJ5O1xuICAgIGNvbnN0IHJldHJ5Q291bnQgPSB0aGlzLnN0YXRzLnJldHJ5O1xuICAgIGlmIChzaG91bGRSZXRyeShyZXRyeUNvbmZpZywgcmV0cnlDb3VudCwgdHJ1ZSkpIHtcbiAgICAgIHRoaXMucmV0cnkocmV0cnlDb25maWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX3RoaXMkY29udGV4dDtcbiAgICAgIGxvZ2dlci53YXJuKGB0aW1lb3V0IHdoaWxlIGxvYWRpbmcgJHsoX3RoaXMkY29udGV4dCA9IHRoaXMuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGNvbnRleHQudXJsfWApO1xuICAgICAgY29uc3QgY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3M7XG4gICAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAgIHRoaXMuYWJvcnRJbnRlcm5hbCgpO1xuICAgICAgICBjYWxsYmFja3Mub25UaW1lb3V0KHRoaXMuc3RhdHMsIHRoaXMuY29udGV4dCwgdGhpcy5sb2FkZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXRyeShyZXRyeUNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRleHQsXG4gICAgICBzdGF0c1xuICAgIH0gPSB0aGlzO1xuICAgIHRoaXMucmV0cnlEZWxheSA9IGdldFJldHJ5RGVsYXkocmV0cnlDb25maWcsIHN0YXRzLnJldHJ5KTtcbiAgICBzdGF0cy5yZXRyeSsrO1xuICAgIGxvZ2dlci53YXJuKGAke3N0YXR1cyA/ICdIVFRQIFN0YXR1cyAnICsgc3RhdHVzIDogJ1RpbWVvdXQnfSB3aGlsZSBsb2FkaW5nICR7Y29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogY29udGV4dC51cmx9LCByZXRyeWluZyAke3N0YXRzLnJldHJ5fS8ke3JldHJ5Q29uZmlnLm1heE51bVJldHJ5fSBpbiAke3RoaXMucmV0cnlEZWxheX1tc2ApO1xuICAgIC8vIGFib3J0IGFuZCByZXNldCBpbnRlcm5hbCBzdGF0ZVxuICAgIHRoaXMuYWJvcnRJbnRlcm5hbCgpO1xuICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgICAvLyBzY2hlZHVsZSByZXRyeVxuICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmV0cnlUaW1lb3V0KTtcbiAgICB0aGlzLnJldHJ5VGltZW91dCA9IHNlbGYuc2V0VGltZW91dCh0aGlzLmxvYWRJbnRlcm5hbC5iaW5kKHRoaXMpLCB0aGlzLnJldHJ5RGVsYXkpO1xuICB9XG4gIGxvYWRwcm9ncmVzcyhldmVudCkge1xuICAgIGNvbnN0IHN0YXRzID0gdGhpcy5zdGF0cztcbiAgICBzdGF0cy5sb2FkZWQgPSBldmVudC5sb2FkZWQ7XG4gICAgaWYgKGV2ZW50Lmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgIHN0YXRzLnRvdGFsID0gZXZlbnQudG90YWw7XG4gICAgfVxuICB9XG4gIGdldENhY2hlQWdlKCkge1xuICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgIGlmICh0aGlzLmxvYWRlciAmJiBBR0VfSEVBREVSX0xJTkVfUkVHRVgudGVzdCh0aGlzLmxvYWRlci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkpIHtcbiAgICAgIGNvbnN0IGFnZUhlYWRlciA9IHRoaXMubG9hZGVyLmdldFJlc3BvbnNlSGVhZGVyKCdhZ2UnKTtcbiAgICAgIHJlc3VsdCA9IGFnZUhlYWRlciA/IHBhcnNlRmxvYXQoYWdlSGVhZGVyKSA6IG51bGw7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZ2V0UmVzcG9uc2VIZWFkZXIobmFtZSkge1xuICAgIGlmICh0aGlzLmxvYWRlciAmJiBuZXcgUmVnRXhwKGBeJHtuYW1lfTpcXFxccypbXFxcXGQuXStcXFxccyokYCwgJ2ltJykudGVzdCh0aGlzLmxvYWRlci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvYWRlci5nZXRSZXNwb25zZUhlYWRlcihuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmV0Y2hTdXBwb3J0ZWQoKSB7XG4gIGlmIChcbiAgLy8gQHRzLWlnbm9yZVxuICBzZWxmLmZldGNoICYmIHNlbGYuQWJvcnRDb250cm9sbGVyICYmIHNlbGYuUmVhZGFibGVTdHJlYW0gJiYgc2VsZi5SZXF1ZXN0KSB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBzZWxmLlJlYWRhYmxlU3RyZWFtKHt9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8qIG5vb3AgKi9cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuY29uc3QgQllURVJBTkdFID0gLyhcXGQrKS0oXFxkKylcXC8oXFxkKykvO1xuY2xhc3MgRmV0Y2hMb2FkZXIge1xuICBjb25zdHJ1Y3Rvcihjb25maWcgLyogSGxzQ29uZmlnICovKSB7XG4gICAgdGhpcy5mZXRjaFNldHVwID0gdm9pZCAwO1xuICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSB2b2lkIDA7XG4gICAgdGhpcy5yZXF1ZXN0ID0gbnVsbDtcbiAgICB0aGlzLnJlc3BvbnNlID0gbnVsbDtcbiAgICB0aGlzLmNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLmNvbmZpZyA9IG51bGw7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBudWxsO1xuICAgIHRoaXMuc3RhdHMgPSB2b2lkIDA7XG4gICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICAgIHRoaXMuZmV0Y2hTZXR1cCA9IGNvbmZpZy5mZXRjaFNldHVwIHx8IGdldFJlcXVlc3Q7XG4gICAgdGhpcy5jb250cm9sbGVyID0gbmV3IHNlbGYuQWJvcnRDb250cm9sbGVyKCk7XG4gICAgdGhpcy5zdGF0cyA9IG5ldyBMb2FkU3RhdHMoKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMubG9hZGVyID0gdGhpcy5jYWxsYmFja3MgPSB0aGlzLmNvbnRleHQgPSB0aGlzLmNvbmZpZyA9IHRoaXMucmVxdWVzdCA9IG51bGw7XG4gICAgdGhpcy5hYm9ydEludGVybmFsKCk7XG4gICAgdGhpcy5yZXNwb25zZSA9IG51bGw7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuZmV0Y2hTZXR1cCA9IHRoaXMuY29udHJvbGxlciA9IHRoaXMuc3RhdHMgPSBudWxsO1xuICB9XG4gIGFib3J0SW50ZXJuYWwoKSB7XG4gICAgaWYgKHRoaXMuY29udHJvbGxlciAmJiAhdGhpcy5zdGF0cy5sb2FkaW5nLmVuZCkge1xuICAgICAgdGhpcy5zdGF0cy5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuY29udHJvbGxlci5hYm9ydCgpO1xuICAgIH1cbiAgfVxuICBhYm9ydCgpIHtcbiAgICB2YXIgX3RoaXMkY2FsbGJhY2tzO1xuICAgIHRoaXMuYWJvcnRJbnRlcm5hbCgpO1xuICAgIGlmICgoX3RoaXMkY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3MpICE9IG51bGwgJiYgX3RoaXMkY2FsbGJhY2tzLm9uQWJvcnQpIHtcbiAgICAgIHRoaXMuY2FsbGJhY2tzLm9uQWJvcnQodGhpcy5zdGF0cywgdGhpcy5jb250ZXh0LCB0aGlzLnJlc3BvbnNlKTtcbiAgICB9XG4gIH1cbiAgbG9hZChjb250ZXh0LCBjb25maWcsIGNhbGxiYWNrcykge1xuICAgIGNvbnN0IHN0YXRzID0gdGhpcy5zdGF0cztcbiAgICBpZiAoc3RhdHMubG9hZGluZy5zdGFydCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2FkZXIgY2FuIG9ubHkgYmUgdXNlZCBvbmNlLicpO1xuICAgIH1cbiAgICBzdGF0cy5sb2FkaW5nLnN0YXJ0ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCBpbml0UGFyYW1zID0gZ2V0UmVxdWVzdFBhcmFtZXRlcnMoY29udGV4dCwgdGhpcy5jb250cm9sbGVyLnNpZ25hbCk7XG4gICAgY29uc3Qgb25Qcm9ncmVzcyA9IGNhbGxiYWNrcy5vblByb2dyZXNzO1xuICAgIGNvbnN0IGlzQXJyYXlCdWZmZXIgPSBjb250ZXh0LnJlc3BvbnNlVHlwZSA9PT0gJ2FycmF5YnVmZmVyJztcbiAgICBjb25zdCBMRU5HVEggPSBpc0FycmF5QnVmZmVyID8gJ2J5dGVMZW5ndGgnIDogJ2xlbmd0aCc7XG4gICAgY29uc3Qge1xuICAgICAgbWF4VGltZVRvRmlyc3RCeXRlTXMsXG4gICAgICBtYXhMb2FkVGltZU1zXG4gICAgfSA9IGNvbmZpZy5sb2FkUG9saWN5O1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4gICAgdGhpcy5yZXF1ZXN0ID0gdGhpcy5mZXRjaFNldHVwKGNvbnRleHQsIGluaXRQYXJhbXMpO1xuICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgIGNvbmZpZy50aW1lb3V0ID0gbWF4VGltZVRvRmlyc3RCeXRlTXMgJiYgaXNGaW5pdGVOdW1iZXIobWF4VGltZVRvRmlyc3RCeXRlTXMpID8gbWF4VGltZVRvRmlyc3RCeXRlTXMgOiBtYXhMb2FkVGltZU1zO1xuICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBzZWxmLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5hYm9ydEludGVybmFsKCk7XG4gICAgICBjYWxsYmFja3Mub25UaW1lb3V0KHN0YXRzLCBjb250ZXh0LCB0aGlzLnJlc3BvbnNlKTtcbiAgICB9LCBjb25maWcudGltZW91dCk7XG4gICAgc2VsZi5mZXRjaCh0aGlzLnJlcXVlc3QpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgdGhpcy5yZXNwb25zZSA9IHRoaXMubG9hZGVyID0gcmVzcG9uc2U7XG4gICAgICBjb25zdCBmaXJzdCA9IE1hdGgubWF4KHNlbGYucGVyZm9ybWFuY2Uubm93KCksIHN0YXRzLmxvYWRpbmcuc3RhcnQpO1xuICAgICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgICBjb25maWcudGltZW91dCA9IG1heExvYWRUaW1lTXM7XG4gICAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gc2VsZi5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5hYm9ydEludGVybmFsKCk7XG4gICAgICAgIGNhbGxiYWNrcy5vblRpbWVvdXQoc3RhdHMsIGNvbnRleHQsIHRoaXMucmVzcG9uc2UpO1xuICAgICAgfSwgbWF4TG9hZFRpbWVNcyAtIChmaXJzdCAtIHN0YXRzLmxvYWRpbmcuc3RhcnQpKTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICBzdGF0dXNUZXh0XG4gICAgICAgIH0gPSByZXNwb25zZTtcbiAgICAgICAgdGhyb3cgbmV3IEZldGNoRXJyb3Ioc3RhdHVzVGV4dCB8fCAnZmV0Y2gsIGJhZCBuZXR3b3JrIHJlc3BvbnNlJywgc3RhdHVzLCByZXNwb25zZSk7XG4gICAgICB9XG4gICAgICBzdGF0cy5sb2FkaW5nLmZpcnN0ID0gZmlyc3Q7XG4gICAgICBzdGF0cy50b3RhbCA9IGdldENvbnRlbnRMZW5ndGgocmVzcG9uc2UuaGVhZGVycykgfHwgc3RhdHMudG90YWw7XG4gICAgICBpZiAob25Qcm9ncmVzcyAmJiBpc0Zpbml0ZU51bWJlcihjb25maWcuaGlnaFdhdGVyTWFyaykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZFByb2dyZXNzaXZlbHkocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBjb25maWcuaGlnaFdhdGVyTWFyaywgb25Qcm9ncmVzcyk7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb250ZXh0LnJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgIH0pLnRoZW4ocmVzcG9uc2VEYXRhID0+IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy5yZXNwb25zZTtcbiAgICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsb2FkZXIgZGVzdHJveWVkJyk7XG4gICAgICB9XG4gICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICAgIHN0YXRzLmxvYWRpbmcuZW5kID0gTWF0aC5tYXgoc2VsZi5wZXJmb3JtYW5jZS5ub3coKSwgc3RhdHMubG9hZGluZy5maXJzdCk7XG4gICAgICBjb25zdCB0b3RhbCA9IHJlc3BvbnNlRGF0YVtMRU5HVEhdO1xuICAgICAgaWYgKHRvdGFsKSB7XG4gICAgICAgIHN0YXRzLmxvYWRlZCA9IHN0YXRzLnRvdGFsID0gdG90YWw7XG4gICAgICB9XG4gICAgICBjb25zdCBsb2FkZXJSZXNwb25zZSA9IHtcbiAgICAgICAgdXJsOiByZXNwb25zZS51cmwsXG4gICAgICAgIGRhdGE6IHJlc3BvbnNlRGF0YSxcbiAgICAgICAgY29kZTogcmVzcG9uc2Uuc3RhdHVzXG4gICAgICB9O1xuICAgICAgaWYgKG9uUHJvZ3Jlc3MgJiYgIWlzRmluaXRlTnVtYmVyKGNvbmZpZy5oaWdoV2F0ZXJNYXJrKSkge1xuICAgICAgICBvblByb2dyZXNzKHN0YXRzLCBjb250ZXh0LCByZXNwb25zZURhdGEsIHJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrcy5vblN1Y2Nlc3MobG9hZGVyUmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCByZXNwb25zZSk7XG4gICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgICBpZiAoc3RhdHMuYWJvcnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBDT1JTIGVycm9ycyByZXN1bHQgaW4gYW4gdW5kZWZpbmVkIGNvZGUuIFNldCBpdCB0byAwIGhlcmUgdG8gYWxpZ24gd2l0aCBYSFIncyBiZWhhdmlvclxuICAgICAgLy8gd2hlbiBkZXN0cm95aW5nLCAnZXJyb3InIGl0c2VsZiBjYW4gYmUgdW5kZWZpbmVkXG4gICAgICBjb25zdCBjb2RlID0gIWVycm9yID8gMCA6IGVycm9yLmNvZGUgfHwgMDtcbiAgICAgIGNvbnN0IHRleHQgPSAhZXJyb3IgPyBudWxsIDogZXJyb3IubWVzc2FnZTtcbiAgICAgIGNhbGxiYWNrcy5vbkVycm9yKHtcbiAgICAgICAgY29kZSxcbiAgICAgICAgdGV4dFxuICAgICAgfSwgY29udGV4dCwgZXJyb3IgPyBlcnJvci5kZXRhaWxzIDogbnVsbCwgc3RhdHMpO1xuICAgIH0pO1xuICB9XG4gIGdldENhY2hlQWdlKCkge1xuICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgIGlmICh0aGlzLnJlc3BvbnNlKSB7XG4gICAgICBjb25zdCBhZ2VIZWFkZXIgPSB0aGlzLnJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdhZ2UnKTtcbiAgICAgIHJlc3VsdCA9IGFnZUhlYWRlciA/IHBhcnNlRmxvYXQoYWdlSGVhZGVyKSA6IG51bGw7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZ2V0UmVzcG9uc2VIZWFkZXIobmFtZSkge1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlID8gdGhpcy5yZXNwb25zZS5oZWFkZXJzLmdldChuYW1lKSA6IG51bGw7XG4gIH1cbiAgbG9hZFByb2dyZXNzaXZlbHkocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBoaWdoV2F0ZXJNYXJrID0gMCwgb25Qcm9ncmVzcykge1xuICAgIGNvbnN0IGNodW5rQ2FjaGUgPSBuZXcgQ2h1bmtDYWNoZSgpO1xuICAgIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgY29uc3QgcHVtcCA9ICgpID0+IHtcbiAgICAgIHJldHVybiByZWFkZXIucmVhZCgpLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgIGlmIChkYXRhLmRvbmUpIHtcbiAgICAgICAgICBpZiAoY2h1bmtDYWNoZS5kYXRhTGVuZ3RoKSB7XG4gICAgICAgICAgICBvblByb2dyZXNzKHN0YXRzLCBjb250ZXh0LCBjaHVua0NhY2hlLmZsdXNoKCksIHJlc3BvbnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQXJyYXlCdWZmZXIoMCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNodW5rID0gZGF0YS52YWx1ZTtcbiAgICAgICAgY29uc3QgbGVuID0gY2h1bmsubGVuZ3RoO1xuICAgICAgICBzdGF0cy5sb2FkZWQgKz0gbGVuO1xuICAgICAgICBpZiAobGVuIDwgaGlnaFdhdGVyTWFyayB8fCBjaHVua0NhY2hlLmRhdGFMZW5ndGgpIHtcbiAgICAgICAgICAvLyBUaGUgY3VycmVudCBjaHVuayBpcyB0b28gc21hbGwgdG8gdG8gYmUgZW1pdHRlZCBvciB0aGUgY2FjaGUgYWxyZWFkeSBoYXMgZGF0YVxuICAgICAgICAgIC8vIFB1c2ggaXQgdG8gdGhlIGNhY2hlXG4gICAgICAgICAgY2h1bmtDYWNoZS5wdXNoKGNodW5rKTtcbiAgICAgICAgICBpZiAoY2h1bmtDYWNoZS5kYXRhTGVuZ3RoID49IGhpZ2hXYXRlck1hcmspIHtcbiAgICAgICAgICAgIC8vIGZsdXNoIGluIG9yZGVyIHRvIGpvaW4gdGhlIHR5cGVkIGFycmF5c1xuICAgICAgICAgICAgb25Qcm9ncmVzcyhzdGF0cywgY29udGV4dCwgY2h1bmtDYWNoZS5mbHVzaCgpLCByZXNwb25zZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIHRoZXJlJ3Mgbm90aGluZyBjYWNoZWQgYWxyZWFkeSwgYW5kIHRoZSBjaGFjaGUgaXMgbGFyZ2UgZW5vdWdoXG4gICAgICAgICAgLy8ganVzdCBlbWl0IHRoZSBwcm9ncmVzcyBldmVudFxuICAgICAgICAgIG9uUHJvZ3Jlc3Moc3RhdHMsIGNvbnRleHQsIGNodW5rLCByZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHB1bXAoKTtcbiAgICAgIH0pLmNhdGNoKCgpID0+IHtcbiAgICAgICAgLyogYWJvcnRlZCAqL1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIHB1bXAoKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0UmVxdWVzdFBhcmFtZXRlcnMoY29udGV4dCwgc2lnbmFsKSB7XG4gIGNvbnN0IGluaXRQYXJhbXMgPSB7XG4gICAgbWV0aG9kOiAnR0VUJyxcbiAgICBtb2RlOiAnY29ycycsXG4gICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicsXG4gICAgc2lnbmFsLFxuICAgIGhlYWRlcnM6IG5ldyBzZWxmLkhlYWRlcnMoX2V4dGVuZHMoe30sIGNvbnRleHQuaGVhZGVycykpXG4gIH07XG4gIGlmIChjb250ZXh0LnJhbmdlRW5kKSB7XG4gICAgaW5pdFBhcmFtcy5oZWFkZXJzLnNldCgnUmFuZ2UnLCAnYnl0ZXM9JyArIGNvbnRleHQucmFuZ2VTdGFydCArICctJyArIFN0cmluZyhjb250ZXh0LnJhbmdlRW5kIC0gMSkpO1xuICB9XG4gIHJldHVybiBpbml0UGFyYW1zO1xufVxuZnVuY3Rpb24gZ2V0Qnl0ZVJhbmdlTGVuZ3RoKGJ5dGVSYW5nZUhlYWRlcikge1xuICBjb25zdCByZXN1bHQgPSBCWVRFUkFOR0UuZXhlYyhieXRlUmFuZ2VIZWFkZXIpO1xuICBpZiAocmVzdWx0KSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHJlc3VsdFsyXSkgLSBwYXJzZUludChyZXN1bHRbMV0pICsgMTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q29udGVudExlbmd0aChoZWFkZXJzKSB7XG4gIGNvbnN0IGNvbnRlbnRSYW5nZSA9IGhlYWRlcnMuZ2V0KCdDb250ZW50LVJhbmdlJyk7XG4gIGlmIChjb250ZW50UmFuZ2UpIHtcbiAgICBjb25zdCBieXRlUmFuZ2VMZW5ndGggPSBnZXRCeXRlUmFuZ2VMZW5ndGgoY29udGVudFJhbmdlKTtcbiAgICBpZiAoaXNGaW5pdGVOdW1iZXIoYnl0ZVJhbmdlTGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIGJ5dGVSYW5nZUxlbmd0aDtcbiAgICB9XG4gIH1cbiAgY29uc3QgY29udGVudExlbmd0aCA9IGhlYWRlcnMuZ2V0KCdDb250ZW50LUxlbmd0aCcpO1xuICBpZiAoY29udGVudExlbmd0aCkge1xuICAgIHJldHVybiBwYXJzZUludChjb250ZW50TGVuZ3RoKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0UmVxdWVzdChjb250ZXh0LCBpbml0UGFyYW1zKSB7XG4gIHJldHVybiBuZXcgc2VsZi5SZXF1ZXN0KGNvbnRleHQudXJsLCBpbml0UGFyYW1zKTtcbn1cbmNsYXNzIEZldGNoRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNvZGUsIGRldGFpbHMpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmNvZGUgPSB2b2lkIDA7XG4gICAgdGhpcy5kZXRhaWxzID0gdm9pZCAwO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgfVxufVxuXG5jb25zdCBXSElURVNQQUNFX0NIQVIgPSAvXFxzLztcbmNvbnN0IEN1ZXMgPSB7XG4gIG5ld0N1ZSh0cmFjaywgc3RhcnRUaW1lLCBlbmRUaW1lLCBjYXB0aW9uU2NyZWVuKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IHJvdztcbiAgICAvLyB0aGUgdHlwZSBkYXRhIHN0YXRlcyB0aGlzIGlzIFZUVEN1ZSwgYnV0IGl0IGNhbiBwb3RlbnRpYWxseSBiZSBhIFRleHRUcmFja0N1ZSBvbiBvbGQgYnJvd3NlcnNcbiAgICBsZXQgY3VlO1xuICAgIGxldCBpbmRlbnRpbmc7XG4gICAgbGV0IGluZGVudDtcbiAgICBsZXQgdGV4dDtcbiAgICBjb25zdCBDdWUgPSBzZWxmLlZUVEN1ZSB8fCBzZWxmLlRleHRUcmFja0N1ZTtcbiAgICBmb3IgKGxldCByID0gMDsgciA8IGNhcHRpb25TY3JlZW4ucm93cy5sZW5ndGg7IHIrKykge1xuICAgICAgcm93ID0gY2FwdGlvblNjcmVlbi5yb3dzW3JdO1xuICAgICAgaW5kZW50aW5nID0gdHJ1ZTtcbiAgICAgIGluZGVudCA9IDA7XG4gICAgICB0ZXh0ID0gJyc7XG4gICAgICBpZiAoIXJvdy5pc0VtcHR5KCkpIHtcbiAgICAgICAgdmFyIF90cmFjayRjdWVzO1xuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHJvdy5jaGFycy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgIGlmIChXSElURVNQQUNFX0NIQVIudGVzdChyb3cuY2hhcnNbY10udWNoYXIpICYmIGluZGVudGluZykge1xuICAgICAgICAgICAgaW5kZW50Kys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHQgKz0gcm93LmNoYXJzW2NdLnVjaGFyO1xuICAgICAgICAgICAgaW5kZW50aW5nID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRvIGJlIHVzZWQgZm9yIGNsZWFuaW5nLXVwIG9ycGhhbmVkIHJvbGwtdXAgY2FwdGlvbnNcbiAgICAgICAgcm93LmN1ZVN0YXJ0VGltZSA9IHN0YXJ0VGltZTtcblxuICAgICAgICAvLyBHaXZlIGEgc2xpZ2h0IGJ1bXAgdG8gdGhlIGVuZFRpbWUgaWYgaXQncyBlcXVhbCB0byBzdGFydFRpbWUgdG8gYXZvaWQgYSBTeW50YXhFcnJvciBpbiBJRVxuICAgICAgICBpZiAoc3RhcnRUaW1lID09PSBlbmRUaW1lKSB7XG4gICAgICAgICAgZW5kVGltZSArPSAwLjAwMDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGVudCA+PSAxNikge1xuICAgICAgICAgIGluZGVudC0tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluZGVudCsrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1ZVRleHQgPSBmaXhMaW5lQnJlYWtzKHRleHQudHJpbSgpKTtcbiAgICAgICAgY29uc3QgaWQgPSBnZW5lcmF0ZUN1ZUlkKHN0YXJ0VGltZSwgZW5kVGltZSwgY3VlVGV4dCk7XG5cbiAgICAgICAgLy8gSWYgdGhpcyBjdWUgYWxyZWFkeSBleGlzdHMgaW4gdGhlIHRyYWNrIGRvIG5vdCBwdXNoIGl0XG4gICAgICAgIGlmICghKHRyYWNrICE9IG51bGwgJiYgKF90cmFjayRjdWVzID0gdHJhY2suY3VlcykgIT0gbnVsbCAmJiBfdHJhY2skY3Vlcy5nZXRDdWVCeUlkKGlkKSkpIHtcbiAgICAgICAgICBjdWUgPSBuZXcgQ3VlKHN0YXJ0VGltZSwgZW5kVGltZSwgY3VlVGV4dCk7XG4gICAgICAgICAgY3VlLmlkID0gaWQ7XG4gICAgICAgICAgY3VlLmxpbmUgPSByICsgMTtcbiAgICAgICAgICBjdWUuYWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgLy8gQ2xhbXAgdGhlIHBvc2l0aW9uIGJldHdlZW4gMTAgYW5kIDgwIHBlcmNlbnQgKENFQS02MDggUEFDIGluZGVudCBjb2RlKVxuICAgICAgICAgIC8vIGh0dHBzOi8vZHZjcy53My5vcmcvaGcvdGV4dC10cmFja3MvcmF3LWZpbGUvZGVmYXVsdC82MDh0b1ZUVC82MDh0b1ZUVC5odG1sI3Bvc2l0aW9uaW5nLWluLWNlYS02MDhcbiAgICAgICAgICAvLyBGaXJlZm94IHRocm93cyBhbiBleGNlcHRpb24gYW5kIGNhcHRpb25zIGJyZWFrIHdpdGggb3V0IG9mIGJvdW5kcyAwLTEwMCB2YWx1ZXNcbiAgICAgICAgICBjdWUucG9zaXRpb24gPSAxMCArIE1hdGgubWluKDgwLCBNYXRoLmZsb29yKGluZGVudCAqIDggLyAzMikgKiAxMCk7XG4gICAgICAgICAgcmVzdWx0LnB1c2goY3VlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHJhY2sgJiYgcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgLy8gU29ydCBib3R0b20gY3VlcyBpbiByZXZlcnNlIG9yZGVyIHNvIHRoYXQgdGhleSByZW5kZXIgaW4gbGluZSBvcmRlciB3aGVuIG92ZXJsYXBwaW5nIGluIENocm9tZVxuICAgICAgcmVzdWx0LnNvcnQoKGN1ZUEsIGN1ZUIpID0+IHtcbiAgICAgICAgaWYgKGN1ZUEubGluZSA9PT0gJ2F1dG8nIHx8IGN1ZUIubGluZSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1ZUEubGluZSA+IDggJiYgY3VlQi5saW5lID4gOCkge1xuICAgICAgICAgIHJldHVybiBjdWVCLmxpbmUgLSBjdWVBLmxpbmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1ZUEubGluZSAtIGN1ZUIubGluZTtcbiAgICAgIH0pO1xuICAgICAgcmVzdWx0LmZvckVhY2goY3VlID0+IGFkZEN1ZVRvVHJhY2sodHJhY2ssIGN1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIHVzZSBmcmFnTG9hZFBvbGljeS5kZWZhdWx0XG4gKi9cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCB1c2UgbWFuaWZlc3RMb2FkUG9saWN5LmRlZmF1bHQgYW5kIHBsYXlsaXN0TG9hZFBvbGljeS5kZWZhdWx0XG4gKi9cblxuY29uc3QgZGVmYXVsdExvYWRQb2xpY3kgPSB7XG4gIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zOiA4MDAwLFxuICBtYXhMb2FkVGltZU1zOiAyMDAwMCxcbiAgdGltZW91dFJldHJ5OiBudWxsLFxuICBlcnJvclJldHJ5OiBudWxsXG59O1xuXG4vKipcbiAqIEBpZ25vcmVcbiAqIElmIHBvc3NpYmxlLCBrZWVwIGhsc0RlZmF1bHRDb25maWcgc2hhbGxvd1xuICogSXQgaXMgY2xvbmVkIHdoZW5ldmVyIGEgbmV3IEhscyBpbnN0YW5jZSBpcyBjcmVhdGVkLCBieSBrZWVwaW5nIHRoZSBjb25maWdcbiAqIHNoYWxsb3cgdGhlIHByb3BlcnRpZXMgYXJlIGNsb25lZCwgYW5kIHdlIGRvbid0IGVuZCB1cCBtYW5pcHVsYXRpbmcgdGhlIGRlZmF1bHRcbiAqL1xuY29uc3QgaGxzRGVmYXVsdENvbmZpZyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHtcbiAgYXV0b1N0YXJ0TG9hZDogdHJ1ZSxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBzdGFydFBvc2l0aW9uOiAtMSxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBkZWZhdWx0QXVkaW9Db2RlYzogdW5kZWZpbmVkLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGRlYnVnOiBmYWxzZSxcbiAgLy8gdXNlZCBieSBsb2dnZXJcbiAgY2FwTGV2ZWxPbkZQU0Ryb3A6IGZhbHNlLFxuICAvLyB1c2VkIGJ5IGZwcy1jb250cm9sbGVyXG4gIGNhcExldmVsVG9QbGF5ZXJTaXplOiBmYWxzZSxcbiAgLy8gdXNlZCBieSBjYXAtbGV2ZWwtY29udHJvbGxlclxuICBpZ25vcmVEZXZpY2VQaXhlbFJhdGlvOiBmYWxzZSxcbiAgLy8gdXNlZCBieSBjYXAtbGV2ZWwtY29udHJvbGxlclxuICBwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2U6IHRydWUsXG4gIGluaXRpYWxMaXZlTWFuaWZlc3RTaXplOiAxLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIG1heEJ1ZmZlckxlbmd0aDogMzAsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgYmFja0J1ZmZlckxlbmd0aDogSW5maW5pdHksXG4gIC8vIHVzZWQgYnkgYnVmZmVyLWNvbnRyb2xsZXJcbiAgZnJvbnRCdWZmZXJGbHVzaFRocmVzaG9sZDogSW5maW5pdHksXG4gIG1heEJ1ZmZlclNpemU6IDYwICogMTAwMCAqIDEwMDAsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgbWF4QnVmZmVySG9sZTogMC4xLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGhpZ2hCdWZmZXJXYXRjaGRvZ1BlcmlvZDogMixcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBudWRnZU9mZnNldDogMC4xLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIG51ZGdlTWF4UmV0cnk6IDMsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTogMC4yNSxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBsaXZlU3luY0R1cmF0aW9uQ291bnQ6IDMsXG4gIC8vIHVzZWQgYnkgbGF0ZW5jeS1jb250cm9sbGVyXG4gIGxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudDogSW5maW5pdHksXG4gIC8vIHVzZWQgYnkgbGF0ZW5jeS1jb250cm9sbGVyXG4gIGxpdmVTeW5jRHVyYXRpb246IHVuZGVmaW5lZCxcbiAgLy8gdXNlZCBieSBsYXRlbmN5LWNvbnRyb2xsZXJcbiAgbGl2ZU1heExhdGVuY3lEdXJhdGlvbjogdW5kZWZpbmVkLFxuICAvLyB1c2VkIGJ5IGxhdGVuY3ktY29udHJvbGxlclxuICBtYXhMaXZlU3luY1BsYXliYWNrUmF0ZTogMSxcbiAgLy8gdXNlZCBieSBsYXRlbmN5LWNvbnRyb2xsZXJcbiAgbGl2ZUR1cmF0aW9uSW5maW5pdHk6IGZhbHNlLFxuICAvLyB1c2VkIGJ5IGJ1ZmZlci1jb250cm9sbGVyXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYmFja0J1ZmZlckxlbmd0aFxuICAgKi9cbiAgbGl2ZUJhY2tCdWZmZXJMZW5ndGg6IG51bGwsXG4gIC8vIHVzZWQgYnkgYnVmZmVyLWNvbnRyb2xsZXJcbiAgbWF4TWF4QnVmZmVyTGVuZ3RoOiA2MDAsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgZW5hYmxlV29ya2VyOiB0cnVlLFxuICAvLyB1c2VkIGJ5IHRyYW5zbXV4ZXJcbiAgd29ya2VyUGF0aDogbnVsbCxcbiAgLy8gdXNlZCBieSB0cmFuc211eGVyXG4gIGVuYWJsZVNvZnR3YXJlQUVTOiB0cnVlLFxuICAvLyB1c2VkIGJ5IGRlY3J5cHRlclxuICBzdGFydExldmVsOiB1bmRlZmluZWQsXG4gIC8vIHVzZWQgYnkgbGV2ZWwtY29udHJvbGxlclxuICBzdGFydEZyYWdQcmVmZXRjaDogZmFsc2UsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgZnBzRHJvcHBlZE1vbml0b3JpbmdQZXJpb2Q6IDUwMDAsXG4gIC8vIHVzZWQgYnkgZnBzLWNvbnRyb2xsZXJcbiAgZnBzRHJvcHBlZE1vbml0b3JpbmdUaHJlc2hvbGQ6IDAuMixcbiAgLy8gdXNlZCBieSBmcHMtY29udHJvbGxlclxuICBhcHBlbmRFcnJvck1heFJldHJ5OiAzLFxuICAvLyB1c2VkIGJ5IGJ1ZmZlci1jb250cm9sbGVyXG4gIGxvYWRlcjogWGhyTG9hZGVyLFxuICAvLyBsb2FkZXI6IEZldGNoTG9hZGVyLFxuICBmTG9hZGVyOiB1bmRlZmluZWQsXG4gIC8vIHVzZWQgYnkgZnJhZ21lbnQtbG9hZGVyXG4gIHBMb2FkZXI6IHVuZGVmaW5lZCxcbiAgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcbiAgeGhyU2V0dXA6IHVuZGVmaW5lZCxcbiAgLy8gdXNlZCBieSB4aHItbG9hZGVyXG4gIGxpY2Vuc2VYaHJTZXR1cDogdW5kZWZpbmVkLFxuICAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIGxpY2Vuc2VSZXNwb25zZUNhbGxiYWNrOiB1bmRlZmluZWQsXG4gIC8vIHVzZWQgYnkgZW1lLWNvbnRyb2xsZXJcbiAgYWJyQ29udHJvbGxlcjogQWJyQ29udHJvbGxlcixcbiAgYnVmZmVyQ29udHJvbGxlcjogQnVmZmVyQ29udHJvbGxlcixcbiAgY2FwTGV2ZWxDb250cm9sbGVyOiBDYXBMZXZlbENvbnRyb2xsZXIsXG4gIGVycm9yQ29udHJvbGxlcjogRXJyb3JDb250cm9sbGVyLFxuICBmcHNDb250cm9sbGVyOiBGUFNDb250cm9sbGVyLFxuICBzdHJldGNoU2hvcnRWaWRlb1RyYWNrOiBmYWxzZSxcbiAgLy8gdXNlZCBieSBtcDQtcmVtdXhlclxuICBtYXhBdWRpb0ZyYW1lc0RyaWZ0OiAxLFxuICAvLyB1c2VkIGJ5IG1wNC1yZW11eGVyXG4gIGZvcmNlS2V5RnJhbWVPbkRpc2NvbnRpbnVpdHk6IHRydWUsXG4gIC8vIHVzZWQgYnkgdHMtZGVtdXhlclxuICBhYnJFd21hRmFzdExpdmU6IDMsXG4gIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyRXdtYVNsb3dMaXZlOiA5LFxuICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIGFickV3bWFGYXN0Vm9EOiAzLFxuICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIGFickV3bWFTbG93Vm9EOiA5LFxuICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIGFickV3bWFEZWZhdWx0RXN0aW1hdGU6IDVlNSxcbiAgLy8gNTAwIGticHMgIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyRXdtYURlZmF1bHRFc3RpbWF0ZU1heDogNWU2LFxuICAvLyA1IG1icHNcbiAgYWJyQmFuZFdpZHRoRmFjdG9yOiAwLjk1LFxuICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIGFickJhbmRXaWR0aFVwRmFjdG9yOiAwLjcsXG4gIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyTWF4V2l0aFJlYWxCaXRyYXRlOiBmYWxzZSxcbiAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBtYXhTdGFydmF0aW9uRGVsYXk6IDQsXG4gIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgbWF4TG9hZGluZ0RlbGF5OiA0LFxuICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIG1pbkF1dG9CaXRyYXRlOiAwLFxuICAvLyB1c2VkIGJ5IGhsc1xuICBlbWVFbmFibGVkOiBmYWxzZSxcbiAgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICB3aWRldmluZUxpY2Vuc2VVcmw6IHVuZGVmaW5lZCxcbiAgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICBkcm1TeXN0ZW1zOiB7fSxcbiAgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICBkcm1TeXN0ZW1PcHRpb25zOiB7fSxcbiAgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NGdW5jOiByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgLFxuICAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIHRlc3RCYW5kd2lkdGg6IHRydWUsXG4gIHByb2dyZXNzaXZlOiBmYWxzZSxcbiAgbG93TGF0ZW5jeU1vZGU6IHRydWUsXG4gIGNtY2Q6IHVuZGVmaW5lZCxcbiAgZW5hYmxlRGF0ZVJhbmdlTWV0YWRhdGFDdWVzOiB0cnVlLFxuICBlbmFibGVFbXNnTWV0YWRhdGFDdWVzOiB0cnVlLFxuICBlbmFibGVJRDNNZXRhZGF0YUN1ZXM6IHRydWUsXG4gIHVzZU1lZGlhQ2FwYWJpbGl0aWVzOiB0cnVlLFxuICBjZXJ0TG9hZFBvbGljeToge1xuICAgIGRlZmF1bHQ6IGRlZmF1bHRMb2FkUG9saWN5XG4gIH0sXG4gIGtleUxvYWRQb2xpY3k6IHtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBtYXhUaW1lVG9GaXJzdEJ5dGVNczogODAwMCxcbiAgICAgIG1heExvYWRUaW1lTXM6IDIwMDAwLFxuICAgICAgdGltZW91dFJldHJ5OiB7XG4gICAgICAgIG1heE51bVJldHJ5OiAxLFxuICAgICAgICByZXRyeURlbGF5TXM6IDEwMDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXlNczogMjAwMDAsXG4gICAgICAgIGJhY2tvZmY6ICdsaW5lYXInXG4gICAgICB9LFxuICAgICAgZXJyb3JSZXRyeToge1xuICAgICAgICBtYXhOdW1SZXRyeTogOCxcbiAgICAgICAgcmV0cnlEZWxheU1zOiAxMDAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDIwMDAwLFxuICAgICAgICBiYWNrb2ZmOiAnbGluZWFyJ1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbWFuaWZlc3RMb2FkUG9saWN5OiB7XG4gICAgZGVmYXVsdDoge1xuICAgICAgbWF4VGltZVRvRmlyc3RCeXRlTXM6IEluZmluaXR5LFxuICAgICAgbWF4TG9hZFRpbWVNczogMjAwMDAsXG4gICAgICB0aW1lb3V0UmV0cnk6IHtcbiAgICAgICAgbWF4TnVtUmV0cnk6IDIsXG4gICAgICAgIHJldHJ5RGVsYXlNczogMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheU1zOiAwXG4gICAgICB9LFxuICAgICAgZXJyb3JSZXRyeToge1xuICAgICAgICBtYXhOdW1SZXRyeTogMSxcbiAgICAgICAgcmV0cnlEZWxheU1zOiAxMDAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDgwMDBcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHBsYXlsaXN0TG9hZFBvbGljeToge1xuICAgIGRlZmF1bHQ6IHtcbiAgICAgIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zOiAxMDAwMCxcbiAgICAgIG1heExvYWRUaW1lTXM6IDIwMDAwLFxuICAgICAgdGltZW91dFJldHJ5OiB7XG4gICAgICAgIG1heE51bVJldHJ5OiAyLFxuICAgICAgICByZXRyeURlbGF5TXM6IDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXlNczogMFxuICAgICAgfSxcbiAgICAgIGVycm9yUmV0cnk6IHtcbiAgICAgICAgbWF4TnVtUmV0cnk6IDIsXG4gICAgICAgIHJldHJ5RGVsYXlNczogMTAwMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheU1zOiA4MDAwXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBmcmFnTG9hZFBvbGljeToge1xuICAgIGRlZmF1bHQ6IHtcbiAgICAgIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zOiAxMDAwMCxcbiAgICAgIG1heExvYWRUaW1lTXM6IDEyMDAwMCxcbiAgICAgIHRpbWVvdXRSZXRyeToge1xuICAgICAgICBtYXhOdW1SZXRyeTogNCxcbiAgICAgICAgcmV0cnlEZWxheU1zOiAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDBcbiAgICAgIH0sXG4gICAgICBlcnJvclJldHJ5OiB7XG4gICAgICAgIG1heE51bVJldHJ5OiA2LFxuICAgICAgICByZXRyeURlbGF5TXM6IDEwMDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXlNczogODAwMFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgc3RlZXJpbmdNYW5pZmVzdExvYWRQb2xpY3k6IHtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBtYXhUaW1lVG9GaXJzdEJ5dGVNczogMTAwMDAsXG4gICAgICBtYXhMb2FkVGltZU1zOiAyMDAwMCxcbiAgICAgIHRpbWVvdXRSZXRyeToge1xuICAgICAgICBtYXhOdW1SZXRyeTogMixcbiAgICAgICAgcmV0cnlEZWxheU1zOiAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDBcbiAgICAgIH0sXG4gICAgICBlcnJvclJldHJ5OiB7XG4gICAgICAgIG1heE51bVJldHJ5OiAxLFxuICAgICAgICByZXRyeURlbGF5TXM6IDEwMDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXlNczogODAwMFxuICAgICAgfVxuICAgIH0gXG4gIH0sXG4gIC8vIFRoZXNlIGRlZmF1bHQgc2V0dGluZ3MgYXJlIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgdGhlIGFib3ZlIHBvbGljaWVzXG4gIC8vIGFuZCBhcmUgbWFpbnRhaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgbWFuaWZlc3RMb2FkaW5nVGltZU91dDogMTAwMDAsXG4gIG1hbmlmZXN0TG9hZGluZ01heFJldHJ5OiAxLFxuICBtYW5pZmVzdExvYWRpbmdSZXRyeURlbGF5OiAxMDAwLFxuICBtYW5pZmVzdExvYWRpbmdNYXhSZXRyeVRpbWVvdXQ6IDY0MDAwLFxuICBsZXZlbExvYWRpbmdUaW1lT3V0OiAxMDAwMCxcbiAgbGV2ZWxMb2FkaW5nTWF4UmV0cnk6IDQsXG4gIGxldmVsTG9hZGluZ1JldHJ5RGVsYXk6IDEwMDAsXG4gIGxldmVsTG9hZGluZ01heFJldHJ5VGltZW91dDogNjQwMDAsXG4gIGZyYWdMb2FkaW5nVGltZU91dDogMjAwMDAsXG4gIGZyYWdMb2FkaW5nTWF4UmV0cnk6IDYsXG4gIGZyYWdMb2FkaW5nUmV0cnlEZWxheTogMTAwMCxcbiAgZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXQ6IDY0MDAwXG59LCB0aW1lbGluZUNvbmZpZygpKSwge30sIHtcbiAgc3VidGl0bGVTdHJlYW1Db250cm9sbGVyOiBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIgLFxuICBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjogU3VidGl0bGVUcmFja0NvbnRyb2xsZXIgLFxuICB0aW1lbGluZUNvbnRyb2xsZXI6IFRpbWVsaW5lQ29udHJvbGxlciAsXG4gIGF1ZGlvU3RyZWFtQ29udHJvbGxlcjogQXVkaW9TdHJlYW1Db250cm9sbGVyICxcbiAgYXVkaW9UcmFja0NvbnRyb2xsZXI6IEF1ZGlvVHJhY2tDb250cm9sbGVyICxcbiAgZW1lQ29udHJvbGxlcjogRU1FQ29udHJvbGxlciAsXG4gIGNtY2RDb250cm9sbGVyOiBDTUNEQ29udHJvbGxlciAsXG4gIGNvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXI6IENvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXIgXG59KTtcbmZ1bmN0aW9uIHRpbWVsaW5lQ29uZmlnKCkge1xuICByZXR1cm4ge1xuICAgIGN1ZUhhbmRsZXI6IEN1ZXMsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgZW5hYmxlV2ViVlRUOiB0cnVlLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGVuYWJsZUlNU0MxOiB0cnVlLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGVuYWJsZUNFQTcwOENhcHRpb25zOiB0cnVlLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrMUxhYmVsOiAnRW5nbGlzaCcsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgY2FwdGlvbnNUZXh0VHJhY2sxTGFuZ3VhZ2VDb2RlOiAnZW4nLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrMkxhYmVsOiAnU3BhbmlzaCcsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgY2FwdGlvbnNUZXh0VHJhY2syTGFuZ3VhZ2VDb2RlOiAnZXMnLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrM0xhYmVsOiAnVW5rbm93biBDQycsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgY2FwdGlvbnNUZXh0VHJhY2szTGFuZ3VhZ2VDb2RlOiAnJyxcbiAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBjYXB0aW9uc1RleHRUcmFjazRMYWJlbDogJ1Vua25vd24gQ0MnLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrNExhbmd1YWdlQ29kZTogJycsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgcmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5OiB0cnVlXG4gIH07XG59XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBtZXJnZUNvbmZpZyhkZWZhdWx0Q29uZmlnLCB1c2VyQ29uZmlnKSB7XG4gIGlmICgodXNlckNvbmZpZy5saXZlU3luY0R1cmF0aW9uQ291bnQgfHwgdXNlckNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQpICYmICh1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb24gfHwgdXNlckNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgaGxzLmpzIGNvbmZpZzogZG9uJ3QgbWl4IHVwIGxpdmVTeW5jRHVyYXRpb25Db3VudC9saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgYW5kIGxpdmVTeW5jRHVyYXRpb24vbGl2ZU1heExhdGVuY3lEdXJhdGlvblwiKTtcbiAgfVxuICBpZiAodXNlckNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgIT09IHVuZGVmaW5lZCAmJiAodXNlckNvbmZpZy5saXZlU3luY0R1cmF0aW9uQ291bnQgPT09IHVuZGVmaW5lZCB8fCB1c2VyQ29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCA8PSB1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgaGxzLmpzIGNvbmZpZzogXCJsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnRcIiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBcImxpdmVTeW5jRHVyYXRpb25Db3VudFwiJyk7XG4gIH1cbiAgaWYgKHVzZXJDb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiAhPT0gdW5kZWZpbmVkICYmICh1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb24gPT09IHVuZGVmaW5lZCB8fCB1c2VyQ29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gPD0gdXNlckNvbmZpZy5saXZlU3luY0R1cmF0aW9uKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBobHMuanMgY29uZmlnOiBcImxpdmVNYXhMYXRlbmN5RHVyYXRpb25cIiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBcImxpdmVTeW5jRHVyYXRpb25cIicpO1xuICB9XG4gIGNvbnN0IGRlZmF1bHRzQ29weSA9IGRlZXBDcHkoZGVmYXVsdENvbmZpZyk7XG5cbiAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCBkZXByZWNhdGVkIGNvbmZpZyB2YWx1ZXNcbiAgY29uc3QgZGVwcmVjYXRlZFNldHRpbmdUeXBlcyA9IFsnbWFuaWZlc3QnLCAnbGV2ZWwnLCAnZnJhZyddO1xuICBjb25zdCBkZXByZWNhdGVkU2V0dGluZ3MgPSBbJ1RpbWVPdXQnLCAnTWF4UmV0cnknLCAnUmV0cnlEZWxheScsICdNYXhSZXRyeVRpbWVvdXQnXTtcbiAgZGVwcmVjYXRlZFNldHRpbmdUeXBlcy5mb3JFYWNoKHR5cGUgPT4ge1xuICAgIGNvbnN0IHBvbGljeU5hbWUgPSBgJHt0eXBlID09PSAnbGV2ZWwnID8gJ3BsYXlsaXN0JyA6IHR5cGV9TG9hZFBvbGljeWA7XG4gICAgY29uc3QgcG9saWN5Tm90U2V0ID0gdXNlckNvbmZpZ1twb2xpY3lOYW1lXSA9PT0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHJlcG9ydCA9IFtdO1xuICAgIGRlcHJlY2F0ZWRTZXR0aW5ncy5mb3JFYWNoKHNldHRpbmcgPT4ge1xuICAgICAgY29uc3QgZGVwcmVjYXRlZFNldHRpbmcgPSBgJHt0eXBlfUxvYWRpbmcke3NldHRpbmd9YDtcbiAgICAgIGNvbnN0IHZhbHVlID0gdXNlckNvbmZpZ1tkZXByZWNhdGVkU2V0dGluZ107XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwb2xpY3lOb3RTZXQpIHtcbiAgICAgICAgcmVwb3J0LnB1c2goZGVwcmVjYXRlZFNldHRpbmcpO1xuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGRlZmF1bHRzQ29weVtwb2xpY3lOYW1lXS5kZWZhdWx0O1xuICAgICAgICB1c2VyQ29uZmlnW3BvbGljeU5hbWVdID0ge1xuICAgICAgICAgIGRlZmF1bHQ6IHNldHRpbmdzXG4gICAgICAgIH07XG4gICAgICAgIHN3aXRjaCAoc2V0dGluZykge1xuICAgICAgICAgIGNhc2UgJ1RpbWVPdXQnOlxuICAgICAgICAgICAgc2V0dGluZ3MubWF4TG9hZFRpbWVNcyA9IHZhbHVlO1xuICAgICAgICAgICAgc2V0dGluZ3MubWF4VGltZVRvRmlyc3RCeXRlTXMgPSB2YWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ01heFJldHJ5JzpcbiAgICAgICAgICAgIHNldHRpbmdzLmVycm9yUmV0cnkubWF4TnVtUmV0cnkgPSB2YWx1ZTtcbiAgICAgICAgICAgIHNldHRpbmdzLnRpbWVvdXRSZXRyeS5tYXhOdW1SZXRyeSA9IHZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnUmV0cnlEZWxheSc6XG4gICAgICAgICAgICBzZXR0aW5ncy5lcnJvclJldHJ5LnJldHJ5RGVsYXlNcyA9IHZhbHVlO1xuICAgICAgICAgICAgc2V0dGluZ3MudGltZW91dFJldHJ5LnJldHJ5RGVsYXlNcyA9IHZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnTWF4UmV0cnlUaW1lb3V0JzpcbiAgICAgICAgICAgIHNldHRpbmdzLmVycm9yUmV0cnkubWF4UmV0cnlEZWxheU1zID0gdmFsdWU7XG4gICAgICAgICAgICBzZXR0aW5ncy50aW1lb3V0UmV0cnkubWF4UmV0cnlEZWxheU1zID0gdmFsdWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChyZXBvcnQubGVuZ3RoKSB7XG4gICAgICBsb2dnZXIud2FybihgaGxzLmpzIGNvbmZpZzogXCIke3JlcG9ydC5qb2luKCdcIiwgXCInKX1cIiBzZXR0aW5nKHMpIGFyZSBkZXByZWNhdGVkLCB1c2UgXCIke3BvbGljeU5hbWV9XCI6ICR7SlNPTi5zdHJpbmdpZnkodXNlckNvbmZpZ1twb2xpY3lOYW1lXSl9YCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBkZWZhdWx0c0NvcHkpLCB1c2VyQ29uZmlnKTtcbn1cbmZ1bmN0aW9uIGRlZXBDcHkob2JqKSB7XG4gIGlmIChvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICByZXR1cm4gb2JqLm1hcChkZWVwQ3B5KTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikucmVkdWNlKChyZXN1bHQsIGtleSkgPT4ge1xuICAgICAgcmVzdWx0W2tleV0gPSBkZWVwQ3B5KG9ialtrZXldKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwge30pO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBlbmFibGVTdHJlYW1pbmdNb2RlKGNvbmZpZykge1xuICBjb25zdCBjdXJyZW50TG9hZGVyID0gY29uZmlnLmxvYWRlcjtcbiAgaWYgKGN1cnJlbnRMb2FkZXIgIT09IEZldGNoTG9hZGVyICYmIGN1cnJlbnRMb2FkZXIgIT09IFhockxvYWRlcikge1xuICAgIC8vIElmIGEgZGV2ZWxvcGVyIGhhcyBjb25maWd1cmVkIHRoZWlyIG93biBsb2FkZXIsIHJlc3BlY3QgdGhhdCBjaG9pY2VcbiAgICBsb2dnZXIubG9nKCdbY29uZmlnXTogQ3VzdG9tIGxvYWRlciBkZXRlY3RlZCwgY2Fubm90IGVuYWJsZSBwcm9ncmVzc2l2ZSBzdHJlYW1pbmcnKTtcbiAgICBjb25maWcucHJvZ3Jlc3NpdmUgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjYW5TdHJlYW1Qcm9ncmVzc2l2ZWx5ID0gZmV0Y2hTdXBwb3J0ZWQoKTtcbiAgICBpZiAoY2FuU3RyZWFtUHJvZ3Jlc3NpdmVseSkge1xuICAgICAgY29uZmlnLmxvYWRlciA9IEZldGNoTG9hZGVyO1xuICAgICAgY29uZmlnLnByb2dyZXNzaXZlID0gdHJ1ZTtcbiAgICAgIGNvbmZpZy5lbmFibGVTb2Z0d2FyZUFFUyA9IHRydWU7XG4gICAgICBsb2dnZXIubG9nKCdbY29uZmlnXTogUHJvZ3Jlc3NpdmUgc3RyZWFtaW5nIGVuYWJsZWQsIHVzaW5nIEZldGNoTG9hZGVyJyk7XG4gICAgfVxuICB9XG59XG5cbmxldCBjaHJvbWVPckZpcmVmb3g7XG5jbGFzcyBMZXZlbENvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlUGxheWxpc3RDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoaGxzLCBjb250ZW50U3RlZXJpbmdDb250cm9sbGVyKSB7XG4gICAgc3VwZXIoaGxzLCAnW2xldmVsLWNvbnRyb2xsZXJdJyk7XG4gICAgdGhpcy5fbGV2ZWxzID0gW107XG4gICAgdGhpcy5fZmlyc3RMZXZlbCA9IC0xO1xuICAgIHRoaXMuX21heEF1dG9MZXZlbCA9IC0xO1xuICAgIHRoaXMuX3N0YXJ0TGV2ZWwgPSB2b2lkIDA7XG4gICAgdGhpcy5jdXJyZW50TGV2ZWwgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudExldmVsSW5kZXggPSAtMTtcbiAgICB0aGlzLm1hbnVhbExldmVsSW5kZXggPSAtMTtcbiAgICB0aGlzLnN0ZWVyaW5nID0gdm9pZCAwO1xuICAgIHRoaXMub25QYXJzZWRDb21wbGV0ZSA9IHZvaWQgMDtcbiAgICB0aGlzLnN0ZWVyaW5nID0gY29udGVudFN0ZWVyaW5nQ29udHJvbGxlcjtcbiAgICB0aGlzLl9yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIF9yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxTX1VQREFURUQsIHRoaXMub25MZXZlbHNVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH1cbiAgX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTFNfVVBEQVRFRCwgdGhpcy5vbkxldmVsc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fdW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHRoaXMuc3RlZXJpbmcgPSBudWxsO1xuICAgIHRoaXMucmVzZXRMZXZlbHMoKTtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cbiAgc3RvcExvYWQoKSB7XG4gICAgY29uc3QgbGV2ZWxzID0gdGhpcy5fbGV2ZWxzO1xuXG4gICAgLy8gY2xlYW4gdXAgbGl2ZSBsZXZlbCBkZXRhaWxzIHRvIGZvcmNlIHJlbG9hZCB0aGVtLCBhbmQgcmVzZXQgbG9hZCBlcnJvcnNcbiAgICBsZXZlbHMuZm9yRWFjaChsZXZlbCA9PiB7XG4gICAgICBsZXZlbC5sb2FkRXJyb3IgPSAwO1xuICAgICAgbGV2ZWwuZnJhZ21lbnRFcnJvciA9IDA7XG4gICAgfSk7XG4gICAgc3VwZXIuc3RvcExvYWQoKTtcbiAgfVxuICByZXNldExldmVscygpIHtcbiAgICB0aGlzLl9zdGFydExldmVsID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWFudWFsTGV2ZWxJbmRleCA9IC0xO1xuICAgIHRoaXMuY3VycmVudExldmVsSW5kZXggPSAtMTtcbiAgICB0aGlzLmN1cnJlbnRMZXZlbCA9IG51bGw7XG4gICAgdGhpcy5fbGV2ZWxzID0gW107XG4gICAgdGhpcy5fbWF4QXV0b0xldmVsID0gLTE7XG4gIH1cbiAgb25NYW5pZmVzdExvYWRpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLnJlc2V0TGV2ZWxzKCk7XG4gIH1cbiAgb25NYW5pZmVzdExvYWRlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSA9IHRoaXMuaGxzLmNvbmZpZy5wcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2U7XG4gICAgY29uc3QgbGV2ZWxzID0gW107XG4gICAgY29uc3QgcmVkdW5kYW50U2V0ID0ge307XG4gICAgY29uc3QgZ2VuZXJhdGVQYXRod2F5U2V0ID0ge307XG4gICAgbGV0IHJlc29sdXRpb25Gb3VuZCA9IGZhbHNlO1xuICAgIGxldCB2aWRlb0NvZGVjRm91bmQgPSBmYWxzZTtcbiAgICBsZXQgYXVkaW9Db2RlY0ZvdW5kID0gZmFsc2U7XG4gICAgZGF0YS5sZXZlbHMuZm9yRWFjaChsZXZlbFBhcnNlZCA9PiB7XG4gICAgICB2YXIgX2F1ZGlvQ29kZWMsIF92aWRlb0NvZGVjO1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGxldmVsUGFyc2VkLmF0dHJzO1xuXG4gICAgICAvLyBlcmFzZSBhdWRpbyBjb2RlYyBpbmZvIGlmIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBtcDRhLjQwLjM0LlxuICAgICAgLy8gZGVtdXhlciB3aWxsIGF1dG9kZXRlY3QgY29kZWMgYW5kIGZhbGxiYWNrIHRvIG1wZWcvYXVkaW9cbiAgICAgIGxldCB7XG4gICAgICAgIGF1ZGlvQ29kZWMsXG4gICAgICAgIHZpZGVvQ29kZWNcbiAgICAgIH0gPSBsZXZlbFBhcnNlZDtcbiAgICAgIGlmICgoKF9hdWRpb0NvZGVjID0gYXVkaW9Db2RlYykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuMzQnKSkgIT09IC0xKSB7XG4gICAgICAgIGNocm9tZU9yRmlyZWZveCB8fCAoY2hyb21lT3JGaXJlZm94ID0gL2Nocm9tZXxmaXJlZm94L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSk7XG4gICAgICAgIGlmIChjaHJvbWVPckZpcmVmb3gpIHtcbiAgICAgICAgICBsZXZlbFBhcnNlZC5hdWRpb0NvZGVjID0gYXVkaW9Db2RlYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGF1ZGlvQ29kZWMpIHtcbiAgICAgICAgbGV2ZWxQYXJzZWQuYXVkaW9Db2RlYyA9IGF1ZGlvQ29kZWMgPSBnZXRDb2RlY0NvbXBhdGlibGVOYW1lKGF1ZGlvQ29kZWMsIHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSk7XG4gICAgICB9XG4gICAgICBpZiAoKChfdmlkZW9Db2RlYyA9IHZpZGVvQ29kZWMpID09IG51bGwgPyB2b2lkIDAgOiBfdmlkZW9Db2RlYy5pbmRleE9mKCdhdmMxJykpID09PSAwKSB7XG4gICAgICAgIHZpZGVvQ29kZWMgPSBsZXZlbFBhcnNlZC52aWRlb0NvZGVjID0gY29udmVydEFWQzFUb0FWQ09USSh2aWRlb0NvZGVjKTtcbiAgICAgIH1cblxuICAgICAgLy8gb25seSBrZWVwIGxldmVscyB3aXRoIHN1cHBvcnRlZCBhdWRpby92aWRlbyBjb2RlY3NcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgdW5rbm93bkNvZGVjc1xuICAgICAgfSA9IGxldmVsUGFyc2VkO1xuICAgICAgcmVzb2x1dGlvbkZvdW5kIHx8IChyZXNvbHV0aW9uRm91bmQgPSAhISh3aWR0aCAmJiBoZWlnaHQpKTtcbiAgICAgIHZpZGVvQ29kZWNGb3VuZCB8fCAodmlkZW9Db2RlY0ZvdW5kID0gISF2aWRlb0NvZGVjKTtcbiAgICAgIGF1ZGlvQ29kZWNGb3VuZCB8fCAoYXVkaW9Db2RlY0ZvdW5kID0gISFhdWRpb0NvZGVjKTtcbiAgICAgIGlmICh1bmtub3duQ29kZWNzICE9IG51bGwgJiYgdW5rbm93bkNvZGVjcy5sZW5ndGggfHwgYXVkaW9Db2RlYyAmJiAhYXJlQ29kZWNzTWVkaWFTb3VyY2VTdXBwb3J0ZWQoYXVkaW9Db2RlYywgJ2F1ZGlvJywgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlKSB8fCB2aWRlb0NvZGVjICYmICFhcmVDb2RlY3NNZWRpYVNvdXJjZVN1cHBvcnRlZCh2aWRlb0NvZGVjLCAndmlkZW8nLCBwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgQ09ERUNTLFxuICAgICAgICAnRlJBTUUtUkFURSc6IEZSQU1FUkFURSxcbiAgICAgICAgJ0hEQ1AtTEVWRUwnOiBIRENQLFxuICAgICAgICAnUEFUSFdBWS1JRCc6IFBBVEhXQVksXG4gICAgICAgIFJFU09MVVRJT04sXG4gICAgICAgICdWSURFTy1SQU5HRSc6IFZJREVPX1JBTkdFXG4gICAgICB9ID0gYXR0cmlidXRlcztcbiAgICAgIGNvbnN0IGNvbnRlbnRTdGVlcmluZ1ByZWZpeCA9IGAke1BBVEhXQVkgfHwgJy4nfS1gO1xuICAgICAgY29uc3QgbGV2ZWxLZXkgPSBgJHtjb250ZW50U3RlZXJpbmdQcmVmaXh9JHtsZXZlbFBhcnNlZC5iaXRyYXRlfS0ke1JFU09MVVRJT059LSR7RlJBTUVSQVRFfS0ke0NPREVDU30tJHtWSURFT19SQU5HRX0tJHtIRENQfWA7XG4gICAgICBpZiAoIXJlZHVuZGFudFNldFtsZXZlbEtleV0pIHtcbiAgICAgICAgY29uc3QgbGV2ZWwgPSBuZXcgTGV2ZWwobGV2ZWxQYXJzZWQpO1xuICAgICAgICByZWR1bmRhbnRTZXRbbGV2ZWxLZXldID0gbGV2ZWw7XG4gICAgICAgIGdlbmVyYXRlUGF0aHdheVNldFtsZXZlbEtleV0gPSAxO1xuICAgICAgICBsZXZlbHMucHVzaChsZXZlbCk7XG4gICAgICB9IGVsc2UgaWYgKHJlZHVuZGFudFNldFtsZXZlbEtleV0udXJpICE9PSBsZXZlbFBhcnNlZC51cmwgJiYgIWxldmVsUGFyc2VkLmF0dHJzWydQQVRIV0FZLUlEJ10pIHtcbiAgICAgICAgLy8gQXNzaWduIFBhdGh3YXkgSURzIHRvIFJlZHVuZGFudCBTdHJlYW1zIChkZWZhdWx0IFBhdGh3YXlzIGlzIFwiLlwiLiBSZWR1bmRhbnQgU3RyZWFtcyBcIi4uXCIsIFwiLi4uXCIsIGFuZCBzbyBvbi4pXG4gICAgICAgIC8vIENvbnRlbnQgU3RlZXJpbmcgY29udHJvbGxlciB0byBoYW5kbGVzIFBhdGh3YXkgZmFsbGJhY2sgb24gZXJyb3JcbiAgICAgICAgY29uc3QgcGF0aHdheUNvdW50ID0gZ2VuZXJhdGVQYXRod2F5U2V0W2xldmVsS2V5XSArPSAxO1xuICAgICAgICBsZXZlbFBhcnNlZC5hdHRyc1snUEFUSFdBWS1JRCddID0gbmV3IEFycmF5KHBhdGh3YXlDb3VudCArIDEpLmpvaW4oJy4nKTtcbiAgICAgICAgY29uc3QgbGV2ZWwgPSBuZXcgTGV2ZWwobGV2ZWxQYXJzZWQpO1xuICAgICAgICByZWR1bmRhbnRTZXRbbGV2ZWxLZXldID0gbGV2ZWw7XG4gICAgICAgIGxldmVscy5wdXNoKGxldmVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZHVuZGFudFNldFtsZXZlbEtleV0uYWRkR3JvdXBJZCgnYXVkaW8nLCBhdHRyaWJ1dGVzLkFVRElPKTtcbiAgICAgICAgcmVkdW5kYW50U2V0W2xldmVsS2V5XS5hZGRHcm91cElkKCd0ZXh0JywgYXR0cmlidXRlcy5TVUJUSVRMRVMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZmlsdGVyQW5kU29ydE1lZGlhT3B0aW9ucyhsZXZlbHMsIGRhdGEsIHJlc29sdXRpb25Gb3VuZCwgdmlkZW9Db2RlY0ZvdW5kLCBhdWRpb0NvZGVjRm91bmQpO1xuICB9XG4gIGZpbHRlckFuZFNvcnRNZWRpYU9wdGlvbnMoZmlsdGVyZWRMZXZlbHMsIGRhdGEsIHJlc29sdXRpb25Gb3VuZCwgdmlkZW9Db2RlY0ZvdW5kLCBhdWRpb0NvZGVjRm91bmQpIHtcbiAgICBsZXQgYXVkaW9UcmFja3MgPSBbXTtcbiAgICBsZXQgc3VidGl0bGVUcmFja3MgPSBbXTtcbiAgICBsZXQgbGV2ZWxzID0gZmlsdGVyZWRMZXZlbHM7XG5cbiAgICAvLyByZW1vdmUgYXVkaW8tb25seSBhbmQgaW52YWxpZCB2aWRlby1yYW5nZSBsZXZlbHMgaWYgd2UgYWxzbyBoYXZlIGxldmVscyB3aXRoIHZpZGVvIGNvZGVjcyBvciBSRVNPTFVUSU9OIHNpZ25hbGxlZFxuICAgIGlmICgocmVzb2x1dGlvbkZvdW5kIHx8IHZpZGVvQ29kZWNGb3VuZCkgJiYgYXVkaW9Db2RlY0ZvdW5kKSB7XG4gICAgICBsZXZlbHMgPSBsZXZlbHMuZmlsdGVyKCh7XG4gICAgICAgIHZpZGVvQ29kZWMsXG4gICAgICAgIHZpZGVvUmFuZ2UsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0pID0+ICghIXZpZGVvQ29kZWMgfHwgISEod2lkdGggJiYgaGVpZ2h0KSkgJiYgaXNWaWRlb1JhbmdlKHZpZGVvUmFuZ2UpKTtcbiAgICB9XG4gICAgaWYgKGxldmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIERpc3BhdGNoIGVycm9yIGFmdGVyIE1BTklGRVNUX0xPQURFRCBpcyBkb25lIHByb3BhZ2F0aW5nXG4gICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuaGxzKSB7XG4gICAgICAgICAgaWYgKGRhdGEubGV2ZWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy53YXJuKGBPbmUgb3IgbW9yZSBDT0RFQ1MgaW4gdmFyaWFudCBub3Qgc3VwcG9ydGVkOiAke0pTT04uc3RyaW5naWZ5KGRhdGEubGV2ZWxzWzBdLmF0dHJzKX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ25vIGxldmVsIHdpdGggY29tcGF0aWJsZSBjb2RlY3MgZm91bmQgaW4gbWFuaWZlc3QnKTtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5NQU5JRkVTVF9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SLFxuICAgICAgICAgICAgZmF0YWw6IHRydWUsXG4gICAgICAgICAgICB1cmw6IGRhdGEudXJsLFxuICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICByZWFzb246IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkYXRhLmF1ZGlvVHJhY2tzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZVxuICAgICAgfSA9IHRoaXMuaGxzLmNvbmZpZztcbiAgICAgIGF1ZGlvVHJhY2tzID0gZGF0YS5hdWRpb1RyYWNrcy5maWx0ZXIodHJhY2sgPT4gIXRyYWNrLmF1ZGlvQ29kZWMgfHwgYXJlQ29kZWNzTWVkaWFTb3VyY2VTdXBwb3J0ZWQodHJhY2suYXVkaW9Db2RlYywgJ2F1ZGlvJywgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlKSk7XG4gICAgICAvLyBBc3NpZ24gaWRzIGFmdGVyIGZpbHRlcmluZyBhcyBhcnJheSBpbmRpY2VzIGJ5IGdyb3VwLWlkXG4gICAgICBhc3NpZ25UcmFja0lkc0J5R3JvdXAoYXVkaW9UcmFja3MpO1xuICAgIH1cbiAgICBpZiAoZGF0YS5zdWJ0aXRsZXMpIHtcbiAgICAgIHN1YnRpdGxlVHJhY2tzID0gZGF0YS5zdWJ0aXRsZXM7XG4gICAgICBhc3NpZ25UcmFja0lkc0J5R3JvdXAoc3VidGl0bGVUcmFja3MpO1xuICAgIH1cbiAgICAvLyBzdGFydCBiaXRyYXRlIGlzIHRoZSBmaXJzdCBiaXRyYXRlIG9mIHRoZSBtYW5pZmVzdFxuICAgIGNvbnN0IHVuc29ydGVkTGV2ZWxzID0gbGV2ZWxzLnNsaWNlKDApO1xuICAgIC8vIHNvcnQgbGV2ZWxzIGZyb20gbG93ZXN0IHRvIGhpZ2hlc3RcbiAgICBsZXZlbHMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgaWYgKGEuYXR0cnNbJ0hEQ1AtTEVWRUwnXSAhPT0gYi5hdHRyc1snSERDUC1MRVZFTCddKSB7XG4gICAgICAgIHJldHVybiAoYS5hdHRyc1snSERDUC1MRVZFTCddIHx8ICcnKSA+IChiLmF0dHJzWydIRENQLUxFVkVMJ10gfHwgJycpID8gMSA6IC0xO1xuICAgICAgfVxuICAgICAgLy8gc29ydCBvbiBoZWlnaHQgYmVmb3JlIGJpdHJhdGUgZm9yIGNhcC1sZXZlbC1jb250cm9sbGVyXG4gICAgICBpZiAocmVzb2x1dGlvbkZvdW5kICYmIGEuaGVpZ2h0ICE9PSBiLmhlaWdodCkge1xuICAgICAgICByZXR1cm4gYS5oZWlnaHQgLSBiLmhlaWdodDtcbiAgICAgIH1cbiAgICAgIGlmIChhLmZyYW1lUmF0ZSAhPT0gYi5mcmFtZVJhdGUpIHtcbiAgICAgICAgcmV0dXJuIGEuZnJhbWVSYXRlIC0gYi5mcmFtZVJhdGU7XG4gICAgICB9XG4gICAgICBpZiAoYS52aWRlb1JhbmdlICE9PSBiLnZpZGVvUmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIFZpZGVvUmFuZ2VWYWx1ZXMuaW5kZXhPZihhLnZpZGVvUmFuZ2UpIC0gVmlkZW9SYW5nZVZhbHVlcy5pbmRleE9mKGIudmlkZW9SYW5nZSk7XG4gICAgICB9XG4gICAgICBpZiAoYS52aWRlb0NvZGVjICE9PSBiLnZpZGVvQ29kZWMpIHtcbiAgICAgICAgY29uc3QgdmFsdWVBID0gdmlkZW9Db2RlY1ByZWZlcmVuY2VWYWx1ZShhLnZpZGVvQ29kZWMpO1xuICAgICAgICBjb25zdCB2YWx1ZUIgPSB2aWRlb0NvZGVjUHJlZmVyZW5jZVZhbHVlKGIudmlkZW9Db2RlYyk7XG4gICAgICAgIGlmICh2YWx1ZUEgIT09IHZhbHVlQikge1xuICAgICAgICAgIHJldHVybiB2YWx1ZUIgLSB2YWx1ZUE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhLnVyaSA9PT0gYi51cmkgJiYgYS5jb2RlY1NldCAhPT0gYi5jb2RlY1NldCkge1xuICAgICAgICBjb25zdCB2YWx1ZUEgPSBjb2RlY3NTZXRTZWxlY3Rpb25QcmVmZXJlbmNlVmFsdWUoYS5jb2RlY1NldCk7XG4gICAgICAgIGNvbnN0IHZhbHVlQiA9IGNvZGVjc1NldFNlbGVjdGlvblByZWZlcmVuY2VWYWx1ZShiLmNvZGVjU2V0KTtcbiAgICAgICAgaWYgKHZhbHVlQSAhPT0gdmFsdWVCKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlQiAtIHZhbHVlQTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGEuYXZlcmFnZUJpdHJhdGUgIT09IGIuYXZlcmFnZUJpdHJhdGUpIHtcbiAgICAgICAgcmV0dXJuIGEuYXZlcmFnZUJpdHJhdGUgLSBiLmF2ZXJhZ2VCaXRyYXRlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSk7XG4gICAgbGV0IGZpcnN0TGV2ZWxJblBsYXlsaXN0ID0gdW5zb3J0ZWRMZXZlbHNbMF07XG4gICAgaWYgKHRoaXMuc3RlZXJpbmcpIHtcbiAgICAgIGxldmVscyA9IHRoaXMuc3RlZXJpbmcuZmlsdGVyUGFyc2VkTGV2ZWxzKGxldmVscyk7XG4gICAgICBpZiAobGV2ZWxzLmxlbmd0aCAhPT0gdW5zb3J0ZWRMZXZlbHMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdW5zb3J0ZWRMZXZlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodW5zb3J0ZWRMZXZlbHNbaV0ucGF0aHdheUlkID09PSBsZXZlbHNbMF0ucGF0aHdheUlkKSB7XG4gICAgICAgICAgICBmaXJzdExldmVsSW5QbGF5bGlzdCA9IHVuc29ydGVkTGV2ZWxzW2ldO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2xldmVscyA9IGxldmVscztcblxuICAgIC8vIGZpbmQgaW5kZXggb2YgZmlyc3QgbGV2ZWwgaW4gc29ydGVkIGxldmVsc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGV2ZWxzW2ldID09PSBmaXJzdExldmVsSW5QbGF5bGlzdCkge1xuICAgICAgICB2YXIgX3RoaXMkaGxzJHVzZXJDb25maWc7XG4gICAgICAgIHRoaXMuX2ZpcnN0TGV2ZWwgPSBpO1xuICAgICAgICBjb25zdCBmaXJzdExldmVsQml0cmF0ZSA9IGZpcnN0TGV2ZWxJblBsYXlsaXN0LmJpdHJhdGU7XG4gICAgICAgIGNvbnN0IGJhbmR3aWR0aEVzdGltYXRlID0gdGhpcy5obHMuYmFuZHdpZHRoRXN0aW1hdGU7XG4gICAgICAgIHRoaXMubG9nKGBtYW5pZmVzdCBsb2FkZWQsICR7bGV2ZWxzLmxlbmd0aH0gbGV2ZWwocykgZm91bmQsIGZpcnN0IGJpdHJhdGU6ICR7Zmlyc3RMZXZlbEJpdHJhdGV9YCk7XG4gICAgICAgIC8vIFVwZGF0ZSBkZWZhdWx0IGJ3ZSB0byBmaXJzdCB2YXJpYW50IGJpdHJhdGUgYXMgbG9uZyBpdCBoYXMgbm90IGJlZW4gY29uZmlndXJlZCBvciBzZXRcbiAgICAgICAgaWYgKCgoX3RoaXMkaGxzJHVzZXJDb25maWcgPSB0aGlzLmhscy51c2VyQ29uZmlnKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkaGxzJHVzZXJDb25maWcuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZSkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbnN0IHN0YXJ0aW5nQndFc3RpbWF0ZSA9IE1hdGgubWluKGZpcnN0TGV2ZWxCaXRyYXRlLCB0aGlzLmhscy5jb25maWcuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZU1heCk7XG4gICAgICAgICAgaWYgKHN0YXJ0aW5nQndFc3RpbWF0ZSA+IGJhbmR3aWR0aEVzdGltYXRlICYmIGJhbmR3aWR0aEVzdGltYXRlID09PSBobHNEZWZhdWx0Q29uZmlnLmFickV3bWFEZWZhdWx0RXN0aW1hdGUpIHtcbiAgICAgICAgICAgIHRoaXMuaGxzLmJhbmR3aWR0aEVzdGltYXRlID0gc3RhcnRpbmdCd0VzdGltYXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBdWRpbyBpcyBvbmx5IGFsdGVybmF0ZSBpZiBtYW5pZmVzdCBpbmNsdWRlIGEgVVJJIGFsb25nIHdpdGggdGhlIGF1ZGlvIGdyb3VwIHRhZyxcbiAgICAvLyBhbmQgdGhpcyBpcyBub3QgYW4gYXVkaW8tb25seSBzdHJlYW0gd2hlcmUgbGV2ZWxzIGNvbnRhaW4gYXVkaW8tb25seVxuICAgIGNvbnN0IGF1ZGlvT25seSA9IGF1ZGlvQ29kZWNGb3VuZCAmJiAhdmlkZW9Db2RlY0ZvdW5kO1xuICAgIGNvbnN0IGVkYXRhID0ge1xuICAgICAgbGV2ZWxzLFxuICAgICAgYXVkaW9UcmFja3MsXG4gICAgICBzdWJ0aXRsZVRyYWNrcyxcbiAgICAgIHNlc3Npb25EYXRhOiBkYXRhLnNlc3Npb25EYXRhLFxuICAgICAgc2Vzc2lvbktleXM6IGRhdGEuc2Vzc2lvbktleXMsXG4gICAgICBmaXJzdExldmVsOiB0aGlzLl9maXJzdExldmVsLFxuICAgICAgc3RhdHM6IGRhdGEuc3RhdHMsXG4gICAgICBhdWRpbzogYXVkaW9Db2RlY0ZvdW5kLFxuICAgICAgdmlkZW86IHZpZGVvQ29kZWNGb3VuZCxcbiAgICAgIGFsdEF1ZGlvOiAhYXVkaW9Pbmx5ICYmIGF1ZGlvVHJhY2tzLnNvbWUodCA9PiAhIXQudXJsKVxuICAgIH07XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCBlZGF0YSk7XG5cbiAgICAvLyBJbml0aWF0ZSBsb2FkaW5nIGFmdGVyIGFsbCBjb250cm9sbGVycyBoYXZlIHJlY2VpdmVkIE1BTklGRVNUX1BBUlNFRFxuICAgIGlmICh0aGlzLmhscy5jb25maWcuYXV0b1N0YXJ0TG9hZCB8fCB0aGlzLmhscy5mb3JjZVN0YXJ0TG9hZCkge1xuICAgICAgdGhpcy5obHMuc3RhcnRMb2FkKHRoaXMuaGxzLmNvbmZpZy5zdGFydFBvc2l0aW9uKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGxldmVscygpIHtcbiAgICBpZiAodGhpcy5fbGV2ZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9sZXZlbHM7XG4gIH1cbiAgZ2V0IGxldmVsKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRMZXZlbEluZGV4O1xuICB9XG4gIHNldCBsZXZlbChuZXdMZXZlbCkge1xuICAgIGNvbnN0IGxldmVscyA9IHRoaXMuX2xldmVscztcbiAgICBpZiAobGV2ZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBjaGVjayBpZiBsZXZlbCBpZHggaXMgdmFsaWRcbiAgICBpZiAobmV3TGV2ZWwgPCAwIHx8IG5ld0xldmVsID49IGxldmVscy5sZW5ndGgpIHtcbiAgICAgIC8vIGludmFsaWQgbGV2ZWwgaWQgZ2l2ZW4sIHRyaWdnZXIgZXJyb3JcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdpbnZhbGlkIGxldmVsIGlkeCcpO1xuICAgICAgY29uc3QgZmF0YWwgPSBuZXdMZXZlbCA8IDA7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuTEVWRUxfU1dJVENIX0VSUk9SLFxuICAgICAgICBsZXZlbDogbmV3TGV2ZWwsXG4gICAgICAgIGZhdGFsLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgcmVhc29uOiBlcnJvci5tZXNzYWdlXG4gICAgICB9KTtcbiAgICAgIGlmIChmYXRhbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBuZXdMZXZlbCA9IE1hdGgubWluKG5ld0xldmVsLCBsZXZlbHMubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIGNvbnN0IGxhc3RMZXZlbEluZGV4ID0gdGhpcy5jdXJyZW50TGV2ZWxJbmRleDtcbiAgICBjb25zdCBsYXN0TGV2ZWwgPSB0aGlzLmN1cnJlbnRMZXZlbDtcbiAgICBjb25zdCBsYXN0UGF0aHdheUlkID0gbGFzdExldmVsID8gbGFzdExldmVsLmF0dHJzWydQQVRIV0FZLUlEJ10gOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgbGV2ZWwgPSBsZXZlbHNbbmV3TGV2ZWxdO1xuICAgIGNvbnN0IHBhdGh3YXlJZCA9IGxldmVsLmF0dHJzWydQQVRIV0FZLUlEJ107XG4gICAgdGhpcy5jdXJyZW50TGV2ZWxJbmRleCA9IG5ld0xldmVsO1xuICAgIHRoaXMuY3VycmVudExldmVsID0gbGV2ZWw7XG4gICAgaWYgKGxhc3RMZXZlbEluZGV4ID09PSBuZXdMZXZlbCAmJiBsZXZlbC5kZXRhaWxzICYmIGxhc3RMZXZlbCAmJiBsYXN0UGF0aHdheUlkID09PSBwYXRod2F5SWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sb2coYFN3aXRjaGluZyB0byBsZXZlbCAke25ld0xldmVsfSAoJHtsZXZlbC5oZWlnaHQgPyBsZXZlbC5oZWlnaHQgKyAncCAnIDogJyd9JHtsZXZlbC52aWRlb1JhbmdlID8gbGV2ZWwudmlkZW9SYW5nZSArICcgJyA6ICcnfSR7bGV2ZWwuY29kZWNTZXQgPyBsZXZlbC5jb2RlY1NldCArICcgJyA6ICcnfUAke2xldmVsLmJpdHJhdGV9KSR7cGF0aHdheUlkID8gJyB3aXRoIFBhdGh3YXkgJyArIHBhdGh3YXlJZCA6ICcnfSBmcm9tIGxldmVsICR7bGFzdExldmVsSW5kZXh9JHtsYXN0UGF0aHdheUlkID8gJyB3aXRoIFBhdGh3YXkgJyArIGxhc3RQYXRod2F5SWQgOiAnJ31gKTtcbiAgICBjb25zdCBsZXZlbFN3aXRjaGluZ0RhdGEgPSB7XG4gICAgICBsZXZlbDogbmV3TGV2ZWwsXG4gICAgICBhdHRyczogbGV2ZWwuYXR0cnMsXG4gICAgICBkZXRhaWxzOiBsZXZlbC5kZXRhaWxzLFxuICAgICAgYml0cmF0ZTogbGV2ZWwuYml0cmF0ZSxcbiAgICAgIGF2ZXJhZ2VCaXRyYXRlOiBsZXZlbC5hdmVyYWdlQml0cmF0ZSxcbiAgICAgIG1heEJpdHJhdGU6IGxldmVsLm1heEJpdHJhdGUsXG4gICAgICByZWFsQml0cmF0ZTogbGV2ZWwucmVhbEJpdHJhdGUsXG4gICAgICB3aWR0aDogbGV2ZWwud2lkdGgsXG4gICAgICBoZWlnaHQ6IGxldmVsLmhlaWdodCxcbiAgICAgIGNvZGVjU2V0OiBsZXZlbC5jb2RlY1NldCxcbiAgICAgIGF1ZGlvQ29kZWM6IGxldmVsLmF1ZGlvQ29kZWMsXG4gICAgICB2aWRlb0NvZGVjOiBsZXZlbC52aWRlb0NvZGVjLFxuICAgICAgYXVkaW9Hcm91cHM6IGxldmVsLmF1ZGlvR3JvdXBzLFxuICAgICAgc3VidGl0bGVHcm91cHM6IGxldmVsLnN1YnRpdGxlR3JvdXBzLFxuICAgICAgbG9hZGVkOiBsZXZlbC5sb2FkZWQsXG4gICAgICBsb2FkRXJyb3I6IGxldmVsLmxvYWRFcnJvcixcbiAgICAgIGZyYWdtZW50RXJyb3I6IGxldmVsLmZyYWdtZW50RXJyb3IsXG4gICAgICBuYW1lOiBsZXZlbC5uYW1lLFxuICAgICAgaWQ6IGxldmVsLmlkLFxuICAgICAgdXJpOiBsZXZlbC51cmksXG4gICAgICB1cmw6IGxldmVsLnVybCxcbiAgICAgIHVybElkOiAwLFxuICAgICAgYXVkaW9Hcm91cElkczogbGV2ZWwuYXVkaW9Hcm91cElkcyxcbiAgICAgIHRleHRHcm91cElkczogbGV2ZWwudGV4dEdyb3VwSWRzXG4gICAgfTtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5MRVZFTF9TV0lUQ0hJTkcsIGxldmVsU3dpdGNoaW5nRGF0YSk7XG4gICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBsb2FkIHBsYXlsaXN0IGZvciB0aGlzIGxldmVsXG4gICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gbGV2ZWwuZGV0YWlscztcbiAgICBpZiAoIWxldmVsRGV0YWlscyB8fCBsZXZlbERldGFpbHMubGl2ZSkge1xuICAgICAgLy8gbGV2ZWwgbm90IHJldHJpZXZlZCB5ZXQsIG9yIGxpdmUgcGxheWxpc3Qgd2UgbmVlZCB0byAocmUpbG9hZCBpdFxuICAgICAgY29uc3QgaGxzVXJsUGFyYW1ldGVycyA9IHRoaXMuc3dpdGNoUGFyYW1zKGxldmVsLnVyaSwgbGFzdExldmVsID09IG51bGwgPyB2b2lkIDAgOiBsYXN0TGV2ZWwuZGV0YWlscyk7XG4gICAgICB0aGlzLmxvYWRQbGF5bGlzdChobHNVcmxQYXJhbWV0ZXJzKTtcbiAgICB9XG4gIH1cbiAgZ2V0IG1hbnVhbExldmVsKCkge1xuICAgIHJldHVybiB0aGlzLm1hbnVhbExldmVsSW5kZXg7XG4gIH1cbiAgc2V0IG1hbnVhbExldmVsKG5ld0xldmVsKSB7XG4gICAgdGhpcy5tYW51YWxMZXZlbEluZGV4ID0gbmV3TGV2ZWw7XG4gICAgaWYgKHRoaXMuX3N0YXJ0TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fc3RhcnRMZXZlbCA9IG5ld0xldmVsO1xuICAgIH1cbiAgICBpZiAobmV3TGV2ZWwgIT09IC0xKSB7XG4gICAgICB0aGlzLmxldmVsID0gbmV3TGV2ZWw7XG4gICAgfVxuICB9XG4gIGdldCBmaXJzdExldmVsKCkge1xuICAgIHJldHVybiB0aGlzLl9maXJzdExldmVsO1xuICB9XG4gIHNldCBmaXJzdExldmVsKG5ld0xldmVsKSB7XG4gICAgdGhpcy5fZmlyc3RMZXZlbCA9IG5ld0xldmVsO1xuICB9XG4gIGdldCBzdGFydExldmVsKCkge1xuICAgIC8vIFNldHRpbmcgaGxzLnN0YXJ0TGV2ZWwgKHRoaXMuX3N0YXJ0TGV2ZWwpIG92ZXJyaWRlcyBjb25maWcuc3RhcnRMZXZlbFxuICAgIGlmICh0aGlzLl9zdGFydExldmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGNvbmZpZ1N0YXJ0TGV2ZWwgPSB0aGlzLmhscy5jb25maWcuc3RhcnRMZXZlbDtcbiAgICAgIGlmIChjb25maWdTdGFydExldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZ1N0YXJ0TGV2ZWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5obHMuZmlyc3RBdXRvTGV2ZWw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zdGFydExldmVsO1xuICB9XG4gIHNldCBzdGFydExldmVsKG5ld0xldmVsKSB7XG4gICAgdGhpcy5fc3RhcnRMZXZlbCA9IG5ld0xldmVsO1xuICB9XG4gIG9uRXJyb3IoZXZlbnQsIGRhdGEpIHtcbiAgICBpZiAoZGF0YS5mYXRhbCB8fCAhZGF0YS5jb250ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkYXRhLmNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5MRVZFTCAmJiBkYXRhLmNvbnRleHQubGV2ZWwgPT09IHRoaXMubGV2ZWwpIHtcbiAgICAgIHRoaXMuY2hlY2tSZXRyeShkYXRhKTtcbiAgICB9XG4gIH1cblxuICAvLyByZXNldCBlcnJvcnMgb24gdGhlIHN1Y2Nlc3NmdWwgbG9hZCBvZiBhIGZyYWdtZW50XG4gIG9uRnJhZ0J1ZmZlcmVkKGV2ZW50LCB7XG4gICAgZnJhZ1xuICB9KSB7XG4gICAgaWYgKGZyYWcgIT09IHVuZGVmaW5lZCAmJiBmcmFnLnR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pIHtcbiAgICAgIGNvbnN0IGVsID0gZnJhZy5lbGVtZW50YXJ5U3RyZWFtcztcbiAgICAgIGlmICghT2JqZWN0LmtleXMoZWwpLnNvbWUodHlwZSA9PiAhIWVsW3R5cGVdKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBsZXZlbCA9IHRoaXMuX2xldmVsc1tmcmFnLmxldmVsXTtcbiAgICAgIGlmIChsZXZlbCAhPSBudWxsICYmIGxldmVsLmxvYWRFcnJvcikge1xuICAgICAgICB0aGlzLmxvZyhgUmVzZXR0aW5nIGxldmVsIGVycm9yIGNvdW50IG9mICR7bGV2ZWwubG9hZEVycm9yfSBvbiBmcmFnIGJ1ZmZlcmVkYCk7XG4gICAgICAgIGxldmVsLmxvYWRFcnJvciA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG9uTGV2ZWxMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgX2RhdGEkZGVsaXZlcnlEaXJlY3RpMjtcbiAgICBjb25zdCB7XG4gICAgICBsZXZlbCxcbiAgICAgIGRldGFpbHNcbiAgICB9ID0gZGF0YTtcbiAgICBjb25zdCBjdXJMZXZlbCA9IHRoaXMuX2xldmVsc1tsZXZlbF07XG4gICAgaWYgKCFjdXJMZXZlbCkge1xuICAgICAgdmFyIF9kYXRhJGRlbGl2ZXJ5RGlyZWN0aTtcbiAgICAgIHRoaXMud2FybihgSW52YWxpZCBsZXZlbCBpbmRleCAke2xldmVsfWApO1xuICAgICAgaWYgKChfZGF0YSRkZWxpdmVyeURpcmVjdGkgPSBkYXRhLmRlbGl2ZXJ5RGlyZWN0aXZlcykgIT0gbnVsbCAmJiBfZGF0YSRkZWxpdmVyeURpcmVjdGkuc2tpcCkge1xuICAgICAgICBkZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBvbmx5IHByb2Nlc3MgbGV2ZWwgbG9hZGVkIGV2ZW50cyBtYXRjaGluZyB3aXRoIGV4cGVjdGVkIGxldmVsXG4gICAgaWYgKGxldmVsID09PSB0aGlzLmN1cnJlbnRMZXZlbEluZGV4KSB7XG4gICAgICAvLyByZXNldCBsZXZlbCBsb2FkIGVycm9yIGNvdW50ZXIgb24gc3VjY2Vzc2Z1bCBsZXZlbCBsb2FkZWQgb25seSBpZiB0aGVyZSBpcyBubyBpc3N1ZXMgd2l0aCBmcmFnbWVudHNcbiAgICAgIGlmIChjdXJMZXZlbC5mcmFnbWVudEVycm9yID09PSAwKSB7XG4gICAgICAgIGN1ckxldmVsLmxvYWRFcnJvciA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLnBsYXlsaXN0TG9hZGVkKGxldmVsLCBkYXRhLCBjdXJMZXZlbC5kZXRhaWxzKTtcbiAgICB9IGVsc2UgaWYgKChfZGF0YSRkZWxpdmVyeURpcmVjdGkyID0gZGF0YS5kZWxpdmVyeURpcmVjdGl2ZXMpICE9IG51bGwgJiYgX2RhdGEkZGVsaXZlcnlEaXJlY3RpMi5za2lwKSB7XG4gICAgICAvLyByZWNlaXZlZCBhIGRlbHRhIHBsYXlsaXN0IHVwZGF0ZSB0aGF0IGNhbm5vdCBiZSBtZXJnZWRcbiAgICAgIGRldGFpbHMuZGVsdGFVcGRhdGVGYWlsZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBsb2FkUGxheWxpc3QoaGxzVXJsUGFyYW1ldGVycykge1xuICAgIHN1cGVyLmxvYWRQbGF5bGlzdCgpO1xuICAgIGNvbnN0IGN1cnJlbnRMZXZlbEluZGV4ID0gdGhpcy5jdXJyZW50TGV2ZWxJbmRleDtcbiAgICBjb25zdCBjdXJyZW50TGV2ZWwgPSB0aGlzLmN1cnJlbnRMZXZlbDtcbiAgICBpZiAoY3VycmVudExldmVsICYmIHRoaXMuc2hvdWxkTG9hZFBsYXlsaXN0KGN1cnJlbnRMZXZlbCkpIHtcbiAgICAgIGxldCB1cmwgPSBjdXJyZW50TGV2ZWwudXJpO1xuICAgICAgaWYgKGhsc1VybFBhcmFtZXRlcnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB1cmwgPSBobHNVcmxQYXJhbWV0ZXJzLmFkZERpcmVjdGl2ZXModXJsKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLndhcm4oYENvdWxkIG5vdCBjb25zdHJ1Y3QgbmV3IFVSTCB3aXRoIEhMUyBEZWxpdmVyeSBEaXJlY3RpdmVzOiAke2Vycm9yfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBwYXRod2F5SWQgPSBjdXJyZW50TGV2ZWwuYXR0cnNbJ1BBVEhXQVktSUQnXTtcbiAgICAgIHRoaXMubG9nKGBMb2FkaW5nIGxldmVsIGluZGV4ICR7Y3VycmVudExldmVsSW5kZXh9JHsoaGxzVXJsUGFyYW1ldGVycyA9PSBudWxsID8gdm9pZCAwIDogaGxzVXJsUGFyYW1ldGVycy5tc24pICE9PSB1bmRlZmluZWQgPyAnIGF0IHNuICcgKyBobHNVcmxQYXJhbWV0ZXJzLm1zbiArICcgcGFydCAnICsgaGxzVXJsUGFyYW1ldGVycy5wYXJ0IDogJyd9IHdpdGgke3BhdGh3YXlJZCA/ICcgUGF0aHdheSAnICsgcGF0aHdheUlkIDogJyd9ICR7dXJsfWApO1xuXG4gICAgICAvLyBjb25zb2xlLmxvZygnQ3VycmVudCBhdWRpbyB0cmFjayBncm91cCBJRDonLCB0aGlzLmhscy5hdWRpb1RyYWNrc1t0aGlzLmhscy5hdWRpb1RyYWNrXS5ncm91cElkKTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdOZXcgdmlkZW8gcXVhbGl0eSBsZXZlbCBhdWRpbyBncm91cCBpZDonLCBsZXZlbE9iamVjdC5hdHRycy5BVURJTywgbGV2ZWwpO1xuICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5MRVZFTF9MT0FESU5HLCB7XG4gICAgICAgIHVybCxcbiAgICAgICAgbGV2ZWw6IGN1cnJlbnRMZXZlbEluZGV4LFxuICAgICAgICBwYXRod2F5SWQ6IGN1cnJlbnRMZXZlbC5hdHRyc1snUEFUSFdBWS1JRCddLFxuICAgICAgICBpZDogMCxcbiAgICAgICAgLy8gRGVwcmVjYXRlZCBMZXZlbCB1cmxJZFxuICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXM6IGhsc1VybFBhcmFtZXRlcnMgfHwgbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldCBuZXh0TG9hZExldmVsKCkge1xuICAgIGlmICh0aGlzLm1hbnVhbExldmVsSW5kZXggIT09IC0xKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYW51YWxMZXZlbEluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5obHMubmV4dEF1dG9MZXZlbDtcbiAgICB9XG4gIH1cbiAgc2V0IG5leHRMb2FkTGV2ZWwobmV4dExldmVsKSB7XG4gICAgdGhpcy5sZXZlbCA9IG5leHRMZXZlbDtcbiAgICBpZiAodGhpcy5tYW51YWxMZXZlbEluZGV4ID09PSAtMSkge1xuICAgICAgdGhpcy5obHMubmV4dEF1dG9MZXZlbCA9IG5leHRMZXZlbDtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlTGV2ZWwobGV2ZWxJbmRleCkge1xuICAgIHZhciBfdGhpcyRjdXJyZW50TGV2ZWw7XG4gICAgY29uc3QgbGV2ZWxzID0gdGhpcy5fbGV2ZWxzLmZpbHRlcigobGV2ZWwsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoaW5kZXggIT09IGxldmVsSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdGVlcmluZykge1xuICAgICAgICB0aGlzLnN0ZWVyaW5nLnJlbW92ZUxldmVsKGxldmVsKTtcbiAgICAgIH1cbiAgICAgIGlmIChsZXZlbCA9PT0gdGhpcy5jdXJyZW50TGV2ZWwpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50TGV2ZWwgPSBudWxsO1xuICAgICAgICB0aGlzLmN1cnJlbnRMZXZlbEluZGV4ID0gLTE7XG4gICAgICAgIGlmIChsZXZlbC5kZXRhaWxzKSB7XG4gICAgICAgICAgbGV2ZWwuZGV0YWlscy5mcmFnbWVudHMuZm9yRWFjaChmID0+IGYubGV2ZWwgPSAtMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgICByZWFzc2lnbkZyYWdtZW50TGV2ZWxJbmRleGVzKGxldmVscyk7XG4gICAgdGhpcy5fbGV2ZWxzID0gbGV2ZWxzO1xuICAgIGlmICh0aGlzLmN1cnJlbnRMZXZlbEluZGV4ID4gLTEgJiYgKF90aGlzJGN1cnJlbnRMZXZlbCA9IHRoaXMuY3VycmVudExldmVsKSAhPSBudWxsICYmIF90aGlzJGN1cnJlbnRMZXZlbC5kZXRhaWxzKSB7XG4gICAgICB0aGlzLmN1cnJlbnRMZXZlbEluZGV4ID0gdGhpcy5jdXJyZW50TGV2ZWwuZGV0YWlscy5mcmFnbWVudHNbMF0ubGV2ZWw7XG4gICAgfVxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkxFVkVMU19VUERBVEVELCB7XG4gICAgICBsZXZlbHNcbiAgICB9KTtcbiAgfVxuICBvbkxldmVsc1VwZGF0ZWQoZXZlbnQsIHtcbiAgICBsZXZlbHNcbiAgfSkge1xuICAgIHRoaXMuX2xldmVscyA9IGxldmVscztcbiAgfVxuICBjaGVja01heEF1dG9VcGRhdGVkKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGF1dG9MZXZlbENhcHBpbmcsXG4gICAgICBtYXhBdXRvTGV2ZWwsXG4gICAgICBtYXhIZGNwTGV2ZWxcbiAgICB9ID0gdGhpcy5obHM7XG4gICAgaWYgKHRoaXMuX21heEF1dG9MZXZlbCAhPT0gbWF4QXV0b0xldmVsKSB7XG4gICAgICB0aGlzLl9tYXhBdXRvTGV2ZWwgPSBtYXhBdXRvTGV2ZWw7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5NQVhfQVVUT19MRVZFTF9VUERBVEVELCB7XG4gICAgICAgIGF1dG9MZXZlbENhcHBpbmcsXG4gICAgICAgIGxldmVsczogdGhpcy5sZXZlbHMsXG4gICAgICAgIG1heEF1dG9MZXZlbCxcbiAgICAgICAgbWluQXV0b0xldmVsOiB0aGlzLmhscy5taW5BdXRvTGV2ZWwsXG4gICAgICAgIG1heEhkY3BMZXZlbFxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhc3NpZ25UcmFja0lkc0J5R3JvdXAodHJhY2tzKSB7XG4gIGNvbnN0IGdyb3VwcyA9IHt9O1xuICB0cmFja3MuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgY29uc3QgZ3JvdXBJZCA9IHRyYWNrLmdyb3VwSWQgfHwgJyc7XG4gICAgdHJhY2suaWQgPSBncm91cHNbZ3JvdXBJZF0gPSBncm91cHNbZ3JvdXBJZF0gfHwgMDtcbiAgICBncm91cHNbZ3JvdXBJZF0rKztcbiAgfSk7XG59XG5cbmNsYXNzIEtleUxvYWRlciB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMua2V5VXJpVG9LZXlJbmZvID0ge307XG4gICAgdGhpcy5lbWVDb250cm9sbGVyID0gbnVsbDtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgfVxuICBhYm9ydCh0eXBlKSB7XG4gICAgZm9yIChjb25zdCB1cmkgaW4gdGhpcy5rZXlVcmlUb0tleUluZm8pIHtcbiAgICAgIGNvbnN0IGxvYWRlciA9IHRoaXMua2V5VXJpVG9LZXlJbmZvW3VyaV0ubG9hZGVyO1xuICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICB2YXIgX2xvYWRlciRjb250ZXh0O1xuICAgICAgICBpZiAodHlwZSAmJiB0eXBlICE9PSAoKF9sb2FkZXIkY29udGV4dCA9IGxvYWRlci5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2xvYWRlciRjb250ZXh0LmZyYWcudHlwZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRldGFjaCgpIHtcbiAgICBmb3IgKGNvbnN0IHVyaSBpbiB0aGlzLmtleVVyaVRvS2V5SW5mbykge1xuICAgICAgY29uc3Qga2V5SW5mbyA9IHRoaXMua2V5VXJpVG9LZXlJbmZvW3VyaV07XG4gICAgICAvLyBSZW1vdmUgY2FjaGVkIEVNRSBrZXlzIG9uIGRldGFjaFxuICAgICAgaWYgKGtleUluZm8ubWVkaWFLZXlTZXNzaW9uQ29udGV4dCB8fCBrZXlJbmZvLmRlY3J5cHRkYXRhLmlzQ29tbW9uRW5jcnlwdGlvbikge1xuICAgICAgICBkZWxldGUgdGhpcy5rZXlVcmlUb0tleUluZm9bdXJpXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRldGFjaCgpO1xuICAgIGZvciAoY29uc3QgdXJpIGluIHRoaXMua2V5VXJpVG9LZXlJbmZvKSB7XG4gICAgICBjb25zdCBsb2FkZXIgPSB0aGlzLmtleVVyaVRvS2V5SW5mb1t1cmldLmxvYWRlcjtcbiAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5rZXlVcmlUb0tleUluZm8gPSB7fTtcbiAgfVxuICBjcmVhdGVLZXlMb2FkRXJyb3IoZnJhZywgZGV0YWlscyA9IEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUiwgZXJyb3IsIG5ldHdvcmtEZXRhaWxzLCByZXNwb25zZSkge1xuICAgIHJldHVybiBuZXcgTG9hZEVycm9yKHtcbiAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgIGRldGFpbHMsXG4gICAgICBmYXRhbDogZmFsc2UsXG4gICAgICBmcmFnLFxuICAgICAgcmVzcG9uc2UsXG4gICAgICBlcnJvcixcbiAgICAgIG5ldHdvcmtEZXRhaWxzXG4gICAgfSk7XG4gIH1cbiAgbG9hZENsZWFyKGxvYWRpbmdGcmFnLCBlbmNyeXB0ZWRGcmFnbWVudHMpIHtcbiAgICBpZiAodGhpcy5lbWVDb250cm9sbGVyICYmIHRoaXMuY29uZmlnLmVtZUVuYWJsZWQpIHtcbiAgICAgIC8vIGFjY2VzcyBrZXktc3lzdGVtIHdpdGggbmVhcmVzdCBrZXkgb24gc3RhcnQgKGxvYWlkbmcgZnJhZyBpcyB1bmVuY3J5cHRlZClcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc24sXG4gICAgICAgIGNjXG4gICAgICB9ID0gbG9hZGluZ0ZyYWc7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVuY3J5cHRlZEZyYWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBmcmFnID0gZW5jcnlwdGVkRnJhZ21lbnRzW2ldO1xuICAgICAgICBpZiAoY2MgPD0gZnJhZy5jYyAmJiAoc24gPT09ICdpbml0U2VnbWVudCcgfHwgZnJhZy5zbiA9PT0gJ2luaXRTZWdtZW50JyB8fCBzbiA8IGZyYWcuc24pKSB7XG4gICAgICAgICAgdGhpcy5lbWVDb250cm9sbGVyLnNlbGVjdEtleVN5c3RlbUZvcm1hdChmcmFnKS50aGVuKGtleVN5c3RlbUZvcm1hdCA9PiB7XG4gICAgICAgICAgICBmcmFnLnNldEtleUZvcm1hdChrZXlTeXN0ZW1Gb3JtYXQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxvYWQoZnJhZykge1xuICAgIGlmICghZnJhZy5kZWNyeXB0ZGF0YSAmJiBmcmFnLmVuY3J5cHRlZCAmJiB0aGlzLmVtZUNvbnRyb2xsZXIpIHtcbiAgICAgIC8vIE11bHRpcGxlIGtleXMsIGJ1dCBub25lIHNlbGVjdGVkLCByZXNvbHZlIGluIGVtZS1jb250cm9sbGVyXG4gICAgICByZXR1cm4gdGhpcy5lbWVDb250cm9sbGVyLnNlbGVjdEtleVN5c3RlbUZvcm1hdChmcmFnKS50aGVuKGtleVN5c3RlbUZvcm1hdCA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRJbnRlcm5hbChmcmFnLCBrZXlTeXN0ZW1Gb3JtYXQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxvYWRJbnRlcm5hbChmcmFnKTtcbiAgfVxuICBsb2FkSW50ZXJuYWwoZnJhZywga2V5U3lzdGVtRm9ybWF0KSB7XG4gICAgdmFyIF9rZXlJbmZvLCBfa2V5SW5mbzI7XG4gICAgaWYgKGtleVN5c3RlbUZvcm1hdCkge1xuICAgICAgZnJhZy5zZXRLZXlGb3JtYXQoa2V5U3lzdGVtRm9ybWF0KTtcbiAgICB9XG4gICAgY29uc3QgZGVjcnlwdGRhdGEgPSBmcmFnLmRlY3J5cHRkYXRhO1xuICAgIGlmICghZGVjcnlwdGRhdGEpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGtleVN5c3RlbUZvcm1hdCA/IGBFeHBlY3RlZCBmcmFnLmRlY3J5cHRkYXRhIHRvIGJlIGRlZmluZWQgYWZ0ZXIgc2V0dGluZyBmb3JtYXQgJHtrZXlTeXN0ZW1Gb3JtYXR9YCA6ICdNaXNzaW5nIGRlY3J5cHRpb24gZGF0YSBvbiBmcmFnbWVudCBpbiBvbktleUxvYWRpbmcnKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLmNyZWF0ZUtleUxvYWRFcnJvcihmcmFnLCBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1IsIGVycm9yKSk7XG4gICAgfVxuICAgIGNvbnN0IHVyaSA9IGRlY3J5cHRkYXRhLnVyaTtcbiAgICBpZiAoIXVyaSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHRoaXMuY3JlYXRlS2V5TG9hZEVycm9yKGZyYWcsIEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUiwgbmV3IEVycm9yKGBJbnZhbGlkIGtleSBVUkk6IFwiJHt1cml9XCJgKSkpO1xuICAgIH1cbiAgICBsZXQga2V5SW5mbyA9IHRoaXMua2V5VXJpVG9LZXlJbmZvW3VyaV07XG4gICAgaWYgKChfa2V5SW5mbyA9IGtleUluZm8pICE9IG51bGwgJiYgX2tleUluZm8uZGVjcnlwdGRhdGEua2V5KSB7XG4gICAgICBkZWNyeXB0ZGF0YS5rZXkgPSBrZXlJbmZvLmRlY3J5cHRkYXRhLmtleTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICBmcmFnLFxuICAgICAgICBrZXlJbmZvXG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gUmV0dXJuIGtleSBsb2FkIHByb21pc2UgYXMgbG9uZyBhcyBpdCBkb2VzIG5vdCBoYXZlIGEgbWVkaWFrZXkgc2Vzc2lvbiB3aXRoIGFuIHVudXNhYmxlIGtleSBzdGF0dXNcbiAgICBpZiAoKF9rZXlJbmZvMiA9IGtleUluZm8pICE9IG51bGwgJiYgX2tleUluZm8yLmtleUxvYWRQcm9taXNlKSB7XG4gICAgICB2YXIgX2tleUluZm8kbWVkaWFLZXlTZXNzO1xuICAgICAgc3dpdGNoICgoX2tleUluZm8kbWVkaWFLZXlTZXNzID0ga2V5SW5mby5tZWRpYUtleVNlc3Npb25Db250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2tleUluZm8kbWVkaWFLZXlTZXNzLmtleVN0YXR1cykge1xuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgY2FzZSAnc3RhdHVzLXBlbmRpbmcnOlxuICAgICAgICBjYXNlICd1c2FibGUnOlxuICAgICAgICBjYXNlICd1c2FibGUtaW4tZnV0dXJlJzpcbiAgICAgICAgICByZXR1cm4ga2V5SW5mby5rZXlMb2FkUHJvbWlzZS50aGVuKGtleUxvYWRlZERhdGEgPT4ge1xuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBjb3JyZWN0IGZyYWdtZW50IHdpdGggdXBkYXRlZCBkZWNyeXB0ZGF0YSBrZXkgYW5kIGxvYWRlZCBrZXlJbmZvXG4gICAgICAgICAgICBkZWNyeXB0ZGF0YS5rZXkgPSBrZXlMb2FkZWREYXRhLmtleUluZm8uZGVjcnlwdGRhdGEua2V5O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgICAga2V5SW5mb1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHdlIGhhdmUgYSBrZXkgc2Vzc2lvbiBhbmQgc3RhdHVzIGFuZCBpdCBpcyBub3QgcGVuZGluZyBvciB1c2FibGUsIGNvbnRpbnVlXG4gICAgICAvLyBUaGlzIHdpbGwgZ28gYmFjayB0byB0aGUgZW1lLWNvbnRyb2xsZXIgZm9yIGV4cGlyZWQga2V5cyB0byBnZXQgYSBuZXcga2V5TG9hZFByb21pc2VcbiAgICB9XG5cbiAgICAvLyBMb2FkIHRoZSBrZXkgb3IgcmV0dXJuIHRoZSBsb2FkaW5nIHByb21pc2VcbiAgICBrZXlJbmZvID0gdGhpcy5rZXlVcmlUb0tleUluZm9bdXJpXSA9IHtcbiAgICAgIGRlY3J5cHRkYXRhLFxuICAgICAga2V5TG9hZFByb21pc2U6IG51bGwsXG4gICAgICBsb2FkZXI6IG51bGwsXG4gICAgICBtZWRpYUtleVNlc3Npb25Db250ZXh0OiBudWxsXG4gICAgfTtcbiAgICBzd2l0Y2ggKGRlY3J5cHRkYXRhLm1ldGhvZCkge1xuICAgICAgY2FzZSAnSVNPLTIzMDAxLTcnOlxuICAgICAgY2FzZSAnU0FNUExFLUFFUyc6XG4gICAgICBjYXNlICdTQU1QTEUtQUVTLUNFTkMnOlxuICAgICAgY2FzZSAnU0FNUExFLUFFUy1DVFInOlxuICAgICAgICBpZiAoZGVjcnlwdGRhdGEua2V5Rm9ybWF0ID09PSAnaWRlbnRpdHknKSB7XG4gICAgICAgICAgLy8gbG9hZEtleUhUVFAgaGFuZGxlcyBodHRwKHMpIGFuZCBkYXRhIFVSTHNcbiAgICAgICAgICByZXR1cm4gdGhpcy5sb2FkS2V5SFRUUChrZXlJbmZvLCBmcmFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sb2FkS2V5RU1FKGtleUluZm8sIGZyYWcpO1xuICAgICAgY2FzZSAnQUVTLTEyOCc6XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRLZXlIVFRQKGtleUluZm8sIGZyYWcpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHRoaXMuY3JlYXRlS2V5TG9hZEVycm9yKGZyYWcsIEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUiwgbmV3IEVycm9yKGBLZXkgc3VwcGxpZWQgd2l0aCB1bnN1cHBvcnRlZCBNRVRIT0Q6IFwiJHtkZWNyeXB0ZGF0YS5tZXRob2R9XCJgKSkpO1xuICAgIH1cbiAgfVxuICBsb2FkS2V5RU1FKGtleUluZm8sIGZyYWcpIHtcbiAgICBjb25zdCBrZXlMb2FkZWREYXRhID0ge1xuICAgICAgZnJhZyxcbiAgICAgIGtleUluZm9cbiAgICB9O1xuICAgIGlmICh0aGlzLmVtZUNvbnRyb2xsZXIgJiYgdGhpcy5jb25maWcuZW1lRW5hYmxlZCkge1xuICAgICAgY29uc3Qga2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlID0gdGhpcy5lbWVDb250cm9sbGVyLmxvYWRLZXkoa2V5TG9hZGVkRGF0YSk7XG4gICAgICBpZiAoa2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlKSB7XG4gICAgICAgIHJldHVybiAoa2V5SW5mby5rZXlMb2FkUHJvbWlzZSA9IGtleVNlc3Npb25Db250ZXh0UHJvbWlzZS50aGVuKGtleVNlc3Npb25Db250ZXh0ID0+IHtcbiAgICAgICAgICBrZXlJbmZvLm1lZGlhS2V5U2Vzc2lvbkNvbnRleHQgPSBrZXlTZXNzaW9uQ29udGV4dDtcbiAgICAgICAgICByZXR1cm4ga2V5TG9hZGVkRGF0YTtcbiAgICAgICAgfSkpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAvLyBSZW1vdmUgcHJvbWlzZSBmb3IgbGljZW5zZSByZW5ld2FsIG9yIHJldHJ5XG4gICAgICAgICAga2V5SW5mby5rZXlMb2FkUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGtleUxvYWRlZERhdGEpO1xuICB9XG4gIGxvYWRLZXlIVFRQKGtleUluZm8sIGZyYWcpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBjb25zdCBMb2FkZXIgPSBjb25maWcubG9hZGVyO1xuICAgIGNvbnN0IGtleUxvYWRlciA9IG5ldyBMb2FkZXIoY29uZmlnKTtcbiAgICBmcmFnLmtleUxvYWRlciA9IGtleUluZm8ubG9hZGVyID0ga2V5TG9hZGVyO1xuICAgIHJldHVybiBrZXlJbmZvLmtleUxvYWRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgbG9hZGVyQ29udGV4dCA9IHtcbiAgICAgICAga2V5SW5mbyxcbiAgICAgICAgZnJhZyxcbiAgICAgICAgcmVzcG9uc2VUeXBlOiAnYXJyYXlidWZmZXInLFxuICAgICAgICB1cmw6IGtleUluZm8uZGVjcnlwdGRhdGEudXJpXG4gICAgICB9O1xuXG4gICAgICAvLyBtYXhSZXRyeSBpcyAwIHNvIHRoYXQgaW5zdGVhZCBvZiByZXRyeWluZyB0aGUgc2FtZSBrZXkgb24gdGhlIHNhbWUgdmFyaWFudCBtdWx0aXBsZSB0aW1lcyxcbiAgICAgIC8vIGtleS1sb2FkZXIgd2lsbCB0cmlnZ2VyIGFuIGVycm9yIGFuZCByZWx5IG9uIHN0cmVhbS1jb250cm9sbGVyIHRvIGhhbmRsZSByZXRyeSBsb2dpYy5cbiAgICAgIC8vIHRoaXMgd2lsbCBhbHNvIGFsaWduIHJldHJ5IGxvZ2ljIHdpdGggZnJhZ21lbnQtbG9hZGVyXG4gICAgICBjb25zdCBsb2FkUG9saWN5ID0gY29uZmlnLmtleUxvYWRQb2xpY3kuZGVmYXVsdDtcbiAgICAgIGNvbnN0IGxvYWRlckNvbmZpZyA9IHtcbiAgICAgICAgbG9hZFBvbGljeSxcbiAgICAgICAgdGltZW91dDogbG9hZFBvbGljeS5tYXhMb2FkVGltZU1zLFxuICAgICAgICBtYXhSZXRyeTogMCxcbiAgICAgICAgcmV0cnlEZWxheTogMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheTogMFxuICAgICAgfTtcbiAgICAgIGNvbnN0IGxvYWRlckNhbGxiYWNrcyA9IHtcbiAgICAgICAgb25TdWNjZXNzOiAocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICBrZXlJbmZvLFxuICAgICAgICAgICAgdXJsOiB1cmlcbiAgICAgICAgICB9ID0gY29udGV4dDtcbiAgICAgICAgICBpZiAoIWZyYWcuZGVjcnlwdGRhdGEgfHwga2V5SW5mbyAhPT0gdGhpcy5rZXlVcmlUb0tleUluZm9bdXJpXSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdCh0aGlzLmNyZWF0ZUtleUxvYWRFcnJvcihmcmFnLCBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1IsIG5ldyBFcnJvcignYWZ0ZXIga2V5IGxvYWQsIGRlY3J5cHRkYXRhIHVuc2V0IG9yIGNoYW5nZWQnKSwgbmV0d29ya0RldGFpbHMpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAga2V5SW5mby5kZWNyeXB0ZGF0YS5rZXkgPSBmcmFnLmRlY3J5cHRkYXRhLmtleSA9IG5ldyBVaW50OEFycmF5KHJlc3BvbnNlLmRhdGEpO1xuXG4gICAgICAgICAgLy8gZGV0YWNoIGZyYWdtZW50IGtleSBsb2FkZXIgb24gbG9hZCBzdWNjZXNzXG4gICAgICAgICAgZnJhZy5rZXlMb2FkZXIgPSBudWxsO1xuICAgICAgICAgIGtleUluZm8ubG9hZGVyID0gbnVsbDtcbiAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICBrZXlJbmZvXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXJyb3I6IChyZXNwb25zZSwgY29udGV4dCwgbmV0d29ya0RldGFpbHMsIHN0YXRzKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldExvYWRlcihjb250ZXh0KTtcbiAgICAgICAgICByZWplY3QodGhpcy5jcmVhdGVLZXlMb2FkRXJyb3IoZnJhZywgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SLCBuZXcgRXJyb3IoYEhUVFAgRXJyb3IgJHtyZXNwb25zZS5jb2RlfSBsb2FkaW5nIGtleSAke3Jlc3BvbnNlLnRleHR9YCksIG5ldHdvcmtEZXRhaWxzLCBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgICB1cmw6IGxvYWRlckNvbnRleHQudXJsLFxuICAgICAgICAgICAgZGF0YTogdW5kZWZpbmVkXG4gICAgICAgICAgfSwgcmVzcG9uc2UpKSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uVGltZW91dDogKHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoY29udGV4dCk7XG4gICAgICAgICAgcmVqZWN0KHRoaXMuY3JlYXRlS2V5TG9hZEVycm9yKGZyYWcsIEVycm9yRGV0YWlscy5LRVlfTE9BRF9USU1FT1VULCBuZXcgRXJyb3IoJ2tleSBsb2FkaW5nIHRpbWVkIG91dCcpLCBuZXR3b3JrRGV0YWlscykpO1xuICAgICAgICB9LFxuICAgICAgICBvbkFib3J0OiAoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldExvYWRlcihjb250ZXh0KTtcbiAgICAgICAgICByZWplY3QodGhpcy5jcmVhdGVLZXlMb2FkRXJyb3IoZnJhZywgRXJyb3JEZXRhaWxzLklOVEVSTkFMX0FCT1JURUQsIG5ldyBFcnJvcigna2V5IGxvYWRpbmcgYWJvcnRlZCcpLCBuZXR3b3JrRGV0YWlscykpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAga2V5TG9hZGVyLmxvYWQobG9hZGVyQ29udGV4dCwgbG9hZGVyQ29uZmlnLCBsb2FkZXJDYWxsYmFja3MpO1xuICAgIH0pO1xuICB9XG4gIHJlc2V0TG9hZGVyKGNvbnRleHQpIHtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnLFxuICAgICAga2V5SW5mbyxcbiAgICAgIHVybDogdXJpXG4gICAgfSA9IGNvbnRleHQ7XG4gICAgY29uc3QgbG9hZGVyID0ga2V5SW5mby5sb2FkZXI7XG4gICAgaWYgKGZyYWcua2V5TG9hZGVyID09PSBsb2FkZXIpIHtcbiAgICAgIGZyYWcua2V5TG9hZGVyID0gbnVsbDtcbiAgICAgIGtleUluZm8ubG9hZGVyID0gbnVsbDtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMua2V5VXJpVG9LZXlJbmZvW3VyaV07XG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlQnVmZmVyKCkge1xuICByZXR1cm4gc2VsZi5Tb3VyY2VCdWZmZXIgfHwgc2VsZi5XZWJLaXRTb3VyY2VCdWZmZXI7XG59XG5mdW5jdGlvbiBpc01TRVN1cHBvcnRlZCgpIHtcbiAgY29uc3QgbWVkaWFTb3VyY2UgPSBnZXRNZWRpYVNvdXJjZSgpO1xuICBpZiAoIW1lZGlhU291cmNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gaWYgU291cmNlQnVmZmVyIGlzIGV4cG9zZWQgZW5zdXJlIGl0cyBBUEkgaXMgdmFsaWRcbiAgLy8gT2xkZXIgYnJvd3NlcnMgZG8gbm90IGV4cG9zZSBTb3VyY2VCdWZmZXIgZ2xvYmFsbHkgc28gY2hlY2tpbmcgU291cmNlQnVmZmVyLnByb3RvdHlwZSBpcyBpbXBvc3NpYmxlXG4gIGNvbnN0IHNvdXJjZUJ1ZmZlciA9IGdldFNvdXJjZUJ1ZmZlcigpO1xuICByZXR1cm4gIXNvdXJjZUJ1ZmZlciB8fCBzb3VyY2VCdWZmZXIucHJvdG90eXBlICYmIHR5cGVvZiBzb3VyY2VCdWZmZXIucHJvdG90eXBlLmFwcGVuZEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc291cmNlQnVmZmVyLnByb3RvdHlwZS5yZW1vdmUgPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBpc1N1cHBvcnRlZCgpIHtcbiAgaWYgKCFpc01TRVN1cHBvcnRlZCgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IG1lZGlhU291cmNlID0gZ2V0TWVkaWFTb3VyY2UoKTtcbiAgcmV0dXJuIHR5cGVvZiAobWVkaWFTb3VyY2UgPT0gbnVsbCA/IHZvaWQgMCA6IG1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCkgPT09ICdmdW5jdGlvbicgJiYgKFsnYXZjMS40MkUwMUUsbXA0YS40MC4yJywgJ2F2MDEuMC4wMU0uMDgnLCAndnAwOS4wMC41MC4wOCddLnNvbWUoY29kZWNzRm9yVmlkZW9Db250YWluZXIgPT4gbWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKG1pbWVUeXBlRm9yQ29kZWMoY29kZWNzRm9yVmlkZW9Db250YWluZXIsICd2aWRlbycpKSkgfHwgWydtcDRhLjQwLjInLCAnZkxhQyddLnNvbWUoY29kZWNGb3JBdWRpb0NvbnRhaW5lciA9PiBtZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQobWltZVR5cGVGb3JDb2RlYyhjb2RlY0ZvckF1ZGlvQ29udGFpbmVyLCAnYXVkaW8nKSkpKTtcbn1cbmZ1bmN0aW9uIGNoYW5nZVR5cGVTdXBwb3J0ZWQoKSB7XG4gIHZhciBfc291cmNlQnVmZmVyJHByb3RvdHk7XG4gIGNvbnN0IHNvdXJjZUJ1ZmZlciA9IGdldFNvdXJjZUJ1ZmZlcigpO1xuICByZXR1cm4gdHlwZW9mIChzb3VyY2VCdWZmZXIgPT0gbnVsbCA/IHZvaWQgMCA6IChfc291cmNlQnVmZmVyJHByb3RvdHkgPSBzb3VyY2VCdWZmZXIucHJvdG90eXBlKSA9PSBudWxsID8gdm9pZCAwIDogX3NvdXJjZUJ1ZmZlciRwcm90b3R5LmNoYW5nZVR5cGUpID09PSAnZnVuY3Rpb24nO1xufVxuXG5jb25zdCBTVEFMTF9NSU5JTVVNX0RVUkFUSU9OX01TID0gMjUwO1xuY29uc3QgTUFYX1NUQVJUX0dBUF9KVU1QID0gMi4wO1xuY29uc3QgU0tJUF9CVUZGRVJfSE9MRV9TVEVQX1NFQ09ORFMgPSAwLjE7XG5jb25zdCBTS0lQX0JVRkZFUl9SQU5HRV9TVEFSVCA9IDAuMDU7XG5jbGFzcyBHYXBDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoY29uZmlnLCBtZWRpYSwgZnJhZ21lbnRUcmFja2VyLCBobHMpIHtcbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlciA9IHZvaWQgMDtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLm51ZGdlUmV0cnkgPSAwO1xuICAgIHRoaXMuc3RhbGxSZXBvcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuc3RhbGxlZCA9IG51bGw7XG4gICAgdGhpcy5tb3ZlZCA9IGZhbHNlO1xuICAgIHRoaXMuc2Vla2luZyA9IGZhbHNlO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMubWVkaWEgPSBtZWRpYTtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlciA9IGZyYWdtZW50VHJhY2tlcjtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmhscyA9IHRoaXMuZnJhZ21lbnRUcmFja2VyID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHBsYXloZWFkIGlzIHN0dWNrIHdpdGhpbiBhIGdhcCwgYW5kIGlmIHNvLCBhdHRlbXB0cyB0byBmcmVlIGl0LlxuICAgKiBBIGdhcCBpcyBhbiB1bmJ1ZmZlcmVkIHJhbmdlIGJldHdlZW4gdHdvIGJ1ZmZlcmVkIHJhbmdlcyAob3IgdGhlIHN0YXJ0IGFuZCB0aGUgZmlyc3QgYnVmZmVyZWQgcmFuZ2UpLlxuICAgKlxuICAgKiBAcGFyYW0gbGFzdEN1cnJlbnRUaW1lIC0gUHJldmlvdXNseSByZWFkIHBsYXloZWFkIHBvc2l0aW9uXG4gICAqL1xuICBwb2xsKGxhc3RDdXJyZW50VGltZSwgYWN0aXZlRnJhZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbmZpZyxcbiAgICAgIG1lZGlhLFxuICAgICAgc3RhbGxlZFxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChtZWRpYSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjdXJyZW50VGltZSxcbiAgICAgIHNlZWtpbmdcbiAgICB9ID0gbWVkaWE7XG4gICAgY29uc3Qgc2Vla2VkID0gdGhpcy5zZWVraW5nICYmICFzZWVraW5nO1xuICAgIGNvbnN0IGJlZ2luU2VlayA9ICF0aGlzLnNlZWtpbmcgJiYgc2Vla2luZztcbiAgICB0aGlzLnNlZWtpbmcgPSBzZWVraW5nO1xuXG4gICAgLy8gVGhlIHBsYXloZWFkIGlzIG1vdmluZywgbm8tb3BcbiAgICBpZiAoY3VycmVudFRpbWUgIT09IGxhc3RDdXJyZW50VGltZSkge1xuICAgICAgdGhpcy5tb3ZlZCA9IHRydWU7XG4gICAgICBpZiAoIXNlZWtpbmcpIHtcbiAgICAgICAgdGhpcy5udWRnZVJldHJ5ID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFsbGVkICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFRoZSBwbGF5aGVhZCBpcyBub3cgbW92aW5nLCBidXQgd2FzIHByZXZpb3VzbHkgc3RhbGxlZFxuICAgICAgICBpZiAodGhpcy5zdGFsbFJlcG9ydGVkKSB7XG4gICAgICAgICAgY29uc3QgX3N0YWxsZWREdXJhdGlvbiA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCkgLSBzdGFsbGVkO1xuICAgICAgICAgIGxvZ2dlci53YXJuKGBwbGF5YmFjayBub3Qgc3R1Y2sgYW55bW9yZSBAJHtjdXJyZW50VGltZX0sIGFmdGVyICR7TWF0aC5yb3VuZChfc3RhbGxlZER1cmF0aW9uKX1tc2ApO1xuICAgICAgICAgIHRoaXMuc3RhbGxSZXBvcnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhbGxlZCA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2xlYXIgc3RhbGxlZCBzdGF0ZSB3aGVuIGJlZ2lubmluZyBvciBmaW5pc2hpbmcgc2Vla2luZyBzbyB0aGF0IHdlIGRvbid0IHJlcG9ydCBzdGFsbHMgY29taW5nIG91dCBvZiBhIHNlZWtcbiAgICBpZiAoYmVnaW5TZWVrIHx8IHNlZWtlZCkge1xuICAgICAgdGhpcy5zdGFsbGVkID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUaGUgcGxheWhlYWQgc2hvdWxkIG5vdCBiZSBtb3ZpbmdcbiAgICBpZiAobWVkaWEucGF1c2VkICYmICFzZWVraW5nIHx8IG1lZGlhLmVuZGVkIHx8IG1lZGlhLnBsYXliYWNrUmF0ZSA9PT0gMCB8fCAhQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKG1lZGlhKS5sZW5ndGgpIHtcbiAgICAgIHRoaXMubnVkZ2VSZXRyeSA9IDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhtZWRpYSwgY3VycmVudFRpbWUsIDApO1xuICAgIGNvbnN0IG5leHRTdGFydCA9IGJ1ZmZlckluZm8ubmV4dFN0YXJ0IHx8IDA7XG4gICAgaWYgKHNlZWtpbmcpIHtcbiAgICAgIC8vIFdhaXRpbmcgZm9yIHNlZWtpbmcgaW4gYSBidWZmZXJlZCByYW5nZSB0byBjb21wbGV0ZVxuICAgICAgY29uc3QgaGFzRW5vdWdoQnVmZmVyID0gYnVmZmVySW5mby5sZW4gPiBNQVhfU1RBUlRfR0FQX0pVTVA7XG4gICAgICAvLyBOZXh0IGJ1ZmZlcmVkIHJhbmdlIGlzIHRvbyBmYXIgYWhlYWQgdG8ganVtcCB0byB3aGlsZSBzdGlsbCBzZWVraW5nXG4gICAgICBjb25zdCBub0J1ZmZlckdhcCA9ICFuZXh0U3RhcnQgfHwgYWN0aXZlRnJhZyAmJiBhY3RpdmVGcmFnLnN0YXJ0IDw9IGN1cnJlbnRUaW1lIHx8IG5leHRTdGFydCAtIGN1cnJlbnRUaW1lID4gTUFYX1NUQVJUX0dBUF9KVU1QICYmICF0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRQYXJ0aWFsRnJhZ21lbnQoY3VycmVudFRpbWUpO1xuICAgICAgaWYgKGhhc0Vub3VnaEJ1ZmZlciB8fCBub0J1ZmZlckdhcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBSZXNldCBtb3ZlZCBzdGF0ZSB3aGVuIHNlZWtpbmcgdG8gYSBwb2ludCBpbiBvciBiZWZvcmUgYSBnYXBcbiAgICAgIHRoaXMubW92ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBTa2lwIHN0YXJ0IGdhcHMgaWYgd2UgaGF2ZW4ndCBwbGF5ZWQsIGJ1dCB0aGUgbGFzdCBwb2xsIGRldGVjdGVkIHRoZSBzdGFydCBvZiBhIHN0YWxsXG4gICAgLy8gVGhlIGFkZGl0aW9uIHBvbGwgZ2l2ZXMgdGhlIGJyb3dzZXIgYSBjaGFuY2UgdG8ganVtcCB0aGUgZ2FwIGZvciB1c1xuICAgIGlmICghdGhpcy5tb3ZlZCAmJiB0aGlzLnN0YWxsZWQgIT09IG51bGwpIHtcbiAgICAgIHZhciBfbGV2ZWwkZGV0YWlscztcbiAgICAgIC8vIFRoZXJlIGlzIG5vIHBsYXlhYmxlIGJ1ZmZlciAoc2Vla2VkLCB3YWl0aW5nIGZvciBidWZmZXIpXG4gICAgICBjb25zdCBpc0J1ZmZlcmVkID0gYnVmZmVySW5mby5sZW4gPiAwO1xuICAgICAgaWYgKCFpc0J1ZmZlcmVkICYmICFuZXh0U3RhcnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gSnVtcCBzdGFydCBnYXBzIHdpdGhpbiBqdW1wIHRocmVzaG9sZFxuICAgICAgY29uc3Qgc3RhcnRKdW1wID0gTWF0aC5tYXgobmV4dFN0YXJ0LCBidWZmZXJJbmZvLnN0YXJ0IHx8IDApIC0gY3VycmVudFRpbWU7XG5cbiAgICAgIC8vIFdoZW4gam9pbmluZyBhIGxpdmUgc3RyZWFtIHdpdGggYXVkaW8gdHJhY2tzLCBhY2NvdW50IGZvciBsaXZlIHBsYXlsaXN0IHdpbmRvdyBzbGlkaW5nIGJ5IGFsbG93aW5nXG4gICAgICAvLyBhIGxhcmdlciBqdW1wIG92ZXIgc3RhcnQgZ2FwcyBjYXVzZWQgYnkgdGhlIGF1ZGlvLXN0cmVhbS1jb250cm9sbGVyIGJ1ZmZlcmluZyBhIHN0YXJ0IGZyYWdtZW50XG4gICAgICAvLyB0aGF0IGJlZ2lucyBvdmVyIDEgdGFyZ2V0IGR1cmF0aW9uIGFmdGVyIHRoZSB2aWRlbyBzdGFydCBwb3NpdGlvbi5cbiAgICAgIGNvbnN0IGxldmVsID0gdGhpcy5obHMubGV2ZWxzID8gdGhpcy5obHMubGV2ZWxzW3RoaXMuaGxzLmN1cnJlbnRMZXZlbF0gOiBudWxsO1xuICAgICAgY29uc3QgaXNMaXZlID0gbGV2ZWwgPT0gbnVsbCA/IHZvaWQgMCA6IChfbGV2ZWwkZGV0YWlscyA9IGxldmVsLmRldGFpbHMpID09IG51bGwgPyB2b2lkIDAgOiBfbGV2ZWwkZGV0YWlscy5saXZlO1xuICAgICAgY29uc3QgbWF4U3RhcnRHYXBKdW1wID0gaXNMaXZlID8gbGV2ZWwuZGV0YWlscy50YXJnZXRkdXJhdGlvbiAqIDIgOiBNQVhfU1RBUlRfR0FQX0pVTVA7XG4gICAgICBjb25zdCBwYXJ0aWFsT3JHYXAgPSB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRQYXJ0aWFsRnJhZ21lbnQoY3VycmVudFRpbWUpO1xuICAgICAgaWYgKHN0YXJ0SnVtcCA+IDAgJiYgKHN0YXJ0SnVtcCA8PSBtYXhTdGFydEdhcEp1bXAgfHwgcGFydGlhbE9yR2FwKSkge1xuICAgICAgICBpZiAoIW1lZGlhLnBhdXNlZCkge1xuICAgICAgICAgIHRoaXMuX3RyeVNraXBCdWZmZXJIb2xlKHBhcnRpYWxPckdhcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN0YXJ0IHRyYWNraW5nIHN0YWxsIHRpbWVcbiAgICBjb25zdCB0bm93ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICBpZiAoc3RhbGxlZCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5zdGFsbGVkID0gdG5vdztcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RhbGxlZER1cmF0aW9uID0gdG5vdyAtIHN0YWxsZWQ7XG4gICAgaWYgKCFzZWVraW5nICYmIHN0YWxsZWREdXJhdGlvbiA+PSBTVEFMTF9NSU5JTVVNX0RVUkFUSU9OX01TKSB7XG4gICAgICAvLyBSZXBvcnQgc3RhbGxpbmcgYWZ0ZXIgdHJ5aW5nIHRvIGZpeFxuICAgICAgdGhpcy5fcmVwb3J0U3RhbGwoYnVmZmVySW5mbyk7XG4gICAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBidWZmZXJlZFdpdGhIb2xlcyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKG1lZGlhLCBjdXJyZW50VGltZSwgY29uZmlnLm1heEJ1ZmZlckhvbGUpO1xuICAgIHRoaXMuX3RyeUZpeEJ1ZmZlclN0YWxsKGJ1ZmZlcmVkV2l0aEhvbGVzLCBzdGFsbGVkRHVyYXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVjdHMgYW5kIGF0dGVtcHRzIHRvIGZpeCBrbm93biBidWZmZXIgc3RhbGxpbmcgaXNzdWVzLlxuICAgKiBAcGFyYW0gYnVmZmVySW5mbyAtIFRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IGJ1ZmZlci5cbiAgICogQHBhcmFtIHN0YWxsZWREdXJhdGlvbk1zIC0gVGhlIGFtb3VudCBvZiB0aW1lIEhscy5qcyBoYXMgYmVlbiBzdGFsbGluZyBmb3IuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdHJ5Rml4QnVmZmVyU3RhbGwoYnVmZmVySW5mbywgc3RhbGxlZER1cmF0aW9uTXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb25maWcsXG4gICAgICBmcmFnbWVudFRyYWNrZXIsXG4gICAgICBtZWRpYVxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChtZWRpYSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIGNvbnN0IHBhcnRpYWwgPSBmcmFnbWVudFRyYWNrZXIuZ2V0UGFydGlhbEZyYWdtZW50KGN1cnJlbnRUaW1lKTtcbiAgICBpZiAocGFydGlhbCkge1xuICAgICAgLy8gVHJ5IHRvIHNraXAgb3ZlciB0aGUgYnVmZmVyIGhvbGUgY2F1c2VkIGJ5IGEgcGFydGlhbCBmcmFnbWVudFxuICAgICAgLy8gVGhpcyBtZXRob2QgaXNuJ3QgbGltaXRlZCBieSB0aGUgc2l6ZSBvZiB0aGUgZ2FwIGJldHdlZW4gYnVmZmVyZWQgcmFuZ2VzXG4gICAgICBjb25zdCB0YXJnZXRUaW1lID0gdGhpcy5fdHJ5U2tpcEJ1ZmZlckhvbGUocGFydGlhbCk7XG4gICAgICAvLyB3ZSByZXR1cm4gaGVyZSBpbiB0aGlzIGNhc2UsIG1lYW5pbmdcbiAgICAgIC8vIHRoZSBicmFuY2ggYmVsb3cgb25seSBleGVjdXRlcyB3aGVuIHdlIGhhdmVuJ3Qgc2Vla2VkIHRvIGEgbmV3IHBvc2l0aW9uXG4gICAgICBpZiAodGFyZ2V0VGltZSB8fCAhdGhpcy5tZWRpYSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgd2UgaGF2ZW4ndCBoYWQgdG8gc2tpcCBvdmVyIGEgYnVmZmVyIGhvbGUgb2YgYSBwYXJ0aWFsIGZyYWdtZW50XG4gICAgLy8gd2UgbWF5IGp1c3QgaGF2ZSB0byBcIm51ZGdlXCIgdGhlIHBsYXlsaXN0IGFzIHRoZSBicm93c2VyIGRlY29kaW5nL3JlbmRlcmluZyBlbmdpbmVcbiAgICAvLyBuZWVkcyB0byBjcm9zcyBzb21lIHNvcnQgb2YgdGhyZXNob2xkIGNvdmVyaW5nIGFsbCBzb3VyY2UtYnVmZmVycyBjb250ZW50XG4gICAgLy8gdG8gc3RhcnQgcGxheWluZyBwcm9wZXJseS5cbiAgICBpZiAoKGJ1ZmZlckluZm8ubGVuID4gY29uZmlnLm1heEJ1ZmZlckhvbGUgfHwgYnVmZmVySW5mby5uZXh0U3RhcnQgJiYgYnVmZmVySW5mby5uZXh0U3RhcnQgLSBjdXJyZW50VGltZSA8IGNvbmZpZy5tYXhCdWZmZXJIb2xlKSAmJiBzdGFsbGVkRHVyYXRpb25NcyA+IGNvbmZpZy5oaWdoQnVmZmVyV2F0Y2hkb2dQZXJpb2QgKiAxMDAwKSB7XG4gICAgICBsb2dnZXIud2FybignVHJ5aW5nIHRvIG51ZGdlIHBsYXloZWFkIG92ZXIgYnVmZmVyLWhvbGUnKTtcbiAgICAgIC8vIFRyeSB0byBudWRnZSBjdXJyZW50VGltZSBvdmVyIGEgYnVmZmVyIGhvbGUgaWYgd2UndmUgYmVlbiBzdGFsbGluZyBmb3IgdGhlIGNvbmZpZ3VyZWQgYW1vdW50IG9mIHNlY29uZHNcbiAgICAgIC8vIFdlIG9ubHkgdHJ5IHRvIGp1bXAgdGhlIGhvbGUgaWYgaXQncyB1bmRlciB0aGUgY29uZmlndXJlZCBzaXplXG4gICAgICAvLyBSZXNldCBzdGFsbGVkIHNvIHRvIHJlYXJtIHdhdGNoZG9nIHRpbWVyXG4gICAgICB0aGlzLnN0YWxsZWQgPSBudWxsO1xuICAgICAgdGhpcy5fdHJ5TnVkZ2VCdWZmZXIoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVHJpZ2dlcnMgYSBCVUZGRVJfU1RBTExFRF9FUlJPUiBldmVudCwgYnV0IG9ubHkgb25jZSBwZXIgc3RhbGwgcGVyaW9kLlxuICAgKiBAcGFyYW0gYnVmZmVyTGVuIC0gVGhlIHBsYXloZWFkIGRpc3RhbmNlIGZyb20gdGhlIGVuZCBvZiB0aGUgY3VycmVudCBidWZmZXIgc2VnbWVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZXBvcnRTdGFsbChidWZmZXJJbmZvKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzLFxuICAgICAgbWVkaWEsXG4gICAgICBzdGFsbFJlcG9ydGVkXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFzdGFsbFJlcG9ydGVkICYmIG1lZGlhKSB7XG4gICAgICAvLyBSZXBvcnQgc3RhbGxlZCBlcnJvciBvbmNlXG4gICAgICB0aGlzLnN0YWxsUmVwb3J0ZWQgPSB0cnVlO1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYFBsYXliYWNrIHN0YWxsaW5nIGF0IEAke21lZGlhLmN1cnJlbnRUaW1lfSBkdWUgdG8gbG93IGJ1ZmZlciAoJHtKU09OLnN0cmluZ2lmeShidWZmZXJJbmZvKX0pYCk7XG4gICAgICBsb2dnZXIud2FybihlcnJvci5tZXNzYWdlKTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX1NUQUxMRURfRVJST1IsXG4gICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGJ1ZmZlcjogYnVmZmVySW5mby5sZW5cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBmaXggYnVmZmVyIHN0YWxscyBieSBqdW1waW5nIG92ZXIga25vd24gZ2FwcyBjYXVzZWQgYnkgcGFydGlhbCBmcmFnbWVudHNcbiAgICogQHBhcmFtIHBhcnRpYWwgLSBUaGUgcGFydGlhbCBmcmFnbWVudCBmb3VuZCBhdCB0aGUgY3VycmVudCB0aW1lICh3aGVyZSBwbGF5YmFjayBpcyBzdGFsbGluZykuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdHJ5U2tpcEJ1ZmZlckhvbGUocGFydGlhbCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbmZpZyxcbiAgICAgIGhscyxcbiAgICAgIG1lZGlhXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKG1lZGlhID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBjdXJyZW50VGltZSBpcyBiZXR3ZWVuIHVuYnVmZmVyZWQgcmVnaW9ucyBvZiBwYXJ0aWFsIGZyYWdtZW50c1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgY29uc3QgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKG1lZGlhLCBjdXJyZW50VGltZSwgMCk7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gY3VycmVudFRpbWUgPCBidWZmZXJJbmZvLnN0YXJ0ID8gYnVmZmVySW5mby5zdGFydCA6IGJ1ZmZlckluZm8ubmV4dFN0YXJ0O1xuICAgIGlmIChzdGFydFRpbWUpIHtcbiAgICAgIGNvbnN0IGJ1ZmZlclN0YXJ2ZWQgPSBidWZmZXJJbmZvLmxlbiA8PSBjb25maWcubWF4QnVmZmVySG9sZTtcbiAgICAgIGNvbnN0IHdhaXRpbmcgPSBidWZmZXJJbmZvLmxlbiA+IDAgJiYgYnVmZmVySW5mby5sZW4gPCAxICYmIG1lZGlhLnJlYWR5U3RhdGUgPCAzO1xuICAgICAgY29uc3QgZ2FwTGVuZ3RoID0gc3RhcnRUaW1lIC0gY3VycmVudFRpbWU7XG4gICAgICBpZiAoZ2FwTGVuZ3RoID4gMCAmJiAoYnVmZmVyU3RhcnZlZCB8fCB3YWl0aW5nKSkge1xuICAgICAgICAvLyBPbmx5IGFsbG93IGxhcmdlIGdhcHMgdG8gYmUgc2tpcHBlZCBpZiBpdCBpcyBhIHN0YXJ0IGdhcCwgb3IgYWxsIGZyYWdtZW50cyBpbiBza2lwIHJhbmdlIGFyZSBwYXJ0aWFsXG4gICAgICAgIGlmIChnYXBMZW5ndGggPiBjb25maWcubWF4QnVmZmVySG9sZSkge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGZyYWdtZW50VHJhY2tlclxuICAgICAgICAgIH0gPSB0aGlzO1xuICAgICAgICAgIGxldCBzdGFydEdhcCA9IGZhbHNlO1xuICAgICAgICAgIGlmIChjdXJyZW50VGltZSA9PT0gMCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRGcmFnID0gZnJhZ21lbnRUcmFja2VyLmdldEFwcGVuZGVkRnJhZygwLCBQbGF5bGlzdExldmVsVHlwZS5NQUlOKTtcbiAgICAgICAgICAgIGlmIChzdGFydEZyYWcgJiYgc3RhcnRUaW1lIDwgc3RhcnRGcmFnLmVuZCkge1xuICAgICAgICAgICAgICBzdGFydEdhcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghc3RhcnRHYXApIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0UHJvdmlzaW9uZWQgPSBwYXJ0aWFsIHx8IGZyYWdtZW50VHJhY2tlci5nZXRBcHBlbmRlZEZyYWcoY3VycmVudFRpbWUsIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pO1xuICAgICAgICAgICAgaWYgKHN0YXJ0UHJvdmlzaW9uZWQpIHtcbiAgICAgICAgICAgICAgbGV0IG1vcmVUb0xvYWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgbGV0IHBvcyA9IHN0YXJ0UHJvdmlzaW9uZWQuZW5kO1xuICAgICAgICAgICAgICB3aGlsZSAocG9zIDwgc3RhcnRUaW1lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvdmlzaW9uZWQgPSBmcmFnbWVudFRyYWNrZXIuZ2V0UGFydGlhbEZyYWdtZW50KHBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKHByb3Zpc2lvbmVkKSB7XG4gICAgICAgICAgICAgICAgICBwb3MgKz0gcHJvdmlzaW9uZWQuZHVyYXRpb247XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG1vcmVUb0xvYWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChtb3JlVG9Mb2FkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0VGltZSA9IE1hdGgubWF4KHN0YXJ0VGltZSArIFNLSVBfQlVGRkVSX1JBTkdFX1NUQVJULCBjdXJyZW50VGltZSArIFNLSVBfQlVGRkVSX0hPTEVfU1RFUF9TRUNPTkRTKTtcbiAgICAgICAgbG9nZ2VyLndhcm4oYHNraXBwaW5nIGhvbGUsIGFkanVzdGluZyBjdXJyZW50VGltZSBmcm9tICR7Y3VycmVudFRpbWV9IHRvICR7dGFyZ2V0VGltZX1gKTtcbiAgICAgICAgdGhpcy5tb3ZlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhbGxlZCA9IG51bGw7XG4gICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gdGFyZ2V0VGltZTtcbiAgICAgICAgaWYgKHBhcnRpYWwgJiYgIXBhcnRpYWwuZ2FwKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGZyYWdtZW50IGxvYWRlZCB3aXRoIGJ1ZmZlciBob2xlcywgc2Vla2luZyBmcm9tICR7Y3VycmVudFRpbWV9IHRvICR7dGFyZ2V0VGltZX1gKTtcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX1NFRUtfT1ZFUl9IT0xFLFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICByZWFzb246IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICBmcmFnOiBwYXJ0aWFsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldFRpbWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIGZpeCBidWZmZXIgc3RhbGxzIGJ5IGFkdmFuY2luZyB0aGUgbWVkaWFFbGVtZW50J3MgY3VycmVudCB0aW1lIGJ5IGEgc21hbGwgYW1vdW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3RyeU51ZGdlQnVmZmVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbmZpZyxcbiAgICAgIGhscyxcbiAgICAgIG1lZGlhLFxuICAgICAgbnVkZ2VSZXRyeVxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChtZWRpYSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIHRoaXMubnVkZ2VSZXRyeSsrO1xuICAgIGlmIChudWRnZVJldHJ5IDwgY29uZmlnLm51ZGdlTWF4UmV0cnkpIHtcbiAgICAgIGNvbnN0IHRhcmdldFRpbWUgPSBjdXJyZW50VGltZSArIChudWRnZVJldHJ5ICsgMSkgKiBjb25maWcubnVkZ2VPZmZzZXQ7XG4gICAgICAvLyBwbGF5YmFjayBzdGFsbGVkIGluIGJ1ZmZlcmVkIGFyZWEgLi4uIGxldCdzIG51ZGdlIGN1cnJlbnRUaW1lIHRvIHRyeSB0byBvdmVyY29tZSB0aGlzXG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgTnVkZ2luZyAnY3VycmVudFRpbWUnIGZyb20gJHtjdXJyZW50VGltZX0gdG8gJHt0YXJnZXRUaW1lfWApO1xuICAgICAgbG9nZ2VyLndhcm4oZXJyb3IubWVzc2FnZSk7XG4gICAgICBtZWRpYS5jdXJyZW50VGltZSA9IHRhcmdldFRpbWU7XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9OVURHRV9PTl9TVEFMTCxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGZhdGFsOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBQbGF5aGVhZCBzdGlsbCBub3QgbW92aW5nIHdoaWxlIGVub3VnaCBkYXRhIGJ1ZmZlcmVkIEAke2N1cnJlbnRUaW1lfSBhZnRlciAke2NvbmZpZy5udWRnZU1heFJldHJ5fSBudWRnZXNgKTtcbiAgICAgIGxvZ2dlci5lcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX1NUQUxMRURfRVJST1IsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IFRJQ0tfSU5URVJWQUwgPSAxMDA7IC8vIGhvdyBvZnRlbiB0byB0aWNrIGluIG1zXG5cbmNsYXNzIFN0cmVhbUNvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlU3RyZWFtQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGhscywgZnJhZ21lbnRUcmFja2VyLCBrZXlMb2FkZXIpIHtcbiAgICBzdXBlcihobHMsIGZyYWdtZW50VHJhY2tlciwga2V5TG9hZGVyLCAnW3N0cmVhbS1jb250cm9sbGVyXScsIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pO1xuICAgIHRoaXMuYXVkaW9Db2RlY1N3YXAgPSBmYWxzZTtcbiAgICB0aGlzLmdhcENvbnRyb2xsZXIgPSBudWxsO1xuICAgIHRoaXMubGV2ZWwgPSAtMTtcbiAgICB0aGlzLl9mb3JjZVN0YXJ0TG9hZCA9IGZhbHNlO1xuICAgIHRoaXMuYWx0QXVkaW8gPSBmYWxzZTtcbiAgICB0aGlzLmF1ZGlvT25seSA9IGZhbHNlO1xuICAgIHRoaXMuZnJhZ1BsYXlpbmcgPSBudWxsO1xuICAgIHRoaXMub252cGxheWluZyA9IG51bGw7XG4gICAgdGhpcy5vbnZzZWVrZWQgPSBudWxsO1xuICAgIHRoaXMuZnJhZ0xhc3RLYnBzID0gMDtcbiAgICB0aGlzLmNvdWxkQmFja3RyYWNrID0gZmFsc2U7XG4gICAgdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IG51bGw7XG4gICAgdGhpcy5hdWRpb0NvZGVjU3dpdGNoID0gZmFsc2U7XG4gICAgdGhpcy52aWRlb0J1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICBfcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRCwgdGhpcy5vbkZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSElORywgdGhpcy5vbkF1ZGlvVHJhY2tTd2l0Y2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENIRUQsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0NSRUFURUQsIHRoaXMub25CdWZmZXJDcmVhdGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9GTFVTSEVELCB0aGlzLm9uQnVmZmVyRmx1c2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTFNfVVBEQVRFRCwgdGhpcy5vbkxldmVsc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gIH1cbiAgX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQsIHRoaXMub25GcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSElORywgdGhpcy5vbkF1ZGlvVHJhY2tTd2l0Y2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSEVELCB0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfQ1JFQVRFRCwgdGhpcy5vbkJ1ZmZlckNyZWF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9GTFVTSEVELCB0aGlzLm9uQnVmZmVyRmx1c2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxTX1VQREFURUQsIHRoaXMub25MZXZlbHNVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgfVxuICBvbkhhbmRsZXJEZXN0cm95aW5nKCkge1xuICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICBzdXBlci5vbkhhbmRsZXJEZXN0cm95aW5nKCk7XG4gIH1cbiAgc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pIHtcbiAgICBpZiAodGhpcy5sZXZlbHMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGFzdEN1cnJlbnRUaW1lLFxuICAgICAgICBobHNcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgICAgdGhpcy5zZXRJbnRlcnZhbChUSUNLX0lOVEVSVkFMKTtcbiAgICAgIHRoaXMubGV2ZWwgPSAtMTtcbiAgICAgIGlmICghdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQpIHtcbiAgICAgICAgLy8gZGV0ZXJtaW5lIGxvYWQgbGV2ZWxcbiAgICAgICAgbGV0IHN0YXJ0TGV2ZWwgPSBobHMuc3RhcnRMZXZlbDtcbiAgICAgICAgaWYgKHN0YXJ0TGV2ZWwgPT09IC0xKSB7XG4gICAgICAgICAgaWYgKGhscy5jb25maWcudGVzdEJhbmR3aWR0aCAmJiB0aGlzLmxldmVscy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAvLyAtMSA6IGd1ZXNzIHN0YXJ0IExldmVsIGJ5IGRvaW5nIGEgYml0cmF0ZSB0ZXN0IGJ5IGxvYWRpbmcgZmlyc3QgZnJhZ21lbnQgb2YgbG93ZXN0IHF1YWxpdHkgbGV2ZWxcbiAgICAgICAgICAgIHN0YXJ0TGV2ZWwgPSAwO1xuICAgICAgICAgICAgdGhpcy5iaXRyYXRlVGVzdCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0TGV2ZWwgPSBobHMuZmlyc3RBdXRvTGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHNldCBuZXcgbGV2ZWwgdG8gcGxheWxpc3QgbG9hZGVyIDogdGhpcyB3aWxsIHRyaWdnZXIgc3RhcnQgbGV2ZWwgbG9hZFxuICAgICAgICAvLyBobHMubmV4dExvYWRMZXZlbCByZW1haW5zIHVudGlsIGl0IGlzIHNldCB0byBhIG5ldyB2YWx1ZSBvciB1bnRpbCBhIG5ldyBmcmFnIGlzIHN1Y2Nlc3NmdWxseSBsb2FkZWRcbiAgICAgICAgaGxzLm5leHRMb2FkTGV2ZWwgPSBzdGFydExldmVsO1xuICAgICAgICB0aGlzLmxldmVsID0gaGxzLmxvYWRMZXZlbDtcbiAgICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gaWYgc3RhcnRQb3NpdGlvbiB1bmRlZmluZWQgYnV0IGxhc3RDdXJyZW50VGltZSBzZXQsIHNldCBzdGFydFBvc2l0aW9uIHRvIGxhc3QgY3VycmVudFRpbWVcbiAgICAgIGlmIChsYXN0Q3VycmVudFRpbWUgPiAwICYmIHN0YXJ0UG9zaXRpb24gPT09IC0xKSB7XG4gICAgICAgIHRoaXMubG9nKGBPdmVycmlkZSBzdGFydFBvc2l0aW9uIHdpdGggbGFzdEN1cnJlbnRUaW1lIEAke2xhc3RDdXJyZW50VGltZS50b0ZpeGVkKDMpfWApO1xuICAgICAgICBzdGFydFBvc2l0aW9uID0gbGFzdEN1cnJlbnRUaW1lO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHN0YXJ0UG9zaXRpb247XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZm9yY2VTdGFydExvYWQgPSB0cnVlO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gICAgfVxuICB9XG4gIHN0b3BMb2FkKCkge1xuICAgIHRoaXMuX2ZvcmNlU3RhcnRMb2FkID0gZmFsc2U7XG4gICAgc3VwZXIuc3RvcExvYWQoKTtcbiAgfVxuICBkb1RpY2soKSB7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIFN0YXRlLldBSVRJTkdfTEVWRUw6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBsZXZlbHMsXG4gICAgICAgICAgICBsZXZlbFxuICAgICAgICAgIH0gPSB0aGlzO1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRMZXZlbCA9IGxldmVscyA9PSBudWxsID8gdm9pZCAwIDogbGV2ZWxzW2xldmVsXTtcbiAgICAgICAgICBjb25zdCBkZXRhaWxzID0gY3VycmVudExldmVsID09IG51bGwgPyB2b2lkIDAgOiBjdXJyZW50TGV2ZWwuZGV0YWlscztcbiAgICAgICAgICBpZiAoZGV0YWlscyAmJiAoIWRldGFpbHMubGl2ZSB8fCB0aGlzLmxldmVsTGFzdExvYWRlZCA9PT0gY3VycmVudExldmVsKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMud2FpdEZvckNkblR1bmVJbihkZXRhaWxzKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmhscy5uZXh0TG9hZExldmVsICE9PSB0aGlzLmxldmVsKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfdGhpcyRtZWRpYTtcbiAgICAgICAgICBjb25zdCBub3cgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgIGNvbnN0IHJldHJ5RGF0ZSA9IHRoaXMucmV0cnlEYXRlO1xuICAgICAgICAgIC8vIGlmIGN1cnJlbnQgdGltZSBpcyBndCB0aGFuIHJldHJ5RGF0ZSwgb3IgaWYgbWVkaWEgc2Vla2luZyBsZXQncyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byByZXRyeSBsb2FkaW5nXG4gICAgICAgICAgaWYgKCFyZXRyeURhdGUgfHwgbm93ID49IHJldHJ5RGF0ZSB8fCAoX3RoaXMkbWVkaWEgPSB0aGlzLm1lZGlhKSAhPSBudWxsICYmIF90aGlzJG1lZGlhLnNlZWtpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgbGV2ZWxzLFxuICAgICAgICAgICAgICBsZXZlbFxuICAgICAgICAgICAgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50TGV2ZWwgPSBsZXZlbHMgPT0gbnVsbCA/IHZvaWQgMCA6IGxldmVsc1tsZXZlbF07XG4gICAgICAgICAgICB0aGlzLnJlc2V0U3RhcnRXaGVuTm90TG9hZGVkKGN1cnJlbnRMZXZlbCB8fCBudWxsKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLklETEUpIHtcbiAgICAgIHRoaXMuZG9UaWNrSWRsZSgpO1xuICAgIH1cbiAgICB0aGlzLm9uVGlja0VuZCgpO1xuICB9XG4gIG9uVGlja0VuZCgpIHtcbiAgICBzdXBlci5vblRpY2tFbmQoKTtcbiAgICB0aGlzLmNoZWNrQnVmZmVyKCk7XG4gICAgdGhpcy5jaGVja0ZyYWdtZW50Q2hhbmdlZCgpO1xuICB9XG4gIGRvVGlja0lkbGUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzLFxuICAgICAgbGV2ZWxMYXN0TG9hZGVkLFxuICAgICAgbGV2ZWxzLFxuICAgICAgbWVkaWFcbiAgICB9ID0gdGhpcztcblxuICAgIC8vIGlmIHN0YXJ0IGxldmVsIG5vdCBwYXJzZWQgeWV0IE9SXG4gICAgLy8gaWYgdmlkZW8gbm90IGF0dGFjaGVkIEFORCBzdGFydCBmcmFnbWVudCBhbHJlYWR5IHJlcXVlc3RlZCBPUiBzdGFydCBmcmFnIHByZWZldGNoIG5vdCBlbmFibGVkXG4gICAgLy8gZXhpdCBsb29wLCBhcyB3ZSBlaXRoZXIgbmVlZCBtb3JlIGluZm8gKGxldmVsIG5vdCBwYXJzZWQpIG9yIHdlIG5lZWQgbWVkaWEgdG8gYmUgYXR0YWNoZWQgdG8gbG9hZCBuZXcgZnJhZ21lbnRcbiAgICBpZiAobGV2ZWxMYXN0TG9hZGVkID09PSBudWxsIHx8ICFtZWRpYSAmJiAodGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgfHwgIWhscy5jb25maWcuc3RhcnRGcmFnUHJlZmV0Y2gpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIFwibWFpblwiIGxldmVsIGlzIGF1ZGlvLW9ubHkgYnV0IHdlIGFyZSBsb2FkaW5nIGFuIGFsdGVybmF0ZSB0cmFjayBpbiB0aGUgc2FtZSBncm91cCwgZG8gbm90IGxvYWQgYW55dGhpbmdcbiAgICBpZiAodGhpcy5hbHRBdWRpbyAmJiB0aGlzLmF1ZGlvT25seSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsZXZlbCA9IGhscy5uZXh0TG9hZExldmVsO1xuICAgIGlmICghKGxldmVscyAhPSBudWxsICYmIGxldmVsc1tsZXZlbF0pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxldmVsSW5mbyA9IGxldmVsc1tsZXZlbF07XG5cbiAgICAvLyBpZiBidWZmZXIgbGVuZ3RoIGlzIGxlc3MgdGhhbiBtYXhCdWZMZW4gdHJ5IHRvIGxvYWQgYSBuZXcgZnJhZ21lbnRcblxuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSB0aGlzLmdldE1haW5Gd2RCdWZmZXJJbmZvKCk7XG4gICAgaWYgKGJ1ZmZlckluZm8gPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGFzdERldGFpbHMgPSB0aGlzLmdldExldmVsRGV0YWlscygpO1xuICAgIGlmIChsYXN0RGV0YWlscyAmJiB0aGlzLl9zdHJlYW1FbmRlZChidWZmZXJJbmZvLCBsYXN0RGV0YWlscykpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSB7fTtcbiAgICAgIGlmICh0aGlzLmFsdEF1ZGlvKSB7XG4gICAgICAgIGRhdGEudHlwZSA9ICd2aWRlbyc7XG4gICAgICB9XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfRU9TLCBkYXRhKTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FTkRFRDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzZXQgbmV4dCBsb2FkIGxldmVsIDogdGhpcyB3aWxsIHRyaWdnZXIgYSBwbGF5bGlzdCBsb2FkIGlmIG5lZWRlZFxuICAgIGlmIChobHMubG9hZExldmVsICE9PSBsZXZlbCAmJiBobHMubWFudWFsTGV2ZWwgPT09IC0xKSB7XG4gICAgICB0aGlzLmxvZyhgQWRhcHRpbmcgdG8gbGV2ZWwgJHtsZXZlbH0gZnJvbSBsZXZlbCAke3RoaXMubGV2ZWx9YCk7XG4gICAgfVxuICAgIHRoaXMubGV2ZWwgPSBobHMubmV4dExvYWRMZXZlbCA9IGxldmVsO1xuICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IGxldmVsSW5mby5kZXRhaWxzO1xuICAgIC8vIGlmIGxldmVsIGluZm8gbm90IHJldHJpZXZlZCB5ZXQsIHN3aXRjaCBzdGF0ZSBhbmQgd2FpdCBmb3IgbGV2ZWwgcmV0cmlldmFsXG4gICAgLy8gaWYgbGl2ZSBwbGF5bGlzdCwgZW5zdXJlIHRoYXQgbmV3IHBsYXlsaXN0IGhhcyBiZWVuIHJlZnJlc2hlZCB0byBhdm9pZCBsb2FkaW5nL3RyeSB0byBsb2FkXG4gICAgLy8gYSB1c2VsZXNzIGFuZCBvdXRkYXRlZCBmcmFnbWVudCAodGhhdCBtaWdodCBldmVuIGludHJvZHVjZSBsb2FkIGVycm9yIGlmIGl0IGlzIGFscmVhZHkgb3V0IG9mIHRoZSBsaXZlIHBsYXlsaXN0KVxuICAgIGlmICghbGV2ZWxEZXRhaWxzIHx8IHRoaXMuc3RhdGUgPT09IFN0YXRlLldBSVRJTkdfTEVWRUwgfHwgbGV2ZWxEZXRhaWxzLmxpdmUgJiYgdGhpcy5sZXZlbExhc3RMb2FkZWQgIT09IGxldmVsSW5mbykge1xuICAgICAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLldBSVRJTkdfTEVWRUw7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlckxlbiA9IGJ1ZmZlckluZm8ubGVuO1xuXG4gICAgLy8gY29tcHV0ZSBtYXggQnVmZmVyIExlbmd0aCB0aGF0IHdlIGNvdWxkIGdldCBmcm9tIHRoaXMgbG9hZCBsZXZlbCwgYmFzZWQgb24gbGV2ZWwgYml0cmF0ZS4gZG9uJ3QgYnVmZmVyIG1vcmUgdGhhbiA2MCBNQiBhbmQgbW9yZSB0aGFuIDMwc1xuICAgIGNvbnN0IG1heEJ1ZkxlbiA9IHRoaXMuZ2V0TWF4QnVmZmVyTGVuZ3RoKGxldmVsSW5mby5tYXhCaXRyYXRlKTtcblxuICAgIC8vIFN0YXkgaWRsZSBpZiB3ZSBhcmUgc3RpbGwgd2l0aCBidWZmZXIgbWFyZ2luc1xuICAgIGlmIChidWZmZXJMZW4gPj0gbWF4QnVmTGVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmJhY2t0cmFja0ZyYWdtZW50ICYmIHRoaXMuYmFja3RyYWNrRnJhZ21lbnQuc3RhcnQgPiBidWZmZXJJbmZvLmVuZCkge1xuICAgICAgdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldEJ1ZmZlclRpbWUgPSB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID8gdGhpcy5iYWNrdHJhY2tGcmFnbWVudC5zdGFydCA6IGJ1ZmZlckluZm8uZW5kO1xuICAgIGxldCBmcmFnID0gdGhpcy5nZXROZXh0RnJhZ21lbnQodGFyZ2V0QnVmZmVyVGltZSwgbGV2ZWxEZXRhaWxzKTtcbiAgICAvLyBBdm9pZCBiYWNrdHJhY2tpbmcgYnkgbG9hZGluZyBhbiBlYXJsaWVyIHNlZ21lbnQgaW4gc3RyZWFtcyB3aXRoIHNlZ21lbnRzIHRoYXQgZG8gbm90IHN0YXJ0IHdpdGggYSBrZXkgZnJhbWUgKGZsYWdnZWQgYnkgYGNvdWxkQmFja3RyYWNrYClcbiAgICBpZiAodGhpcy5jb3VsZEJhY2t0cmFjayAmJiAhdGhpcy5mcmFnUHJldmlvdXMgJiYgZnJhZyAmJiBmcmFnLnNuICE9PSAnaW5pdFNlZ21lbnQnICYmIHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGZyYWcpICE9PSBGcmFnbWVudFN0YXRlLk9LKSB7XG4gICAgICB2YXIgX3RoaXMkYmFja3RyYWNrRnJhZ21lO1xuICAgICAgY29uc3QgYmFja3RyYWNrU24gPSAoKF90aGlzJGJhY2t0cmFja0ZyYWdtZSA9IHRoaXMuYmFja3RyYWNrRnJhZ21lbnQpICE9IG51bGwgPyBfdGhpcyRiYWNrdHJhY2tGcmFnbWUgOiBmcmFnKS5zbjtcbiAgICAgIGNvbnN0IGZyYWdJZHggPSBiYWNrdHJhY2tTbiAtIGxldmVsRGV0YWlscy5zdGFydFNOO1xuICAgICAgY29uc3QgYmFja3RyYWNrRnJhZyA9IGxldmVsRGV0YWlscy5mcmFnbWVudHNbZnJhZ0lkeCAtIDFdO1xuICAgICAgaWYgKGJhY2t0cmFja0ZyYWcgJiYgZnJhZy5jYyA9PT0gYmFja3RyYWNrRnJhZy5jYykge1xuICAgICAgICBmcmFnID0gYmFja3RyYWNrRnJhZztcbiAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoYmFja3RyYWNrRnJhZyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmJhY2t0cmFja0ZyYWdtZW50ICYmIGJ1ZmZlckluZm8ubGVuKSB7XG4gICAgICB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID0gbnVsbDtcbiAgICB9XG4gICAgLy8gQXZvaWQgbG9vcCBsb2FkaW5nIGJ5IHVzaW5nIG5leHRMb2FkUG9zaXRpb24gc2V0IGZvciBiYWNrdHJhY2tpbmcgYW5kIHNraXBwaW5nIGNvbnNlY3V0aXZlIEdBUCB0YWdzXG4gICAgaWYgKGZyYWcgJiYgdGhpcy5pc0xvb3BMb2FkaW5nKGZyYWcsIHRhcmdldEJ1ZmZlclRpbWUpKSB7XG4gICAgICBjb25zdCBnYXBTdGFydCA9IGZyYWcuZ2FwO1xuICAgICAgaWYgKCFnYXBTdGFydCkge1xuICAgICAgICAvLyBDbGVhbnVwIHRoZSBmcmFnbWVudCB0cmFja2VyIGJlZm9yZSB0cnlpbmcgdG8gZmluZCB0aGUgbmV4dCB1bmJ1ZmZlcmVkIGZyYWdtZW50XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLmF1ZGlvT25seSAmJiAhdGhpcy5hbHRBdWRpbyA/IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJTyA6IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFTztcbiAgICAgICAgY29uc3QgbWVkaWFCdWZmZXIgPSAodHlwZSA9PT0gRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPID8gdGhpcy52aWRlb0J1ZmZlciA6IHRoaXMubWVkaWFCdWZmZXIpIHx8IHRoaXMubWVkaWE7XG4gICAgICAgIGlmIChtZWRpYUJ1ZmZlcikge1xuICAgICAgICAgIHRoaXMuYWZ0ZXJCdWZmZXJGbHVzaGVkKG1lZGlhQnVmZmVyLCB0eXBlLCBQbGF5bGlzdExldmVsVHlwZS5NQUlOKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnJhZyA9IHRoaXMuZ2V0TmV4dEZyYWdtZW50TG9vcExvYWRpbmcoZnJhZywgbGV2ZWxEZXRhaWxzLCBidWZmZXJJbmZvLCBQbGF5bGlzdExldmVsVHlwZS5NQUlOLCBtYXhCdWZMZW4pO1xuICAgIH1cbiAgICBpZiAoIWZyYWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGZyYWcuaW5pdFNlZ21lbnQgJiYgIWZyYWcuaW5pdFNlZ21lbnQuZGF0YSAmJiAhdGhpcy5iaXRyYXRlVGVzdCkge1xuICAgICAgZnJhZyA9IGZyYWcuaW5pdFNlZ21lbnQ7XG4gICAgfVxuICAgIHRoaXMubG9hZEZyYWdtZW50KGZyYWcsIGxldmVsSW5mbywgdGFyZ2V0QnVmZmVyVGltZSk7XG4gIH1cbiAgbG9hZEZyYWdtZW50KGZyYWcsIGxldmVsLCB0YXJnZXRCdWZmZXJUaW1lKSB7XG4gICAgLy8gQ2hlY2sgaWYgZnJhZ21lbnQgaXMgbm90IGxvYWRlZFxuICAgIGNvbnN0IGZyYWdTdGF0ZSA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGZyYWcpO1xuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBmcmFnO1xuICAgIGlmIChmcmFnU3RhdGUgPT09IEZyYWdtZW50U3RhdGUuTk9UX0xPQURFRCB8fCBmcmFnU3RhdGUgPT09IEZyYWdtZW50U3RhdGUuUEFSVElBTCkge1xuICAgICAgaWYgKGZyYWcuc24gPT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgICAgdGhpcy5fbG9hZEluaXRTZWdtZW50KGZyYWcsIGxldmVsKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5iaXRyYXRlVGVzdCkge1xuICAgICAgICB0aGlzLmxvZyhgRnJhZ21lbnQgJHtmcmFnLnNufSBvZiBsZXZlbCAke2ZyYWcubGV2ZWx9IGlzIGJlaW5nIGRvd25sb2FkZWQgdG8gdGVzdCBiaXRyYXRlIGFuZCB3aWxsIG5vdCBiZSBidWZmZXJlZGApO1xuICAgICAgICB0aGlzLl9sb2FkQml0cmF0ZVRlc3RGcmFnKGZyYWcsIGxldmVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgICAgc3VwZXIubG9hZEZyYWdtZW50KGZyYWcsIGxldmVsLCB0YXJnZXRCdWZmZXJUaW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jbGVhclRyYWNrZXJJZk5lZWRlZChmcmFnKTtcbiAgICB9XG4gIH1cbiAgZ2V0QnVmZmVyZWRGcmFnKHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldEJ1ZmZlcmVkRnJhZyhwb3NpdGlvbiwgUGxheWxpc3RMZXZlbFR5cGUuTUFJTik7XG4gIH1cbiAgZm9sbG93aW5nQnVmZmVyZWRGcmFnKGZyYWcpIHtcbiAgICBpZiAoZnJhZykge1xuICAgICAgLy8gdHJ5IHRvIGdldCByYW5nZSBvZiBuZXh0IGZyYWdtZW50ICg1MDBtcyBhZnRlciB0aGlzIHJhbmdlKVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyZWRGcmFnKGZyYWcuZW5kICsgMC41KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKlxuICAgIG9uIGltbWVkaWF0ZSBsZXZlbCBzd2l0Y2ggOlxuICAgICAtIHBhdXNlIHBsYXliYWNrIGlmIHBsYXlpbmdcbiAgICAgLSBjYW5jZWwgYW55IHBlbmRpbmcgbG9hZCByZXF1ZXN0XG4gICAgIC0gYW5kIHRyaWdnZXIgYSBidWZmZXIgZmx1c2hcbiAgKi9cbiAgaW1tZWRpYXRlTGV2ZWxTd2l0Y2goKSB7XG4gICAgdGhpcy5hYm9ydEN1cnJlbnRGcmFnKCk7XG4gICAgdGhpcy5mbHVzaE1haW5CdWZmZXIoMCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgfVxuXG4gIC8qKlxuICAgKiB0cnkgdG8gc3dpdGNoIEFTQVAgd2l0aG91dCBicmVha2luZyB2aWRlbyBwbGF5YmFjazpcbiAgICogaW4gb3JkZXIgdG8gZW5zdXJlIHNtb290aCBidXQgcXVpY2sgbGV2ZWwgc3dpdGNoaW5nLFxuICAgKiB3ZSBuZWVkIHRvIGZpbmQgdGhlIG5leHQgZmx1c2hhYmxlIGJ1ZmZlciByYW5nZVxuICAgKiB3ZSBzaG91bGQgdGFrZSBpbnRvIGFjY291bnQgbmV3IHNlZ21lbnQgZmV0Y2ggdGltZVxuICAgKi9cbiAgbmV4dExldmVsU3dpdGNoKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxldmVscyxcbiAgICAgIG1lZGlhXG4gICAgfSA9IHRoaXM7XG4gICAgLy8gZW5zdXJlIHRoYXQgbWVkaWEgaXMgZGVmaW5lZCBhbmQgdGhhdCBtZXRhZGF0YSBhcmUgYXZhaWxhYmxlICh0byByZXRyaWV2ZSBjdXJyZW50VGltZSlcbiAgICBpZiAobWVkaWEgIT0gbnVsbCAmJiBtZWRpYS5yZWFkeVN0YXRlKSB7XG4gICAgICBsZXQgZmV0Y2hkZWxheTtcbiAgICAgIGNvbnN0IGZyYWdQbGF5aW5nQ3VycmVudCA9IHRoaXMuZ2V0QXBwZW5kZWRGcmFnKG1lZGlhLmN1cnJlbnRUaW1lKTtcbiAgICAgIGlmIChmcmFnUGxheWluZ0N1cnJlbnQgJiYgZnJhZ1BsYXlpbmdDdXJyZW50LnN0YXJ0ID4gMSkge1xuICAgICAgICAvLyBmbHVzaCBidWZmZXIgcHJlY2VkaW5nIGN1cnJlbnQgZnJhZ21lbnQgKGZsdXNoIHVudGlsIGN1cnJlbnQgZnJhZ21lbnQgc3RhcnQgb2Zmc2V0KVxuICAgICAgICAvLyBtaW51cyAxcyB0byBhdm9pZCB2aWRlbyBmcmVlemluZywgdGhhdCBjb3VsZCBoYXBwZW4gaWYgd2UgZmx1c2gga2V5ZnJhbWUgb2YgY3VycmVudCB2aWRlbyAuLi5cbiAgICAgICAgdGhpcy5mbHVzaE1haW5CdWZmZXIoMCwgZnJhZ1BsYXlpbmdDdXJyZW50LnN0YXJ0IC0gMSk7XG4gICAgICB9XG4gICAgICBjb25zdCBsZXZlbERldGFpbHMgPSB0aGlzLmdldExldmVsRGV0YWlscygpO1xuICAgICAgaWYgKGxldmVsRGV0YWlscyAhPSBudWxsICYmIGxldmVsRGV0YWlscy5saXZlKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlckluZm8gPSB0aGlzLmdldE1haW5Gd2RCdWZmZXJJbmZvKCk7XG4gICAgICAgIC8vIERvIG5vdCBmbHVzaCBpbiBsaXZlIHN0cmVhbSB3aXRoIGxvdyBidWZmZXJcbiAgICAgICAgaWYgKCFidWZmZXJJbmZvIHx8IGJ1ZmZlckluZm8ubGVuIDwgbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uICogMikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFtZWRpYS5wYXVzZWQgJiYgbGV2ZWxzKSB7XG4gICAgICAgIC8vIGFkZCBhIHNhZmV0eSBkZWxheSBvZiAxc1xuICAgICAgICBjb25zdCBuZXh0TGV2ZWxJZCA9IHRoaXMuaGxzLm5leHRMb2FkTGV2ZWw7XG4gICAgICAgIGNvbnN0IG5leHRMZXZlbCA9IGxldmVsc1tuZXh0TGV2ZWxJZF07XG4gICAgICAgIGNvbnN0IGZyYWdMYXN0S2JwcyA9IHRoaXMuZnJhZ0xhc3RLYnBzO1xuICAgICAgICBpZiAoZnJhZ0xhc3RLYnBzICYmIHRoaXMuZnJhZ0N1cnJlbnQpIHtcbiAgICAgICAgICBmZXRjaGRlbGF5ID0gdGhpcy5mcmFnQ3VycmVudC5kdXJhdGlvbiAqIG5leHRMZXZlbC5tYXhCaXRyYXRlIC8gKDEwMDAgKiBmcmFnTGFzdEticHMpICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmZXRjaGRlbGF5ID0gMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmV0Y2hkZWxheSA9IDA7XG4gICAgICB9XG4gICAgICAvLyB0aGlzLmxvZygnZmV0Y2hkZWxheTonK2ZldGNoZGVsYXkpO1xuICAgICAgLy8gZmluZCBidWZmZXIgcmFuZ2UgdGhhdCB3aWxsIGJlIHJlYWNoZWQgb25jZSBuZXcgZnJhZ21lbnQgd2lsbCBiZSBmZXRjaGVkXG4gICAgICBjb25zdCBidWZmZXJlZEZyYWcgPSB0aGlzLmdldEJ1ZmZlcmVkRnJhZyhtZWRpYS5jdXJyZW50VGltZSArIGZldGNoZGVsYXkpO1xuICAgICAgaWYgKGJ1ZmZlcmVkRnJhZykge1xuICAgICAgICAvLyB3ZSBjYW4gZmx1c2ggYnVmZmVyIHJhbmdlIGZvbGxvd2luZyB0aGlzIG9uZSB3aXRob3V0IHN0YWxsaW5nIHBsYXliYWNrXG4gICAgICAgIGNvbnN0IG5leHRCdWZmZXJlZEZyYWcgPSB0aGlzLmZvbGxvd2luZ0J1ZmZlcmVkRnJhZyhidWZmZXJlZEZyYWcpO1xuICAgICAgICBpZiAobmV4dEJ1ZmZlcmVkRnJhZykge1xuICAgICAgICAgIC8vIGlmIHdlIGFyZSBoZXJlLCB3ZSBjYW4gYWxzbyBjYW5jZWwgYW55IGxvYWRpbmcvZGVtdXhpbmcgaW4gcHJvZ3Jlc3MsIGFzIHRoZXkgYXJlIHVzZWxlc3NcbiAgICAgICAgICB0aGlzLmFib3J0Q3VycmVudEZyYWcoKTtcbiAgICAgICAgICAvLyBzdGFydCBmbHVzaCBwb3NpdGlvbiBpcyBpbiBuZXh0IGJ1ZmZlcmVkIGZyYWcuIExlYXZlIHNvbWUgcGFkZGluZyBmb3Igbm9uLWluZGVwZW5kZW50IHNlZ21lbnRzIGFuZCBzbW9vdGhlciBwbGF5YmFjay5cbiAgICAgICAgICBjb25zdCBtYXhTdGFydCA9IG5leHRCdWZmZXJlZEZyYWcubWF4U3RhcnRQVFMgPyBuZXh0QnVmZmVyZWRGcmFnLm1heFN0YXJ0UFRTIDogbmV4dEJ1ZmZlcmVkRnJhZy5zdGFydDtcbiAgICAgICAgICBjb25zdCBmcmFnRHVyYXRpb24gPSBuZXh0QnVmZmVyZWRGcmFnLmR1cmF0aW9uO1xuICAgICAgICAgIGNvbnN0IHN0YXJ0UHRzID0gTWF0aC5tYXgoYnVmZmVyZWRGcmFnLmVuZCwgbWF4U3RhcnQgKyBNYXRoLm1pbihNYXRoLm1heChmcmFnRHVyYXRpb24gLSB0aGlzLmNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBmcmFnRHVyYXRpb24gKiAodGhpcy5jb3VsZEJhY2t0cmFjayA/IDAuNSA6IDAuMTI1KSksIGZyYWdEdXJhdGlvbiAqICh0aGlzLmNvdWxkQmFja3RyYWNrID8gMC43NSA6IDAuMjUpKSk7XG4gICAgICAgICAgdGhpcy5mbHVzaE1haW5CdWZmZXIoc3RhcnRQdHMsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYWJvcnRDdXJyZW50RnJhZygpIHtcbiAgICBjb25zdCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IG51bGw7XG4gICAgaWYgKGZyYWdDdXJyZW50KSB7XG4gICAgICBmcmFnQ3VycmVudC5hYm9ydFJlcXVlc3RzKCk7XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnQ3VycmVudCk7XG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBTdGF0ZS5LRVlfTE9BRElORzpcbiAgICAgIGNhc2UgU3RhdGUuRlJBR19MT0FESU5HOlxuICAgICAgY2FzZSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTpcbiAgICAgIGNhc2UgU3RhdGUuUEFSU0lORzpcbiAgICAgIGNhc2UgU3RhdGUuUEFSU0VEOlxuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuZ2V0TG9hZFBvc2l0aW9uKCk7XG4gIH1cbiAgZmx1c2hNYWluQnVmZmVyKHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpIHtcbiAgICBzdXBlci5mbHVzaE1haW5CdWZmZXIoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgdGhpcy5hbHRBdWRpbyA/ICd2aWRlbycgOiBudWxsKTtcbiAgfVxuICBvbk1lZGlhQXR0YWNoZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBzdXBlci5vbk1lZGlhQXR0YWNoZWQoZXZlbnQsIGRhdGEpO1xuICAgIGNvbnN0IG1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICB0aGlzLm9udnBsYXlpbmcgPSB0aGlzLm9uTWVkaWFQbGF5aW5nLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbnZzZWVrZWQgPSB0aGlzLm9uTWVkaWFTZWVrZWQuYmluZCh0aGlzKTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdwbGF5aW5nJywgdGhpcy5vbnZwbGF5aW5nKTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdzZWVrZWQnLCB0aGlzLm9udnNlZWtlZCk7XG4gICAgdGhpcy5nYXBDb250cm9sbGVyID0gbmV3IEdhcENvbnRyb2xsZXIodGhpcy5jb25maWcsIG1lZGlhLCB0aGlzLmZyYWdtZW50VHJhY2tlciwgdGhpcy5obHMpO1xuICB9XG4gIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbWVkaWFcbiAgICB9ID0gdGhpcztcbiAgICBpZiAobWVkaWEgJiYgdGhpcy5vbnZwbGF5aW5nICYmIHRoaXMub252c2Vla2VkKSB7XG4gICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdwbGF5aW5nJywgdGhpcy5vbnZwbGF5aW5nKTtcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlZWtlZCcsIHRoaXMub252c2Vla2VkKTtcbiAgICAgIHRoaXMub252cGxheWluZyA9IHRoaXMub252c2Vla2VkID0gbnVsbDtcbiAgICAgIHRoaXMudmlkZW9CdWZmZXIgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmZyYWdQbGF5aW5nID0gbnVsbDtcbiAgICBpZiAodGhpcy5nYXBDb250cm9sbGVyKSB7XG4gICAgICB0aGlzLmdhcENvbnRyb2xsZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5nYXBDb250cm9sbGVyID0gbnVsbDtcbiAgICB9XG4gICAgc3VwZXIub25NZWRpYURldGFjaGluZygpO1xuICB9XG4gIG9uTWVkaWFQbGF5aW5nKCkge1xuICAgIC8vIHRpY2sgdG8gc3BlZWQgdXAgRlJBR19DSEFOR0VEIHRyaWdnZXJpbmdcbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuICBvbk1lZGlhU2Vla2VkKCkge1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhID8gbWVkaWEuY3VycmVudFRpbWUgOiBudWxsO1xuICAgIGlmIChpc0Zpbml0ZU51bWJlcihjdXJyZW50VGltZSkpIHtcbiAgICAgIHRoaXMubG9nKGBNZWRpYSBzZWVrZWQgdG8gJHtjdXJyZW50VGltZS50b0ZpeGVkKDMpfWApO1xuICAgIH1cblxuICAgIC8vIElmIHNlZWtlZCB3YXMgaXNzdWVkIGJlZm9yZSBidWZmZXIgd2FzIGFwcGVuZGVkIGRvIG5vdCB0aWNrIGltbWVkaWF0ZWx5XG4gICAgY29uc3QgYnVmZmVySW5mbyA9IHRoaXMuZ2V0TWFpbkZ3ZEJ1ZmZlckluZm8oKTtcbiAgICBpZiAoYnVmZmVySW5mbyA9PT0gbnVsbCB8fCBidWZmZXJJbmZvLmxlbiA9PT0gMCkge1xuICAgICAgdGhpcy53YXJuKGBNYWluIGZvcndhcmQgYnVmZmVyIGxlbmd0aCBvbiBcInNlZWtlZFwiIGV2ZW50ICR7YnVmZmVySW5mbyA/IGJ1ZmZlckluZm8ubGVuIDogJ2VtcHR5J30pYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gdGljayB0byBzcGVlZCB1cCBGUkFHX0NIQU5HRUQgdHJpZ2dlcmluZ1xuICAgIHRoaXMudGljaygpO1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIC8vIHJlc2V0IGJ1ZmZlciBvbiBtYW5pZmVzdCBsb2FkaW5nXG4gICAgdGhpcy5sb2coJ1RyaWdnZXIgQlVGRkVSX1JFU0VUJyk7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX1JFU0VULCB1bmRlZmluZWQpO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUFsbEZyYWdtZW50cygpO1xuICAgIHRoaXMuY291bGRCYWNrdHJhY2sgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHRoaXMuZnJhZ0xhc3RLYnBzID0gMDtcbiAgICB0aGlzLmxldmVscyA9IHRoaXMuZnJhZ1BsYXlpbmcgPSB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID0gdGhpcy5sZXZlbExhc3RMb2FkZWQgPSBudWxsO1xuICAgIHRoaXMuYWx0QXVkaW8gPSB0aGlzLmF1ZGlvT25seSA9IHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gIH1cbiAgb25NYW5pZmVzdFBhcnNlZChldmVudCwgZGF0YSkge1xuICAgIC8vIGRldGVjdCBpZiB3ZSBoYXZlIGRpZmZlcmVudCBraW5kIG9mIGF1ZGlvIGNvZGVjcyB1c2VkIGFtb25nc3QgcGxheWxpc3RzXG4gICAgbGV0IGFhYyA9IGZhbHNlO1xuICAgIGxldCBoZWFhYyA9IGZhbHNlO1xuICAgIGRhdGEubGV2ZWxzLmZvckVhY2gobGV2ZWwgPT4ge1xuICAgICAgY29uc3QgY29kZWMgPSBsZXZlbC5hdWRpb0NvZGVjO1xuICAgICAgaWYgKGNvZGVjKSB7XG4gICAgICAgIGFhYyA9IGFhYyB8fCBjb2RlYy5pbmRleE9mKCdtcDRhLjQwLjInKSAhPT0gLTE7XG4gICAgICAgIGhlYWFjID0gaGVhYWMgfHwgY29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09IC0xO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuYXVkaW9Db2RlY1N3aXRjaCA9IGFhYyAmJiBoZWFhYyAmJiAhY2hhbmdlVHlwZVN1cHBvcnRlZCgpO1xuICAgIGlmICh0aGlzLmF1ZGlvQ29kZWNTd2l0Y2gpIHtcbiAgICAgIHRoaXMubG9nKCdCb3RoIEFBQy9IRS1BQUMgYXVkaW8gZm91bmQgaW4gbGV2ZWxzOyBkZWNsYXJpbmcgbGV2ZWwgY29kZWMgYXMgSEUtQUFDJyk7XG4gICAgfVxuICAgIHRoaXMubGV2ZWxzID0gZGF0YS5sZXZlbHM7XG4gICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgfVxuICBvbkxldmVsTG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxldmVsc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmICghbGV2ZWxzIHx8IHRoaXMuc3RhdGUgIT09IFN0YXRlLklETEUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGV2ZWwgPSBsZXZlbHNbZGF0YS5sZXZlbF07XG4gICAgaWYgKCFsZXZlbC5kZXRhaWxzIHx8IGxldmVsLmRldGFpbHMubGl2ZSAmJiB0aGlzLmxldmVsTGFzdExvYWRlZCAhPT0gbGV2ZWwgfHwgdGhpcy53YWl0Rm9yQ2RuVHVuZUluKGxldmVsLmRldGFpbHMpKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19MRVZFTDtcbiAgICB9XG4gIH1cbiAgb25MZXZlbExvYWRlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBfY3VyTGV2ZWwkZGV0YWlscztcbiAgICBjb25zdCB7XG4gICAgICBsZXZlbHNcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBuZXdMZXZlbElkID0gZGF0YS5sZXZlbDtcbiAgICBjb25zdCBuZXdEZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICAgIGNvbnN0IGR1cmF0aW9uID0gbmV3RGV0YWlscy50b3RhbGR1cmF0aW9uO1xuICAgIGlmICghbGV2ZWxzKSB7XG4gICAgICB0aGlzLndhcm4oYExldmVscyB3ZXJlIHJlc2V0IHdoaWxlIGxvYWRpbmcgbGV2ZWwgJHtuZXdMZXZlbElkfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxvZyhgTGV2ZWwgJHtuZXdMZXZlbElkfSBsb2FkZWQgWyR7bmV3RGV0YWlscy5zdGFydFNOfSwke25ld0RldGFpbHMuZW5kU059XSR7bmV3RGV0YWlscy5sYXN0UGFydFNuID8gYFtwYXJ0LSR7bmV3RGV0YWlscy5sYXN0UGFydFNufS0ke25ld0RldGFpbHMubGFzdFBhcnRJbmRleH1dYCA6ICcnfSwgY2MgWyR7bmV3RGV0YWlscy5zdGFydENDfSwgJHtuZXdEZXRhaWxzLmVuZENDfV0gZHVyYXRpb246JHtkdXJhdGlvbn1gKTtcbiAgICBjb25zdCBjdXJMZXZlbCA9IGxldmVsc1tuZXdMZXZlbElkXTtcbiAgICBjb25zdCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgaWYgKGZyYWdDdXJyZW50ICYmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5GUkFHX0xPQURJTkcgfHwgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlkpKSB7XG4gICAgICBpZiAoZnJhZ0N1cnJlbnQubGV2ZWwgIT09IGRhdGEubGV2ZWwgJiYgZnJhZ0N1cnJlbnQubG9hZGVyKSB7XG4gICAgICAgIHRoaXMuYWJvcnRDdXJyZW50RnJhZygpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgc2xpZGluZyA9IDA7XG4gICAgaWYgKG5ld0RldGFpbHMubGl2ZSB8fCAoX2N1ckxldmVsJGRldGFpbHMgPSBjdXJMZXZlbC5kZXRhaWxzKSAhPSBudWxsICYmIF9jdXJMZXZlbCRkZXRhaWxzLmxpdmUpIHtcbiAgICAgIHZhciBfdGhpcyRsZXZlbExhc3RMb2FkZWQ7XG4gICAgICB0aGlzLmNoZWNrTGl2ZVVwZGF0ZShuZXdEZXRhaWxzKTtcbiAgICAgIGlmIChuZXdEZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNsaWRpbmcgPSB0aGlzLmFsaWduUGxheWxpc3RzKG5ld0RldGFpbHMsIGN1ckxldmVsLmRldGFpbHMsIChfdGhpcyRsZXZlbExhc3RMb2FkZWQgPSB0aGlzLmxldmVsTGFzdExvYWRlZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGxldmVsTGFzdExvYWRlZC5kZXRhaWxzKTtcbiAgICB9XG4gICAgLy8gb3ZlcnJpZGUgbGV2ZWwgaW5mb1xuICAgIGN1ckxldmVsLmRldGFpbHMgPSBuZXdEZXRhaWxzO1xuICAgIHRoaXMubGV2ZWxMYXN0TG9hZGVkID0gY3VyTGV2ZWw7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTEVWRUxfVVBEQVRFRCwge1xuICAgICAgZGV0YWlsczogbmV3RGV0YWlscyxcbiAgICAgIGxldmVsOiBuZXdMZXZlbElkXG4gICAgfSk7XG5cbiAgICAvLyBvbmx5IHN3aXRjaCBiYWNrIHRvIElETEUgc3RhdGUgaWYgd2Ugd2VyZSB3YWl0aW5nIGZvciBsZXZlbCB0byBzdGFydCBkb3dubG9hZGluZyBhIG5ldyBmcmFnbWVudFxuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5XQUlUSU5HX0xFVkVMKSB7XG4gICAgICBpZiAodGhpcy53YWl0Rm9yQ2RuVHVuZUluKG5ld0RldGFpbHMpKSB7XG4gICAgICAgIC8vIFdhaXQgZm9yIExvdy1MYXRlbmN5IENETiBUdW5lLWluXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkKSB7XG4gICAgICB0aGlzLnNldFN0YXJ0UG9zaXRpb24obmV3RGV0YWlscywgc2xpZGluZyk7XG4gICAgfSBlbHNlIGlmIChuZXdEZXRhaWxzLmxpdmUpIHtcbiAgICAgIHRoaXMuc3luY2hyb25pemVUb0xpdmVFZGdlKG5ld0RldGFpbHMpO1xuICAgIH1cblxuICAgIC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuICBfaGFuZGxlRnJhZ21lbnRMb2FkUHJvZ3Jlc3MoZGF0YSkge1xuICAgIHZhciBfZnJhZyRpbml0U2VnbWVudDtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnLFxuICAgICAgcGFydCxcbiAgICAgIHBheWxvYWRcbiAgICB9ID0gZGF0YTtcbiAgICBjb25zdCB7XG4gICAgICBsZXZlbHNcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWxldmVscykge1xuICAgICAgdGhpcy53YXJuKGBMZXZlbHMgd2VyZSByZXNldCB3aGlsZSBmcmFnbWVudCBsb2FkIHdhcyBpbiBwcm9ncmVzcy4gRnJhZ21lbnQgJHtmcmFnLnNufSBvZiBsZXZlbCAke2ZyYWcubGV2ZWx9IHdpbGwgbm90IGJlIGJ1ZmZlcmVkYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRMZXZlbCA9IGxldmVsc1tmcmFnLmxldmVsXTtcbiAgICBjb25zdCBkZXRhaWxzID0gY3VycmVudExldmVsLmRldGFpbHM7XG4gICAgaWYgKCFkZXRhaWxzKSB7XG4gICAgICB0aGlzLndhcm4oYERyb3BwaW5nIGZyYWdtZW50ICR7ZnJhZy5zbn0gb2YgbGV2ZWwgJHtmcmFnLmxldmVsfSBhZnRlciBsZXZlbCBkZXRhaWxzIHdlcmUgcmVzZXRgKTtcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB2aWRlb0NvZGVjID0gY3VycmVudExldmVsLnZpZGVvQ29kZWM7XG5cbiAgICAvLyB0aW1lIE9mZnNldCBpcyBhY2N1cmF0ZSBpZiBsZXZlbCBQVFMgaXMga25vd24sIG9yIGlmIHBsYXlsaXN0IGlzIG5vdCBzbGlkaW5nIChub3QgbGl2ZSlcbiAgICBjb25zdCBhY2N1cmF0ZVRpbWVPZmZzZXQgPSBkZXRhaWxzLlBUU0tub3duIHx8ICFkZXRhaWxzLmxpdmU7XG4gICAgY29uc3QgaW5pdFNlZ21lbnREYXRhID0gKF9mcmFnJGluaXRTZWdtZW50ID0gZnJhZy5pbml0U2VnbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mcmFnJGluaXRTZWdtZW50LmRhdGE7XG4gICAgY29uc3QgYXVkaW9Db2RlYyA9IHRoaXMuX2dldEF1ZGlvQ29kZWMoY3VycmVudExldmVsKTtcblxuICAgIC8vIHRyYW5zbXV4IHRoZSBNUEVHLVRTIGRhdGEgdG8gSVNPLUJNRkYgc2VnbWVudHNcbiAgICAvLyB0aGlzLmxvZyhgVHJhbnNtdXhpbmcgJHtmcmFnLnNufSBvZiBbJHtkZXRhaWxzLnN0YXJ0U059ICwke2RldGFpbHMuZW5kU059XSxsZXZlbCAke2ZyYWcubGV2ZWx9LCBjYyAke2ZyYWcuY2N9YCk7XG4gICAgY29uc3QgdHJhbnNtdXhlciA9IHRoaXMudHJhbnNtdXhlciA9IHRoaXMudHJhbnNtdXhlciB8fCBuZXcgVHJhbnNtdXhlckludGVyZmFjZSh0aGlzLmhscywgUGxheWxpc3RMZXZlbFR5cGUuTUFJTiwgdGhpcy5faGFuZGxlVHJhbnNtdXhDb21wbGV0ZS5iaW5kKHRoaXMpLCB0aGlzLl9oYW5kbGVUcmFuc211eGVyRmx1c2guYmluZCh0aGlzKSk7XG4gICAgY29uc3QgcGFydEluZGV4ID0gcGFydCA/IHBhcnQuaW5kZXggOiAtMTtcbiAgICBjb25zdCBwYXJ0aWFsID0gcGFydEluZGV4ICE9PSAtMTtcbiAgICBjb25zdCBjaHVua01ldGEgPSBuZXcgQ2h1bmtNZXRhZGF0YShmcmFnLmxldmVsLCBmcmFnLnNuLCBmcmFnLnN0YXRzLmNodW5rQ291bnQsIHBheWxvYWQuYnl0ZUxlbmd0aCwgcGFydEluZGV4LCBwYXJ0aWFsKTtcbiAgICBjb25zdCBpbml0UFRTID0gdGhpcy5pbml0UFRTW2ZyYWcuY2NdO1xuICAgIHRyYW5zbXV4ZXIucHVzaChwYXlsb2FkLCBpbml0U2VnbWVudERhdGEsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGZyYWcsIHBhcnQsIGRldGFpbHMudG90YWxkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBjaHVua01ldGEsIGluaXRQVFMpO1xuICB9XG4gIG9uQXVkaW9UcmFja1N3aXRjaGluZyhldmVudCwgZGF0YSkge1xuICAgIC8vIGlmIGFueSBVUkwgZm91bmQgb24gbmV3IGF1ZGlvIHRyYWNrLCBpdCBpcyBhbiBhbHRlcm5hdGUgYXVkaW8gdHJhY2tcbiAgICBjb25zdCBmcm9tQWx0QXVkaW8gPSB0aGlzLmFsdEF1ZGlvO1xuICAgIGNvbnN0IGFsdEF1ZGlvID0gISFkYXRhLnVybDtcbiAgICAvLyBpZiB3ZSBzd2l0Y2ggb24gbWFpbiBhdWRpbywgZW5zdXJlIHRoYXQgbWFpbiBmcmFnbWVudCBzY2hlZHVsaW5nIGlzIHN5bmNlZCB3aXRoIG1lZGlhLmJ1ZmZlcmVkXG4gICAgLy8gZG9uJ3QgZG8gYW55dGhpbmcgaWYgd2Ugc3dpdGNoIHRvIGFsdCBhdWRpbzogYXVkaW8gc3RyZWFtIGNvbnRyb2xsZXIgaXMgaGFuZGxpbmcgaXQuXG4gICAgLy8gd2Ugd2lsbCBqdXN0IGhhdmUgdG8gY2hhbmdlIGJ1ZmZlciBzY2hlZHVsaW5nIG9uIGF1ZGlvVHJhY2tTd2l0Y2hlZFxuICAgIGlmICghYWx0QXVkaW8pIHtcbiAgICAgIGlmICh0aGlzLm1lZGlhQnVmZmVyICE9PSB0aGlzLm1lZGlhKSB7XG4gICAgICAgIHRoaXMubG9nKCdTd2l0Y2hpbmcgb24gbWFpbiBhdWRpbywgdXNlIG1lZGlhLmJ1ZmZlcmVkIHRvIHNjaGVkdWxlIG1haW4gZnJhZ21lbnQgbG9hZGluZycpO1xuICAgICAgICB0aGlzLm1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYTtcbiAgICAgICAgY29uc3QgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIHJlZmlsbCBhdWRpbyBidWZmZXIgZnJvbSBtYWluOiBjYW5jZWwgYW55IGZyYWcgbG9hZGluZyB0byBzcGVlZCB1cCBhdWRpbyBzd2l0Y2hcbiAgICAgICAgaWYgKGZyYWdDdXJyZW50KSB7XG4gICAgICAgICAgdGhpcy5sb2coJ1N3aXRjaGluZyB0byBtYWluIGF1ZGlvIHRyYWNrLCBjYW5jZWwgbWFpbiBmcmFnbWVudCBsb2FkJyk7XG4gICAgICAgICAgZnJhZ0N1cnJlbnQuYWJvcnRSZXF1ZXN0cygpO1xuICAgICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWdDdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkZXN0cm95IHRyYW5zbXV4ZXIgdG8gZm9yY2UgaW5pdCBzZWdtZW50IGdlbmVyYXRpb24gKGZvbGxvd2luZyBhdWRpbyBzd2l0Y2gpXG4gICAgICAgIHRoaXMucmVzZXRUcmFuc211eGVyKCk7XG4gICAgICAgIC8vIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIGxvYWQgbmV3IGZyYWdtZW50XG4gICAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5hdWRpb09ubHkpIHtcbiAgICAgICAgLy8gUmVzZXQgYXVkaW8gdHJhbnNtdXhlciBzbyB3aGVuIHN3aXRjaGluZyBiYWNrIHRvIG1haW4gYXVkaW8gd2UncmUgbm90IHN0aWxsIGFwcGVuZGluZyB3aGVyZSB3ZSBsZWZ0IG9mZlxuICAgICAgICB0aGlzLnJlc2V0VHJhbnNtdXhlcigpO1xuICAgICAgfVxuICAgICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgICAvLyBJZiBzd2l0Y2hpbmcgZnJvbSBhbHQgdG8gbWFpbiBhdWRpbywgZmx1c2ggYWxsIGF1ZGlvIGFuZCB0cmlnZ2VyIHRyYWNrIHN3aXRjaGVkXG4gICAgICBpZiAoZnJvbUFsdEF1ZGlvKSB7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHtcbiAgICAgICAgICBzdGFydE9mZnNldDogMCxcbiAgICAgICAgICBlbmRPZmZzZXQ6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICAgICAgICB0eXBlOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVBbGxGcmFnbWVudHMoKTtcbiAgICAgIH1cbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hFRCwgZGF0YSk7XG4gICAgfVxuICB9XG4gIG9uQXVkaW9UcmFja1N3aXRjaGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3QgdHJhY2tJZCA9IGRhdGEuaWQ7XG4gICAgY29uc3QgYWx0QXVkaW8gPSAhIXRoaXMuaGxzLmF1ZGlvVHJhY2tzW3RyYWNrSWRdLnVybDtcbiAgICBpZiAoYWx0QXVkaW8pIHtcbiAgICAgIGNvbnN0IHZpZGVvQnVmZmVyID0gdGhpcy52aWRlb0J1ZmZlcjtcbiAgICAgIC8vIGlmIHdlIHN3aXRjaGVkIG9uIGFsdGVybmF0ZSBhdWRpbywgZW5zdXJlIHRoYXQgbWFpbiBmcmFnbWVudCBzY2hlZHVsaW5nIGlzIHN5bmNlZCB3aXRoIHZpZGVvIHNvdXJjZWJ1ZmZlciBidWZmZXJlZFxuICAgICAgaWYgKHZpZGVvQnVmZmVyICYmIHRoaXMubWVkaWFCdWZmZXIgIT09IHZpZGVvQnVmZmVyKSB7XG4gICAgICAgIHRoaXMubG9nKCdTd2l0Y2hpbmcgb24gYWx0ZXJuYXRlIGF1ZGlvLCB1c2UgdmlkZW8uYnVmZmVyZWQgdG8gc2NoZWR1bGUgbWFpbiBmcmFnbWVudCBsb2FkaW5nJyk7XG4gICAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB2aWRlb0J1ZmZlcjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5hbHRBdWRpbyA9IGFsdEF1ZGlvO1xuICAgIHRoaXMudGljaygpO1xuICB9XG4gIG9uQnVmZmVyQ3JlYXRlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHRyYWNrcyA9IGRhdGEudHJhY2tzO1xuICAgIGxldCBtZWRpYVRyYWNrO1xuICAgIGxldCBuYW1lO1xuICAgIGxldCBhbHRlcm5hdGUgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IHR5cGUgaW4gdHJhY2tzKSB7XG4gICAgICBjb25zdCB0cmFjayA9IHRyYWNrc1t0eXBlXTtcbiAgICAgIGlmICh0cmFjay5pZCA9PT0gJ21haW4nKSB7XG4gICAgICAgIG5hbWUgPSB0eXBlO1xuICAgICAgICBtZWRpYVRyYWNrID0gdHJhY2s7XG4gICAgICAgIC8vIGtlZXAgdmlkZW8gc291cmNlIGJ1ZmZlciByZWZlcmVuY2VcbiAgICAgICAgaWYgKHR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICBjb25zdCB2aWRlb1RyYWNrID0gdHJhY2tzW3R5cGVdO1xuICAgICAgICAgIGlmICh2aWRlb1RyYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnZpZGVvQnVmZmVyID0gdmlkZW9UcmFjay5idWZmZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbHRlcm5hdGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWx0ZXJuYXRlICYmIG1lZGlhVHJhY2spIHtcbiAgICAgIHRoaXMubG9nKGBBbHRlcm5hdGUgdHJhY2sgZm91bmQsIHVzZSAke25hbWV9LmJ1ZmZlcmVkIHRvIHNjaGVkdWxlIG1haW4gZnJhZ21lbnQgbG9hZGluZ2ApO1xuICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IG1lZGlhVHJhY2suYnVmZmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYTtcbiAgICB9XG4gIH1cbiAgb25GcmFnQnVmZmVyZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnLFxuICAgICAgcGFydFxuICAgIH0gPSBkYXRhO1xuICAgIGlmIChmcmFnICYmIGZyYWcudHlwZSAhPT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgIC8vIElmIGEgbGV2ZWwgc3dpdGNoIHdhcyByZXF1ZXN0ZWQgd2hpbGUgYSBmcmFnbWVudCB3YXMgYnVmZmVyaW5nLCBpdCB3aWxsIGVtaXQgdGhlIEZSQUdfQlVGRkVSRUQgZXZlbnQgdXBvbiBjb21wbGV0aW9uXG4gICAgICAvLyBBdm9pZCBzZXR0aW5nIHN0YXRlIGJhY2sgdG8gSURMRSwgc2luY2UgdGhhdCB3aWxsIGludGVyZmVyZSB3aXRoIGEgbGV2ZWwgc3dpdGNoXG4gICAgICB0aGlzLndhcm4oYEZyYWdtZW50ICR7ZnJhZy5zbn0ke3BhcnQgPyAnIHA6ICcgKyBwYXJ0LmluZGV4IDogJyd9IG9mIGxldmVsICR7ZnJhZy5sZXZlbH0gZmluaXNoZWQgYnVmZmVyaW5nLCBidXQgd2FzIGFib3J0ZWQuIHN0YXRlOiAke3RoaXMuc3RhdGV9YCk7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0VEKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdGF0cyA9IHBhcnQgPyBwYXJ0LnN0YXRzIDogZnJhZy5zdGF0cztcbiAgICB0aGlzLmZyYWdMYXN0S2JwcyA9IE1hdGgucm91bmQoOCAqIHN0YXRzLnRvdGFsIC8gKHN0YXRzLmJ1ZmZlcmluZy5lbmQgLSBzdGF0cy5sb2FkaW5nLmZpcnN0KSk7XG4gICAgaWYgKGZyYWcuc24gIT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gZnJhZztcbiAgICB9XG4gICAgdGhpcy5mcmFnQnVmZmVyZWRDb21wbGV0ZShmcmFnLCBwYXJ0KTtcbiAgfVxuICBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF9kYXRhJGNvbnRleHQ7XG4gICAgaWYgKGRhdGEuZmF0YWwpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FUlJPUjtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpdGNoIChkYXRhLmRldGFpbHMpIHtcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfR0FQOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19ERUNSWVBUX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQ6XG4gICAgICAgIHRoaXMub25GcmFnbWVudE9yS2V5TG9hZEVycm9yKFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4sIGRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQ6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9QQVJTSU5HX0VSUk9SOlxuICAgICAgICAvLyBpbiBjYXNlIG9mIG5vbiBmYXRhbCBlcnJvciB3aGlsZSBsb2FkaW5nIGxldmVsLCBpZiBsZXZlbCBjb250cm9sbGVyIGlzIG5vdCByZXRyeWluZyB0byBsb2FkIGxldmVsLCBzd2l0Y2ggYmFjayB0byBJRExFXG4gICAgICAgIGlmICghZGF0YS5sZXZlbFJldHJ5ICYmIHRoaXMuc3RhdGUgPT09IFN0YXRlLldBSVRJTkdfTEVWRUwgJiYgKChfZGF0YSRjb250ZXh0ID0gZGF0YS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGEkY29udGV4dC50eXBlKSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5MRVZFTCkge1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9GVUxMX0VSUk9SOlxuICAgICAgICBpZiAoIWRhdGEucGFyZW50IHx8IGRhdGEucGFyZW50ICE9PSAnbWFpbicpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRfRVJST1IpIHtcbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlZHVjZUxlbmd0aEFuZEZsdXNoQnVmZmVyKGRhdGEpKSB7XG4gICAgICAgICAgdGhpcy5mbHVzaE1haW5CdWZmZXIoMCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLklOVEVSTkFMX0VYQ0VQVElPTjpcbiAgICAgICAgdGhpcy5yZWNvdmVyV29ya2VyRXJyb3IoZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIENoZWNrcyB0aGUgaGVhbHRoIG9mIHRoZSBidWZmZXIgYW5kIGF0dGVtcHRzIHRvIHJlc29sdmUgcGxheWJhY2sgc3RhbGxzLlxuICBjaGVja0J1ZmZlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZWRpYSxcbiAgICAgIGdhcENvbnRyb2xsZXJcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIW1lZGlhIHx8ICFnYXBDb250cm9sbGVyIHx8ICFtZWRpYS5yZWFkeVN0YXRlKSB7XG4gICAgICAvLyBFeGl0IGVhcmx5IGlmIHdlIGRvbid0IGhhdmUgbWVkaWEgb3IgaWYgdGhlIG1lZGlhIGhhc24ndCBidWZmZXJlZCBhbnl0aGluZyB5ZXQgKHJlYWR5U3RhdGUgMClcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMubG9hZGVkbWV0YWRhdGEgfHwgIUJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZChtZWRpYSkubGVuZ3RoKSB7XG4gICAgICAvLyBSZXNvbHZlIGdhcHMgdXNpbmcgdGhlIG1haW4gYnVmZmVyLCB3aG9zZSByYW5nZXMgYXJlIHRoZSBpbnRlcnNlY3Rpb25zIG9mIHRoZSBBL1Ygc291cmNlYnVmZmVyc1xuICAgICAgY29uc3QgYWN0aXZlRnJhZyA9IHRoaXMuc3RhdGUgIT09IFN0YXRlLklETEUgPyB0aGlzLmZyYWdDdXJyZW50IDogbnVsbDtcbiAgICAgIGdhcENvbnRyb2xsZXIucG9sbCh0aGlzLmxhc3RDdXJyZW50VGltZSwgYWN0aXZlRnJhZyk7XG4gICAgfVxuICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gIH1cbiAgb25GcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWQoKSB7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgLy8gaWYgbG9hZGVkbWV0YWRhdGEgaXMgbm90IHNldCwgaXQgbWVhbnMgdGhhdCB3ZSBhcmUgZW1lcmdlbmN5IHN3aXRjaCBkb3duIG9uIGZpcnN0IGZyYWdcbiAgICAvLyBpbiB0aGF0IGNhc2UsIHJlc2V0IHN0YXJ0RnJhZ1JlcXVlc3RlZCBmbGFnXG4gICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhKSB7XG4gICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uO1xuICAgIH1cbiAgICB0aGlzLnRpY2tJbW1lZGlhdGUoKTtcbiAgfVxuICBvbkJ1ZmZlckZsdXNoZWQoZXZlbnQsIHtcbiAgICB0eXBlXG4gIH0pIHtcbiAgICBpZiAodHlwZSAhPT0gRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPIHx8IHRoaXMuYXVkaW9Pbmx5ICYmICF0aGlzLmFsdEF1ZGlvKSB7XG4gICAgICBjb25zdCBtZWRpYUJ1ZmZlciA9ICh0eXBlID09PSBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU8gPyB0aGlzLnZpZGVvQnVmZmVyIDogdGhpcy5tZWRpYUJ1ZmZlcikgfHwgdGhpcy5tZWRpYTtcbiAgICAgIHRoaXMuYWZ0ZXJCdWZmZXJGbHVzaGVkKG1lZGlhQnVmZmVyLCB0eXBlLCBQbGF5bGlzdExldmVsVHlwZS5NQUlOKTtcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH1cbiAgfVxuICBvbkxldmVsc1VwZGF0ZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBpZiAodGhpcy5sZXZlbCA+IC0xICYmIHRoaXMuZnJhZ0N1cnJlbnQpIHtcbiAgICAgIHRoaXMubGV2ZWwgPSB0aGlzLmZyYWdDdXJyZW50LmxldmVsO1xuICAgIH1cbiAgICB0aGlzLmxldmVscyA9IGRhdGEubGV2ZWxzO1xuICB9XG4gIHN3YXBBdWRpb0NvZGVjKCkge1xuICAgIHRoaXMuYXVkaW9Db2RlY1N3YXAgPSAhdGhpcy5hdWRpb0NvZGVjU3dhcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWVrcyB0byB0aGUgc2V0IHN0YXJ0UG9zaXRpb24gaWYgbm90IGVxdWFsIHRvIHRoZSBtZWRpYUVsZW1lbnQncyBjdXJyZW50IHRpbWUuXG4gICAqL1xuICBzZWVrVG9TdGFydFBvcygpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZWRpYVxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghbWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICBsZXQgc3RhcnRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICAvLyBvbmx5IGFkanVzdCBjdXJyZW50VGltZSBpZiBkaWZmZXJlbnQgZnJvbSBzdGFydFBvc2l0aW9uIG9yIGlmIHN0YXJ0UG9zaXRpb24gbm90IGJ1ZmZlcmVkXG4gICAgLy8gYXQgdGhhdCBzdGFnZSwgdGhlcmUgc2hvdWxkIGJlIG9ubHkgb25lIGJ1ZmZlcmVkIHJhbmdlLCBhcyB3ZSByZWFjaCB0aGF0IGNvZGUgYWZ0ZXIgZmlyc3QgZnJhZ21lbnQgaGFzIGJlZW4gYnVmZmVyZWRcbiAgICBpZiAoc3RhcnRQb3NpdGlvbiA+PSAwICYmIGN1cnJlbnRUaW1lIDwgc3RhcnRQb3NpdGlvbikge1xuICAgICAgaWYgKG1lZGlhLnNlZWtpbmcpIHtcbiAgICAgICAgdGhpcy5sb2coYGNvdWxkIG5vdCBzZWVrIHRvICR7c3RhcnRQb3NpdGlvbn0sIGFscmVhZHkgc2Vla2luZyBhdCAke2N1cnJlbnRUaW1lfWApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBidWZmZXJlZCA9IEJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZChtZWRpYSk7XG4gICAgICBjb25zdCBidWZmZXJTdGFydCA9IGJ1ZmZlcmVkLmxlbmd0aCA/IGJ1ZmZlcmVkLnN0YXJ0KDApIDogMDtcbiAgICAgIGNvbnN0IGRlbHRhID0gYnVmZmVyU3RhcnQgLSBzdGFydFBvc2l0aW9uO1xuICAgICAgaWYgKGRlbHRhID4gMCAmJiAoZGVsdGEgPCB0aGlzLmNvbmZpZy5tYXhCdWZmZXJIb2xlIHx8IGRlbHRhIDwgdGhpcy5jb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSkpIHtcbiAgICAgICAgdGhpcy5sb2coYGFkanVzdGluZyBzdGFydCBwb3NpdGlvbiBieSAke2RlbHRhfSB0byBtYXRjaCBidWZmZXIgc3RhcnRgKTtcbiAgICAgICAgc3RhcnRQb3NpdGlvbiArPSBkZWx0YTtcbiAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbjtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nKGBzZWVrIHRvIHRhcmdldCBzdGFydCBwb3NpdGlvbiAke3N0YXJ0UG9zaXRpb259IGZyb20gY3VycmVudCB0aW1lICR7Y3VycmVudFRpbWV9YCk7XG4gICAgICBtZWRpYS5jdXJyZW50VGltZSA9IHN0YXJ0UG9zaXRpb247XG4gICAgfVxuICB9XG4gIF9nZXRBdWRpb0NvZGVjKGN1cnJlbnRMZXZlbCkge1xuICAgIGxldCBhdWRpb0NvZGVjID0gdGhpcy5jb25maWcuZGVmYXVsdEF1ZGlvQ29kZWMgfHwgY3VycmVudExldmVsLmF1ZGlvQ29kZWM7XG4gICAgaWYgKHRoaXMuYXVkaW9Db2RlY1N3YXAgJiYgYXVkaW9Db2RlYykge1xuICAgICAgdGhpcy5sb2coJ1N3YXBwaW5nIGF1ZGlvIGNvZGVjJyk7XG4gICAgICBpZiAoYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjUnKSAhPT0gLTEpIHtcbiAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjInO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjUnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXVkaW9Db2RlYztcbiAgfVxuICBfbG9hZEJpdHJhdGVUZXN0RnJhZyhmcmFnLCBsZXZlbCkge1xuICAgIGZyYWcuYml0cmF0ZVRlc3QgPSB0cnVlO1xuICAgIHRoaXMuX2RvRnJhZ0xvYWQoZnJhZywgbGV2ZWwpLnRoZW4oZGF0YSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGhsc1xuICAgICAgfSA9IHRoaXM7XG4gICAgICBpZiAoIWRhdGEgfHwgdGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV2ZWwuZnJhZ21lbnRFcnJvciA9IDA7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmJpdHJhdGVUZXN0ID0gZmFsc2U7XG4gICAgICBjb25zdCBzdGF0cyA9IGZyYWcuc3RhdHM7XG4gICAgICAvLyBCaXRyYXRlIHRlc3RzIGZyYWdtZW50cyBhcmUgbmVpdGhlciBwYXJzZWQgbm9yIGJ1ZmZlcmVkXG4gICAgICBzdGF0cy5wYXJzaW5nLnN0YXJ0ID0gc3RhdHMucGFyc2luZy5lbmQgPSBzdGF0cy5idWZmZXJpbmcuc3RhcnQgPSBzdGF0cy5idWZmZXJpbmcuZW5kID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0xPQURFRCwgZGF0YSk7XG4gICAgICBmcmFnLmJpdHJhdGVUZXN0ID0gZmFsc2U7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZVRyYW5zbXV4Q29tcGxldGUodHJhbnNtdXhSZXN1bHQpIHtcbiAgICB2YXIgX2lkMyRzYW1wbGVzO1xuICAgIGNvbnN0IGlkID0gJ21haW4nO1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlbXV4UmVzdWx0LFxuICAgICAgY2h1bmtNZXRhXG4gICAgfSA9IHRyYW5zbXV4UmVzdWx0O1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldEN1cnJlbnRDb250ZXh0KGNodW5rTWV0YSk7XG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICB0aGlzLnJlc2V0V2hlbk1pc3NpbmdDb250ZXh0KGNodW5rTWV0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGZyYWcsXG4gICAgICBwYXJ0LFxuICAgICAgbGV2ZWxcbiAgICB9ID0gY29udGV4dDtcbiAgICBjb25zdCB7XG4gICAgICB2aWRlbyxcbiAgICAgIHRleHQsXG4gICAgICBpZDMsXG4gICAgICBpbml0U2VnbWVudFxuICAgIH0gPSByZW11eFJlc3VsdDtcbiAgICBjb25zdCB7XG4gICAgICBkZXRhaWxzXG4gICAgfSA9IGxldmVsO1xuICAgIC8vIFRoZSBhdWRpby1zdHJlYW0tY29udHJvbGxlciBoYW5kbGVzIGF1ZGlvIGJ1ZmZlcmluZyBpZiBIbHMuanMgaXMgcGxheWluZyBhbiBhbHRlcm5hdGUgYXVkaW8gdHJhY2tcbiAgICBjb25zdCBhdWRpbyA9IHRoaXMuYWx0QXVkaW8gPyB1bmRlZmluZWQgOiByZW11eFJlc3VsdC5hdWRpbztcblxuICAgIC8vIENoZWNrIGlmIHRoZSBjdXJyZW50IGZyYWdtZW50IGhhcyBiZWVuIGFib3J0ZWQuIFdlIGNoZWNrIHRoaXMgYnkgZmlyc3Qgc2VlaW5nIGlmIHdlJ3JlIHN0aWxsIHBsYXlpbmcgdGhlIGN1cnJlbnQgbGV2ZWwuXG4gICAgLy8gSWYgd2UgYXJlLCBzdWJzZXF1ZW50bHkgY2hlY2sgaWYgdGhlIGN1cnJlbnRseSBsb2FkaW5nIGZyYWdtZW50IChmcmFnQ3VycmVudCkgaGFzIGNoYW5nZWQuXG4gICAgaWYgKHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpKSB7XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBUlNJTkc7XG4gICAgaWYgKGluaXRTZWdtZW50KSB7XG4gICAgICBpZiAoaW5pdFNlZ21lbnQgIT0gbnVsbCAmJiBpbml0U2VnbWVudC50cmFja3MpIHtcbiAgICAgICAgY29uc3QgbWFwRnJhZ21lbnQgPSBmcmFnLmluaXRTZWdtZW50IHx8IGZyYWc7XG4gICAgICAgIHRoaXMuX2J1ZmZlckluaXRTZWdtZW50KGxldmVsLCBpbml0U2VnbWVudC50cmFja3MsIG1hcEZyYWdtZW50LCBjaHVua01ldGEpO1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCwge1xuICAgICAgICAgIGZyYWc6IG1hcEZyYWdtZW50LFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIHRyYWNrczogaW5pdFNlZ21lbnQudHJhY2tzXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGlzIHdvdWxkIGJlIG5pY2UgaWYgTnVtYmVyLmlzRmluaXRlIGFjdGVkIGFzIGEgdHlwZWd1YXJkLCBidXQgaXQgZG9lc24ndC4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzEwMDM4XG4gICAgICBjb25zdCBpbml0UFRTID0gaW5pdFNlZ21lbnQuaW5pdFBUUztcbiAgICAgIGNvbnN0IHRpbWVzY2FsZSA9IGluaXRTZWdtZW50LnRpbWVzY2FsZTtcbiAgICAgIGlmIChpc0Zpbml0ZU51bWJlcihpbml0UFRTKSkge1xuICAgICAgICB0aGlzLmluaXRQVFNbZnJhZy5jY10gPSB7XG4gICAgICAgICAgYmFzZVRpbWU6IGluaXRQVFMsXG4gICAgICAgICAgdGltZXNjYWxlXG4gICAgICAgIH07XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5JTklUX1BUU19GT1VORCwge1xuICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgaW5pdFBUUyxcbiAgICAgICAgICB0aW1lc2NhbGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQXZvaWQgYnVmZmVyaW5nIGlmIGJhY2t0cmFja2luZyB0aGlzIGZyYWdtZW50XG4gICAgaWYgKHZpZGVvICYmIGRldGFpbHMgJiYgZnJhZy5zbiAhPT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgY29uc3QgcHJldkZyYWcgPSBkZXRhaWxzLmZyYWdtZW50c1tmcmFnLnNuIC0gMSAtIGRldGFpbHMuc3RhcnRTTl07XG4gICAgICBjb25zdCBpc0ZpcnN0RnJhZ21lbnQgPSBmcmFnLnNuID09PSBkZXRhaWxzLnN0YXJ0U047XG4gICAgICBjb25zdCBpc0ZpcnN0SW5EaXNjb250aW51aXR5ID0gIXByZXZGcmFnIHx8IGZyYWcuY2MgPiBwcmV2RnJhZy5jYztcbiAgICAgIGlmIChyZW11eFJlc3VsdC5pbmRlcGVuZGVudCAhPT0gZmFsc2UpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHN0YXJ0UFRTLFxuICAgICAgICAgIGVuZFBUUyxcbiAgICAgICAgICBzdGFydERUUyxcbiAgICAgICAgICBlbmREVFNcbiAgICAgICAgfSA9IHZpZGVvO1xuICAgICAgICBpZiAocGFydCkge1xuICAgICAgICAgIHBhcnQuZWxlbWVudGFyeVN0cmVhbXNbdmlkZW8udHlwZV0gPSB7XG4gICAgICAgICAgICBzdGFydFBUUyxcbiAgICAgICAgICAgIGVuZFBUUyxcbiAgICAgICAgICAgIHN0YXJ0RFRTLFxuICAgICAgICAgICAgZW5kRFRTXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodmlkZW8uZmlyc3RLZXlGcmFtZSAmJiB2aWRlby5pbmRlcGVuZGVudCAmJiBjaHVua01ldGEuaWQgPT09IDEgJiYgIWlzRmlyc3RJbkRpc2NvbnRpbnVpdHkpIHtcbiAgICAgICAgICAgIHRoaXMuY291bGRCYWNrdHJhY2sgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmlkZW8uZHJvcHBlZCAmJiB2aWRlby5pbmRlcGVuZGVudCkge1xuICAgICAgICAgICAgLy8gQmFja3RyYWNrIGlmIGRyb3BwZWQgZnJhbWVzIGNyZWF0ZSBhIGdhcCBhZnRlciBjdXJyZW50VGltZVxuXG4gICAgICAgICAgICBjb25zdCBidWZmZXJJbmZvID0gdGhpcy5nZXRNYWluRndkQnVmZmVySW5mbygpO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0QnVmZmVyVGltZSA9IChidWZmZXJJbmZvID8gYnVmZmVySW5mby5lbmQgOiB0aGlzLmdldExvYWRQb3NpdGlvbigpKSArIHRoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGU7XG4gICAgICAgICAgICBjb25zdCBzdGFydFRpbWUgPSB2aWRlby5maXJzdEtleUZyYW1lUFRTID8gdmlkZW8uZmlyc3RLZXlGcmFtZVBUUyA6IHN0YXJ0UFRTO1xuICAgICAgICAgICAgaWYgKCFpc0ZpcnN0RnJhZ21lbnQgJiYgdGFyZ2V0QnVmZmVyVGltZSA8IHN0YXJ0VGltZSAtIHRoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGUgJiYgIWlzRmlyc3RJbkRpc2NvbnRpbnVpdHkpIHtcbiAgICAgICAgICAgICAgdGhpcy5iYWNrdHJhY2soZnJhZyk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNGaXJzdEluRGlzY29udGludWl0eSkge1xuICAgICAgICAgICAgICAvLyBNYXJrIHNlZ21lbnQgd2l0aCBhIGdhcCB0byBhdm9pZCBsb29wIGxvYWRpbmdcbiAgICAgICAgICAgICAgZnJhZy5nYXAgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2V0IHZpZGVvIHN0cmVhbSBzdGFydCB0byBmcmFnbWVudCBzdGFydCBzbyB0aGF0IHRydW5jYXRlZCBzYW1wbGVzIGRvIG5vdCBkaXN0b3J0IHRoZSB0aW1lbGluZSwgYW5kIG1hcmsgaXQgcGFydGlhbFxuICAgICAgICAgICAgZnJhZy5zZXRFbGVtZW50YXJ5U3RyZWFtSW5mbyh2aWRlby50eXBlLCBmcmFnLnN0YXJ0LCBlbmRQVFMsIGZyYWcuc3RhcnQsIGVuZERUUywgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0ZpcnN0RnJhZ21lbnQgJiYgc3RhcnRQVFMgPiBNQVhfU1RBUlRfR0FQX0pVTVApIHtcbiAgICAgICAgICAgIC8vIE1hcmsgc2VnbWVudCB3aXRoIGEgZ2FwIHRvIHNraXAgbGFyZ2Ugc3RhcnQgZ2FwXG4gICAgICAgICAgICBmcmFnLmdhcCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZyYWcuc2V0RWxlbWVudGFyeVN0cmVhbUluZm8odmlkZW8udHlwZSwgc3RhcnRQVFMsIGVuZFBUUywgc3RhcnREVFMsIGVuZERUUyk7XG4gICAgICAgIGlmICh0aGlzLmJhY2t0cmFja0ZyYWdtZW50KSB7XG4gICAgICAgICAgdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IGZyYWc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXJGcmFnbWVudERhdGEodmlkZW8sIGZyYWcsIHBhcnQsIGNodW5rTWV0YSwgaXNGaXJzdEZyYWdtZW50IHx8IGlzRmlyc3RJbkRpc2NvbnRpbnVpdHkpO1xuICAgICAgfSBlbHNlIGlmIChpc0ZpcnN0RnJhZ21lbnQgfHwgaXNGaXJzdEluRGlzY29udGludWl0eSkge1xuICAgICAgICAvLyBNYXJrIHNlZ21lbnQgd2l0aCBhIGdhcCB0byBhdm9pZCBsb29wIGxvYWRpbmdcbiAgICAgICAgZnJhZy5nYXAgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5iYWNrdHJhY2soZnJhZyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGF1ZGlvKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHN0YXJ0UFRTLFxuICAgICAgICBlbmRQVFMsXG4gICAgICAgIHN0YXJ0RFRTLFxuICAgICAgICBlbmREVFNcbiAgICAgIH0gPSBhdWRpbztcbiAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgIHBhcnQuZWxlbWVudGFyeVN0cmVhbXNbRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPXSA9IHtcbiAgICAgICAgICBzdGFydFBUUyxcbiAgICAgICAgICBlbmRQVFMsXG4gICAgICAgICAgc3RhcnREVFMsXG4gICAgICAgICAgZW5kRFRTXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBmcmFnLnNldEVsZW1lbnRhcnlTdHJlYW1JbmZvKEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJTywgc3RhcnRQVFMsIGVuZFBUUywgc3RhcnREVFMsIGVuZERUUyk7XG4gICAgICB0aGlzLmJ1ZmZlckZyYWdtZW50RGF0YShhdWRpbywgZnJhZywgcGFydCwgY2h1bmtNZXRhKTtcbiAgICB9XG4gICAgaWYgKGRldGFpbHMgJiYgaWQzICE9IG51bGwgJiYgKF9pZDMkc2FtcGxlcyA9IGlkMy5zYW1wbGVzKSAhPSBudWxsICYmIF9pZDMkc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGVtaXR0ZWRJRDMgPSB7XG4gICAgICAgIGlkLFxuICAgICAgICBmcmFnLFxuICAgICAgICBkZXRhaWxzLFxuICAgICAgICBzYW1wbGVzOiBpZDMuc2FtcGxlc1xuICAgICAgfTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX1BBUlNJTkdfTUVUQURBVEEsIGVtaXR0ZWRJRDMpO1xuICAgIH1cbiAgICBpZiAoZGV0YWlscyAmJiB0ZXh0KSB7XG4gICAgICBjb25zdCBlbWl0dGVkVGV4dCA9IHtcbiAgICAgICAgaWQsXG4gICAgICAgIGZyYWcsXG4gICAgICAgIGRldGFpbHMsXG4gICAgICAgIHNhbXBsZXM6IHRleHQuc2FtcGxlc1xuICAgICAgfTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIGVtaXR0ZWRUZXh0KTtcbiAgICB9XG4gIH1cbiAgX2J1ZmZlckluaXRTZWdtZW50KGN1cnJlbnRMZXZlbCwgdHJhY2tzLCBmcmFnLCBjaHVua01ldGEpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmF1ZGlvT25seSA9ICEhdHJhY2tzLmF1ZGlvICYmICF0cmFja3MudmlkZW87XG5cbiAgICAvLyBpZiBhdWRpbyB0cmFjayBpcyBleHBlY3RlZCB0byBjb21lIGZyb20gYXVkaW8gc3RyZWFtIGNvbnRyb2xsZXIsIGRpc2NhcmQgYW55IGNvbWluZyBmcm9tIG1haW5cbiAgICBpZiAodGhpcy5hbHRBdWRpbyAmJiAhdGhpcy5hdWRpb09ubHkpIHtcbiAgICAgIGRlbGV0ZSB0cmFja3MuYXVkaW87XG4gICAgfVxuICAgIC8vIGluY2x1ZGUgbGV2ZWxDb2RlYyBpbiBhdWRpbyBhbmQgdmlkZW8gdHJhY2tzXG4gICAgY29uc3Qge1xuICAgICAgYXVkaW8sXG4gICAgICB2aWRlbyxcbiAgICAgIGF1ZGlvdmlkZW9cbiAgICB9ID0gdHJhY2tzO1xuICAgIGlmIChhdWRpbykge1xuICAgICAgbGV0IGF1ZGlvQ29kZWMgPSBjdXJyZW50TGV2ZWwuYXVkaW9Db2RlYztcbiAgICAgIGNvbnN0IHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKHRoaXMuYXVkaW9Db2RlY1N3aXRjaCkge1xuICAgICAgICBpZiAoYXVkaW9Db2RlYykge1xuICAgICAgICAgIGlmIChhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkge1xuICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjInO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEluIHRoZSBjYXNlIHRoYXQgQUFDIGFuZCBIRS1BQUMgYXVkaW8gY29kZWNzIGFyZSBzaWduYWxsZWQgaW4gbWFuaWZlc3QsXG4gICAgICAgIC8vIGZvcmNlIEhFLUFBQywgYXMgaXQgc2VlbXMgdGhhdCBtb3N0IGJyb3dzZXJzIHByZWZlcnMgaXQuXG4gICAgICAgIC8vIGRvbid0IGZvcmNlIEhFLUFBQyBpZiBtb25vIHN0cmVhbSwgb3IgaW4gRmlyZWZveFxuICAgICAgICBpZiAoYXVkaW8ubWV0YWRhdGEuY2hhbm5lbENvdW50ICE9PSAxICYmIHVhLmluZGV4T2YoJ2ZpcmVmb3gnKSA9PT0gLTEpIHtcbiAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEhFLUFBQyBpcyBicm9rZW4gb24gQW5kcm9pZCwgYWx3YXlzIHNpZ25hbCBhdWRpbyBjb2RlYyBhcyBBQUMgZXZlbiBpZiB2YXJpYW50IG1hbmlmZXN0IHN0YXRlcyBvdGhlcndpc2VcbiAgICAgIGlmIChhdWRpb0NvZGVjICYmIGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09IC0xICYmIHVhLmluZGV4T2YoJ2FuZHJvaWQnKSAhPT0gLTEgJiYgYXVkaW8uY29udGFpbmVyICE9PSAnYXVkaW8vbXBlZycpIHtcbiAgICAgICAgLy8gRXhjbHVkZSBtcGVnIGF1ZGlvXG4gICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC4yJztcbiAgICAgICAgdGhpcy5sb2coYEFuZHJvaWQ6IGZvcmNlIGF1ZGlvIGNvZGVjIHRvICR7YXVkaW9Db2RlY31gKTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50TGV2ZWwuYXVkaW9Db2RlYyAmJiBjdXJyZW50TGV2ZWwuYXVkaW9Db2RlYyAhPT0gYXVkaW9Db2RlYykge1xuICAgICAgICB0aGlzLmxvZyhgU3dhcHBpbmcgbWFuaWZlc3QgYXVkaW8gY29kZWMgXCIke2N1cnJlbnRMZXZlbC5hdWRpb0NvZGVjfVwiIGZvciBcIiR7YXVkaW9Db2RlY31cImApO1xuICAgICAgfVxuICAgICAgYXVkaW8ubGV2ZWxDb2RlYyA9IGF1ZGlvQ29kZWM7XG4gICAgICBhdWRpby5pZCA9ICdtYWluJztcbiAgICAgIHRoaXMubG9nKGBJbml0IGF1ZGlvIGJ1ZmZlciwgY29udGFpbmVyOiR7YXVkaW8uY29udGFpbmVyfSwgY29kZWNzW3NlbGVjdGVkL2xldmVsL3BhcnNlZF09WyR7YXVkaW9Db2RlYyB8fCAnJ30vJHtjdXJyZW50TGV2ZWwuYXVkaW9Db2RlYyB8fCAnJ30vJHthdWRpby5jb2RlY31dYCk7XG4gICAgfVxuICAgIGlmICh2aWRlbykge1xuICAgICAgdmlkZW8ubGV2ZWxDb2RlYyA9IGN1cnJlbnRMZXZlbC52aWRlb0NvZGVjO1xuICAgICAgdmlkZW8uaWQgPSAnbWFpbic7XG4gICAgICB0aGlzLmxvZyhgSW5pdCB2aWRlbyBidWZmZXIsIGNvbnRhaW5lcjoke3ZpZGVvLmNvbnRhaW5lcn0sIGNvZGVjc1tsZXZlbC9wYXJzZWRdPVske2N1cnJlbnRMZXZlbC52aWRlb0NvZGVjIHx8ICcnfS8ke3ZpZGVvLmNvZGVjfV1gKTtcbiAgICB9XG4gICAgaWYgKGF1ZGlvdmlkZW8pIHtcbiAgICAgIHRoaXMubG9nKGBJbml0IGF1ZGlvdmlkZW8gYnVmZmVyLCBjb250YWluZXI6JHthdWRpb3ZpZGVvLmNvbnRhaW5lcn0sIGNvZGVjc1tsZXZlbC9wYXJzZWRdPVske2N1cnJlbnRMZXZlbC5jb2RlY3N9LyR7YXVkaW92aWRlby5jb2RlY31dYCk7XG4gICAgfVxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9DT0RFQ1MsIHRyYWNrcyk7XG4gICAgLy8gbG9vcCB0aHJvdWdoIHRyYWNrcyB0aGF0IGFyZSBnb2luZyB0byBiZSBwcm92aWRlZCB0byBidWZmZXJDb250cm9sbGVyXG4gICAgT2JqZWN0LmtleXModHJhY2tzKS5mb3JFYWNoKHRyYWNrTmFtZSA9PiB7XG4gICAgICBjb25zdCB0cmFjayA9IHRyYWNrc1t0cmFja05hbWVdO1xuICAgICAgY29uc3QgaW5pdFNlZ21lbnQgPSB0cmFjay5pbml0U2VnbWVudDtcbiAgICAgIGlmIChpbml0U2VnbWVudCAhPSBudWxsICYmIGluaXRTZWdtZW50LmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0FQUEVORElORywge1xuICAgICAgICAgIHR5cGU6IHRyYWNrTmFtZSxcbiAgICAgICAgICBkYXRhOiBpbml0U2VnbWVudCxcbiAgICAgICAgICBmcmFnLFxuICAgICAgICAgIHBhcnQ6IG51bGwsXG4gICAgICAgICAgY2h1bmtNZXRhLFxuICAgICAgICAgIHBhcmVudDogZnJhZy50eXBlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICB0aGlzLnRpY2tJbW1lZGlhdGUoKTtcbiAgfVxuICBnZXRNYWluRndkQnVmZmVySW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRGd2RCdWZmZXJJbmZvKHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogdGhpcy5tZWRpYSwgUGxheWxpc3RMZXZlbFR5cGUuTUFJTik7XG4gIH1cbiAgYmFja3RyYWNrKGZyYWcpIHtcbiAgICB0aGlzLmNvdWxkQmFja3RyYWNrID0gdHJ1ZTtcbiAgICAvLyBDYXVzZXMgZmluZEZyYWdtZW50cyB0byBiYWNrdHJhY2sgdGhyb3VnaCBmcmFnbWVudHMgdG8gZmluZCB0aGUga2V5ZnJhbWVcbiAgICB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID0gZnJhZztcbiAgICB0aGlzLnJlc2V0VHJhbnNtdXhlcigpO1xuICAgIHRoaXMuZmx1c2hCdWZmZXJHYXAoZnJhZyk7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IGZyYWcuc3RhcnQ7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gIH1cbiAgY2hlY2tGcmFnbWVudENoYW5nZWQoKSB7XG4gICAgY29uc3QgdmlkZW8gPSB0aGlzLm1lZGlhO1xuICAgIGxldCBmcmFnUGxheWluZ0N1cnJlbnQgPSBudWxsO1xuICAgIGlmICh2aWRlbyAmJiB2aWRlby5yZWFkeVN0YXRlID4gMSAmJiB2aWRlby5zZWVraW5nID09PSBmYWxzZSkge1xuICAgICAgY29uc3QgY3VycmVudFRpbWUgPSB2aWRlby5jdXJyZW50VGltZTtcbiAgICAgIC8qIGlmIHZpZGVvIGVsZW1lbnQgaXMgaW4gc2Vla2VkIHN0YXRlLCBjdXJyZW50VGltZSBjYW4gb25seSBpbmNyZWFzZS5cbiAgICAgICAgKGFzc3VtaW5nIHRoYXQgcGxheWJhY2sgcmF0ZSBpcyBwb3NpdGl2ZSAuLi4pXG4gICAgICAgIEFzIHNvbWV0aW1lcyBjdXJyZW50VGltZSBqdW1wcyBiYWNrIHRvIHplcm8gYWZ0ZXIgYVxuICAgICAgICBtZWRpYSBkZWNvZGUgZXJyb3IsIGNoZWNrIHRoaXMsIHRvIGF2b2lkIHNlZWtpbmcgYmFjayB0b1xuICAgICAgICB3cm9uZyBwb3NpdGlvbiBhZnRlciBhIG1lZGlhIGRlY29kZSBlcnJvclxuICAgICAgKi9cblxuICAgICAgaWYgKEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKHZpZGVvLCBjdXJyZW50VGltZSkpIHtcbiAgICAgICAgZnJhZ1BsYXlpbmdDdXJyZW50ID0gdGhpcy5nZXRBcHBlbmRlZEZyYWcoY3VycmVudFRpbWUpO1xuICAgICAgfSBlbHNlIGlmIChCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZCh2aWRlbywgY3VycmVudFRpbWUgKyAwLjEpKSB7XG4gICAgICAgIC8qIGVuc3VyZSB0aGF0IEZSQUdfQ0hBTkdFRCBldmVudCBpcyB0cmlnZ2VyZWQgYXQgc3RhcnR1cCxcbiAgICAgICAgICB3aGVuIGZpcnN0IHZpZGVvIGZyYW1lIGlzIGRpc3BsYXllZCBhbmQgcGxheWJhY2sgaXMgcGF1c2VkLlxuICAgICAgICAgIGFkZCBhIHRvbGVyYW5jZSBvZiAxMDBtcywgaW4gY2FzZSBjdXJyZW50IHBvc2l0aW9uIGlzIG5vdCBidWZmZXJlZCxcbiAgICAgICAgICBjaGVjayBpZiBjdXJyZW50IHBvcysxMDBtcyBpcyBidWZmZXJlZCBhbmQgdXNlIHRoYXQgYnVmZmVyIHJhbmdlXG4gICAgICAgICAgZm9yIEZSQUdfQ0hBTkdFRCBldmVudCByZXBvcnRpbmcgKi9cbiAgICAgICAgZnJhZ1BsYXlpbmdDdXJyZW50ID0gdGhpcy5nZXRBcHBlbmRlZEZyYWcoY3VycmVudFRpbWUgKyAwLjEpO1xuICAgICAgfVxuICAgICAgaWYgKGZyYWdQbGF5aW5nQ3VycmVudCkge1xuICAgICAgICB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgY29uc3QgZnJhZ1BsYXlpbmcgPSB0aGlzLmZyYWdQbGF5aW5nO1xuICAgICAgICBjb25zdCBmcmFnQ3VycmVudExldmVsID0gZnJhZ1BsYXlpbmdDdXJyZW50LmxldmVsO1xuICAgICAgICBpZiAoIWZyYWdQbGF5aW5nIHx8IGZyYWdQbGF5aW5nQ3VycmVudC5zbiAhPT0gZnJhZ1BsYXlpbmcuc24gfHwgZnJhZ1BsYXlpbmcubGV2ZWwgIT09IGZyYWdDdXJyZW50TGV2ZWwpIHtcbiAgICAgICAgICB0aGlzLmZyYWdQbGF5aW5nID0gZnJhZ1BsYXlpbmdDdXJyZW50O1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfQ0hBTkdFRCwge1xuICAgICAgICAgICAgZnJhZzogZnJhZ1BsYXlpbmdDdXJyZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKCFmcmFnUGxheWluZyB8fCBmcmFnUGxheWluZy5sZXZlbCAhPT0gZnJhZ0N1cnJlbnRMZXZlbCkge1xuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTEVWRUxfU1dJVENIRUQsIHtcbiAgICAgICAgICAgICAgbGV2ZWw6IGZyYWdDdXJyZW50TGV2ZWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgbmV4dExldmVsKCkge1xuICAgIGNvbnN0IGZyYWcgPSB0aGlzLm5leHRCdWZmZXJlZEZyYWc7XG4gICAgaWYgKGZyYWcpIHtcbiAgICAgIHJldHVybiBmcmFnLmxldmVsO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgZ2V0IGN1cnJlbnRGcmFnKCkge1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIHJldHVybiB0aGlzLmZyYWdQbGF5aW5nIHx8IHRoaXMuZ2V0QXBwZW5kZWRGcmFnKG1lZGlhLmN1cnJlbnRUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2V0IGN1cnJlbnRQcm9ncmFtRGF0ZVRpbWUoKSB7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICAgIGNvbnN0IGZyYWcgPSB0aGlzLmN1cnJlbnRGcmFnO1xuICAgICAgaWYgKGZyYWcgJiYgaXNGaW5pdGVOdW1iZXIoY3VycmVudFRpbWUpICYmIGlzRmluaXRlTnVtYmVyKGZyYWcucHJvZ3JhbURhdGVUaW1lKSkge1xuICAgICAgICBjb25zdCBlcG9jTXMgPSBmcmFnLnByb2dyYW1EYXRlVGltZSArIChjdXJyZW50VGltZSAtIGZyYWcuc3RhcnQpICogMTAwMDtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGVwb2NNcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdldCBjdXJyZW50TGV2ZWwoKSB7XG4gICAgY29uc3QgZnJhZyA9IHRoaXMuY3VycmVudEZyYWc7XG4gICAgaWYgKGZyYWcpIHtcbiAgICAgIHJldHVybiBmcmFnLmxldmVsO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgZ2V0IG5leHRCdWZmZXJlZEZyYWcoKSB7XG4gICAgY29uc3QgZnJhZyA9IHRoaXMuY3VycmVudEZyYWc7XG4gICAgaWYgKGZyYWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmZvbGxvd2luZ0J1ZmZlcmVkRnJhZyhmcmFnKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2V0IGZvcmNlU3RhcnRMb2FkKCkge1xuICAgIHJldHVybiB0aGlzLl9mb3JjZVN0YXJ0TG9hZDtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBgSGxzYCBjbGFzcyBpcyB0aGUgY29yZSBvZiB0aGUgSExTLmpzIGxpYnJhcnkgdXNlZCB0byBpbnN0YW50aWF0ZSBwbGF5ZXIgaW5zdGFuY2VzLlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBIbHMge1xuICAvKipcbiAgICogR2V0IHRoZSB2aWRlby1kZXYvaGxzLmpzIHBhY2thZ2UgdmVyc2lvbi5cbiAgICovXG4gIHN0YXRpYyBnZXQgdmVyc2lvbigpIHtcbiAgICByZXR1cm4gXCIxLjUuNlwiO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSByZXF1aXJlZCBNZWRpYVNvdXJjZSBFeHRlbnNpb25zIGFyZSBhdmFpbGFibGUuXG4gICAqL1xuICBzdGF0aWMgaXNNU0VTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIGlzTVNFU3VwcG9ydGVkKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgTWVkaWFTb3VyY2UgRXh0ZW5zaW9ucyBhcmUgYXZhaWxhYmxlIGFuZCBpc1R5cGVTdXBwb3J0ZWQgY2hlY2tzIHBhc3MgZm9yIGFueSBiYXNlbGluZSBjb2RlY3MuXG4gICAqL1xuICBzdGF0aWMgaXNTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIGlzU3VwcG9ydGVkKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBNZWRpYVNvdXJjZSBnbG9iYWwgdXNlZCBmb3IgTVNFIHBsYXliYWNrIChNYW5hZ2VkTWVkaWFTb3VyY2UsIE1lZGlhU291cmNlLCBvciBXZWJLaXRNZWRpYVNvdXJjZSkuXG4gICAqL1xuICBzdGF0aWMgZ2V0TWVkaWFTb3VyY2UoKSB7XG4gICAgcmV0dXJuIGdldE1lZGlhU291cmNlKCk7XG4gIH1cbiAgc3RhdGljIGdldCBFdmVudHMoKSB7XG4gICAgcmV0dXJuIEV2ZW50cztcbiAgfVxuICBzdGF0aWMgZ2V0IEVycm9yVHlwZXMoKSB7XG4gICAgcmV0dXJuIEVycm9yVHlwZXM7XG4gIH1cbiAgc3RhdGljIGdldCBFcnJvckRldGFpbHMoKSB7XG4gICAgcmV0dXJuIEVycm9yRGV0YWlscztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBhcHBsaWVkIHRvIG5ldyBpbnN0YW5jZXMuXG4gICAqL1xuICBzdGF0aWMgZ2V0IERlZmF1bHRDb25maWcoKSB7XG4gICAgaWYgKCFIbHMuZGVmYXVsdENvbmZpZykge1xuICAgICAgcmV0dXJuIGhsc0RlZmF1bHRDb25maWc7XG4gICAgfVxuICAgIHJldHVybiBIbHMuZGVmYXVsdENvbmZpZztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlIHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gYXBwbGllZCB0byBuZXcgaW5zdGFuY2VzLlxuICAgKi9cbiAgc3RhdGljIHNldCBEZWZhdWx0Q29uZmlnKGRlZmF1bHRDb25maWcpIHtcbiAgICBIbHMuZGVmYXVsdENvbmZpZyA9IGRlZmF1bHRDb25maWc7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBhbiBITFMgY2xpZW50IHRoYXQgY2FuIGF0dGFjaCB0byBleGFjdGx5IG9uZSBgSFRNTE1lZGlhRWxlbWVudGAuXG4gICAqIEBwYXJhbSB1c2VyQ29uZmlnIC0gQ29uZmlndXJhdGlvbiBvcHRpb25zIGFwcGxpZWQgb3ZlciBgSGxzLkRlZmF1bHRDb25maWdgXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih1c2VyQ29uZmlnID0ge30pIHtcbiAgICAvKipcbiAgICAgKiBUaGUgcnVudGltZSBjb25maWd1cmF0aW9uIHVzZWQgYnkgdGhlIHBsYXllci4gQXQgaW5zdGFudGlhdGlvbiB0aGlzIGlzIGNvbWJpbmF0aW9uIG9mIGBobHMudXNlckNvbmZpZ2AgbWVyZ2VkIG92ZXIgYEhscy5EZWZhdWx0Q29uZmlnYC5cbiAgICAgKi9cbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QgcHJvdmlkZWQgb24gcGxheWVyIGluc3RhbnRpYXRpb24uXG4gICAgICovXG4gICAgdGhpcy51c2VyQ29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMuY29yZUNvbXBvbmVudHMgPSB2b2lkIDA7XG4gICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgdGhpcy5fZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nID0gLTE7XG4gICAgdGhpcy5fbWF4SGRjcExldmVsID0gbnVsbDtcbiAgICB0aGlzLmFickNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5idWZmZXJDb250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuY2FwTGV2ZWxDb250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLmVtZUNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jbWNkQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLl9tZWRpYSA9IG51bGw7XG4gICAgdGhpcy51cmwgPSBudWxsO1xuICAgIHRoaXMudHJpZ2dlcmluZ0V4Y2VwdGlvbiA9IHZvaWQgMDtcbiAgICBlbmFibGVMb2dzKHVzZXJDb25maWcuZGVidWcgfHwgZmFsc2UsICdIbHMgaW5zdGFuY2UnKTtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZyA9IG1lcmdlQ29uZmlnKEhscy5EZWZhdWx0Q29uZmlnLCB1c2VyQ29uZmlnKTtcbiAgICB0aGlzLnVzZXJDb25maWcgPSB1c2VyQ29uZmlnO1xuICAgIGlmIChjb25maWcucHJvZ3Jlc3NpdmUpIHtcbiAgICAgIGVuYWJsZVN0cmVhbWluZ01vZGUoY29uZmlnKTtcbiAgICB9XG5cbiAgICAvLyBjb3JlIGNvbnRyb2xsZXJzIGFuZCBuZXR3b3JrIGxvYWRlcnNcbiAgICBjb25zdCB7XG4gICAgICBhYnJDb250cm9sbGVyOiBDb25maWdBYnJDb250cm9sbGVyLFxuICAgICAgYnVmZmVyQ29udHJvbGxlcjogQ29uZmlnQnVmZmVyQ29udHJvbGxlcixcbiAgICAgIGNhcExldmVsQ29udHJvbGxlcjogQ29uZmlnQ2FwTGV2ZWxDb250cm9sbGVyLFxuICAgICAgZXJyb3JDb250cm9sbGVyOiBDb25maWdFcnJvckNvbnRyb2xsZXIsXG4gICAgICBmcHNDb250cm9sbGVyOiBDb25maWdGcHNDb250cm9sbGVyXG4gICAgfSA9IGNvbmZpZztcbiAgICBjb25zdCBlcnJvckNvbnRyb2xsZXIgPSBuZXcgQ29uZmlnRXJyb3JDb250cm9sbGVyKHRoaXMpO1xuICAgIGNvbnN0IGFickNvbnRyb2xsZXIgPSB0aGlzLmFickNvbnRyb2xsZXIgPSBuZXcgQ29uZmlnQWJyQ29udHJvbGxlcih0aGlzKTtcbiAgICBjb25zdCBidWZmZXJDb250cm9sbGVyID0gdGhpcy5idWZmZXJDb250cm9sbGVyID0gbmV3IENvbmZpZ0J1ZmZlckNvbnRyb2xsZXIodGhpcyk7XG4gICAgY29uc3QgY2FwTGV2ZWxDb250cm9sbGVyID0gdGhpcy5jYXBMZXZlbENvbnRyb2xsZXIgPSBuZXcgQ29uZmlnQ2FwTGV2ZWxDb250cm9sbGVyKHRoaXMpO1xuICAgIGNvbnN0IGZwc0NvbnRyb2xsZXIgPSBuZXcgQ29uZmlnRnBzQ29udHJvbGxlcih0aGlzKTtcbiAgICBjb25zdCBwbGF5TGlzdExvYWRlciA9IG5ldyBQbGF5bGlzdExvYWRlcih0aGlzKTtcbiAgICBjb25zdCBpZDNUcmFja0NvbnRyb2xsZXIgPSBuZXcgSUQzVHJhY2tDb250cm9sbGVyKHRoaXMpO1xuICAgIGNvbnN0IENvbmZpZ0NvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXIgPSBjb25maWcuY29udGVudFN0ZWVyaW5nQ29udHJvbGxlcjtcbiAgICAvLyBDb25lbnRTdGVlcmluZ0NvbnRyb2xsZXIgaXMgZGVmaW5lZCBiZWZvcmUgTGV2ZWxDb250cm9sbGVyIHRvIHJlY2VpdmUgTXVsdGl2YXJpYW50IFBsYXlsaXN0IGV2ZW50cyBmaXJzdFxuICAgIGNvbnN0IGNvbnRlbnRTdGVlcmluZyA9IENvbmZpZ0NvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXIgPyBuZXcgQ29uZmlnQ29udGVudFN0ZWVyaW5nQ29udHJvbGxlcih0aGlzKSA6IG51bGw7XG4gICAgY29uc3QgbGV2ZWxDb250cm9sbGVyID0gdGhpcy5sZXZlbENvbnRyb2xsZXIgPSBuZXcgTGV2ZWxDb250cm9sbGVyKHRoaXMsIGNvbnRlbnRTdGVlcmluZyk7XG4gICAgLy8gRnJhZ21lbnRUcmFja2VyIG11c3QgYmUgZGVmaW5lZCBiZWZvcmUgU3RyZWFtQ29udHJvbGxlciBiZWNhdXNlIHRoZSBvcmRlciBvZiBldmVudCBoYW5kbGluZyBpcyBpbXBvcnRhbnRcbiAgICBjb25zdCBmcmFnbWVudFRyYWNrZXIgPSBuZXcgRnJhZ21lbnRUcmFja2VyKHRoaXMpO1xuICAgIGNvbnN0IGtleUxvYWRlciA9IG5ldyBLZXlMb2FkZXIodGhpcy5jb25maWcpO1xuICAgIGNvbnN0IHN0cmVhbUNvbnRyb2xsZXIgPSB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSBuZXcgU3RyZWFtQ29udHJvbGxlcih0aGlzLCBmcmFnbWVudFRyYWNrZXIsIGtleUxvYWRlcik7XG5cbiAgICAvLyBDYXAgbGV2ZWwgY29udHJvbGxlciB1c2VzIHN0cmVhbUNvbnRyb2xsZXIgdG8gZmx1c2ggdGhlIGJ1ZmZlclxuICAgIGNhcExldmVsQ29udHJvbGxlci5zZXRTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIpO1xuICAgIC8vIGZwc0NvbnRyb2xsZXIgdXNlcyBzdHJlYW1Db250cm9sbGVyIHRvIHN3aXRjaCB3aGVuIGZyYW1lcyBhcmUgYmVpbmcgZHJvcHBlZFxuICAgIGZwc0NvbnRyb2xsZXIuc2V0U3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyKTtcbiAgICBjb25zdCBuZXR3b3JrQ29udHJvbGxlcnMgPSBbcGxheUxpc3RMb2FkZXIsIGxldmVsQ29udHJvbGxlciwgc3RyZWFtQ29udHJvbGxlcl07XG4gICAgaWYgKGNvbnRlbnRTdGVlcmluZykge1xuICAgICAgbmV0d29ya0NvbnRyb2xsZXJzLnNwbGljZSgxLCAwLCBjb250ZW50U3RlZXJpbmcpO1xuICAgIH1cbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycyA9IG5ldHdvcmtDb250cm9sbGVycztcbiAgICBjb25zdCBjb3JlQ29tcG9uZW50cyA9IFthYnJDb250cm9sbGVyLCBidWZmZXJDb250cm9sbGVyLCBjYXBMZXZlbENvbnRyb2xsZXIsIGZwc0NvbnRyb2xsZXIsIGlkM1RyYWNrQ29udHJvbGxlciwgZnJhZ21lbnRUcmFja2VyXTtcbiAgICB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyID0gdGhpcy5jcmVhdGVDb250cm9sbGVyKGNvbmZpZy5hdWRpb1RyYWNrQ29udHJvbGxlciwgbmV0d29ya0NvbnRyb2xsZXJzKTtcbiAgICBjb25zdCBBdWRpb1N0cmVhbUNvbnRyb2xsZXJDbGFzcyA9IGNvbmZpZy5hdWRpb1N0cmVhbUNvbnRyb2xsZXI7XG4gICAgaWYgKEF1ZGlvU3RyZWFtQ29udHJvbGxlckNsYXNzKSB7XG4gICAgICBuZXR3b3JrQ29udHJvbGxlcnMucHVzaChuZXcgQXVkaW9TdHJlYW1Db250cm9sbGVyQ2xhc3ModGhpcywgZnJhZ21lbnRUcmFja2VyLCBrZXlMb2FkZXIpKTtcbiAgICB9XG4gICAgLy8gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgbXVzdCBiZSBkZWZpbmVkIGJlZm9yZSBzdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIgYmVjYXVzZSB0aGUgb3JkZXIgb2YgZXZlbnQgaGFuZGxpbmcgaXMgaW1wb3J0YW50XG4gICAgdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuY3JlYXRlQ29udHJvbGxlcihjb25maWcuc3VidGl0bGVUcmFja0NvbnRyb2xsZXIsIG5ldHdvcmtDb250cm9sbGVycyk7XG4gICAgY29uc3QgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyQ2xhc3MgPSBjb25maWcuc3VidGl0bGVTdHJlYW1Db250cm9sbGVyO1xuICAgIGlmIChTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXJDbGFzcykge1xuICAgICAgbmV0d29ya0NvbnRyb2xsZXJzLnB1c2gobmV3IFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlckNsYXNzKHRoaXMsIGZyYWdtZW50VHJhY2tlciwga2V5TG9hZGVyKSk7XG4gICAgfVxuICAgIHRoaXMuY3JlYXRlQ29udHJvbGxlcihjb25maWcudGltZWxpbmVDb250cm9sbGVyLCBjb3JlQ29tcG9uZW50cyk7XG4gICAga2V5TG9hZGVyLmVtZUNvbnRyb2xsZXIgPSB0aGlzLmVtZUNvbnRyb2xsZXIgPSB0aGlzLmNyZWF0ZUNvbnRyb2xsZXIoY29uZmlnLmVtZUNvbnRyb2xsZXIsIGNvcmVDb21wb25lbnRzKTtcbiAgICB0aGlzLmNtY2RDb250cm9sbGVyID0gdGhpcy5jcmVhdGVDb250cm9sbGVyKGNvbmZpZy5jbWNkQ29udHJvbGxlciwgY29yZUNvbXBvbmVudHMpO1xuICAgIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIgPSB0aGlzLmNyZWF0ZUNvbnRyb2xsZXIoTGF0ZW5jeUNvbnRyb2xsZXIsIGNvcmVDb21wb25lbnRzKTtcbiAgICB0aGlzLmNvcmVDb21wb25lbnRzID0gY29yZUNvbXBvbmVudHM7XG5cbiAgICAvLyBFcnJvciBjb250cm9sbGVyIGhhbmRsZXMgZXJyb3JzIGJlZm9yZSBhbmQgYWZ0ZXIgYWxsIG90aGVyIGNvbnRyb2xsZXJzXG4gICAgLy8gVGhpcyBsaXN0ZW5lciB3aWxsIGJlIGludm9rZWQgYWZ0ZXIgYWxsIG90aGVyIGNvbnRyb2xsZXJzIGVycm9yIGxpc3RlbmVyc1xuICAgIG5ldHdvcmtDb250cm9sbGVycy5wdXNoKGVycm9yQ29udHJvbGxlcik7XG4gICAgY29uc3Qgb25FcnJvck91dCA9IGVycm9yQ29udHJvbGxlci5vbkVycm9yT3V0O1xuICAgIGlmICh0eXBlb2Ygb25FcnJvck91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5vbihFdmVudHMuRVJST1IsIG9uRXJyb3JPdXQsIGVycm9yQ29udHJvbGxlcik7XG4gICAgfVxuICB9XG4gIGNyZWF0ZUNvbnRyb2xsZXIoQ29udHJvbGxlckNsYXNzLCBjb21wb25lbnRzKSB7XG4gICAgaWYgKENvbnRyb2xsZXJDbGFzcykge1xuICAgICAgY29uc3QgY29udHJvbGxlckluc3RhbmNlID0gbmV3IENvbnRyb2xsZXJDbGFzcyh0aGlzKTtcbiAgICAgIGlmIChjb21wb25lbnRzKSB7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaChjb250cm9sbGVySW5zdGFuY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRyb2xsZXJJbnN0YW5jZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBEZWxlZ2F0ZSB0aGUgRXZlbnRFbWl0dGVyIHRocm91Z2ggdGhlIHB1YmxpYyBBUEkgb2YgSGxzLmpzXG4gIG9uKGV2ZW50LCBsaXN0ZW5lciwgY29udGV4dCA9IHRoaXMpIHtcbiAgICB0aGlzLl9lbWl0dGVyLm9uKGV2ZW50LCBsaXN0ZW5lciwgY29udGV4dCk7XG4gIH1cbiAgb25jZShldmVudCwgbGlzdGVuZXIsIGNvbnRleHQgPSB0aGlzKSB7XG4gICAgdGhpcy5fZW1pdHRlci5vbmNlKGV2ZW50LCBsaXN0ZW5lciwgY29udGV4dCk7XG4gIH1cbiAgcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgdGhpcy5fZW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpO1xuICB9XG4gIG9mZihldmVudCwgbGlzdGVuZXIsIGNvbnRleHQgPSB0aGlzLCBvbmNlKSB7XG4gICAgdGhpcy5fZW1pdHRlci5vZmYoZXZlbnQsIGxpc3RlbmVyLCBjb250ZXh0LCBvbmNlKTtcbiAgfVxuICBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5fZW1pdHRlci5saXN0ZW5lcnMoZXZlbnQpO1xuICB9XG4gIGVtaXQoZXZlbnQsIG5hbWUsIGV2ZW50T2JqZWN0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VtaXR0ZXIuZW1pdChldmVudCwgbmFtZSwgZXZlbnRPYmplY3QpO1xuICB9XG4gIHRyaWdnZXIoZXZlbnQsIGV2ZW50T2JqZWN0KSB7XG4gICAgaWYgKHRoaXMuY29uZmlnLmRlYnVnKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KGV2ZW50LCBldmVudCwgZXZlbnRPYmplY3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KGV2ZW50LCBldmVudCwgZXZlbnRPYmplY3QpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKCdBbiBpbnRlcm5hbCBlcnJvciBoYXBwZW5lZCB3aGlsZSBoYW5kbGluZyBldmVudCAnICsgZXZlbnQgKyAnLiBFcnJvciBtZXNzYWdlOiBcIicgKyBlcnJvci5tZXNzYWdlICsgJ1wiLiBIZXJlIGlzIGEgc3RhY2t0cmFjZTonLCBlcnJvcik7XG4gICAgICAgIC8vIFByZXZlbnQgcmVjdXJzaW9uIGluIGVycm9yIGV2ZW50IGhhbmRsZXJzIHRoYXQgdGhyb3cgIzU0OTdcbiAgICAgICAgaWYgKCF0aGlzLnRyaWdnZXJpbmdFeGNlcHRpb24pIHtcbiAgICAgICAgICB0aGlzLnRyaWdnZXJpbmdFeGNlcHRpb24gPSB0cnVlO1xuICAgICAgICAgIGNvbnN0IGZhdGFsID0gZXZlbnQgPT09IEV2ZW50cy5FUlJPUjtcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLklOVEVSTkFMX0VYQ0VQVElPTixcbiAgICAgICAgICAgIGZhdGFsLFxuICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICBlcnJvclxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMudHJpZ2dlcmluZ0V4Y2VwdGlvbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsaXN0ZW5lckNvdW50KGV2ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VtaXR0ZXIubGlzdGVuZXJDb3VudChldmVudCk7XG4gIH1cblxuICAvKipcbiAgICogRGlzcG9zZSBvZiB0aGUgaW5zdGFuY2VcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgbG9nZ2VyLmxvZygnZGVzdHJveScpO1xuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuREVTVFJPWUlORywgdW5kZWZpbmVkKTtcbiAgICB0aGlzLmRldGFjaE1lZGlhKCk7XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nID0gLTE7XG4gICAgdGhpcy51cmwgPSBudWxsO1xuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzLmZvckVhY2goY29tcG9uZW50ID0+IGNvbXBvbmVudC5kZXN0cm95KCkpO1xuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5jb3JlQ29tcG9uZW50cy5mb3JFYWNoKGNvbXBvbmVudCA9PiBjb21wb25lbnQuZGVzdHJveSgpKTtcbiAgICB0aGlzLmNvcmVDb21wb25lbnRzLmxlbmd0aCA9IDA7XG4gICAgLy8gUmVtb3ZlIGFueSByZWZlcmVuY2VzIHRoYXQgY291bGQgYmUgaGVsZCBpbiBjb25maWcgb3B0aW9ucyBvciBjYWxsYmFja3NcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBjb25maWcueGhyU2V0dXAgPSBjb25maWcuZmV0Y2hTZXR1cCA9IHVuZGVmaW5lZDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy51c2VyQ29uZmlnID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRhY2hlcyBIbHMuanMgdG8gYSBtZWRpYSBlbGVtZW50XG4gICAqL1xuICBhdHRhY2hNZWRpYShtZWRpYSkge1xuICAgIGxvZ2dlci5sb2coJ2F0dGFjaE1lZGlhJyk7XG4gICAgdGhpcy5fbWVkaWEgPSBtZWRpYTtcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLk1FRElBX0FUVEFDSElORywge1xuICAgICAgbWVkaWE6IG1lZGlhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGV0YWNoIEhscy5qcyBmcm9tIHRoZSBtZWRpYVxuICAgKi9cbiAgZGV0YWNoTWVkaWEoKSB7XG4gICAgbG9nZ2VyLmxvZygnZGV0YWNoTWVkaWEnKTtcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLk1FRElBX0RFVEFDSElORywgdW5kZWZpbmVkKTtcbiAgICB0aGlzLl9tZWRpYSA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBzb3VyY2UgVVJMLiBDYW4gYmUgcmVsYXRpdmUgb3IgYWJzb2x1dGUuXG4gICAqL1xuICBsb2FkU291cmNlKHVybCkge1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgY29uc3QgbG9hZGVkU291cmNlID0gdGhpcy51cmw7XG4gICAgY29uc3QgbG9hZGluZ1NvdXJjZSA9IHRoaXMudXJsID0gdXJsVG9vbGtpdEV4cG9ydHMuYnVpbGRBYnNvbHV0ZVVSTChzZWxmLmxvY2F0aW9uLmhyZWYsIHVybCwge1xuICAgICAgYWx3YXlzTm9ybWFsaXplOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5fYXV0b0xldmVsQ2FwcGluZyA9IC0xO1xuICAgIHRoaXMuX21heEhkY3BMZXZlbCA9IG51bGw7XG4gICAgbG9nZ2VyLmxvZyhgbG9hZFNvdXJjZToke2xvYWRpbmdTb3VyY2V9YCk7XG4gICAgaWYgKG1lZGlhICYmIGxvYWRlZFNvdXJjZSAmJiAobG9hZGVkU291cmNlICE9PSBsb2FkaW5nU291cmNlIHx8IHRoaXMuYnVmZmVyQ29udHJvbGxlci5oYXNTb3VyY2VUeXBlcygpKSkge1xuICAgICAgdGhpcy5kZXRhY2hNZWRpYSgpO1xuICAgICAgdGhpcy5hdHRhY2hNZWRpYShtZWRpYSk7XG4gICAgfVxuICAgIC8vIHdoZW4gYXR0YWNoaW5nIHRvIGEgc291cmNlIFVSTCwgdHJpZ2dlciBhIHBsYXlsaXN0IGxvYWRcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHtcbiAgICAgIHVybDogdXJsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgbG9hZGluZyBkYXRhIGZyb20gdGhlIHN0cmVhbSBzb3VyY2UuXG4gICAqIERlcGVuZGluZyBvbiBkZWZhdWx0IGNvbmZpZywgY2xpZW50IHN0YXJ0cyBsb2FkaW5nIGF1dG9tYXRpY2FsbHkgd2hlbiBhIHNvdXJjZSBpcyBzZXQuXG4gICAqXG4gICAqIEBwYXJhbSBzdGFydFBvc2l0aW9uIC0gU2V0IHRoZSBzdGFydCBwb3NpdGlvbiB0byBzdHJlYW0gZnJvbS5cbiAgICogRGVmYXVsdHMgdG8gLTEgKE5vbmU6IHN0YXJ0cyBmcm9tIGVhcmxpZXN0IHBvaW50KVxuICAgKi9cbiAgc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24gPSAtMSkge1xuICAgIGxvZ2dlci5sb2coYHN0YXJ0TG9hZCgke3N0YXJ0UG9zaXRpb259KWApO1xuICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMuZm9yRWFjaChjb250cm9sbGVyID0+IHtcbiAgICAgIGNvbnRyb2xsZXIuc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgbG9hZGluZyBvZiBhbnkgc3RyZWFtIGRhdGEuXG4gICAqL1xuICBzdG9wTG9hZCgpIHtcbiAgICBsb2dnZXIubG9nKCdzdG9wTG9hZCcpO1xuICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzLmZvckVhY2goY29udHJvbGxlciA9PiB7XG4gICAgICBjb250cm9sbGVyLnN0b3BMb2FkKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVzdW1lcyBzdHJlYW0gY29udHJvbGxlciBzZWdtZW50IGxvYWRpbmcgaWYgcHJldmlvdXNseSBzdGFydGVkLlxuICAgKi9cbiAgcmVzdW1lQnVmZmVyaW5nKCkge1xuICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzLmZvckVhY2goY29udHJvbGxlciA9PiB7XG4gICAgICAgIGlmICgnZnJhZ21lbnRMb2FkZXInIGluIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBjb250cm9sbGVyLnN0YXJ0TG9hZCgtMSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wcyBzdHJlYW0gY29udHJvbGxlciBzZWdtZW50IGxvYWRpbmcgd2l0aG91dCBjaGFuZ2luZyAnc3RhcnRlZCcgc3RhdGUgbGlrZSBzdG9wTG9hZCgpLlxuICAgKiBUaGlzIGFsbG93cyBmb3IgbWVkaWEgYnVmZmVyaW5nIHRvIGJlIHBhdXNlZCB3aXRob3V0IGludGVydXB0aW5nIHBsYXlsaXN0IGxvYWRpbmcuXG4gICAqL1xuICBwYXVzZUJ1ZmZlcmluZygpIHtcbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycy5mb3JFYWNoKGNvbnRyb2xsZXIgPT4ge1xuICAgICAgaWYgKCdmcmFnbWVudExvYWRlcicgaW4gY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLnN0b3BMb2FkKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3dhcCB0aHJvdWdoIHBvc3NpYmxlIGF1ZGlvIGNvZGVjcyBpbiB0aGUgc3RyZWFtIChmb3IgZXhhbXBsZSB0byBzd2l0Y2ggZnJvbSBzdGVyZW8gdG8gNS4xKVxuICAgKi9cbiAgc3dhcEF1ZGlvQ29kZWMoKSB7XG4gICAgbG9nZ2VyLmxvZygnc3dhcEF1ZGlvQ29kZWMnKTtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuc3dhcEF1ZGlvQ29kZWMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBtZWRpYS1lbGVtZW50IGZhaWxzLCB0aGlzIGFsbG93cyB0byBkZXRhY2ggYW5kIHRoZW4gcmUtYXR0YWNoIGl0XG4gICAqIGFzIG9uZSBjYWxsIChjb252ZW5pZW5jZSBtZXRob2QpLlxuICAgKlxuICAgKiBBdXRvbWF0aWMgcmVjb3Zlcnkgb2YgbWVkaWEtZXJyb3JzIGJ5IHRoaXMgcHJvY2VzcyBpcyBjb25maWd1cmFibGUuXG4gICAqL1xuICByZWNvdmVyTWVkaWFFcnJvcigpIHtcbiAgICBsb2dnZXIubG9nKCdyZWNvdmVyTWVkaWFFcnJvcicpO1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5fbWVkaWE7XG4gICAgdGhpcy5kZXRhY2hNZWRpYSgpO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgdGhpcy5hdHRhY2hNZWRpYShtZWRpYSk7XG4gICAgfVxuICB9XG4gIHJlbW92ZUxldmVsKGxldmVsSW5kZXgpIHtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5yZW1vdmVMZXZlbChsZXZlbEluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBhbiBhcnJheSBvZiBsZXZlbHMgKHZhcmlhbnRzKSBzb3J0ZWQgYnkgSERDUC1MRVZFTCwgUkVTT0xVVElPTiAoaGVpZ2h0KSwgRlJBTUUtUkFURSwgQ09ERUNTLCBWSURFTy1SQU5HRSwgYW5kIEJBTkRXSURUSFxuICAgKi9cbiAgZ2V0IGxldmVscygpIHtcbiAgICBjb25zdCBsZXZlbHMgPSB0aGlzLmxldmVsQ29udHJvbGxlci5sZXZlbHM7XG4gICAgcmV0dXJuIGxldmVscyA/IGxldmVscyA6IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGV4IG9mIHF1YWxpdHkgbGV2ZWwgKHZhcmlhbnQpIGN1cnJlbnRseSBwbGF5ZWRcbiAgICovXG4gIGdldCBjdXJyZW50TGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5jdXJyZW50TGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHF1YWxpdHkgbGV2ZWwgaW5kZXggaW1tZWRpYXRlbHkuIFRoaXMgd2lsbCBmbHVzaCB0aGUgY3VycmVudCBidWZmZXIgdG8gcmVwbGFjZSB0aGUgcXVhbGl0eSBhc2FwLiBUaGF0IG1lYW5zIHBsYXliYWNrIHdpbGwgaW50ZXJydXB0IGF0IGxlYXN0IHNob3J0bHkgdG8gcmUtYnVmZmVyIGFuZCByZS1zeW5jIGV2ZW50dWFsbHkuIFNldCB0byAtMSBmb3IgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbi5cbiAgICovXG4gIHNldCBjdXJyZW50TGV2ZWwobmV3TGV2ZWwpIHtcbiAgICBsb2dnZXIubG9nKGBzZXQgY3VycmVudExldmVsOiR7bmV3TGV2ZWx9YCk7XG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuaW1tZWRpYXRlTGV2ZWxTd2l0Y2goKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRleCBvZiBuZXh0IHF1YWxpdHkgbGV2ZWwgbG9hZGVkIGFzIHNjaGVkdWxlZCBieSBzdHJlYW0gY29udHJvbGxlci5cbiAgICovXG4gIGdldCBuZXh0TGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHF1YWxpdHkgbGV2ZWwgaW5kZXggZm9yIG5leHQgbG9hZGVkIGRhdGEuXG4gICAqIFRoaXMgd2lsbCBzd2l0Y2ggdGhlIHZpZGVvIHF1YWxpdHkgYXNhcCwgd2l0aG91dCBpbnRlcnJ1cHRpbmcgcGxheWJhY2suXG4gICAqIE1heSBhYm9ydCBjdXJyZW50IGxvYWRpbmcgb2YgZGF0YSwgYW5kIGZsdXNoIHBhcnRzIG9mIGJ1ZmZlciAob3V0c2lkZSBjdXJyZW50bHkgcGxheWVkIGZyYWdtZW50IHJlZ2lvbikuXG4gICAqIEBwYXJhbSBuZXdMZXZlbCAtIFBhc3MgLTEgZm9yIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb25cbiAgICovXG4gIHNldCBuZXh0TGV2ZWwobmV3TGV2ZWwpIHtcbiAgICBsb2dnZXIubG9nKGBzZXQgbmV4dExldmVsOiR7bmV3TGV2ZWx9YCk7XG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBxdWFsaXR5IGxldmVsIG9mIHRoZSBjdXJyZW50bHkgb3IgbGFzdCAob2Ygbm9uZSBpcyBsb2FkZWQgY3VycmVudGx5KSBzZWdtZW50XG4gICAqL1xuICBnZXQgbG9hZExldmVsKCkge1xuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5sZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgcXVhbGl0eSBsZXZlbCBpbmRleCBmb3IgbmV4dCBsb2FkZWQgZGF0YSBpbiBhIGNvbnNlcnZhdGl2ZSB3YXkuXG4gICAqIFRoaXMgd2lsbCBzd2l0Y2ggdGhlIHF1YWxpdHkgd2l0aG91dCBmbHVzaGluZywgYnV0IGludGVycnVwdCBjdXJyZW50IGxvYWRpbmcuXG4gICAqIFRodXMgdGhlIG1vbWVudCB3aGVuIHRoZSBxdWFsaXR5IHN3aXRjaCB3aWxsIGFwcGVhciBpbiBlZmZlY3Qgd2lsbCBvbmx5IGJlIGFmdGVyIHRoZSBhbHJlYWR5IGV4aXN0aW5nIGJ1ZmZlci5cbiAgICogQHBhcmFtIG5ld0xldmVsIC0gUGFzcyAtMSBmb3IgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvblxuICAgKi9cbiAgc2V0IGxvYWRMZXZlbChuZXdMZXZlbCkge1xuICAgIGxvZ2dlci5sb2coYHNldCBsb2FkTGV2ZWw6JHtuZXdMZXZlbH1gKTtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbCA9IG5ld0xldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCBuZXh0IHF1YWxpdHkgbGV2ZWwgbG9hZGVkXG4gICAqL1xuICBnZXQgbmV4dExvYWRMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubmV4dExvYWRMZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgcXVhbGl0eSBsZXZlbCBvZiBuZXh0IGxvYWRlZCBzZWdtZW50IGluIGEgZnVsbHkgXCJub24tZGVzdHJ1Y3RpdmVcIiB3YXkuXG4gICAqIFNhbWUgYXMgYGxvYWRMZXZlbGAgYnV0IHdpbGwgd2FpdCBmb3IgbmV4dCBzd2l0Y2ggKHVudGlsIGN1cnJlbnQgbG9hZGluZyBpcyBkb25lKS5cbiAgICovXG4gIHNldCBuZXh0TG9hZExldmVsKGxldmVsKSB7XG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIubmV4dExvYWRMZXZlbCA9IGxldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBcImZpcnN0IGxldmVsXCI6IGxpa2UgYSBkZWZhdWx0IGxldmVsLCBpZiBub3Qgc2V0LFxuICAgKiBmYWxscyBiYWNrIHRvIGluZGV4IG9mIGZpcnN0IGxldmVsIHJlZmVyZW5jZWQgaW4gbWFuaWZlc3RcbiAgICovXG4gIGdldCBmaXJzdExldmVsKCkge1xuICAgIHJldHVybiBNYXRoLm1heCh0aGlzLmxldmVsQ29udHJvbGxlci5maXJzdExldmVsLCB0aGlzLm1pbkF1dG9MZXZlbCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBcImZpcnN0LWxldmVsXCIsIHNlZSBnZXR0ZXIuXG4gICAqL1xuICBzZXQgZmlyc3RMZXZlbChuZXdMZXZlbCkge1xuICAgIGxvZ2dlci5sb2coYHNldCBmaXJzdExldmVsOiR7bmV3TGV2ZWx9YCk7XG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIuZmlyc3RMZXZlbCA9IG5ld0xldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgZGVzaXJlZCBzdGFydCBsZXZlbCBmb3IgdGhlIGZpcnN0IGZyYWdtZW50IHRoYXQgd2lsbCBiZSBsb2FkZWQuXG4gICAqIFRoZSBkZWZhdWx0IHZhbHVlIG9mIC0xIGluZGljYXRlcyBhdXRvbWF0aWMgc3RhcnQgbGV2ZWwgc2VsZWN0aW9uLlxuICAgKiBTZXR0aW5nIGhscy5uZXh0QXV0b0xldmVsIHdpdGhvdXQgc2V0dGluZyBhIHN0YXJ0TGV2ZWwgd2lsbCByZXN1bHQgaW5cbiAgICogdGhlIG5leHRBdXRvTGV2ZWwgdmFsdWUgYmVpbmcgdXNlZCBmb3Igb25lIGZyYWdtZW50IGxvYWQuXG4gICAqL1xuICBnZXQgc3RhcnRMZXZlbCgpIHtcbiAgICBjb25zdCBzdGFydExldmVsID0gdGhpcy5sZXZlbENvbnRyb2xsZXIuc3RhcnRMZXZlbDtcbiAgICBpZiAoc3RhcnRMZXZlbCA9PT0gLTEgJiYgdGhpcy5hYnJDb250cm9sbGVyLmZvcmNlZEF1dG9MZXZlbCA+IC0xKSB7XG4gICAgICByZXR1cm4gdGhpcy5hYnJDb250cm9sbGVyLmZvcmNlZEF1dG9MZXZlbDtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXJ0TGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogc2V0ICBzdGFydCBsZXZlbCAobGV2ZWwgb2YgZmlyc3QgZnJhZ21lbnQgdGhhdCB3aWxsIGJlIHBsYXllZCBiYWNrKVxuICAgKiBpZiBub3Qgb3ZlcnJpZGVkIGJ5IHVzZXIsIGZpcnN0IGxldmVsIGFwcGVhcmluZyBpbiBtYW5pZmVzdCB3aWxsIGJlIHVzZWQgYXMgc3RhcnQgbGV2ZWxcbiAgICogaWYgLTEgOiBhdXRvbWF0aWMgc3RhcnQgbGV2ZWwgc2VsZWN0aW9uLCBwbGF5YmFjayB3aWxsIHN0YXJ0IGZyb20gbGV2ZWwgbWF0Y2hpbmcgZG93bmxvYWQgYmFuZHdpZHRoXG4gICAqIChkZXRlcm1pbmVkIGZyb20gZG93bmxvYWQgb2YgZmlyc3Qgc2VnbWVudClcbiAgICovXG4gIHNldCBzdGFydExldmVsKG5ld0xldmVsKSB7XG4gICAgbG9nZ2VyLmxvZyhgc2V0IHN0YXJ0TGV2ZWw6JHtuZXdMZXZlbH1gKTtcbiAgICAvLyBpZiBub3QgaW4gYXV0b21hdGljIHN0YXJ0IGxldmVsIGRldGVjdGlvbiwgZW5zdXJlIHN0YXJ0TGV2ZWwgaXMgZ3JlYXRlciB0aGFuIG1pbkF1dG9MZXZlbFxuICAgIGlmIChuZXdMZXZlbCAhPT0gLTEpIHtcbiAgICAgIG5ld0xldmVsID0gTWF0aC5tYXgobmV3TGV2ZWwsIHRoaXMubWluQXV0b0xldmVsKTtcbiAgICB9XG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIuc3RhcnRMZXZlbCA9IG5ld0xldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgbGV2ZWwgY2FwcGluZyBpcyBlbmFibGVkLlxuICAgKiBEZWZhdWx0IHZhbHVlIGlzIHNldCB2aWEgYGNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZWAuXG4gICAqL1xuICBnZXQgY2FwTGV2ZWxUb1BsYXllclNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgbGV2ZWwgY2FwcGluZy4gSWYgZGlzYWJsZWQgYWZ0ZXIgcHJldmlvdXNseSBlbmFibGVkLCBgbmV4dExldmVsU3dpdGNoYCB3aWxsIGJlIGltbWVkaWF0ZWx5IGNhbGxlZC5cbiAgICovXG4gIHNldCBjYXBMZXZlbFRvUGxheWVyU2l6ZShzaG91bGRTdGFydENhcHBpbmcpIHtcbiAgICBjb25zdCBuZXdDYXBMZXZlbFRvUGxheWVyU2l6ZSA9ICEhc2hvdWxkU3RhcnRDYXBwaW5nO1xuICAgIGlmIChuZXdDYXBMZXZlbFRvUGxheWVyU2l6ZSAhPT0gdGhpcy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemUpIHtcbiAgICAgIGlmIChuZXdDYXBMZXZlbFRvUGxheWVyU2l6ZSkge1xuICAgICAgICB0aGlzLmNhcExldmVsQ29udHJvbGxlci5zdGFydENhcHBpbmcoKTsgLy8gSWYgY2FwcGluZyBvY2N1cnMsIG5leHRMZXZlbFN3aXRjaCB3aWxsIGhhcHBlbiBiYXNlZCBvbiBzaXplLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYXBMZXZlbENvbnRyb2xsZXIuc3RvcENhcHBpbmcoKTtcbiAgICAgICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gLTE7XG4gICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWxTd2l0Y2goKTsgLy8gTm93IHdlJ3JlIHVuY2FwcGVkLCBnZXQgdGhlIG5leHQgbGV2ZWwgYXNhcC5cbiAgICAgIH1cbiAgICAgIHRoaXMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplID0gbmV3Q2FwTGV2ZWxUb1BsYXllclNpemU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhcHBpbmcvbWF4IGxldmVsIHZhbHVlIHRoYXQgc2hvdWxkIGJlIHVzZWQgYnkgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbiBhbGdvcml0aG0gKGBBQlJDb250cm9sbGVyYClcbiAgICovXG4gIGdldCBhdXRvTGV2ZWxDYXBwaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgYmFuZHdpZHRoIGVzdGltYXRlIGluIGJpdHMgcGVyIHNlY29uZCwgd2hlbiBhdmFpbGFibGUuIE90aGVyd2lzZSwgYE5hTmAgaXMgcmV0dXJuZWQuXG4gICAqL1xuICBnZXQgYmFuZHdpZHRoRXN0aW1hdGUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgYndFc3RpbWF0b3JcbiAgICB9ID0gdGhpcy5hYnJDb250cm9sbGVyO1xuICAgIGlmICghYndFc3RpbWF0b3IpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHJldHVybiBid0VzdGltYXRvci5nZXRFc3RpbWF0ZSgpO1xuICB9XG4gIHNldCBiYW5kd2lkdGhFc3RpbWF0ZShhYnJFd21hRGVmYXVsdEVzdGltYXRlKSB7XG4gICAgdGhpcy5hYnJDb250cm9sbGVyLnJlc2V0RXN0aW1hdG9yKGFickV3bWFEZWZhdWx0RXN0aW1hdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCB0aW1lIHRvIGZpcnN0IGJ5dGUgZXN0aW1hdGVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB0dGZiRXN0aW1hdGUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgYndFc3RpbWF0b3JcbiAgICB9ID0gdGhpcy5hYnJDb250cm9sbGVyO1xuICAgIGlmICghYndFc3RpbWF0b3IpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHJldHVybiBid0VzdGltYXRvci5nZXRFc3RpbWF0ZVRURkIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYXBwaW5nL21heCBsZXZlbCB2YWx1ZSB0aGF0IHNob3VsZCBiZSB1c2VkIGJ5IGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24gYWxnb3JpdGhtIChgQUJSQ29udHJvbGxlcmApXG4gICAqL1xuICBzZXQgYXV0b0xldmVsQ2FwcGluZyhuZXdMZXZlbCkge1xuICAgIGlmICh0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nICE9PSBuZXdMZXZlbCkge1xuICAgICAgbG9nZ2VyLmxvZyhgc2V0IGF1dG9MZXZlbENhcHBpbmc6JHtuZXdMZXZlbH1gKTtcbiAgICAgIHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgPSBuZXdMZXZlbDtcbiAgICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLmNoZWNrTWF4QXV0b1VwZGF0ZWQoKTtcbiAgICB9XG4gIH1cbiAgZ2V0IG1heEhkY3BMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWF4SGRjcExldmVsO1xuICB9XG4gIHNldCBtYXhIZGNwTGV2ZWwodmFsdWUpIHtcbiAgICBpZiAoaXNIZGNwTGV2ZWwodmFsdWUpICYmIHRoaXMuX21heEhkY3BMZXZlbCAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX21heEhkY3BMZXZlbCA9IHZhbHVlO1xuICAgICAgdGhpcy5sZXZlbENvbnRyb2xsZXIuY2hlY2tNYXhBdXRvVXBkYXRlZCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcnVlIHdoZW4gYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbiBlbmFibGVkXG4gICAqL1xuICBnZXQgYXV0b0xldmVsRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWwgPT09IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIExldmVsIHNldCBtYW51YWxseSAoaWYgYW55KVxuICAgKi9cbiAgZ2V0IG1hbnVhbExldmVsKCkge1xuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBtaW4gbGV2ZWwgc2VsZWN0YWJsZSBpbiBhdXRvIG1vZGUgYWNjb3JkaW5nIHRvIGNvbmZpZy5taW5BdXRvQml0cmF0ZVxuICAgKi9cbiAgZ2V0IG1pbkF1dG9MZXZlbCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBsZXZlbHMsXG4gICAgICBjb25maWc6IHtcbiAgICAgICAgbWluQXV0b0JpdHJhdGVcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWxldmVscykgcmV0dXJuIDA7XG4gICAgY29uc3QgbGVuID0gbGV2ZWxzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAobGV2ZWxzW2ldLm1heEJpdHJhdGUgPj0gbWluQXV0b0JpdHJhdGUpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIG1heCBsZXZlbCBzZWxlY3RhYmxlIGluIGF1dG8gbW9kZSBhY2NvcmRpbmcgdG8gYXV0b0xldmVsQ2FwcGluZ1xuICAgKi9cbiAgZ2V0IG1heEF1dG9MZXZlbCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBsZXZlbHMsXG4gICAgICBhdXRvTGV2ZWxDYXBwaW5nLFxuICAgICAgbWF4SGRjcExldmVsXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IG1heEF1dG9MZXZlbDtcbiAgICBpZiAoYXV0b0xldmVsQ2FwcGluZyA9PT0gLTEgJiYgbGV2ZWxzICE9IG51bGwgJiYgbGV2ZWxzLmxlbmd0aCkge1xuICAgICAgbWF4QXV0b0xldmVsID0gbGV2ZWxzLmxlbmd0aCAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heEF1dG9MZXZlbCA9IGF1dG9MZXZlbENhcHBpbmc7XG4gICAgfVxuICAgIGlmIChtYXhIZGNwTGV2ZWwpIHtcbiAgICAgIGZvciAobGV0IGkgPSBtYXhBdXRvTGV2ZWw7IGktLTspIHtcbiAgICAgICAgY29uc3QgaGRjcExldmVsID0gbGV2ZWxzW2ldLmF0dHJzWydIRENQLUxFVkVMJ107XG4gICAgICAgIGlmIChoZGNwTGV2ZWwgJiYgaGRjcExldmVsIDw9IG1heEhkY3BMZXZlbCkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXhBdXRvTGV2ZWw7XG4gIH1cbiAgZ2V0IGZpcnN0QXV0b0xldmVsKCkge1xuICAgIHJldHVybiB0aGlzLmFickNvbnRyb2xsZXIuZmlyc3RBdXRvTGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogbmV4dCBhdXRvbWF0aWNhbGx5IHNlbGVjdGVkIHF1YWxpdHkgbGV2ZWxcbiAgICovXG4gIGdldCBuZXh0QXV0b0xldmVsKCkge1xuICAgIHJldHVybiB0aGlzLmFickNvbnRyb2xsZXIubmV4dEF1dG9MZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiB0aGlzIHNldHRlciBpcyB1c2VkIHRvIGZvcmNlIG5leHQgYXV0byBsZXZlbC5cbiAgICogdGhpcyBpcyB1c2VmdWwgdG8gZm9yY2UgYSBzd2l0Y2ggZG93biBpbiBhdXRvIG1vZGU6XG4gICAqIGluIGNhc2Ugb2YgbG9hZCBlcnJvciBvbiBsZXZlbCBOLCBobHMuanMgY2FuIHNldCBuZXh0QXV0b0xldmVsIHRvIE4tMSBmb3IgZXhhbXBsZSlcbiAgICogZm9yY2VkIHZhbHVlIGlzIHZhbGlkIGZvciBvbmUgZnJhZ21lbnQuIHVwb24gc3VjY2Vzc2Z1bCBmcmFnIGxvYWRpbmcgYXQgZm9yY2VkIGxldmVsLFxuICAgKiB0aGlzIHZhbHVlIHdpbGwgYmUgcmVzZXR0ZWQgdG8gLTEgYnkgQUJSIGNvbnRyb2xsZXIuXG4gICAqL1xuICBzZXQgbmV4dEF1dG9MZXZlbChuZXh0TGV2ZWwpIHtcbiAgICB0aGlzLmFickNvbnRyb2xsZXIubmV4dEF1dG9MZXZlbCA9IG5leHRMZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIGRhdGV0aW1lIHZhbHVlIHJlbGF0aXZlIHRvIG1lZGlhLmN1cnJlbnRUaW1lIGZvciB0aGUgYWN0aXZlIGxldmVsIFByb2dyYW0gRGF0ZSBUaW1lIGlmIHByZXNlbnRcbiAgICovXG4gIGdldCBwbGF5aW5nRGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmN1cnJlbnRQcm9ncmFtRGF0ZVRpbWU7XG4gIH1cbiAgZ2V0IG1haW5Gb3J3YXJkQnVmZmVySW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmdldE1haW5Gd2RCdWZmZXJJbmZvKCk7XG4gIH1cblxuICAvKipcbiAgICogRmluZCBhbmQgc2VsZWN0IHRoZSBiZXN0IG1hdGNoaW5nIGF1ZGlvIHRyYWNrLCBtYWtpbmcgYSBsZXZlbCBzd2l0Y2ggd2hlbiBhIEdyb3VwIGNoYW5nZSBpcyBuZWNlc3NhcnkuXG4gICAqIFVwZGF0ZXMgYGhscy5jb25maWcuYXVkaW9QcmVmZXJlbmNlYC4gUmV0dXJucyB0aGUgc2VsZWN0ZWQgdHJhY2ssIG9yIG51bGwgd2hlbiBubyBtYXRjaGluZyB0cmFjayBpcyBmb3VuZC5cbiAgICovXG4gIHNldEF1ZGlvT3B0aW9uKGF1ZGlvT3B0aW9uKSB7XG4gICAgdmFyIF90aGlzJGF1ZGlvVHJhY2tDb250cjtcbiAgICByZXR1cm4gKF90aGlzJGF1ZGlvVHJhY2tDb250ciA9IHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXIpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRhdWRpb1RyYWNrQ29udHIuc2V0QXVkaW9PcHRpb24oYXVkaW9PcHRpb24pO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kIGFuZCBzZWxlY3QgdGhlIGJlc3QgbWF0Y2hpbmcgc3VidGl0bGUgdHJhY2ssIG1ha2luZyBhIGxldmVsIHN3aXRjaCB3aGVuIGEgR3JvdXAgY2hhbmdlIGlzIG5lY2Vzc2FyeS5cbiAgICogVXBkYXRlcyBgaGxzLmNvbmZpZy5zdWJ0aXRsZVByZWZlcmVuY2VgLiBSZXR1cm5zIHRoZSBzZWxlY3RlZCB0cmFjaywgb3IgbnVsbCB3aGVuIG5vIG1hdGNoaW5nIHRyYWNrIGlzIGZvdW5kLlxuICAgKi9cbiAgc2V0U3VidGl0bGVPcHRpb24oc3VidGl0bGVPcHRpb24pIHtcbiAgICB2YXIgX3RoaXMkc3VidGl0bGVUcmFja0NvO1xuICAgIChfdGhpcyRzdWJ0aXRsZVRyYWNrQ28gPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkc3VidGl0bGVUcmFja0NvLnNldFN1YnRpdGxlT3B0aW9uKHN1YnRpdGxlT3B0aW9uKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvbXBsZXRlIGxpc3Qgb2YgYXVkaW8gdHJhY2tzIGFjcm9zcyBhbGwgbWVkaWEgZ3JvdXBzXG4gICAqL1xuICBnZXQgYWxsQXVkaW9UcmFja3MoKSB7XG4gICAgY29uc3QgYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgIHJldHVybiBhdWRpb1RyYWNrQ29udHJvbGxlciA/IGF1ZGlvVHJhY2tDb250cm9sbGVyLmFsbEF1ZGlvVHJhY2tzIDogW107XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsaXN0IG9mIHNlbGVjdGFibGUgYXVkaW8gdHJhY2tzXG4gICAqL1xuICBnZXQgYXVkaW9UcmFja3MoKSB7XG4gICAgY29uc3QgYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgIHJldHVybiBhdWRpb1RyYWNrQ29udHJvbGxlciA/IGF1ZGlvVHJhY2tDb250cm9sbGVyLmF1ZGlvVHJhY2tzIDogW107XG4gIH1cblxuICAvKipcbiAgICogaW5kZXggb2YgdGhlIHNlbGVjdGVkIGF1ZGlvIHRyYWNrIChpbmRleCBpbiBhdWRpbyB0cmFjayBsaXN0cylcbiAgICovXG4gIGdldCBhdWRpb1RyYWNrKCkge1xuICAgIGNvbnN0IGF1ZGlvVHJhY2tDb250cm9sbGVyID0gdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlcjtcbiAgICByZXR1cm4gYXVkaW9UcmFja0NvbnRyb2xsZXIgPyBhdWRpb1RyYWNrQ29udHJvbGxlci5hdWRpb1RyYWNrIDogLTE7XG4gIH1cblxuICAvKipcbiAgICogc2VsZWN0cyBhbiBhdWRpbyB0cmFjaywgYmFzZWQgb24gaXRzIGluZGV4IGluIGF1ZGlvIHRyYWNrIGxpc3RzXG4gICAqL1xuICBzZXQgYXVkaW9UcmFjayhhdWRpb1RyYWNrSWQpIHtcbiAgICBjb25zdCBhdWRpb1RyYWNrQ29udHJvbGxlciA9IHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXI7XG4gICAgaWYgKGF1ZGlvVHJhY2tDb250cm9sbGVyKSB7XG4gICAgICBhdWRpb1RyYWNrQ29udHJvbGxlci5hdWRpb1RyYWNrID0gYXVkaW9UcmFja0lkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIGNvbXBsZXRlIGxpc3Qgb2Ygc3VidGl0bGUgdHJhY2tzIGFjcm9zcyBhbGwgbWVkaWEgZ3JvdXBzXG4gICAqL1xuICBnZXQgYWxsU3VidGl0bGVUcmFja3MoKSB7XG4gICAgY29uc3Qgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgIHJldHVybiBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA/IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLmFsbFN1YnRpdGxlVHJhY2tzIDogW107XG4gIH1cblxuICAvKipcbiAgICogZ2V0IGFsdGVybmF0ZSBzdWJ0aXRsZSB0cmFja3MgbGlzdCBmcm9tIHBsYXlsaXN0XG4gICAqL1xuICBnZXQgc3VidGl0bGVUcmFja3MoKSB7XG4gICAgY29uc3Qgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgIHJldHVybiBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA/IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlVHJhY2tzIDogW107XG4gIH1cblxuICAvKipcbiAgICogaW5kZXggb2YgdGhlIHNlbGVjdGVkIHN1YnRpdGxlIHRyYWNrIChpbmRleCBpbiBzdWJ0aXRsZSB0cmFjayBsaXN0cylcbiAgICovXG4gIGdldCBzdWJ0aXRsZVRyYWNrKCkge1xuICAgIGNvbnN0IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICByZXR1cm4gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPyBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5zdWJ0aXRsZVRyYWNrIDogLTE7XG4gIH1cbiAgZ2V0IG1lZGlhKCkge1xuICAgIHJldHVybiB0aGlzLl9tZWRpYTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzZWxlY3QgYW4gc3VidGl0bGUgdHJhY2ssIGJhc2VkIG9uIGl0cyBpbmRleCBpbiBzdWJ0aXRsZSB0cmFjayBsaXN0c1xuICAgKi9cbiAgc2V0IHN1YnRpdGxlVHJhY2soc3VidGl0bGVUcmFja0lkKSB7XG4gICAgY29uc3Qgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgIGlmIChzdWJ0aXRsZVRyYWNrQ29udHJvbGxlcikge1xuICAgICAgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVUcmFjayA9IHN1YnRpdGxlVHJhY2tJZDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciBzdWJ0aXRsZSBkaXNwbGF5IGlzIGVuYWJsZWQgb3Igbm90XG4gICAqL1xuICBnZXQgc3VidGl0bGVEaXNwbGF5KCkge1xuICAgIGNvbnN0IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICByZXR1cm4gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPyBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5zdWJ0aXRsZURpc3BsYXkgOiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGUvZGlzYWJsZSBzdWJ0aXRsZSBkaXNwbGF5IHJlbmRlcmluZ1xuICAgKi9cbiAgc2V0IHN1YnRpdGxlRGlzcGxheSh2YWx1ZSkge1xuICAgIGNvbnN0IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICBpZiAoc3VidGl0bGVUcmFja0NvbnRyb2xsZXIpIHtcbiAgICAgIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlRGlzcGxheSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgbW9kZSBmb3IgTG93LUxhdGVuY3kgSExTIGxvYWRpbmdcbiAgICovXG4gIGdldCBsb3dMYXRlbmN5TW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcubG93TGF0ZW5jeU1vZGU7XG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlL2Rpc2FibGUgTG93LUxhdGVuY3kgSExTIHBhcnQgcGxheWxpc3QgYW5kIHNlZ21lbnQgbG9hZGluZywgYW5kIHN0YXJ0IGxpdmUgc3RyZWFtcyBhdCBwbGF5bGlzdCBQQVJULUhPTEQtQkFDSyByYXRoZXIgdGhhbiBIT0xELUJBQ0suXG4gICAqL1xuICBzZXQgbG93TGF0ZW5jeU1vZGUobW9kZSkge1xuICAgIHRoaXMuY29uZmlnLmxvd0xhdGVuY3lNb2RlID0gbW9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQb3NpdGlvbiAoaW4gc2Vjb25kcykgb2YgbGl2ZSBzeW5jIHBvaW50IChpZSBlZGdlIG9mIGxpdmUgcG9zaXRpb24gbWludXMgc2FmZXR5IGRlbGF5IGRlZmluZWQgYnkgYGBgaGxzLmNvbmZpZy5saXZlU3luY0R1cmF0aW9uYGBgKVxuICAgKiBAcmV0dXJucyBudWxsIHByaW9yIHRvIGxvYWRpbmcgbGl2ZSBQbGF5bGlzdFxuICAgKi9cbiAgZ2V0IGxpdmVTeW5jUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIubGl2ZVN5bmNQb3NpdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFc3RpbWF0ZWQgcG9zaXRpb24gKGluIHNlY29uZHMpIG9mIGxpdmUgZWRnZSAoaWUgZWRnZSBvZiBsaXZlIHBsYXlsaXN0IHBsdXMgdGltZSBzeW5jIHBsYXlsaXN0IGFkdmFuY2VkKVxuICAgKiBAcmV0dXJucyAwIGJlZm9yZSBmaXJzdCBwbGF5bGlzdCBpcyBsb2FkZWRcbiAgICovXG4gIGdldCBsYXRlbmN5KCkge1xuICAgIHJldHVybiB0aGlzLmxhdGVuY3lDb250cm9sbGVyLmxhdGVuY3k7XG4gIH1cblxuICAvKipcbiAgICogbWF4aW11bSBkaXN0YW5jZSBmcm9tIHRoZSBlZGdlIGJlZm9yZSB0aGUgcGxheWVyIHNlZWtzIGZvcndhcmQgdG8gYGBgaGxzLmxpdmVTeW5jUG9zaXRpb25gYGBcbiAgICogY29uZmlndXJlZCB1c2luZyBgYGBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnRgYGAgKG11bHRpcGxlIG9mIHRhcmdldCBkdXJhdGlvbikgb3IgYGBgbGl2ZU1heExhdGVuY3lEdXJhdGlvbmBgYFxuICAgKiBAcmV0dXJucyAwIGJlZm9yZSBmaXJzdCBwbGF5bGlzdCBpcyBsb2FkZWRcbiAgICovXG4gIGdldCBtYXhMYXRlbmN5KCkge1xuICAgIHJldHVybiB0aGlzLmxhdGVuY3lDb250cm9sbGVyLm1heExhdGVuY3k7XG4gIH1cblxuICAvKipcbiAgICogdGFyZ2V0IGRpc3RhbmNlIGZyb20gdGhlIGVkZ2UgYXMgY2FsY3VsYXRlZCBieSB0aGUgbGF0ZW5jeSBjb250cm9sbGVyXG4gICAqL1xuICBnZXQgdGFyZ2V0TGF0ZW5jeSgpIHtcbiAgICByZXR1cm4gdGhpcy5sYXRlbmN5Q29udHJvbGxlci50YXJnZXRMYXRlbmN5O1xuICB9XG5cbiAgLyoqXG4gICAqIHRoZSByYXRlIGF0IHdoaWNoIHRoZSBlZGdlIG9mIHRoZSBjdXJyZW50IGxpdmUgcGxheWxpc3QgaXMgYWR2YW5jaW5nIG9yIDEgaWYgdGhlcmUgaXMgbm9uZVxuICAgKi9cbiAgZ2V0IGRyaWZ0KCkge1xuICAgIHJldHVybiB0aGlzLmxhdGVuY3lDb250cm9sbGVyLmRyaWZ0O1xuICB9XG5cbiAgLyoqXG4gICAqIHNldCB0byB0cnVlIHdoZW4gc3RhcnRMb2FkIGlzIGNhbGxlZCBiZWZvcmUgTUFOSUZFU1RfUEFSU0VEIGV2ZW50XG4gICAqL1xuICBnZXQgZm9yY2VTdGFydExvYWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5mb3JjZVN0YXJ0TG9hZDtcbiAgfVxufVxuSGxzLmRlZmF1bHRDb25maWcgPSB2b2lkIDA7XG5cbmV4cG9ydCB7IEFickNvbnRyb2xsZXIsIEF0dHJMaXN0LCBBdWRpb1N0cmVhbUNvbnRyb2xsZXIsIEF1ZGlvVHJhY2tDb250cm9sbGVyLCBCYXNlUGxheWxpc3RDb250cm9sbGVyLCBCYXNlU2VnbWVudCwgQmFzZVN0cmVhbUNvbnRyb2xsZXIsIEJ1ZmZlckNvbnRyb2xsZXIsIENNQ0RDb250cm9sbGVyLCBDYXBMZXZlbENvbnRyb2xsZXIsIENodW5rTWV0YWRhdGEsIENvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXIsIERhdGVSYW5nZSwgRU1FQ29udHJvbGxlciwgRXJyb3JBY3Rpb25GbGFncywgRXJyb3JDb250cm9sbGVyLCBFcnJvckRldGFpbHMsIEVycm9yVHlwZXMsIEV2ZW50cywgRlBTQ29udHJvbGxlciwgRnJhZ21lbnQsIEhscywgSGxzU2tpcCwgSGxzVXJsUGFyYW1ldGVycywgS2V5U3lzdGVtRm9ybWF0cywgS2V5U3lzdGVtcywgTGV2ZWwsIExldmVsRGV0YWlscywgTGV2ZWxLZXksIExvYWRTdGF0cywgTWV0YWRhdGFTY2hlbWEsIE5ldHdvcmtFcnJvckFjdGlvbiwgUGFydCwgUGxheWxpc3RMZXZlbFR5cGUsIFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlciwgU3VidGl0bGVUcmFja0NvbnRyb2xsZXIsIFRpbWVsaW5lQ29udHJvbGxlciwgSGxzIGFzIGRlZmF1bHQsIGdldE1lZGlhU291cmNlLCBpc01TRVN1cHBvcnRlZCwgaXNTdXBwb3J0ZWQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhscy5tanMubWFwXG4iXSwibmFtZXMiOlsiZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMiLCJ4IiwiX19lc01vZHVsZSIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInVybFRvb2xraXQiLCJleHBvcnRzIiwibW9kdWxlIiwicm9vdCIsIlVSTF9SRUdFWCIsIkZJUlNUX1NFR01FTlRfUkVHRVgiLCJTTEFTSF9ET1RfUkVHRVgiLCJTTEFTSF9ET1RfRE9UX1JFR0VYIiwiVVJMVG9vbGtpdCIsImJ1aWxkQWJzb2x1dGVVUkwiLCJiYXNlVVJMIiwicmVsYXRpdmVVUkwiLCJvcHRzIiwidHJpbSIsImFsd2F5c05vcm1hbGl6ZSIsImJhc2VQYXJ0c0Zvck5vcm1hbGlzZSIsInBhcnNlVVJMIiwiRXJyb3IiLCJwYXRoIiwibm9ybWFsaXplUGF0aCIsImJ1aWxkVVJMRnJvbVBhcnRzIiwicmVsYXRpdmVQYXJ0cyIsInNjaGVtZSIsImJhc2VQYXJ0cyIsIm5ldExvYyIsInBhdGhQYXJ0cyIsImV4ZWMiLCJidWlsdFBhcnRzIiwicGFyYW1zIiwicXVlcnkiLCJmcmFnbWVudCIsImJhc2VVUkxQYXRoIiwibmV3UGF0aCIsInN1YnN0cmluZyIsImxhc3RJbmRleE9mIiwidXJsIiwicGFydHMiLCJzcGxpdCIsInJldmVyc2UiLCJqb2luIiwicmVwbGFjZSIsImxlbmd0aCIsInVybFRvb2xraXRFeHBvcnRzIiwib3duS2V5cyIsImUiLCJyIiwidCIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJvIiwiZmlsdGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQyIiwiYXJndW1lbnRzIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZGVmaW5lUHJvcGVydHkiLCJfdG9QcmltaXRpdmUiLCJTeW1ib2wiLCJ0b1ByaW1pdGl2ZSIsImkiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJOdW1iZXIiLCJfdG9Qcm9wZXJ0eUtleSIsIm9iaiIsImtleSIsInZhbHVlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfZXh0ZW5kcyIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJzb3VyY2UiLCJpc0Zpbml0ZU51bWJlciIsImlzRmluaXRlIiwiaXNTYWZlSW50ZWdlciIsIk1hdGgiLCJhYnMiLCJNQVhfU0FGRV9JTlRFR0VSIiwiRXZlbnRzIiwiRXJyb3JUeXBlcyIsIkVycm9yRGV0YWlscyIsIm5vb3AiLCJmYWtlTG9nZ2VyIiwidHJhY2UiLCJkZWJ1ZyIsImxvZyIsIndhcm4iLCJpbmZvIiwiZXJyb3IiLCJleHBvcnRlZExvZ2dlciIsImNvbnNvbGVQcmludEZuIiwidHlwZSIsImZ1bmMiLCJzZWxmIiwiY29uc29sZSIsImV4cG9ydExvZ2dlckZ1bmN0aW9ucyIsImRlYnVnQ29uZmlnIiwiZnVuY3Rpb25zIiwiZW5hYmxlTG9ncyIsImlkIiwibG9nZ2VyIiwiREVDSU1BTF9SRVNPTFVUSU9OX1JFR0VYIiwiQVRUUl9MSVNUX1JFR0VYIiwiQXR0ckxpc3QiLCJjb25zdHJ1Y3RvciIsImF0dHJzIiwicGFyc2VBdHRyTGlzdCIsImNsaWVudEF0dHJzIiwiYXR0ciIsImRlY2ltYWxJbnRlZ2VyIiwiYXR0ck5hbWUiLCJpbnRWYWx1ZSIsInBhcnNlSW50IiwiSW5maW5pdHkiLCJoZXhhZGVjaW1hbEludGVnZXIiLCJzdHJpbmdWYWx1ZSIsInNsaWNlIiwiVWludDhBcnJheSIsImhleGFkZWNpbWFsSW50ZWdlckFzTnVtYmVyIiwiZGVjaW1hbEZsb2F0aW5nUG9pbnQiLCJwYXJzZUZsb2F0Iiwib3B0aW9uYWxGbG9hdCIsImRlZmF1bHRWYWx1ZSIsImVudW1lcmF0ZWRTdHJpbmciLCJib29sIiwiZGVjaW1hbFJlc29sdXRpb24iLCJyZXMiLCJ1bmRlZmluZWQiLCJ3aWR0aCIsImhlaWdodCIsImlucHV0IiwibWF0Y2giLCJxdW90ZSIsImxhc3RJbmRleCIsImluZGV4T2YiLCJuYW1lIiwiaXNEYXRlUmFuZ2VDdWVBdHRyaWJ1dGUiLCJpc1NDVEUzNUF0dHJpYnV0ZSIsIkRhdGVSYW5nZSIsImRhdGVSYW5nZUF0dHIiLCJkYXRlUmFuZ2VXaXRoU2FtZUlkIiwiX3N0YXJ0RGF0ZSIsIl9lbmREYXRlIiwiX2JhZFZhbHVlRm9yU2FtZUlkIiwicHJldmlvdXNBdHRyIiwiSUQiLCJEYXRlIiwiZW5kRGF0ZSIsImdldFRpbWUiLCJjbGFzcyIsIkNMQVNTIiwic3RhcnREYXRlIiwiZHVyYXRpb24iLCJwbGFubmVkRHVyYXRpb24iLCJlbmRPbk5leHQiLCJpc1ZhbGlkIiwiTG9hZFN0YXRzIiwiYWJvcnRlZCIsImxvYWRlZCIsInJldHJ5IiwidG90YWwiLCJjaHVua0NvdW50IiwiYndFc3RpbWF0ZSIsImxvYWRpbmciLCJzdGFydCIsImZpcnN0IiwiZW5kIiwicGFyc2luZyIsImJ1ZmZlcmluZyIsIkVsZW1lbnRhcnlTdHJlYW1UeXBlcyIsIkFVRElPIiwiVklERU8iLCJBVURJT1ZJREVPIiwiQmFzZVNlZ21lbnQiLCJiYXNldXJsIiwiX2J5dGVSYW5nZSIsIl91cmwiLCJyZWx1cmwiLCJlbGVtZW50YXJ5U3RyZWFtcyIsInNldEJ5dGVSYW5nZSIsInByZXZpb3VzIiwiYnl0ZVJhbmdlRW5kT2Zmc2V0IiwiYnl0ZVJhbmdlIiwiYnl0ZVJhbmdlU3RhcnRPZmZzZXQiLCJGcmFnbWVudCIsIl9kZWNyeXB0ZGF0YSIsInJhd1Byb2dyYW1EYXRlVGltZSIsInByb2dyYW1EYXRlVGltZSIsInRhZ0xpc3QiLCJzbiIsImxldmVsa2V5cyIsImxvYWRlciIsImtleUxvYWRlciIsImxldmVsIiwiY2MiLCJzdGFydFBUUyIsImVuZFBUUyIsInN0YXJ0RFRTIiwiZW5kRFRTIiwiZGVsdGFQVFMiLCJtYXhTdGFydFBUUyIsIm1pbkVuZFBUUyIsInN0YXRzIiwiZGF0YSIsImJpdHJhdGVUZXN0IiwidGl0bGUiLCJpbml0U2VnbWVudCIsImVuZExpc3QiLCJnYXAiLCJ1cmxJZCIsImRlY3J5cHRkYXRhIiwiTk9ORSIsImlkZW50aXR5IiwiZ2V0RGVjcnlwdERhdGEiLCJrZXlGb3JtYXRzIiwiZW5kUHJvZ3JhbURhdGVUaW1lIiwiZW5jcnlwdGVkIiwiX3RoaXMkX2RlY3J5cHRkYXRhIiwibGVuIiwic2V0S2V5Rm9ybWF0Iiwia2V5Rm9ybWF0IiwiYWJvcnRSZXF1ZXN0cyIsIl90aGlzJGxvYWRlciIsIl90aGlzJGtleUxvYWRlciIsImFib3J0Iiwic2V0RWxlbWVudGFyeVN0cmVhbUluZm8iLCJwYXJ0aWFsIiwibWluIiwibWF4IiwiY2xlYXJFbGVtZW50YXJ5U3RyZWFtSW5mbyIsIlBhcnQiLCJwYXJ0QXR0cnMiLCJmcmFnIiwiaW5kZXgiLCJmcmFnT2Zmc2V0IiwiaW5kZXBlbmRlbnQiLCJhdWRpbyIsInZpZGVvIiwiYXVkaW92aWRlbyIsIkRFRkFVTFRfVEFSR0VUX0RVUkFUSU9OIiwiTGV2ZWxEZXRhaWxzIiwiYmFzZVVybCIsIlBUU0tub3duIiwiYWxpZ25lZFNsaWRpbmciLCJhdmVyYWdldGFyZ2V0ZHVyYXRpb24iLCJlbmRDQyIsImVuZFNOIiwiZnJhZ21lbnRzIiwiZnJhZ21lbnRIaW50IiwicGFydExpc3QiLCJkYXRlUmFuZ2VzIiwibGl2ZSIsImFnZUhlYWRlciIsImFkdmFuY2VkRGF0ZVRpbWUiLCJ1cGRhdGVkIiwiYWR2YW5jZWQiLCJhdmFpbGFiaWxpdHlEZWxheSIsIm1pc3NlcyIsInN0YXJ0Q0MiLCJzdGFydFNOIiwic3RhcnRUaW1lT2Zmc2V0IiwidGFyZ2V0ZHVyYXRpb24iLCJ0b3RhbGR1cmF0aW9uIiwibTN1OCIsInZlcnNpb24iLCJjYW5CbG9ja1JlbG9hZCIsImNhblNraXBVbnRpbCIsImNhblNraXBEYXRlUmFuZ2VzIiwic2tpcHBlZFNlZ21lbnRzIiwicmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcyIsInBhcnRIb2xkQmFjayIsImhvbGRCYWNrIiwicGFydFRhcmdldCIsInByZWxvYWRIaW50IiwicmVuZGl0aW9uUmVwb3J0cyIsInR1bmVJbkdvYWwiLCJkZWx0YVVwZGF0ZUZhaWxlZCIsImRyaWZ0U3RhcnRUaW1lIiwiZHJpZnRFbmRUaW1lIiwiZHJpZnRTdGFydCIsImRyaWZ0RW5kIiwiZW5jcnlwdGVkRnJhZ21lbnRzIiwicGxheWxpc3RQYXJzaW5nRXJyb3IiLCJ2YXJpYWJsZUxpc3QiLCJoYXNWYXJpYWJsZVJlZnMiLCJyZWxvYWRlZCIsInBhcnRTbkRpZmYiLCJsYXN0UGFydFNuIiwicGFydEluZGV4RGlmZiIsImxhc3RQYXJ0SW5kZXgiLCJmbG9vciIsImhhc1Byb2dyYW1EYXRlVGltZSIsImxldmVsVGFyZ2V0RHVyYXRpb24iLCJkcmlmdCIsInJ1blRpbWUiLCJydW5EdXJhdGlvbiIsImVkZ2UiLCJwYXJ0RW5kIiwiZnJhZ21lbnRFbmQiLCJfdGhpcyRwYXJ0TGlzdCIsIl90aGlzJGZyYWdtZW50cyIsImFnZSIsIm5vdyIsIl90aGlzJHBhcnRMaXN0MiIsIl90aGlzJHBhcnRMaXN0MyIsImJhc2U2NERlY29kZSIsImJhc2U2NGVuY29kZWRTdHIiLCJmcm9tIiwiYXRvYiIsImMiLCJjaGFyQ29kZUF0IiwiZ2V0S2V5SWRCeXRlcyIsInN0ciIsImtleUlkYnl0ZXMiLCJzdHJUb1V0ZjhhcnJheSIsInN1YmFycmF5IiwicGFkZGVka2V5SWRieXRlcyIsInNldCIsImNoYW5nZUVuZGlhbm5lc3MiLCJrZXlJZCIsInN3YXAiLCJhcnJheSIsInRvIiwiY3VyIiwiY29udmVydERhdGFVcmlUb0FycmF5Qnl0ZXMiLCJ1cmkiLCJjb2xvbnNwbGl0Iiwia2V5ZGF0YSIsInNlbWljb2xvbnNwbGl0IiwiY29tbWFzcGxpdCIsImlzYmFzZTY0Iiwic3BsaWNlIiwidW5lc2NhcGUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJvcHRpb25hbFNlbGYiLCJLZXlTeXN0ZW1zIiwiQ0xFQVJLRVkiLCJGQUlSUExBWSIsIlBMQVlSRUFEWSIsIldJREVWSU5FIiwiS2V5U3lzdGVtRm9ybWF0cyIsImtleVN5c3RlbUZvcm1hdFRvS2V5U3lzdGVtRG9tYWluIiwiZm9ybWF0IiwiS2V5U3lzdGVtSWRzIiwia2V5U3lzdGVtSWRUb0tleVN5c3RlbURvbWFpbiIsInN5c3RlbUlkIiwia2V5U3lzdGVtRG9tYWluVG9LZXlTeXN0ZW1Gb3JtYXQiLCJrZXlTeXN0ZW0iLCJnZXRLZXlTeXN0ZW1zRm9yQ29uZmlnIiwiY29uZmlnIiwiZHJtU3lzdGVtcyIsIndpZGV2aW5lTGljZW5zZVVybCIsImtleVN5c3RlbXNUb0F0dGVtcHQiLCJyZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MiLCJfb3B0aW9uYWxTZWxmJG5hdmlnYXQiLCJuYXZpZ2F0b3IiLCJnZXRTdXBwb3J0ZWRNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25zIiwiYXVkaW9Db2RlY3MiLCJ2aWRlb0NvZGVjcyIsImRybVN5c3RlbU9wdGlvbnMiLCJpbml0RGF0YVR5cGVzIiwiY3JlYXRlTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9ucyIsImJhc2VDb25maWciLCJwZXJzaXN0ZW50U3RhdGUiLCJkaXN0aW5jdGl2ZUlkZW50aWZpZXIiLCJzZXNzaW9uVHlwZXMiLCJzZXNzaW9uVHlwZSIsImF1ZGlvQ2FwYWJpbGl0aWVzIiwibWFwIiwiY29kZWMiLCJjb250ZW50VHlwZSIsInJvYnVzdG5lc3MiLCJhdWRpb1JvYnVzdG5lc3MiLCJlbmNyeXB0aW9uU2NoZW1lIiwiYXVkaW9FbmNyeXB0aW9uU2NoZW1lIiwidmlkZW9DYXBhYmlsaXRpZXMiLCJ2aWRlb1JvYnVzdG5lc3MiLCJ2aWRlb0VuY3J5cHRpb25TY2hlbWUiLCJzbGljZVVpbnQ4IiwiQXJyYXkiLCJpc0hlYWRlciQyIiwib2Zmc2V0IiwiaXNGb290ZXIiLCJnZXRJRDNEYXRhIiwiZnJvbnQiLCJzaXplIiwicmVhZFNpemUiLCJjYW5QYXJzZSQyIiwiZ2V0VGltZVN0YW1wIiwiZnJhbWVzIiwiZ2V0SUQzRnJhbWVzIiwiZnJhbWUiLCJpc1RpbWVTdGFtcEZyYW1lIiwicmVhZFRpbWVTdGFtcCIsImdldEZyYW1lRGF0YSIsImZyb21DaGFyQ29kZSIsImlkM0RhdGEiLCJmcmFtZURhdGEiLCJkZWNvZGVGcmFtZSIsImRlY29kZVByaXZGcmFtZSIsImRlY29kZVVSTEZyYW1lIiwiZGVjb2RlVGV4dEZyYW1lIiwib3duZXIiLCJ1dGY4QXJyYXlUb1N0ciIsInByaXZhdGVEYXRhIiwiYnVmZmVyIiwiZGVzY3JpcHRpb24iLCJ0ZXh0IiwidGltZVN0YW1wRnJhbWUiLCJieXRlTGVuZ3RoIiwicHRzMzNCaXQiLCJ0aW1lc3RhbXAiLCJyb3VuZCIsImV4aXRPbk51bGwiLCJkZWNvZGVyIiwiZ2V0VGV4dERlY29kZXIiLCJkZWNvZGVkIiwiZGVjb2RlIiwiaWR4IiwiY2hhcjIiLCJjaGFyMyIsIm91dCIsInVzZXJBZ2VudCIsImluY2x1ZGVzIiwiVGV4dERlY29kZXIiLCJIZXgiLCJoZXhEdW1wIiwiaCIsInRvU3RyaW5nIiwiVUlOVDMyX01BWCQxIiwicG93IiwiUmVtdXhlclRyYWNrSWRDb25maWciLCJpZDMiLCJiaW4yc3RyIiwicmVhZFVpbnQxNiIsInZhbCIsInJlYWRVaW50MzIiLCJyZWFkU2ludDMyIiwicmVhZFVpbnQ2NCIsInJlc3VsdCIsIndyaXRlVWludDMyIiwiaGFzTW9vZkRhdGEiLCJmaW5kQm94IiwicmVzdWx0cyIsImVuZGJveCIsInN1YnJlc3VsdHMiLCJwYXJzZVNlZ21lbnRJbmRleCIsInNpZHgiLCJyZWZlcmVuY2VzIiwidGltZXNjYWxlIiwiZWFybGllc3RQcmVzZW50YXRpb25UaW1lIiwiZmlyc3RPZmZzZXQiLCJzdGFydEJ5dGUiLCJyZWZlcmVuY2VzQ291bnQiLCJyZWZlcmVuY2VJbmRleCIsInJlZmVyZW5jZUluZm8iLCJyZWZlcmVuY2VTaXplIiwicmVmZXJlbmNlVHlwZSIsInN1YnNlZ21lbnREdXJhdGlvbiIsInBhcnNlSW5pdFNlZ21lbnQiLCJ0cmFrcyIsInRyYWsiLCJ0a2hkIiwidHJhY2tJZCIsIm1kaGQiLCJoZGxyIiwiaGRsclR5cGUiLCJzb3VuIiwidmlkZSIsInN0c2QiLCJzdHNkRGF0YSIsInBhcnNlU3RzZCIsInRyZXgiLCJ0cmFjayIsImRlZmF1bHQiLCJmbGFncyIsInNhbXBsZUVudHJpZXMiLCJzYW1wbGVFbnRyaWVzRW5kIiwiZm91ckNDIiwiZW5jQm94IiwiZW5jQm94Q2hpbGRyZW4iLCJzaW5mcyIsInNpbmYiLCJzY2htIiwiZnJtYSIsImF2Y0NCb3giLCJ0b0hleCIsImNvZGVjQm94IiwiZXNkc0JveCIsInNraXBCRVJJbnRlZ2VyIiwib2JqZWN0VHlwZSIsImZpcnN0Qnl0ZSIsImF1ZGlvT2JqZWN0VHlwZSIsImh2Y0NCb3giLCJwcm9maWxlQnl0ZSIsInByb2ZpbGVTcGFjZSIsImdlbmVyYWxQcm9maWxlSWRjIiwicHJvZmlsZUNvbXBhdCIsInRpZXJGbGFnIiwibGV2ZWxJREMiLCJjb25zdHJhaW50SW5kaWNhdG9yIiwidG9VcHBlckNhc2UiLCJjb25zdHJhaW50U3RyaW5nIiwiYnl0ZSIsImVuY29kZWRCeXRlIiwiZHZjQ0JveCIsInByb2ZpbGUiLCJhZGRMZWFkaW5nWmVybyIsInZwY0NCb3giLCJiaXREZXB0aCIsImF2MUNCb3giLCJoaWdoQml0RGVwdGgiLCJ0d2VsdmVCaXQiLCJtb25vY2hyb21lIiwiY2hyb21hU3Vic2FtcGxpbmdYIiwiY2hyb21hU3Vic2FtcGxpbmdZIiwiY2hyb21hU2FtcGxlUG9zaXRpb24iLCJjb2xvclByaW1hcmllcyIsInRyYW5zZmVyQ2hhcmFjdGVyaXN0aWNzIiwibWF0cml4Q29lZmZpY2llbnRzIiwidmlkZW9GdWxsUmFuZ2VGbGFnIiwiYnl0ZXMiLCJsaW1pdCIsIm51bSIsInBhdGNoRW5jeXB0aW9uRGF0YSIsImlzQ29tbW9uRW5jcnlwdGlvbiIsImVuY0JveGVzIiwiaXNBdWRpbyIsImVuYyIsInNpbmZCb3hlcyIsInRlbmMiLCJwYXJzZVNpbmYiLCJ0ZW5jS2V5SWQiLCJzb21lIiwiYiIsImdldFN0YXJ0RFRTIiwiaW5pdERhdGEiLCJmbXA0IiwicmVkdWNlIiwidHJhZiIsInRmZHQiLCJ0ZmhkIiwiYmFzZVRpbWUiLCJzY2FsZSIsInN0YXJ0VGltZSIsImdldER1cmF0aW9uIiwicmF3RHVyYXRpb24iLCJ2aWRlb0R1cmF0aW9uIiwiYXVkaW9EdXJhdGlvbiIsInRyYWZzIiwidHJhY2tEZWZhdWx0IiwidGZoZEZsYWdzIiwic2FtcGxlRHVyYXRpb24iLCJ0cnVucyIsImoiLCJjb21wdXRlUmF3RHVyYXRpb25Gcm9tU2FtcGxlcyIsInNhbXBsZUNvdW50Iiwic2lkeE1pblN0YXJ0Iiwic2lkeE1heEVuZCIsInNpZHhEdXJhdGlvbiIsInNpZHhzIiwic3ViU2VnbWVudER1cmF0aW9uIiwiZHVyIiwicmVmIiwidHJ1biIsIm9mZnNldFN0YXJ0RFRTIiwidGltZU9mZnNldCIsImJhc2VNZWRpYURlY29kZVRpbWUiLCJ1cHBlciIsImxvd2VyIiwic2VnbWVudFZhbGlkUmFuZ2UiLCJzZWdtZW50ZWRSYW5nZSIsInZhbGlkIiwicmVtYWluZGVyIiwibW9vZnMiLCJsYXN0IiwiYnl0ZU9mZnNldCIsImFwcGVuZFVpbnQ4QXJyYXkiLCJkYXRhMSIsImRhdGEyIiwidGVtcCIsInBhcnNlU2FtcGxlcyIsInNlaVNhbXBsZXMiLCJ2aWRlb0RhdGEiLCJzYW1wbGVzIiwiaXNIRVZDRmxhdm9yIiwibW9vZiIsIm1vb2ZPZmZzZXQiLCJiYXNlRGF0YU9mZnNldFByZXNlbnQiLCJzYW1wbGVEZXNjcmlwdGlvbkluZGV4UHJlc2VudCIsImRlZmF1bHRTYW1wbGVEdXJhdGlvblByZXNlbnQiLCJkZWZhdWx0U2FtcGxlRHVyYXRpb24iLCJkZWZhdWx0U2FtcGxlU2l6ZVByZXNlbnQiLCJkZWZhdWx0U2FtcGxlU2l6ZSIsImRlZmF1bHRTYW1wbGVGbGFnc1ByZXNlbnQiLCJ0ZmhkT2Zmc2V0IiwiaXNIRVZDIiwiZGF0YU9mZnNldFByZXNlbnQiLCJkYXRhT2Zmc2V0IiwiZmlyc3RTYW1wbGVGbGFnc1ByZXNlbnQiLCJzYW1wbGVEdXJhdGlvblByZXNlbnQiLCJzYW1wbGVTaXplUHJlc2VudCIsInNhbXBsZVNpemUiLCJzYW1wbGVGbGFnc1ByZXNlbnQiLCJzYW1wbGVDb21wb3NpdGlvbk9mZnNldHNQcmVzZW50IiwiY29tcG9zaXRpb25PZmZzZXQiLCJ0cnVuT2Zmc2V0Iiwic2FtcGxlT2Zmc2V0IiwiaXgiLCJuYWx1VG90YWxTaXplIiwibmFsdVNpemUiLCJpc1NFSU1lc3NhZ2UiLCJwYXJzZVNFSU1lc3NhZ2VGcm9tTkFMdSIsImRlbGltaXQiLCJiYXNlQ29kZWMiLCJuYWx1SGVhZGVyIiwibmFsdVR5cGUiLCJ1bmVzY2FwZWREYXRhIiwiaGVhZGVyU2l6ZSIsInB0cyIsImRpc2NhcmRFUEIiLCJzZWlQdHIiLCJwYXlsb2FkVHlwZSIsInBheWxvYWRTaXplIiwibGVmdE92ZXIiLCJwYXlQdHIiLCJjb3VudHJ5Q29kZSIsInByb3ZpZGVyQ29kZSIsInVzZXJTdHJ1Y3R1cmUiLCJ1c2VyRGF0YVR5cGUiLCJ0b3RhbENDcyIsImVuYWJsZWQiLCJ0b3RhbEJ5dGVzIiwiYnl0ZUFycmF5IiwidXVpZFN0ckFycmF5IiwiX2IiLCJ1c2VyRGF0YUJ5dGVzIiwidXVpZCIsInVzZXJEYXRhIiwiRVBCUG9zaXRpb25zIiwibmV3TGVuZ3RoIiwibmV3RGF0YSIsInNvdXJjZUluZGV4Iiwic2hpZnQiLCJwYXJzZUVtc2ciLCJzY2hlbWVJZFVyaSIsInRpbWVTY2FsZSIsInByZXNlbnRhdGlvblRpbWVEZWx0YSIsInByZXNlbnRhdGlvblRpbWUiLCJldmVudER1cmF0aW9uIiwibGVmdFByZXNlbnRhdGlvblRpbWUiLCJyaWdodFByZXNlbnRhdGlvblRpbWUiLCJwYXlsb2FkIiwibXA0Qm94IiwibXA0cHNzaCIsImtleWlkcyIsIlJhbmdlRXJyb3IiLCJraWRzIiwiayIsImtpZENvdW50IiwiRGF0YVZpZXciLCJzZXRVaW50MzIiLCJkYXRhU2l6ZSIsInBhcnNlUHNzaCIsIkFycmF5QnVmZmVyIiwidmlldyIsImJveFNpemUiLCJnZXRVaW50MzIiLCJkYXRhU2l6ZU9yS2lkQ291bnQiLCJrZXlVcmlUb0tleUlkTWFwIiwiTGV2ZWxLZXkiLCJjbGVhcktleVVyaVRvS2V5SWRNYXAiLCJtZXRob2QiLCJmb3JtYXR2ZXJzaW9ucyIsIml2Iiwia2V5Rm9ybWF0VmVyc2lvbnMiLCJwc3NoIiwiaXNTdXBwb3J0ZWQiLCJjcmVhdGVJbml0aWFsaXphdGlvblZlY3RvciIsImtleUJ5dGVzIiwiUGxheVJlYWR5S2V5U3lzdGVtVVVJRCIsImtleUJ5dGVzVXRmMTYiLCJVaW50MTZBcnJheSIsImtleUJ5dGVTdHIiLCJ4bWxLZXlCeXRlcyIsInBhcnNlciIsIkRPTVBhcnNlciIsInhtbERvYyIsInBhcnNlRnJvbVN0cmluZyIsImtleURhdGEiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImNoaWxkTm9kZXMiLCJub2RlVmFsdWUiLCJnZXRBdHRyaWJ1dGUiLCJrZXlJZEFycmF5IiwicGFkZGVkIiwiZHYiLCJzZWdtZW50TnVtYmVyIiwidWludDhWaWV3IiwiVkFSSUFCTEVfUkVQTEFDRU1FTlRfUkVHRVgiLCJoYXNWYXJpYWJsZVJlZmVyZW5jZXMiLCJ0ZXN0Iiwic3Vic3RpdHV0ZVZhcmlhYmxlc0luQXR0cmlidXRlcyIsInBhcnNlZCIsImF0dHJpYnV0ZU5hbWVzIiwic3Vic3RpdHV0ZVZhcmlhYmxlcyIsInZhcmlhYmxlUmVmZXJlbmNlIiwidmFyaWFibGVOYW1lIiwidmFyaWFibGVWYWx1ZSIsImFkZFZhcmlhYmxlRGVmaW5pdGlvbiIsInBhcmVudFVybCIsIk5BTUUiLCJWQUxVRSIsIlFVRVJZUEFSQU0iLCJzZWFyY2hQYXJhbXMiLCJVUkwiLCJoYXMiLCJnZXQiLCJtZXNzYWdlIiwiaW1wb3J0VmFyaWFibGVEZWZpbml0aW9uIiwic291cmNlVmFyaWFibGVMaXN0IiwiSU1QT1JUIiwiZ2V0TWVkaWFTb3VyY2UiLCJwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UiLCJtbXMiLCJNZWRpYVNvdXJjZSIsIk1hbmFnZWRNZWRpYVNvdXJjZSIsIldlYktpdE1lZGlhU291cmNlIiwic2FtcGxlRW50cnlDb2Rlc0lTTyIsImEzZHMiLCJhbGFjIiwiYWxhdyIsImRyYTEiLCJkdHNjIiwiZHRzZSIsImR0c2giLCJlbmNhIiwiZkxhQyIsImZsYWMiLCJGTEFDIiwiZzcxOSIsImc3MjYiLCJtNGFlIiwibWhhMSIsIm1oYTIiLCJtaG0xIiwibWhtMiIsIm1scGEiLCJtcDRhIiwiT3B1cyIsIm9wdXMiLCJzYW1yIiwic2F3YiIsInNhd3AiLCJzZXZjIiwic3FjcCIsInNzbXYiLCJ0d29zIiwidWxhdyIsImF2YzEiLCJhdmMyIiwiYXZjMyIsImF2YzQiLCJhdmNwIiwiYXYwMSIsImRyYWMiLCJkdmExIiwiZHZhdiIsImR2aDEiLCJkdmhlIiwiZW5jdiIsImhldjEiLCJodmMxIiwibWpwMiIsIm1wNHYiLCJtdmMxIiwibXZjMiIsIm12YzMiLCJtdmM0IiwicmVzdiIsInJ2NjAiLCJzMjYzIiwic3ZjMSIsInN2YzIiLCJ2cDA4IiwidnAwOSIsInN0cHAiLCJ3dnR0IiwiaXNDb2RlY1R5cGUiLCJ0eXBlQ29kZXMiLCJhcmVDb2RlY3NNZWRpYVNvdXJjZVN1cHBvcnRlZCIsImNvZGVjcyIsImlzQ29kZWNNZWRpYVNvdXJjZVN1cHBvcnRlZCIsIl9NZWRpYVNvdXJjZSRpc1R5cGVTdSIsImlzVHlwZVN1cHBvcnRlZCIsIm1pbWVUeXBlRm9yQ29kZWMiLCJ2aWRlb0NvZGVjUHJlZmVyZW5jZVZhbHVlIiwidmlkZW9Db2RlYyIsImNvZGVjc1NldFNlbGVjdGlvblByZWZlcmVuY2VWYWx1ZSIsImNvZGVjU2V0IiwicHJlZmVyZW5jZVZhbHVlIiwiQ09ERUNfQ09NUEFUSUJMRV9OQU1FUyIsImdldENvZGVjQ29tcGF0aWJsZU5hbWVMb3dlciIsImxvd2VyQ2FzZUNvZGVjIiwiY29kZWNzVG9DaGVjayIsIkFVRElPX0NPREVDX1JFR0VYUCIsImdldENvZGVjQ29tcGF0aWJsZU5hbWUiLCJtIiwidG9Mb3dlckNhc2UiLCJwaWNrTW9zdENvbXBsZXRlQ29kZWNOYW1lIiwicGFyc2VkQ29kZWMiLCJsZXZlbENvZGVjIiwiY29udmVydEFWQzFUb0FWQ09USSIsImF2Y2RhdGEiLCJNQVNURVJfUExBWUxJU1RfUkVHRVgiLCJNQVNURVJfUExBWUxJU1RfTUVESUFfUkVHRVgiLCJJU19NRURJQV9QTEFZTElTVCIsIkxFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QiLCJSZWdFeHAiLCJMRVZFTF9QTEFZTElTVF9SRUdFWF9TTE9XIiwiTTNVOFBhcnNlciIsImZpbmRHcm91cCIsImdyb3VwcyIsIm1lZGlhR3JvdXBJZCIsImdyb3VwIiwicmVzb2x2ZSIsImlzTWVkaWFQbGF5bGlzdCIsInBhcnNlTWFzdGVyUGxheWxpc3QiLCJzdHJpbmciLCJjb250ZW50U3RlZXJpbmciLCJsZXZlbHMiLCJzZXNzaW9uRGF0YSIsInNlc3Npb25LZXlzIiwibGV2ZWxzV2l0aEtub3duQ29kZWNzIiwiX2xldmVsJHVua25vd25Db2RlY3MiLCJiaXRyYXRlIiwicmVzb2x1dGlvbiIsInNldENvZGVjcyIsIkNPREVDUyIsInVua25vd25Db2RlY3MiLCJ0YWciLCJhdHRyaWJ1dGVzIiwic2Vzc2lvbkF0dHJzIiwiZGF0YUlkIiwic2Vzc2lvbktleSIsInBhcnNlS2V5IiwidmFyaWFibGVBdHRyaWJ1dGVzIiwiY29udGVudFN0ZWVyaW5nQXR0cmlidXRlcyIsInBhdGh3YXlJZCIsInBhcnNlU3RhcnRUaW1lT2Zmc2V0Iiwic3RyaXBVbmtub3duQ29kZWNMZXZlbHMiLCJwYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEiLCJncm91cHNCeVR5cGUiLCJhdWRpb0NvZGVjIiwiU1VCVElUTEVTIiwidGV4dENvZGVjIiwiVFlQRSIsIm1lZGlhcyIsImxhbmciLCJMQU5HVUFHRSIsImFzc29jTGFuZyIsImNoYW5uZWxzIiwiQ0hBTk5FTFMiLCJjaGFyYWN0ZXJpc3RpY3MiLCJDSEFSQUNURVJJU1RJQ1MiLCJpbnN0cmVhbUlkIiwibWVkaWEiLCJncm91cElkIiwiYXV0b3NlbGVjdCIsImZvcmNlZCIsIlVSSSIsImdyb3VwQ29kZWMiLCJhc3NpZ25Db2RlYyIsInBhcnNlTGV2ZWxQbGF5bGlzdCIsImxldmVsVXJsSWQiLCJtdWx0aXZhcmlhbnRWYXJpYWJsZUxpc3QiLCJjdXJyZW50SW5pdFNlZ21lbnQiLCJjdXJyZW50U04iLCJjdXJyZW50UGFydCIsImRpc2NvbnRpbnVpdHlDb3VudGVyIiwicHJldkZyYWciLCJmaXJzdFBkdEluZGV4IiwiY3JlYXRlTmV4dEZyYWciLCJuZXh0Qnl0ZVJhbmdlIiwic2V0RnJhZ0xldmVsS2V5cyIsImFzc2lnblByb2dyYW1EYXRlVGltZSIsInZhbHVlMSIsInZhbHVlMiIsInNraXBBdHRycyIsIl9pIiwidW5zaGlmdCIsImRhdGVSYW5nZSIsImxldmVsS2V5IiwibWFwQXR0cnMiLCJpbml0Iiwic2V0SW5pdFNlZ21lbnQiLCJzZXJ2ZXJDb250cm9sQXR0cnMiLCJwYXJ0SW5mQXR0cnMiLCJwcmV2aW91c0ZyYWdtZW50UGFydCIsInBhcnQiLCJwcmVsb2FkSGludEF0dHJzIiwicmVuZGl0aW9uUmVwb3J0QXR0cnMiLCJwb3AiLCJmcmFnbWVudExlbmd0aCIsImZpcnN0RnJhZ21lbnQiLCJsYXN0RnJhZ21lbnQiLCJsYXN0U24iLCJiYWNrZmlsbFByb2dyYW1EYXRlVGltZXMiLCJrZXlUYWdBdHRyaWJ1dGVzIiwiX2tleUF0dHJzJE1FVEhPRCIsIl9rZXlBdHRycyRLRVlGT1JNQVQiLCJrZXlBdHRycyIsImRlY3J5cHRtZXRob2QiLCJNRVRIT0QiLCJkZWNyeXB0dXJpIiwiZGVjcnlwdGl2IiwiZGVjcnlwdGtleWZvcm1hdHZlcnNpb25zIiwiS0VZRk9STUFUVkVSU0lPTlMiLCJkZWNyeXB0a2V5Zm9ybWF0IiwiS0VZRk9STUFUIiwiSVYiLCJyZXNvbHZlZFVyaSIsInN0YXJ0QXR0cmlidXRlcyIsInN0YXJ0QXR0cnMiLCJjb2RlY3NBdHRyaWJ1dGVWYWx1ZSIsImZpbHRlcmVkIiwiZ3JvdXBJdGVtIiwiY29kZWNQcm9wZXJ0eSIsImNvZGVjVmFsdWUiLCJmcmFnUHJldiIsInBhcnNlIiwiQllURVJBTkdFIiwiUGxheWxpc3RDb250ZXh0VHlwZSIsIk1BTklGRVNUIiwiTEVWRUwiLCJBVURJT19UUkFDSyIsIlNVQlRJVExFX1RSQUNLIiwiUGxheWxpc3RMZXZlbFR5cGUiLCJNQUlOIiwiU1VCVElUTEUiLCJtYXBDb250ZXh0VG9MZXZlbFR5cGUiLCJjb250ZXh0IiwiZ2V0UmVzcG9uc2VVcmwiLCJyZXNwb25zZSIsIlBsYXlsaXN0TG9hZGVyIiwiaGxzIiwibG9hZGVycyIsImNyZWF0ZSIsInJlZ2lzdGVyTGlzdGVuZXJzIiwic3RhcnRMb2FkIiwic3RhcnRQb3NpdGlvbiIsInN0b3BMb2FkIiwiZGVzdHJveUludGVybmFsTG9hZGVycyIsIm9uIiwiTUFOSUZFU1RfTE9BRElORyIsIm9uTWFuaWZlc3RMb2FkaW5nIiwiTEVWRUxfTE9BRElORyIsIm9uTGV2ZWxMb2FkaW5nIiwiQVVESU9fVFJBQ0tfTE9BRElORyIsIm9uQXVkaW9UcmFja0xvYWRpbmciLCJTVUJUSVRMRV9UUkFDS19MT0FESU5HIiwib25TdWJ0aXRsZVRyYWNrTG9hZGluZyIsInVucmVnaXN0ZXJMaXN0ZW5lcnMiLCJvZmYiLCJjcmVhdGVJbnRlcm5hbExvYWRlciIsIlBMb2FkZXIiLCJwTG9hZGVyIiwiTG9hZGVyIiwiSW50ZXJuYWxMb2FkZXIiLCJnZXRJbnRlcm5hbExvYWRlciIsInJlc2V0SW50ZXJuYWxMb2FkZXIiLCJjb250ZXh0VHlwZSIsImRlc3Ryb3kiLCJldmVudCIsImxvYWQiLCJyZXNwb25zZVR5cGUiLCJkZWxpdmVyeURpcmVjdGl2ZXMiLCJfY29udGV4dCRkZWxpdmVyeURpcmUiLCJsb2FkZXJDb250ZXh0IiwibG9hZFBvbGljeSIsIm1hbmlmZXN0TG9hZFBvbGljeSIsInBsYXlsaXN0TG9hZFBvbGljeSIsInRpbWVvdXRSZXRyeSIsImVycm9yUmV0cnkiLCJsZXZlbERldGFpbHMiLCJkZXRhaWxzIiwiYXVkaW9UcmFja3MiLCJzdWJ0aXRsZVRyYWNrcyIsInRhcmdldER1cmF0aW9uIiwibWF4TG93TGF0ZW5jeVBsYXlsaXN0UmVmcmVzaCIsIm1heFRpbWVUb0ZpcnN0Qnl0ZU1zIiwibWF4TG9hZFRpbWVNcyIsImxlZ2FjeVJldHJ5Q29tcGF0aWJpbGl0eSIsImxvYWRlckNvbmZpZyIsInRpbWVvdXQiLCJtYXhSZXRyeSIsIm1heE51bVJldHJ5IiwicmV0cnlEZWxheSIsInJldHJ5RGVsYXlNcyIsIm1heFJldHJ5RGVsYXkiLCJtYXhSZXRyeURlbGF5TXMiLCJsb2FkZXJDYWxsYmFja3MiLCJvblN1Y2Nlc3MiLCJuZXR3b3JrRGV0YWlscyIsImhhbmRsZU1hbmlmZXN0UGFyc2luZ0Vycm9yIiwicGVyZm9ybWFuY2UiLCJoYW5kbGVUcmFja09yTGV2ZWxQbGF5bGlzdCIsImhhbmRsZU1hc3RlclBsYXlsaXN0Iiwib25FcnJvciIsImhhbmRsZU5ldHdvcmtFcnJvciIsIm9uVGltZW91dCIsInBhcnNlZFJlc3VsdCIsInN1YnRpdGxlcyIsImNhcHRpb25zIiwiZW1iZWRkZWRBdWRpb0ZvdW5kIiwiYXVkaW9UcmFjayIsInRyaWdnZXIiLCJNQU5JRkVTVF9MT0FERUQiLCJsZXZlbElkIiwibGV2ZWxUeXBlIiwic2luZ2xlTGV2ZWwiLCJoYW5kbGVQbGF5bGlzdExvYWRlZCIsIkVSUk9SIiwiTkVUV09SS19FUlJPUiIsIk1BTklGRVNUX1BBUlNJTkdfRVJST1IiLCJmYXRhbCIsImVyciIsInJlYXNvbiIsImNvZGUiLCJVTktOT1dOIiwiTUFOSUZFU1RfTE9BRF9USU1FT1VUIiwiTUFOSUZFU1RfTE9BRF9FUlJPUiIsIkxFVkVMX0xPQURfVElNRU9VVCIsIkxFVkVMX0xPQURfRVJST1IiLCJBVURJT19UUkFDS19MT0FEX1RJTUVPVVQiLCJBVURJT19UUkFDS19MT0FEX0VSUk9SIiwiU1VCVElUTEVfVFJBQ0tfTE9BRF9USU1FT1VUIiwiU1VCVElUTEVfTE9BRF9FUlJPUiIsImVycm9yRGF0YSIsInBhcmVudCIsImxldmVsSW5kZXgiLCJfZXJyb3IiLCJMRVZFTF9FTVBUWV9FUlJPUiIsIkxFVkVMX1BBUlNJTkdfRVJST1IiLCJnZXRDYWNoZUFnZSIsImlzTmFOIiwiTEVWRUxfTE9BREVEIiwiQVVESU9fVFJBQ0tfTE9BREVEIiwiU1VCVElUTEVfVFJBQ0tfTE9BREVEIiwic2VuZEFkZFRyYWNrRXZlbnQiLCJ2aWRlb0VsIiwiRXZlbnQiLCJkb2N1bWVudCIsImNyZWF0ZUV2ZW50IiwiaW5pdEV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsImFkZEN1ZVRvVHJhY2siLCJjdWUiLCJtb2RlIiwiY3VlcyIsImdldEN1ZUJ5SWQiLCJhZGRDdWUiLCJ0ZXh0VHJhY2tDdWUiLCJUZXh0VHJhY2tDdWUiLCJlbmRUaW1lIiwiZXJyMiIsImNsZWFyQ3VycmVudEN1ZXMiLCJyZW1vdmVDdWUiLCJyZW1vdmVDdWVzSW5SYW5nZSIsInByZWRpY2F0ZSIsImdldEN1ZXNJblJhbmdlIiwiZ2V0Rmlyc3RDdWVJbmRleEFmdGVyVGltZSIsInRpbWUiLCJsZWZ0IiwicmlnaHQiLCJtaWQiLCJjdWVzRm91bmQiLCJmaXJzdEN1ZUluUmFuZ2UiLCJmaWx0ZXJTdWJ0aXRsZVRyYWNrcyIsInRleHRUcmFja0xpc3QiLCJ0cmFja3MiLCJraW5kIiwibGFiZWwiLCJNZXRhZGF0YVNjaGVtYSIsImF1ZGlvSWQzIiwiZW1zZyIsIk1JTl9DVUVfRFVSQVRJT04iLCJnZXRDdWVDbGFzcyIsIlZUVEN1ZSIsImNyZWF0ZUN1ZVdpdGhEYXRhRmllbGRzIiwiQ3VlIiwiSlNPTiIsInN0cmluZ2lmeSIsIk1BWF9DVUVfRU5EVElNRSIsIlBPU0lUSVZFX0lORklOSVRZIiwiTUFYX1ZBTFVFIiwiZGF0ZVJhbmdlRGF0ZVRvVGltZWxpbmVTZWNvbmRzIiwiZGF0ZSIsImhleFRvQXJyYXlCdWZmZXIiLCJJRDNUcmFja0NvbnRyb2xsZXIiLCJpZDNUcmFjayIsImRhdGVSYW5nZUN1ZXNBcHBlbmRlZCIsIl9yZWdpc3Rlckxpc3RlbmVycyIsIl91bnJlZ2lzdGVyTGlzdGVuZXJzIiwiTUVESUFfQVRUQUNIRUQiLCJvbk1lZGlhQXR0YWNoZWQiLCJNRURJQV9ERVRBQ0hJTkciLCJvbk1lZGlhRGV0YWNoaW5nIiwiRlJBR19QQVJTSU5HX01FVEFEQVRBIiwib25GcmFnUGFyc2luZ01ldGFkYXRhIiwiQlVGRkVSX0ZMVVNISU5HIiwib25CdWZmZXJGbHVzaGluZyIsIkxFVkVMX1VQREFURUQiLCJvbkxldmVsVXBkYXRlZCIsImNyZWF0ZVRyYWNrIiwiZ2V0SUQzVHJhY2siLCJ0ZXh0VHJhY2tzIiwidGV4dFRyYWNrIiwiYWRkVGV4dFRyYWNrIiwiZW5hYmxlRW1zZ01ldGFkYXRhQ3VlcyIsImVuYWJsZUlEM01ldGFkYXRhQ3VlcyIsInRpbWVEaWZmIiwidXBkYXRlSWQzQ3VlRW5kcyIsIl90aGlzJGlkM1RyYWNrIiwic3RhcnRPZmZzZXQiLCJlbmRPZmZzZXQiLCJlbmFibGVEYXRlUmFuZ2VNZXRhZGF0YUN1ZXMiLCJpZHMiLCJpZHNUb1JlbW92ZSIsImRhdGVUaW1lT2Zmc2V0IiwiYXBwZW5kZWREYXRlUmFuZ2VDdWVzIiwiZHVyYXRpb25Lbm93biIsIm5leHREYXRlUmFuZ2VXaXRoU2FtZUNsYXNzIiwiY2FuZGlkYXRlRGF0ZVJhbmdlIiwib3RoZXJEYXRlUmFuZ2UiLCJfY3VlIiwiTGF0ZW5jeUNvbnRyb2xsZXIiLCJjdXJyZW50VGltZSIsInN0YWxsQ291bnQiLCJfbGF0ZW5jeSIsInRpbWV1cGRhdGVIYW5kbGVyIiwidGltZXVwZGF0ZSIsImxhdGVuY3kiLCJtYXhMYXRlbmN5IiwibGl2ZU1heExhdGVuY3lEdXJhdGlvbiIsImxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCIsInRhcmdldExhdGVuY3kiLCJsaXZlU3luY0R1cmF0aW9uIiwibGl2ZVN5bmNEdXJhdGlvbkNvdW50IiwibG93TGF0ZW5jeU1vZGUiLCJ1c2VyQ29uZmlnIiwibWF4TGl2ZVN5bmNPblN0YWxsSW5jcmVhc2UiLCJsaXZlU3luY09uU3RhbGxJbmNyZWFzZSIsImxpdmVTeW5jUG9zaXRpb24iLCJsaXZlRWRnZSIsImVzdGltYXRlTGl2ZUVkZ2UiLCJzeW5jUG9zaXRpb24iLCJlZGdlU3RhbGxlZCIsIm1heExldmVsVXBkYXRlQWdlIiwiZm9yd2FyZEJ1ZmZlckxlbmd0aCIsImJ1ZmZlcmVkUmFuZ2VzIiwiYnVmZmVyZWQiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIl90aGlzJGxldmVsRGV0YWlscyIsIkJVRkZFUl9TVEFMTEVEX0VSUk9SIiwiY29tcHV0ZUxhdGVuY3kiLCJtYXhMaXZlU3luY1BsYXliYWNrUmF0ZSIsImRpc3RhbmNlRnJvbVRhcmdldCIsImxpdmVNaW5MYXRlbmN5RHVyYXRpb24iLCJpbkxpdmVSYW5nZSIsInJhdGUiLCJleHAiLCJwbGF5YmFja1JhdGUiLCJIZGNwTGV2ZWxzIiwiaXNIZGNwTGV2ZWwiLCJWaWRlb1JhbmdlVmFsdWVzIiwiaXNWaWRlb1JhbmdlIiwiSGxzU2tpcCIsIk5vIiwiWWVzIiwidjIiLCJnZXRTa2lwVmFsdWUiLCJtc24iLCJzbkNoYW5nZUdvYWwiLCJIbHNVcmxQYXJhbWV0ZXJzIiwic2tpcCIsImFkZERpcmVjdGl2ZXMiLCJocmVmIiwiTGV2ZWwiLCJfYXR0cnMiLCJmcmFtZVJhdGUiLCJmcmFnbWVudEVycm9yIiwibG9hZEVycm9yIiwicmVhbEJpdHJhdGUiLCJzdXBwb3J0ZWRQcm9taXNlIiwic3VwcG9ydGVkUmVzdWx0IiwiX2F2Z0JpdHJhdGUiLCJfYXVkaW9Hcm91cHMiLCJfc3VidGl0bGVHcm91cHMiLCJfdXJsSWQiLCJzIiwiYWRkR3JvdXBJZCIsIm1heEJpdHJhdGUiLCJhdmVyYWdlQml0cmF0ZSIsInZpZGVvUmFuZ2UiLCJzY29yZSIsImhhc0F1ZGlvR3JvdXAiLCJoYXNHcm91cCIsImhhc1N1YnRpdGxlR3JvdXAiLCJhdWRpb0dyb3VwcyIsInN1YnRpdGxlR3JvdXBzIiwiYXVkaW9Hcm91cElkcyIsImF1ZGlvR3JvdXBJZCIsInRleHRHcm91cElkcyIsInRleHRHcm91cElkIiwiX3RoaXMkYXVkaW9Hcm91cHMiLCJfdGhpcyRzdWJ0aXRsZUdyb3VwcyIsImFkZEZhbGxiYWNrIiwidXBkYXRlRnJvbVRvUFRTIiwiZnJhZ0Zyb20iLCJmcmFnVG8iLCJmcmFnVG9QVFMiLCJjb250aWd1b3VzIiwidXBkYXRlRnJhZ1BUU0RUUyIsInBhcnNlZE1lZGlhRHVyYXRpb24iLCJmcmFnU3RhcnRQdHMiLCJmcmFnRW5kUHRzIiwiZnJhZ0lkeCIsIm1lcmdlRGV0YWlscyIsIm9sZERldGFpbHMiLCJuZXdEZXRhaWxzIiwib2xkRnJhZ21lbnRzIiwib2xkSW5pdCIsImNjT2Zmc2V0IiwiUFRTRnJhZyIsIm1hcEZyYWdtZW50SW50ZXJzZWN0aW9uIiwib2xkRnJhZyIsIm5ld0ZyYWciLCJmcmFnbWVudHNUb0NoZWNrIiwiY29uY2F0IiwiX2N1cnJlbnRJbml0U2VnbWVudCIsIm1lcmdlRGF0ZVJhbmdlcyIsIm5ld0ZyYWdtZW50cyIsIm1hcFBhcnRJbnRlcnNlY3Rpb24iLCJvbGRQYXJ0IiwibmV3UGFydCIsImFkanVzdFNsaWRpbmciLCJvbGREYXRlUmFuZ2VzIiwiZGVsdGFEYXRlUmFuZ2VzIiwib2xkUGFydHMiLCJuZXdQYXJ0cyIsImludGVyc2VjdGlvbkZuIiwiZGVsdGEiLCJuZXdGcmFncyIsIm9sZEZyYWdzIiwiYWRkU2xpZGluZyIsImNvbXB1dGVSZWxvYWRJbnRlcnZhbCIsImRpc3RhbmNlVG9MaXZlRWRnZU1zIiwicmVsb2FkSW50ZXJ2YWwiLCJsaXZlRWRnZU1heFRhcmdldER1cmF0aW9ucyIsImxhc3RTZWdtZW50RHVyYXRpb24iLCJnZXRGcmFnbWVudFdpdGhTTiIsImZyYWdDdXJyZW50IiwiZ2V0UGFydFdpdGgiLCJwYXJ0SW5kZXgiLCJfbGV2ZWwkZGV0YWlscyIsImZpbmRQYXJ0IiwicmVhc3NpZ25GcmFnbWVudExldmVsSW5kZXhlcyIsImlzVGltZW91dEVycm9yIiwiRlJBR19MT0FEX1RJTUVPVVQiLCJLRVlfTE9BRF9USU1FT1VUIiwiZ2V0UmV0cnlDb25maWciLCJpc1RpbWVvdXQiLCJnZXRSZXRyeURlbGF5IiwicmV0cnlDb25maWciLCJyZXRyeUNvdW50IiwiYmFja29mZkZhY3RvciIsImJhY2tvZmYiLCJnZXRMb2FkZXJDb25maWdXaXRob3V0UmV0aWVzIiwibG9kZXJDb25maWciLCJzaG91bGRSZXRyeSIsImxvYWRlclJlc3BvbnNlIiwiaHR0cFN0YXR1cyIsInJldHJ5Rm9ySHR0cFN0YXR1cyIsIm9uTGluZSIsIkJpbmFyeVNlYXJjaCIsInNlYXJjaCIsImxpc3QiLCJjb21wYXJpc29uRm4iLCJtaW5JbmRleCIsIm1heEluZGV4IiwiY3VycmVudEluZGV4IiwiY3VycmVudEVsZW1lbnQiLCJjb21wYXJpc29uUmVzdWx0IiwiZmluZEZyYWdtZW50QnlQRFQiLCJQRFRWYWx1ZSIsIm1heEZyYWdMb29rVXBUb2xlcmFuY2UiLCJpc0FycmF5Iiwic3RhcnRQRFQiLCJlbmRQRFQiLCJzZWciLCJwZHRXaXRoaW5Ub2xlcmFuY2VUZXN0IiwiZmluZEZyYWdtZW50QnlQVFMiLCJmcmFnUHJldmlvdXMiLCJidWZmZXJFbmQiLCJmcmFnTmV4dCIsImJ1ZmZlckVkZ2VFcnJvciIsImZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdCIsImZvdW5kRnJhZ21lbnQiLCJjYW5kaWRhdGUiLCJjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UiLCJwZHRCdWZmZXJFbmQiLCJmaW5kRnJhZ1dpdGhDQyIsIk5ldHdvcmtFcnJvckFjdGlvbiIsIkRvTm90aGluZyIsIlNlbmRFbmRDYWxsYmFjayIsIlNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3giLCJSZW1vdmVBbHRlcm5hdGVQZXJtYW5lbnRseSIsIkluc2VydERpc2NvbnRpbnVpdHkiLCJSZXRyeVJlcXVlc3QiLCJFcnJvckFjdGlvbkZsYWdzIiwiTm9uZSIsIk1vdmVBbGxBbHRlcm5hdGVzTWF0Y2hpbmdIb3N0IiwiTW92ZUFsbEFsdGVybmF0ZXNNYXRjaGluZ0hEQ1AiLCJTd2l0Y2hUb1NEUiIsIkVycm9yQ29udHJvbGxlciIsInBsYXlsaXN0RXJyb3IiLCJwZW5hbGl6ZWRSZW5kaXRpb25zIiwib25FcnJvck91dCIsImdldFZhcmlhbnRMZXZlbEluZGV4IiwibG9hZExldmVsIiwiX2RhdGEkZnJhZyIsIl9kYXRhJGxldmVsIiwiRlJBR19MT0FEX0VSUk9SIiwiS0VZX0xPQURfRVJST1IiLCJlcnJvckFjdGlvbiIsImdldEZyYWdSZXRyeU9yU3dpdGNoQWN0aW9uIiwiRlJBR19QQVJTSU5HX0VSUk9SIiwiYWN0aW9uIiwiRlJBR19HQVAiLCJGUkFHX0RFQ1JZUFRfRVJST1IiLCJfZGF0YSRjb250ZXh0IiwiX2RhdGEkY29udGV4dCRsZXZlbERlIiwiZ2V0UGxheWxpc3RSZXRyeU9yU3dpdGNoQWN0aW9uIiwibGV2ZWxSZXRyeSIsImdldExldmVsU3dpdGNoQWN0aW9uIiwiS0VZX1NZU1RFTV9TVEFUVVNfT1VUUFVUX1JFU1RSSUNURUQiLCJyZXN0cmljdGVkSGRjcExldmVsIiwiaGRjcExldmVsIiwia2V5U3lzdGVtRXJyb3IiLCJCVUZGRVJfQUREX0NPREVDX0VSUk9SIiwiUkVNVVhfQUxMT0NfRVJST1IiLCJCVUZGRVJfQVBQRU5EX0VSUk9SIiwiSU5URVJOQUxfRVhDRVBUSU9OIiwiQlVGRkVSX0FQUEVORElOR19FUlJPUiIsIkJVRkZFUl9GVUxMX0VSUk9SIiwiTEVWRUxfU1dJVENIX0VSUk9SIiwiQlVGRkVSX1NFRUtfT1ZFUl9IT0xFIiwiQlVGRkVSX05VREdFX09OX1NUQUxMIiwiS0VZX1NZU1RFTV9FUlJPUiIsInZhcmlhbnRMZXZlbEluZGV4IiwiZnJhZ0xvYWRQb2xpY3kiLCJrZXlMb2FkUG9saWN5Iiwic3RhcnRzV2l0aCIsImZyYWdtZW50RXJyb3JzIiwiYWNjIiwiX2RhdGEkZnJhZzIiLCJfZGF0YSRjb250ZXh0MiIsImVycm9yRGV0YWlscyIsIm5leHRMZXZlbCIsIm1pbkF1dG9MZXZlbCIsIm1heEF1dG9MZXZlbCIsImF1dG9MZXZlbEVuYWJsZWQiLCJmcmFnRXJyb3JUeXBlIiwiaXNBdWRpb0NvZGVjRXJyb3IiLCJzb3VyY2VCdWZmZXJOYW1lIiwiZmluZEF1ZGlvQ29kZWNBbHRlcm5hdGUiLCJpc1ZpZGVvQ29kZWNFcnJvciIsImZpbmRWaWRlb0NvZGVjQWx0ZXJuYXRlIiwicGxheWxpc3RFcnJvclR5cGUiLCJwbGF5bGlzdEVycm9yR3JvdXBJZCIsIl9sZXZlbCRhdWRpb0dyb3VwcyIsIl9sZXZlbCRzdWJ0aXRsZUdyb3VwcyIsImxldmVsQ2FuZGlkYXRlIiwiZnJhZ0NhbmRpZGF0ZSIsIm5leHRBdXRvTGV2ZWwiLCJfZGF0YSRlcnJvckFjdGlvbiIsInNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3giLCJyZXNvbHZlZCIsInJlY292ZXJNZWRpYUVycm9yIiwic3dpdGNoTGV2ZWwiLCJtYXhIZGNwTGV2ZWwiLCJuZXh0TG9hZExldmVsIiwiQmFzZVBsYXlsaXN0Q29udHJvbGxlciIsImxvZ1ByZWZpeCIsInRpbWVyIiwicmVxdWVzdFNjaGVkdWxlZCIsImNhbkxvYWQiLCJjbGVhclRpbWVyIiwiY2xlYXJUaW1lb3V0IiwibG9hZFBsYXlsaXN0Iiwic3dpdGNoUGFyYW1zIiwicGxheWxpc3RVcmkiLCJmb3VuZEluZGV4IiwiY3VycmVudEdvYWwiLCJobHNVcmxQYXJhbWV0ZXJzIiwic2hvdWxkTG9hZFBsYXlsaXN0IiwicGxheWxpc3QiLCJzaG91bGRSZWxvYWRQbGF5bGlzdCIsInBsYXlsaXN0TG9hZGVkIiwicHJldmlvdXNEZXRhaWxzIiwiZWxhcHNlZCIsImVuZFNuIiwiaGFzUGFydHMiLCJsYXN0UGFydCIsIm5leHRTblN0YXJ0SW5kZXgiLCJsYXN0QWR2YW5jZWQiLCJjZG5BZ2UiLCJzZWdtZW50cyIsInRvRml4ZWQiLCJnZXREZWxpdmVyeURpcmVjdGl2ZXMiLCJidWZmZXJJbmZvIiwibWFpbkZvcndhcmRCdWZmZXJJbmZvIiwicG9zaXRpb24iLCJlc3RpbWF0ZWRUaW1lVW50aWxVcGRhdGUiLCJzZXRUaW1lb3V0IiwicHJldmlvdXNEZWxpdmVyeURpcmVjdGl2ZXMiLCJjaGVja1JldHJ5IiwiZXJyb3JFdmVudCIsIl9lcnJvckV2ZW50JGNvbnRleHQiLCJkZWxheSIsIkVXTUEiLCJoYWxmTGlmZSIsImVzdGltYXRlIiwid2VpZ2h0IiwiYWxwaGFfIiwiZXN0aW1hdGVfIiwidG90YWxXZWlnaHRfIiwic2FtcGxlIiwiYWRqQWxwaGEiLCJnZXRUb3RhbFdlaWdodCIsImdldEVzdGltYXRlIiwiemVyb0ZhY3RvciIsIkV3bWFCYW5kV2lkdGhFc3RpbWF0b3IiLCJzbG93IiwiZmFzdCIsImRlZmF1bHRFc3RpbWF0ZSIsImRlZmF1bHRUVEZCIiwiZGVmYXVsdEVzdGltYXRlXyIsIm1pbldlaWdodF8iLCJtaW5EZWxheU1zXyIsInNsb3dfIiwiZmFzdF8iLCJkZWZhdWx0VFRGQl8iLCJ0dGZiXyIsInVwZGF0ZSIsImR1cmF0aW9uTXMiLCJudW1CeXRlcyIsIm51bUJpdHMiLCJkdXJhdGlvblMiLCJiYW5kd2lkdGhJbkJwcyIsInNhbXBsZVRURkIiLCJ0dGZiIiwic2Vjb25kcyIsInNxcnQiLCJjYW5Fc3RpbWF0ZSIsImdldEVzdGltYXRlVFRGQiIsIlNVUFBPUlRFRF9JTkZPX0RFRkFVTFQiLCJzdXBwb3J0ZWQiLCJjb25maWd1cmF0aW9ucyIsImRlY29kaW5nSW5mb1Jlc3VsdHMiLCJwb3dlckVmZmljaWVudCIsInNtb290aCIsIlNVUFBPUlRFRF9JTkZPX0NBQ0hFIiwicmVxdWlyZXNNZWRpYUNhcGFiaWxpdGllc0RlY29kaW5nSW5mbyIsImF1ZGlvVHJhY2tzQnlHcm91cCIsImN1cnJlbnRWaWRlb1JhbmdlIiwiY3VycmVudEZyYW1lUmF0ZSIsImN1cnJlbnRCdyIsImF1ZGlvUHJlZmVyZW5jZSIsImF1ZGlvQ29kZWNQcmVmZXJlbmNlIiwiY2hhbm5lbHNQcmVmZXJlbmNlIiwibWF4Q2hhbm5lbHMiLCJhdWRpb0NoYW5uZWxzIiwiYXVkaW9UcmFja0dyb3VwIiwiZ2V0TWVkaWFEZWNvZGluZ0luZm9Qcm9taXNlIiwibWVkaWFDYXBhYmlsaXRpZXMiLCJQcm9taXNlIiwiYmFzZVZpZGVvQ29uZmlndXJhdGlvbiIsImNlaWwiLCJmcmFtZXJhdGUiLCJ0cmFuc2ZlckZ1bmN0aW9uIiwiX2F1ZGlvVHJhY2tzQnlHcm91cCRnIiwiY2hhbm5lbHNOdW1iZXIiLCJhbGwiLCJjb25maWd1cmF0aW9uIiwiZGVjb2RpbmdJbmZvS2V5IiwiZ2V0TWVkaWFEZWNvZGluZ0luZm9LZXkiLCJkZWNvZGluZ0luZm8iLCJ0aGVuIiwiY2F0Y2giLCJtZWRpYUNvbmZpZyIsInNwYXRpYWxSZW5kZXJpbmciLCJpc0hkclN1cHBvcnRlZCIsIm1hdGNoTWVkaWEiLCJtZWRpYVF1ZXJ5TGlzdCIsImJhZFF1ZXJ5IiwibWF0Y2hlcyIsImdldFZpZGVvU2VsZWN0aW9uT3B0aW9ucyIsInZpZGVvUHJlZmVyZW5jZSIsInByZWZlckhEUiIsImFsbG93ZWRWaWRlb1JhbmdlcyIsInJhbmdlIiwiZ2V0U3RhcnRDb2RlY1RpZXIiLCJjb2RlY1RpZXJzIiwiY29kZWNTZXRzIiwicHJlZmVyU3RlcmVvIiwiaGFzU3RlcmVvIiwiaGFzQ3VycmVudFZpZGVvUmFuZ2UiLCJtaW5IZWlnaHQiLCJtaW5GcmFtZXJhdGUiLCJtaW5CaXRyYXRlIiwic2VsZWN0ZWRTY29yZSIsInZpZGVvUmFuZ2VzIiwidGllciIsIm1hdGNoaW5nVmlkZW9SYW5nZXMiLCJtYXhIZWlnaHQiLCJtYXhGcmFtZXJhdGUiLCJzZWxlY3RlZCIsImNhbmRpZGF0ZVRpZXIiLCJsb2dTdGFydENvZGVjQ2FuZGlkYXRlSWdub3JlZCIsImhhc0RlZmF1bHRBdWRpbyIsIm1heFNjb3JlIiwiY29kZVNldCIsImdldEF1ZGlvVHJhY2tzQnlHcm91cCIsImFsbEF1ZGlvVHJhY2tzIiwidHJhY2tHcm91cCIsImhhc0RlZmF1bHQiLCJoYXNBdXRvU2VsZWN0IiwiY2hhbm5lbHNLZXkiLCJoYXNBdXRvU2VsZWN0QXVkaW8iLCJnZXRDb2RlY1RpZXJzIiwidGllcnMiLCJTRFIiLCJsZXNzZXJXaWR0aE9ySGVpZ2h0IiwiYXVkaW9Hcm91cCIsImZpbmRNYXRjaGluZ09wdGlvbiIsIm9wdGlvbiIsIm1hdGNoUHJlZGljYXRlIiwibWF0Y2hlc09wdGlvbiIsImlzRGVmYXVsdCIsImNoYXJhY3RlcmlzdGljc01hdGNoIiwiY2hhcmFjdGVyaXN0aWNzQSIsImNoYXJhY3RlcmlzdGljc0IiLCJhcnJBIiwiYXJyQiIsImVsIiwiYXVkaW9NYXRjaFByZWRpY2F0ZSIsImZpbmRDbG9zZXN0TGV2ZWxXaXRoQXVkaW9Hcm91cCIsInNlYXJjaEluZGV4IiwiY3VycmVudExldmVsIiwidmFyaWFudHMiLCJ2YXJpYW50TWFwIiwicmVuZGl0aW9ucyIsImN1cnJlbnRWaWRlb0NvZGVjIiwibWF0Y2hpbmdWaWRlbyIsInNlYXJjaERvd25BbmRVcExpc3QiLCJhcnIiLCJBYnJDb250cm9sbGVyIiwiX2hscyIsImxhc3RMZXZlbExvYWRTZWMiLCJsYXN0TG9hZGVkRnJhZ0xldmVsIiwiZmlyc3RTZWxlY3Rpb24iLCJfbmV4dEF1dG9MZXZlbCIsIm5leHRBdXRvTGV2ZWxLZXkiLCJwYXJ0Q3VycmVudCIsImJpdHJhdGVUZXN0RGVsYXkiLCJid0VzdGltYXRvciIsIl9hYmFuZG9uUnVsZXNDaGVjayIsInRpbWVMb2FkaW5nIiwicGF1c2VkIiwicmVhZHlTdGF0ZSIsInR0ZmJFc3RpbWF0ZSIsImJ1ZmZlclN0YXJ2YXRpb25EZWxheSIsImxvYWRlZEZpcnN0Qnl0ZSIsImdldEJ3RXN0aW1hdGUiLCJleHBlY3RlZExlbiIsInRpbWVTdHJlYW1pbmciLCJsb2FkUmF0ZSIsImZyYWdMb2FkZWREZWxheSIsImJ3ZSIsImZyYWdMZXZlbE5leHRMb2FkZWREZWxheSIsImxldmVsTmV4dEJpdHJhdGUiLCJnZXRUaW1lVG9Mb2FkRnJhZyIsIm5leHRMb2FkTGV2ZWxCaXRyYXRlIiwiYWJyQmFuZFdpZHRoVXBGYWN0b3IiLCJyZXNldEVzdGltYXRvciIsIkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRCIsImluaXRFc3RpbWF0b3IiLCJhYnJFd21hRGVmYXVsdEVzdGltYXRlIiwiYWJyRXdtYVNsb3dWb0QiLCJhYnJFd21hRmFzdFZvRCIsIkZSQUdfTE9BRElORyIsIm9uRnJhZ0xvYWRpbmciLCJGUkFHX0xPQURFRCIsIm9uRnJhZ0xvYWRlZCIsIkZSQUdfQlVGRkVSRUQiLCJvbkZyYWdCdWZmZXJlZCIsIkxFVkVMX1NXSVRDSElORyIsIm9uTGV2ZWxTd2l0Y2hpbmciLCJvbkxldmVsTG9hZGVkIiwiTEVWRUxTX1VQREFURUQiLCJvbkxldmVsc1VwZGF0ZWQiLCJNQVhfQVVUT19MRVZFTF9VUERBVEVEIiwib25NYXhBdXRvTGV2ZWxVcGRhdGVkIiwiaWdub3JlRnJhZ21lbnQiLCJfZGF0YSRwYXJ0Iiwic2V0SW50ZXJ2YWwiLCJ0aW1lVG9GaXJzdEJ5dGVTZWMiLCJiYW5kd2lkdGgiLCJmcmFnU2l6ZUJpdHMiLCJpc1N3aXRjaCIsImZyYWdMb2FkU2VjIiwicGxheWxpc3RMb2FkU2VjIiwidGltZUxvYWRpbmdNcyIsImFickV3bWFTbG93TGl2ZSIsImFickV3bWFGYXN0TGl2ZSIsImFick1heFdpdGhSZWFsQml0cmF0ZSIsImxvYWRlZEJ5dGVzIiwibG9hZGVkRHVyYXRpb24iLCJmcmFnQnVmZmVyZWREYXRhIiwicHJvY2Vzc2luZ01zIiwiY2xlYXJJbnRlcnZhbCIsImZpcnN0QXV0b0xldmVsIiwibWF4U3RhcnREZWxheSIsIm1heFN0YXJ2YXRpb25EZWxheSIsImFickF1dG9MZXZlbCIsImZpbmRCZXN0TGV2ZWwiLCJmaXJzdExldmVsIiwiY2xhbXBlZCIsImZvcmNlZEF1dG9MZXZlbCIsInVzZUVzdGltYXRlIiwibG9hZGVkRmlyc3RGcmFnIiwiZ2V0QXV0b0xldmVsS2V5IiwibmV4dEFCUkF1dG9MZXZlbCIsImdldE5leHRBQlJBdXRvTGV2ZWwiLCJnZXRTdGFydmF0aW9uRGVsYXkiLCJjdXJyZW50RnJhZ0R1cmF0aW9uIiwiYXZnYnciLCJid0ZhY3RvciIsImFickJhbmRXaWR0aEZhY3RvciIsImJ3VXBGYWN0b3IiLCJfYmVzdExldmVsIiwibWF4TG9hZGluZ0RlbGF5IiwiYmVzdExldmVsIiwibWluTGV2ZWwiLCJhdXRvTGV2ZWwiLCJtYXhGZXRjaER1cmF0aW9uIiwic2VsZWN0aW9uQmFzZUxldmVsIiwiY3VycmVudENvZGVjU2V0Iiwic3RhcnRUaWVyIiwidHRmYkVzdGltYXRlU2VjIiwibGV2ZWxzU2tpcHBlZCIsIl9sZXZlbEluZm8kc3VwcG9ydGVkUiIsImxldmVsSW5mbyIsInVwU3dpdGNoIiwidXNlTWVkaWFDYXBhYmlsaXRpZXMiLCJyZW1vdmVMZXZlbCIsImF2Z0R1cmF0aW9uIiwiYWRqdXN0ZWRidyIsImZldGNoRHVyYXRpb24iLCJjYW5Td2l0Y2hXaXRoaW5Ub2xlcmFuY2UiLCJUYXNrTG9vcCIsIl9ib3VuZFRpY2siLCJfdGlja1RpbWVyIiwiX3RpY2tJbnRlcnZhbCIsIl90aWNrQ2FsbENvdW50IiwidGljayIsIm9uSGFuZGxlckRlc3Ryb3lpbmciLCJvbkhhbmRsZXJEZXN0cm95ZWQiLCJjbGVhck5leHRUaWNrIiwiaGFzSW50ZXJ2YWwiLCJoYXNOZXh0VGljayIsIm1pbGxpcyIsImRvVGljayIsInRpY2tJbW1lZGlhdGUiLCJGcmFnbWVudFN0YXRlIiwiTk9UX0xPQURFRCIsIkFQUEVORElORyIsIlBBUlRJQUwiLCJPSyIsIkZyYWdtZW50VHJhY2tlciIsImFjdGl2ZVBhcnRMaXN0cyIsImVuZExpc3RGcmFnbWVudHMiLCJ0aW1lUmFuZ2VzIiwiYnVmZmVyUGFkZGluZyIsImhhc0dhcHMiLCJCVUZGRVJfQVBQRU5ERUQiLCJvbkJ1ZmZlckFwcGVuZGVkIiwiZ2V0QXBwZW5kZWRGcmFnIiwiYWN0aXZlUGFydHMiLCJhY3RpdmVQYXJ0IiwiYXBwZW5kZWRQVFMiLCJnZXRCdWZmZXJlZEZyYWciLCJmcmFnbWVudEVudGl0eSIsImJvZHkiLCJkZXRlY3RFdmljdGVkRnJhZ21lbnRzIiwiZWxlbWVudGFyeVN0cmVhbSIsInRpbWVSYW5nZSIsInBsYXlsaXN0VHlwZSIsImFwcGVuZGVkUGFydCIsImFwcGVuZGVkUGFydFNuIiwicmVtb3ZlRnJhZ21lbnQiLCJlc0RhdGEiLCJpc05vdEJ1ZmZlcmVkIiwiaXNUaW1lQnVmZmVyZWQiLCJkZXRlY3RQYXJ0aWFsRnJhZ21lbnRzIiwiZnJhZ0tleSIsImdldEZyYWdtZW50S2V5IiwiaXNGcmFnSGludCIsInN0cmVhbUluZm8iLCJnZXRCdWZmZXJlZFRpbWVzIiwiaXNQYXJ0aWFsIiwicmVtb3ZlUGFydHMiLCJzblRvS2VlcCIsImZyYWdCdWZmZXJlZCIsImZvcmNlIiwiZ2V0UGFydGlhbEZyYWdtZW50IiwiYmVzdEZyYWdtZW50IiwidGltZVBhZGRpbmciLCJiZXN0T3ZlcmxhcCIsImlzRW5kTGlzdEFwcGVuZGVkIiwibGFzdEZyYWdtZW50RW50aXR5IiwiZ2V0U3RhdGUiLCJoYXNGcmFnbWVudCIsIl90aGlzJGFjdGl2ZVBhcnRMaXN0cyIsInJlbW92ZUZyYWdtZW50c0luUmFuZ2UiLCJ3aXRoR2FwT25seSIsInVuYnVmZmVyZWRPbmx5Iiwic25Ub1JlbW92ZSIsInJlbW92ZUFsbEZyYWdtZW50cyIsIl9mcmFnbWVudEVudGl0eSRyYW5nZSIsIl9mcmFnbWVudEVudGl0eSRyYW5nZTIiLCJfZnJhZ21lbnRFbnRpdHkkcmFuZ2UzIiwibm9vcEJ1ZmZlcmVkIiwiQnVmZmVySGVscGVyIiwiaXNCdWZmZXJlZCIsImdldEJ1ZmZlcmVkIiwicG9zIiwibWF4SG9sZUR1cmF0aW9uIiwidmJ1ZmZlcmVkIiwiYnVmZmVyZWRJbmZvIiwibmV4dFN0YXJ0Iiwic29ydCIsImEiLCJkaWZmIiwiYnVmZmVyZWQyIiwiYnVmMmxlbiIsImJ1ZjJlbmQiLCJidWZmZXJMZW4iLCJidWZmZXJTdGFydE5leHQiLCJidWZmZXJTdGFydCIsIkNodW5rTWV0YWRhdGEiLCJ0cmFuc211eGluZyIsImdldE5ld1BlcmZvcm1hbmNlVGltaW5nIiwiZXhlY3V0ZVN0YXJ0IiwiZXhlY3V0ZUVuZCIsImZpbmRGaXJzdEZyYWdXaXRoQ0MiLCJfZnJhZ21lbnRzJGkiLCJzaG91bGRBbGlnbk9uRGlzY29udGludWl0aWVzIiwibGFzdEZyYWciLCJzd2l0Y2hEZXRhaWxzIiwiZmluZERpc2NvbnRpbnVvdXNSZWZlcmVuY2VGcmFnIiwicHJldkRldGFpbHMiLCJjdXJEZXRhaWxzIiwicHJldkZyYWdzIiwiY3VyRnJhZ3MiLCJwcmV2U3RhcnRGcmFnIiwiYWRqdXN0RnJhZ21lbnRTdGFydCIsInNsaWRpbmciLCJhZGp1c3RTbGlkaW5nU3RhcnQiLCJhbGlnblN0cmVhbSIsImFsaWduRGlzY29udGludWl0aWVzIiwiYWxpZ25NZWRpYVBsYXlsaXN0QnlQRFQiLCJyZWZlcmVuY2VGcmFnIiwicmVmRGV0YWlscyIsInJlZkZyYWdtZW50cyIsInJlZkZyYWciLCJ0YXJnZXRDQyIsInJlZlBEVCIsInRhcmdldFBEVCIsIk1JTl9DSFVOS19TSVpFIiwiRnJhZ21lbnRMb2FkZXIiLCJwYXJ0TG9hZFRpbWVvdXQiLCJvblByb2dyZXNzIiwicmVqZWN0IiwiTG9hZEVycm9yIiwiRnJhZ21lbnRJTG9hZGVyIiwiZkxvYWRlciIsIkRlZmF1bHRJTG9hZGVyIiwidGFncyIsImNyZWF0ZUdhcExvYWRFcnJvciIsImNyZWF0ZUxvYWRlckNvbnRleHQiLCJoaWdoV2F0ZXJNYXJrIiwicmVzZXRMb2FkZXIiLCJyZXNldElWIiwib25BYm9ydCIsIklOVEVSTkFMX0FCT1JURUQiLCJsb2FkUGFydCIsInVwZGF0ZVN0YXRzRnJvbVBhcnQiLCJwYXJ0TG9hZGVkRGF0YSIsImZyYWdTdGF0cyIsInBhcnRTdGF0cyIsInBhcnRUb3RhbCIsImVzdFRvdGFsUGFydHMiLCJlc3RMb2FkZWRQYXJ0cyIsImVzdFJlbWFpbmluZ1BhcnRzIiwiZXN0UmVtYWluaW5nQnl0ZXMiLCJmcmFnTG9hZGluZyIsInBhcnRMb2FkaW5nIiwic2VnbWVudCIsImhlYWRlcnMiLCJyYW5nZVN0YXJ0IiwicmFuZ2VFbmQiLCJfZnJhZyRkZWNyeXB0ZGF0YSIsImJ5dGVSYW5nZVN0YXJ0IiwiYnl0ZVJhbmdlRW5kIiwiZnJhZ21lbnRMZW4iLCJNRURJQV9FUlJPUiIsIkFFU0NyeXB0byIsInN1YnRsZSIsImFlc0lWIiwiZGVjcnlwdCIsIkZhc3RBRVNLZXkiLCJleHBhbmRLZXkiLCJpbXBvcnRLZXkiLCJyZW1vdmVQYWRkaW5nIiwib3V0cHV0Qnl0ZXMiLCJwYWRkaW5nQnl0ZXMiLCJnZXRVaW50OCIsIkFFU0RlY3J5cHRvciIsInJjb24iLCJzdWJNaXgiLCJVaW50MzJBcnJheSIsImludlN1Yk1peCIsInNCb3giLCJpbnZTQm94Iiwia3NSb3dzIiwia2V5U2l6ZSIsImtleVNjaGVkdWxlIiwiaW52S2V5U2NoZWR1bGUiLCJpbml0VGFibGUiLCJ1aW50OEFycmF5VG9VaW50MzJBcnJheV8iLCJhcnJheUJ1ZmZlciIsIm5ld0FycmF5Iiwic3ViTWl4MCIsInN1Yk1peDEiLCJzdWJNaXgyIiwic3ViTWl4MyIsImludlN1Yk1peDAiLCJpbnZTdWJNaXgxIiwiaW52U3ViTWl4MiIsImludlN1Yk1peDMiLCJkIiwieGkiLCJzeCIsIngyIiwieDQiLCJ4OCIsImtleUJ1ZmZlciIsInNhbWVLZXkiLCJrc1JvdyIsImludktzUm93Iiwic2JveCIsInByZXYiLCJuZXR3b3JrVG9Ib3N0T3JkZXJTd2FwIiwid29yZCIsImlucHV0QXJyYXlCdWZmZXIiLCJuUm91bmRzIiwiaW52U0JPWCIsImluaXRWZWN0b3IiLCJpbml0VmVjdG9yMCIsImluaXRWZWN0b3IxIiwiaW5pdFZlY3RvcjIiLCJpbml0VmVjdG9yMyIsImlucHV0SW50MzIiLCJJbnQzMkFycmF5Iiwib3V0cHV0SW50MzIiLCJ0MCIsInQxIiwidDIiLCJ0MyIsInMwIiwiczEiLCJzMiIsInMzIiwiaW5wdXRXb3JkczAiLCJpbnB1dFdvcmRzMSIsImlucHV0V29yZHMyIiwiaW5wdXRXb3JkczMiLCJzd2FwV29yZCIsIkNIVU5LX1NJWkUiLCJEZWNyeXB0ZXIiLCJyZW1vdmVQS0NTN1BhZGRpbmciLCJsb2dFbmFibGVkIiwic29mdHdhcmVEZWNyeXB0ZXIiLCJmYXN0QWVzS2V5IiwicmVtYWluZGVyRGF0YSIsImN1cnJlbnRJViIsImN1cnJlbnRSZXN1bHQiLCJ1c2VTb2Z0d2FyZSIsImVuYWJsZVNvZnR3YXJlQUVTIiwiYnJvd3NlckNyeXB0byIsImNyeXB0byIsIndlYmtpdFN1YnRsZSIsImlzU3luYyIsImZsdXNoIiwicmVzZXQiLCJzb2Z0d2FyZURlY3J5cHQiLCJkZWNyeXB0UmVzdWx0Iiwid2ViQ3J5cHRvRGVjcnlwdCIsImxvZ09uY2UiLCJjdXJyZW50Q2h1bmsiLCJnZXRWYWxpZENodW5rIiwiYWVzS2V5Iiwib25XZWJDcnlwdG9FcnJvciIsInNwbGl0UG9pbnQiLCJtc2ciLCJUaW1lUmFuZ2VzIiwiU3RhdGUiLCJTVE9QUEVEIiwiSURMRSIsIktFWV9MT0FESU5HIiwiRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlkiLCJXQUlUSU5HX1RSQUNLIiwiUEFSU0lORyIsIlBBUlNFRCIsIkVOREVEIiwiV0FJVElOR19JTklUX1BUUyIsIldBSVRJTkdfTEVWRUwiLCJCYXNlU3RyZWFtQ29udHJvbGxlciIsImZyYWdtZW50VHJhY2tlciIsInRyYW5zbXV4ZXIiLCJfc3RhdGUiLCJtZWRpYUJ1ZmZlciIsImxhc3RDdXJyZW50VGltZSIsIm5leHRMb2FkUG9zaXRpb24iLCJsb2FkZWRtZXRhZGF0YSIsInJldHJ5RGF0ZSIsImZyYWdtZW50TG9hZGVyIiwibGV2ZWxMYXN0TG9hZGVkIiwic3RhcnRGcmFnUmVxdWVzdGVkIiwiZGVjcnlwdGVyIiwiaW5pdFBUUyIsIm9udnNlZWtpbmciLCJvbnZlbmRlZCIsIm9uTWFuaWZlc3RMb2FkZWQiLCJvblRpY2tFbmQiLCJyZXNldFRyYW5zbXV4ZXIiLCJzdGF0ZSIsIl9zdHJlYW1FbmRlZCIsImxhc3RQYXJ0QnVmZmVyZWQiLCJnZXRMZXZlbERldGFpbHMiLCJfdGhpcyRsZXZlbExhc3RMb2FkZWQiLCJvbk1lZGlhU2Vla2luZyIsIm9uTWVkaWFFbmRlZCIsImF1dG9TdGFydExvYWQiLCJlbmRlZCIsImRldGFjaCIsIm1heEJ1ZmZlckhvbGUiLCJyZXNldExvYWRpbmdTdGF0ZSIsInRvbGVyYW5jZSIsImZyYWdTdGFydE9mZnNldCIsImZyYWdFbmRPZmZzZXQiLCJwYXN0RnJhZ21lbnQiLCJsb2FkRnJhZ21lbnQiLCJ0YXJnZXRCdWZmZXJUaW1lIiwiX2xvYWRGcmFnRm9yUGxheWJhY2siLCJwcm9ncmVzc0NhbGxiYWNrIiwiZnJhZ0NvbnRleHRDaGFuZ2VkIiwiX2hhbmRsZUZyYWdtZW50TG9hZFByb2dyZXNzIiwiX2RvRnJhZ0xvYWQiLCJfaGFuZGxlRnJhZ21lbnRMb2FkQ29tcGxldGUiLCJyZXNldEZyYWdtZW50TG9hZGluZyIsImNsZWFyVHJhY2tlcklmTmVlZGVkIiwiX3RoaXMkbWVkaWFCdWZmZXIiLCJmcmFnU3RhdGUiLCJnZXRGd2RCdWZmZXJJbmZvIiwibWluRm9yd2FyZEJ1ZmZlckxlbmd0aCIsIm1heEJ1ZmZlckxlbmd0aCIsInJlZHVjZU1heEJ1ZmZlckxlbmd0aCIsImNoZWNrTGl2ZVVwZGF0ZSIsImZsdXNoTWFpbkJ1ZmZlciIsImZsdXNoU2NvcGUiLCJfbG9hZEluaXRTZWdtZW50IiwiZGVjcnlwdERhdGEiLCJkZWNyeXB0ZWREYXRhIiwiRlJBR19ERUNSWVBURUQiLCJ0c3RhcnQiLCJ0ZGVjcnlwdCIsImNvbXBsZXRlSW5pdFNlZ21lbnRMb2FkIiwiZnJhZ0J1ZmZlcmVkQ29tcGxldGUiLCJfZnJhZyRzdGFydFBUUyIsIl9mcmFnJGVuZFBUUyIsIl90aGlzJGZyYWdDdXJyZW50IiwiX3RoaXMkZnJhZ1ByZXZpb3VzIiwiTmFOIiwiX3RoaXMkbGV2ZWxzIiwic2Vla1RvU3RhcnRQb3MiLCJmcmFnTG9hZGVkRW5kRGF0YSIsInBhcnRzTG9hZGVkIiwiY29tcGxldGUiLCJmcmFnTG9hZGVkIiwiY2h1bmtNZXRhIiwia2V5TG9hZGluZ1Byb21pc2UiLCJrZXlMb2FkZWREYXRhIiwiS0VZX0xPQURFRCIsImxvYWRDbGVhciIsImdldE5leHRQYXJ0IiwiX3Jlc3VsdCIsImRvRnJhZ1BhcnRzTG9hZCIsImhhbmRsZUZyYWdMb2FkRXJyb3IiLCJsb2FkZWRFbmRPZlBhcnRzIiwiZGF0YU9uUHJvZ3Jlc3MiLCJwcm9ncmVzc2l2ZSIsImZyYWdMb2FkZWREYXRhIiwiZnJvbVBhcnQiLCJpbml0aWFsUGFydExpc3QiLCJsb2FkZWRQYXJ0IiwibmV4dFBhcnQiLCJoYW5kbGVGcmFnTG9hZEFib3J0ZWQiLCJPVEhFUl9FUlJPUiIsIl9oYW5kbGVUcmFuc211eGVyRmx1c2giLCJnZXRDdXJyZW50Q29udGV4dCIsInVwZGF0ZUxldmVsVGltaW5nIiwiYnVmZmVyRnJhZ21lbnREYXRhIiwibm9CYWNrdHJhY2tpbmciLCJfYnVmZmVyIiwiQlVGRkVSX0FQUEVORElORyIsImRyb3BwZWQiLCJmbHVzaEJ1ZmZlckdhcCIsImZyYWdEdXJhdGlvbiIsInNlZ21lbnRGcmFjdGlvbiIsImJ1ZmZlcmFibGUiLCJnZXRMb2FkUG9zaXRpb24iLCJnZXRGd2RCdWZmZXJJbmZvQXRQb3MiLCJidWZmZXJlZEZyYWdBdFBvcyIsImdldE1heEJ1ZmZlckxlbmd0aCIsImxldmVsQml0cmF0ZSIsIm1heEJ1ZkxlbiIsIm1heEJ1ZmZlclNpemUiLCJtYXhNYXhCdWZmZXJMZW5ndGgiLCJ0aHJlc2hvbGQiLCJtaW5MZW5ndGgiLCJmcmFnT3JQYXJ0IiwiZ2V0TmV4dEZyYWdtZW50IiwiZnJhZ0xlbiIsImluaXRpYWxMaXZlTWFuaWZlc3RTaXplIiwiZ2V0SW5pdGlhbExpdmVGcmFnbWVudCIsImdldEZyYWdtZW50QXRQb3NpdGlvbiIsIm1hcFRvSW5pdEZyYWdXaGVuUmVxdWlyZWQiLCJpc0xvb3BMb2FkaW5nIiwidHJhY2tlclN0YXRlIiwiZ2V0TmV4dEZyYWdtZW50TG9vcExvYWRpbmciLCJnYXBTdGFydCIsIm5leHRGcmFnbWVudCIsIm5leHRidWZmZXJJbmZvIiwiaW5kZXBlbmRlbnRBdHRyT21pdHRlZCIsInRhcmdldFNOIiwibGl2ZVN0YXJ0IiwibG9hZGluZ1BhcnRzIiwibG9va3VwVG9sZXJhbmNlIiwiY3VyU05JZHgiLCJzYW1lTGV2ZWwiLCJuZXh0RnJhZyIsInN5bmNocm9uaXplVG9MaXZlRWRnZSIsIndpdGhpblNsaWRpbmdXaW5kb3ciLCJhbGlnblBsYXlsaXN0cyIsInNsaWRpbmdTdGFydCIsImZpcnN0TGV2ZWxMb2FkIiwiYWxpZ25lZCIsImFsaWduZWRTbGlkaW5nU3RhcnQiLCJ3YWl0Rm9yQ2RuVHVuZUluIiwiYWR2YW5jZVBhcnRMaW1pdCIsInNldFN0YXJ0UG9zaXRpb24iLCJvZmZzZXRJbk11bHRpdmFyaWFudFBsYXlsaXN0Iiwib25GcmFnbWVudE9yS2V5TG9hZEVycm9yIiwiZmlsdGVyVHlwZSIsIl90aGlzJGZyYWdDdXJyZW50MiIsImdhcFRhZ0VuY291bnRlcmVkIiwicmVzZXRTdGFydFdoZW5Ob3RMb2FkZWQiLCJyZXNldEZyYWdtZW50RXJyb3JzIiwicmVkdWNlTGVuZ3RoQW5kRmx1c2hCdWZmZXIiLCJmbHVzaEJ1ZmZlciIsImFmdGVyQnVmZmVyRmx1c2hlZCIsImJ1ZmZlclR5cGUiLCJidWZmZXJlZFRpbWVSYW5nZXMiLCJyZXNldFdoZW5NaXNzaW5nQ29udGV4dCIsInJlbW92ZVVuYnVmZmVyZWRGcmFncyIsIl90aGlzJHRyYW5zbXV4ZXIiLCJwYXJzZWREdXJhdGlvbiIsIkxFVkVMX1BUU19VUERBVEVEIiwiRlJBR19QQVJTRUQiLCJyZWNvdmVyV29ya2VyRXJyb3IiLCJuZXh0U3RhdGUiLCJwcmV2aW91c1N0YXRlIiwiQ2h1bmtDYWNoZSIsImNodW5rcyIsImRhdGFMZW5ndGgiLCJjaHVuayIsImNvbmNhdFVpbnQ4QXJyYXlzIiwiaGFzVU1EV29ya2VyIiwiX19ITFNfV09SS0VSX0JVTkRMRV9fIiwiaW5qZWN0V29ya2VyIiwiYmxvYiIsIkJsb2IiLCJvYmplY3RVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJ3b3JrZXIiLCJXb3JrZXIiLCJsb2FkV29ya2VyIiwic2NyaXB0VVJMIiwibG9jYXRpb24iLCJkdW1teVRyYWNrIiwiaW5wdXRUaW1lU2NhbGUiLCJwaWQiLCJzZXF1ZW5jZU51bWJlciIsIkJhc2VBdWRpb0RlbXV4ZXIiLCJfYXVkaW9UcmFjayIsIl9pZDNUcmFjayIsImZyYW1lSW5kZXgiLCJjYWNoZWREYXRhIiwiYmFzZVBUUyIsImxhc3RQVFMiLCJyZXNldEluaXRTZWdtZW50IiwidHJhY2tEdXJhdGlvbiIsInJlc2V0VGltZVN0YW1wIiwiZGVhdWx0VGltZXN0YW1wIiwicmVzZXRDb250aWd1aXR5IiwiY2FuUGFyc2UiLCJhcHBlbmRGcmFtZSIsImRlbXV4IiwibGFzdERhdGFJbmRleCIsImluaXRQVFNGbiIsImR0cyIsInBhcnRpYWxEYXRhIiwidmlkZW9UcmFjayIsImRlbXV4U2FtcGxlQWVzIiwiaW5pdDkwa0h6IiwiZ2V0QXVkaW9Db25maWciLCJvYnNlcnZlciIsImFkdHNPYmplY3RUeXBlIiwiYWR0c0V4dGVuc2lvblNhbXBsaW5nSW5kZXgiLCJhZHRzQ2hhbm5lbENvbmZpZyIsIm1hbmlmZXN0Q29kZWMiLCJhZHRzU2FtcGxpbmdSYXRlcyIsImFkdHNTYW1wbGluZ0luZGV4IiwiZW1pdCIsInNhbXBsZXJhdGUiLCJjaGFubmVsQ291bnQiLCJpc0hlYWRlclBhdHRlcm4kMSIsImdldEhlYWRlckxlbmd0aCIsImdldEZ1bGxGcmFtZUxlbmd0aCIsImNhbkdldEZyYW1lTGVuZ3RoIiwiaXNIZWFkZXIkMSIsImNhblBhcnNlJDEiLCJwcm9iZSQxIiwiaGVhZGVyTGVuZ3RoIiwiZnJhbWVMZW5ndGgiLCJuZXdPZmZzZXQiLCJpbml0VHJhY2tDb25maWciLCJnZXRGcmFtZUR1cmF0aW9uIiwicGFyc2VGcmFtZUhlYWRlciIsImFwcGVuZEZyYW1lJDIiLCJmcmFtZUR1cmF0aW9uIiwic3RhbXAiLCJoZWFkZXIiLCJ1bml0IiwiX2xlbmd0aCIsIm1pc3NpbmciLCJfc2FtcGxlIiwiY2hyb21lVmVyc2lvbiQxIiwiQml0cmF0ZXNNYXAiLCJTYW1wbGluZ1JhdGVNYXAiLCJTYW1wbGVzQ29lZmZpY2llbnRzIiwiQnl0ZXNJblNsb3QiLCJhcHBlbmRGcmFtZSQxIiwicGFyc2VIZWFkZXIiLCJzYW1wbGVzUGVyRnJhbWUiLCJzYW1wbGVSYXRlIiwibXBlZ1ZlcnNpb24iLCJtcGVnTGF5ZXIiLCJiaXRSYXRlSW5kZXgiLCJzYW1wbGVSYXRlSW5kZXgiLCJwYWRkaW5nQml0IiwiY2hhbm5lbE1vZGUiLCJjb2x1bW5JbkJpdHJhdGVzIiwiYml0UmF0ZSIsImNvbHVtbkluU2FtcGxlUmF0ZXMiLCJzYW1wbGVDb2VmZmljaWVudCIsImJ5dGVzSW5TbG90IiwibmVlZENocm9tZUZpeCIsImlzSGVhZGVyUGF0dGVybiIsImlzSGVhZGVyIiwicHJvYmUiLCJBQUNEZW11eGVyIiwiY29udGFpbmVyIiwic2VnbWVudENvZGVjIiwiZW1zZ1NjaGVtZVBhdHRlcm4iLCJNUDREZW11eGVyIiwidHh0VHJhY2siLCJjYXB0aW9uVHJhY2siLCJ2aWRlb1NhbXBsZXMiLCJzZWdtZW50ZWREYXRhIiwiZXh0cmFjdElEM1RyYWNrIiwiZW1zZ3MiLCJlbXNnSW5mbyIsImdldEF1ZGlvQlNJRCIsImJzaWQiLCJtYXNrIiwiYml0cyIsIkFDM0RlbXV4ZXIiLCJzYW1wbGluZ1JhdGVDb2RlIiwic2FtcGxpbmdSYXRlTWFwIiwiZnJhbWVTaXplQ29kZSIsImZyYW1lU2l6ZU1hcCIsInNraXBDb3VudCIsImxmZW9uIiwiY2hhbm5lbHNNYXAiLCJic21vZCIsIkJhc2VWaWRlb1BhcnNlciIsIlZpZGVvU2FtcGxlIiwiY3JlYXRlVmlkZW9TYW1wbGUiLCJ1bml0cyIsImdldExhc3ROYWxVbml0IiwiX1ZpZGVvU2FtcGxlIiwibGFzdFVuaXQiLCJwdXNoQWNjZXNzVW5pdCIsIm5iU2FtcGxlcyIsImxhc3RTYW1wbGUiLCJFeHBHb2xvbWIiLCJieXRlc0F2YWlsYWJsZSIsImJpdHNBdmFpbGFibGUiLCJsb2FkV29yZCIsIndvcmtpbmdCeXRlcyIsImF2YWlsYWJsZUJ5dGVzIiwic2tpcEJpdHMiLCJjb3VudCIsInNraXBCeXRlcyIsInJlYWRCaXRzIiwidmFsdSIsInNraXBMWiIsImxlYWRpbmdaZXJvQ291bnQiLCJza2lwVUVHIiwic2tpcEVHIiwicmVhZFVFRyIsImNseiIsInJlYWRFRyIsInJlYWRCb29sZWFuIiwicmVhZFVCeXRlIiwicmVhZFVTaG9ydCIsInJlYWRVSW50Iiwic2tpcFNjYWxpbmdMaXN0IiwibGFzdFNjYWxlIiwibmV4dFNjYWxlIiwiZGVsdGFTY2FsZSIsInJlYWRTUFMiLCJmcmFtZUNyb3BMZWZ0T2Zmc2V0IiwiZnJhbWVDcm9wUmlnaHRPZmZzZXQiLCJmcmFtZUNyb3BUb3BPZmZzZXQiLCJmcmFtZUNyb3BCb3R0b21PZmZzZXQiLCJudW1SZWZGcmFtZXNJblBpY09yZGVyQ250Q3ljbGUiLCJzY2FsaW5nTGlzdENvdW50IiwicHJvZmlsZUlkYyIsImNocm9tYUZvcm1hdElkYyIsInBpY09yZGVyQ250VHlwZSIsInBpY1dpZHRoSW5NYnNNaW51czEiLCJwaWNIZWlnaHRJbk1hcFVuaXRzTWludXMxIiwiZnJhbWVNYnNPbmx5RmxhZyIsInBpeGVsUmF0aW8iLCJhc3BlY3RSYXRpb0lkYyIsInJlYWRTbGljZVR5cGUiLCJBdmNWaWRlb1BhcnNlciIsInBhcnNlQVZDUEVTIiwicGVzIiwicGFyc2VBVkNOQUx1Iiwic3BzZm91bmQiLCJhdWRGb3VuZCIsIl9WaWRlb1NhbXBsZTIiLCJpc2tleSIsInNsaWNlVHlwZSIsIl90cmFjayRwaXhlbFJhdGlvIiwiX3RyYWNrJHBpeGVsUmF0aW8yIiwic3BzIiwiZXhwR29sb21iRGVjb2RlciIsImNvZGVjYXJyYXkiLCJjb2RlY3N0cmluZyIsInBwcyIsIm5hbHVTdGF0ZSIsImxhc3RTdGF0ZSIsIm92ZXJmbG93IiwidW5pdFR5cGUiLCJsYXN0VW5pdFN0YXJ0IiwibGFzdFVuaXRUeXBlIiwiU2FtcGxlQWVzRGVjcnlwdGVyIiwiZGVjcnlwdEJ1ZmZlciIsImVuY3J5cHRlZERhdGEiLCJkZWNyeXB0QWFjU2FtcGxlIiwic2FtcGxlSW5kZXgiLCJjYWxsYmFjayIsImN1clVuaXQiLCJlbmNyeXB0ZWRCdWZmZXIiLCJkZWNyeXB0ZWRCdWZmZXIiLCJkZWNyeXB0QWFjU2FtcGxlcyIsImdldEF2Y0VuY3J5cHRlZERhdGEiLCJkZWNvZGVkRGF0YSIsImVuY3J5cHRlZERhdGFMZW4iLCJJbnQ4QXJyYXkiLCJvdXRwdXRQb3MiLCJpbnB1dFBvcyIsImdldEF2Y0RlY3J5cHRlZFVuaXQiLCJ1aW50OERlY3J5cHRlZERhdGEiLCJkZWNyeXB0QXZjU2FtcGxlIiwidW5pdEluZGV4IiwiZGVjcnlwdEF2Y1NhbXBsZXMiLCJjdXJVbml0cyIsIlBBQ0tFVF9MRU5HVEgiLCJUU0RlbXV4ZXIiLCJ0eXBlU3VwcG9ydGVkIiwic2FtcGxlQWVzIiwicG10UGFyc2VkIiwiX2R1cmF0aW9uIiwiX3BtdElkIiwiX3ZpZGVvVHJhY2siLCJfdHh0VHJhY2siLCJhYWNPdmVyRmxvdyIsInZpZGVvUGFyc2VyIiwic3luY09mZnNldCIsInNjYW53aW5kb3ciLCJmb3VuZFBhdCIsInBhY2tldFN0YXJ0IiwidHNQYWNrZXRzIiwicGFyc2VQSUQiLCJwZXNEYXRhIiwiaXNTYW1wbGVBZXMiLCJ2aWRlb1BpZCIsImF1ZGlvUGlkIiwiaWQzUGlkIiwiYXVkaW9EYXRhIiwidW5rbm93blBJRCIsInBtdElkIiwidHNQYWNrZXRFcnJvcnMiLCJzdHQiLCJhdGYiLCJwYXJzZVBFUyIsInBhcnNlQUFDUEVTIiwicGFyc2VNUEVHUEVTIiwicGFyc2VBQzNQRVMiLCJwYXJzZUlEM1BFUyIsInBhcnNlUEFUIiwicGFyc2VkUElEcyIsInBhcnNlUE1UIiwic2VnbWVudFZpZGVvQ29kZWMiLCJzZWdtZW50QXVkaW9Db2RlYyIsImRlbXV4UmVzdWx0IiwiZXh0cmFjdFJlbWFpbmluZ1NhbXBsZXMiLCJmcmFtZU1pc3NpbmdCeXRlcyIsInNhbXBsZUxlbmd0aCIsImZyYW1lT3ZlcmZsb3dCeXRlcyIsInJlY292ZXJhYmxlIiwiaWQzU2FtcGxlIiwic2VjdGlvbkxlbmd0aCIsInRhYmxlRW5kIiwicHJvZ3JhbUluZm9MZW5ndGgiLCJlc0luZm9MZW5ndGgiLCJsb2dFbmNyeXB0ZWRTYW1wbGVzRm91bmRJblVuZW5jcnlwdGVkU3RyZWFtIiwibXBlZyIsIm1wMyIsImFjMyIsInBhcnNlUG9zIiwicmVtYWluaW5nIiwiZGVzY3JpcHRvcklkIiwiZGVzY3JpcHRvckxlbiIsInN0cmVhbSIsInBlc0xlbiIsInBlc0hkckxlbiIsInBlc1B0cyIsInBlc0R0cyIsInBlc1ByZWZpeCIsInBlc0ZsYWdzIiwicGF5bG9hZFN0YXJ0T2Zmc2V0IiwiZGF0YUxlbiIsIk1QM0RlbXV4ZXIiLCJBQUMiLCJnZXRTaWxlbnRGcmFtZSIsIlVJTlQzMl9NQVgiLCJNUDQiLCJ0eXBlcyIsImF2Y0MiLCJidHJ0IiwiZGluZiIsImRyZWYiLCJlc2RzIiwiZnR5cCIsIm1kYXQiLCJtZGlhIiwibWZoZCIsIm1pbmYiLCJtb292IiwiZGFjMyIsIm12ZXgiLCJtdmhkIiwicGFzcCIsInNkdHAiLCJzdGJsIiwic3RjbyIsInN0c2MiLCJzdHN6Iiwic3R0cyIsInZtaGQiLCJzbWhkIiwidmlkZW9IZGxyIiwiYXVkaW9IZGxyIiwiSERMUl9UWVBFUyIsIlNUVFMiLCJTVFNDIiwiU1RDTyIsIlNUU1oiLCJWTUhEIiwiU01IRCIsIlNUU0QiLCJtYWpvckJyYW5kIiwiYXZjMUJyYW5kIiwibWlub3JWZXJzaW9uIiwiRlRZUCIsImJveCIsIkRJTkYiLCJ1cHBlcldvcmREdXJhdGlvbiIsImxvd2VyV29yZER1cmF0aW9uIiwiYm94ZXMiLCJkZXBlbmRzT24iLCJpc0RlcGVuZGVkT24iLCJoYXNSZWR1bmRhbmN5IiwiYXZjYyIsImhTcGFjaW5nIiwidlNwYWNpbmciLCJjb25maWdsZW4iLCJhdWRpb1N0c2QiLCJzYW1wbGVEZXBlbmRlbmN5VGFibGUiLCJ1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lIiwibG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSIsImFycmF5bGVuIiwiY3RzIiwiaXNMZWFkaW5nIiwicGFkZGluZ1ZhbHVlIiwiaXNOb25TeW5jIiwiZGVncmFkUHJpbyIsIm1vdmllIiwiTVBFR19UU19DTE9DS19GUkVRX0haIiwidG9UaW1lc2NhbGVGcm9tQmFzZSIsImRlc3RTY2FsZSIsInNyY0Jhc2UiLCJ0b1RpbWVzY2FsZUZyb21TY2FsZSIsInNyY1NjYWxlIiwidG9Nc0Zyb21NcGVnVHNDbG9jayIsInRvTXBlZ1RzQ2xvY2tGcm9tVGltZXNjYWxlIiwiTUFYX1NJTEVOVF9GUkFNRV9EVVJBVElPTiIsIkFBQ19TQU1QTEVTX1BFUl9GUkFNRSIsIk1QRUdfQVVESU9fU0FNUExFX1BFUl9GUkFNRSIsIkFDM19TQU1QTEVTX1BFUl9GUkFNRSIsImNocm9tZVZlcnNpb24iLCJzYWZhcmlXZWJraXRWZXJzaW9uIiwiTVA0UmVtdXhlciIsInZlbmRvciIsIklTR2VuZXJhdGVkIiwiX2luaXRQVFMiLCJfaW5pdERUUyIsIm5leHRBdmNEdHMiLCJuZXh0QXVkaW9QdHMiLCJ2aWRlb1NhbXBsZUR1cmF0aW9uIiwiaXNBdWRpb0NvbnRpZ3VvdXMiLCJpc1ZpZGVvQ29udGlndW91cyIsInZpZGVvVHJhY2tDb25maWciLCJkZWZhdWx0VGltZVN0YW1wIiwicmVzZXROZXh0VGltZXN0YW1wIiwiZ2V0VmlkZW9TdGFydFB0cyIsInJvbGxvdmVyRGV0ZWN0ZWQiLCJtaW5QVFMiLCJub3JtYWxpemVQdHMiLCJyZW11eCIsImFjY3VyYXRlVGltZU9mZnNldCIsImF1ZGlvVGltZU9mZnNldCIsInZpZGVvVGltZU9mZnNldCIsImhhc0F1ZGlvIiwiaGFzVmlkZW8iLCJlbm91Z2hBdWRpb1NhbXBsZXMiLCJlbm91Z2hWaWRlb1NhbXBsZXMiLCJjYW5SZW11eEF2YyIsIl92aWRlb1RyYWNrJHBpeGVsUmF0aSIsIl9jb25maWckcGl4ZWxSYXRpbyIsIl92aWRlb1RyYWNrJHBpeGVsUmF0aTIiLCJfY29uZmlnJHBpeGVsUmF0aW8yIiwiZ2VuZXJhdGVJUyIsImZpcnN0S2V5RnJhbWVJbmRleCIsImZpcnN0S2V5RnJhbWVQVFMiLCJmaW5kS2V5ZnJhbWVJbmRleCIsImZvcmNlS2V5RnJhbWVPbkRpc2NvbnRpbnVpdHkiLCJ0c0RlbHRhIiwiYXVkaW92aWRlb1RpbWVzdGFtcERlbHRhIiwicmVtdXhBdWRpbyIsImF1ZGlvVHJhY2tMZW5ndGgiLCJyZW11eFZpZGVvIiwiZmlyc3RLZXlGcmFtZSIsImZsdXNoVGV4dFRyYWNrTWV0YWRhdGFDdWVTYW1wbGVzIiwiZmx1c2hUZXh0VHJhY2tVc2VyZGF0YUN1ZVNhbXBsZXMiLCJhdWRpb1NhbXBsZXMiLCJjb21wdXRlUFRTRFRTIiwiaW5pdERUUyIsIm1ldGFkYXRhIiwiaW5wdXRTYW1wbGVzIiwib3V0cHV0U2FtcGxlcyIsIm1wNFNhbXBsZUR1cmF0aW9uIiwiZmlyc3REVFMiLCJsYXN0RFRTIiwibWF4UFRTIiwiTkVHQVRJVkVfSU5GSU5JVFkiLCJzb3J0U2FtcGxlcyIsImluaXRUaW1lIiwiZGVsdGFkdHMiLCJkZWx0YXB0cyIsImlucHV0RHVyYXRpb24iLCJhdmVyYWdlU2FtcGxlRHVyYXRpb24iLCJmb3VuZEhvbGUiLCJmb3VuZE92ZXJsYXAiLCJmaXJzdFBUUyIsIm5iTmFsdSIsIm5hbHVMZW4iLCJkdHNTdGVwIiwibmJVbml0cyIsInNhbXBsZUxlbiIsIm1kYXRTaXplIiwiTVVYX0VSUk9SIiwic3RyZXRjaGVkTGFzdEZyYW1lIiwibWluRHRzRGVsdGEiLCJtaW5QdHNEZWx0YSIsIm1heER0c0RlbHRhIiwibWF4UHRzRGVsdGEiLCJWaWRlb1NhbXBsZVVuaXRzIiwibXA0U2FtcGxlTGVuZ3RoIiwidW5pdERhdGEiLCJ1bml0RGF0YUxlbiIsInB0c0RlbHRhIiwibGFzdEZyYW1lRHVyYXRpb24iLCJzdHJldGNoU2hvcnRWaWRlb1RyYWNrIiwiZ2FwVG9sZXJhbmNlIiwiZGVsdGFUb0ZyYW1lRW5kIiwiY29tcG9zaXRpb25UaW1lT2Zmc2V0IiwiTXA0U2FtcGxlIiwibmV4dER0cyIsIm5leHRQdHMiLCJuYiIsImdldFNhbXBsZXNQZXJGcmFtZSIsIm1wNHRpbWVTY2FsZSIsInNjYWxlRmFjdG9yIiwiaW5wdXRTYW1wbGVEdXJhdGlvbiIsInJhd01QRUciLCJhbGlnbmVkV2l0aFZpZGVvIiwidGltZU9mZnNldE1wZWdUUyIsIm1heEF1ZGlvRnJhbWVzRHJpZnQiLCJuZXdTdGFtcCIsImZpbGxGcmFtZSIsIl9uYlNhbXBsZXMiLCJhdWRpb1NhbXBsZSIsInByZXZTYW1wbGUiLCJ1bml0TGVuIiwicmVtdXhFbXB0eUF1ZGlvIiwic2lsZW50RnJhbWUiLCJyZWZlcmVuY2UiLCJpc0tleWZyYW1lIiwiUGFzc1Rocm91Z2hSZW11eGVyIiwiZW1pdEluaXRTZWdtZW50IiwiaW5pdFRyYWNrcyIsImxhc3RFbmRUaW1lIiwiZGVmYXVsdEluaXRQVFMiLCJnZW5lcmF0ZUluaXRTZWdtZW50IiwiZ2V0UGFyc2VkVHJhY2tDb2RlYyIsIl9pbml0RGF0YSIsIl9pbml0RGF0YTIiLCJkZWNvZGVUaW1lIiwiaXNJbnZhbGlkSW5pdFB0cyIsIm1pbkR1cmF0aW9uIiwibXV4Q29uZmlnIiwiVHJhbnNtdXhlciIsImFzeW5jIiwiZGVtdXhlciIsInJlbXV4ZXIiLCJkZWNyeXB0aW9uUHJvbWlzZSIsInRyYW5zbXV4Q29uZmlnIiwiY3VycmVudFRyYW5zbXV4U3RhdGUiLCJjb25maWd1cmUiLCJ1aW50RGF0YSIsImRpc2NvbnRpbnVpdHkiLCJ0cmFja1N3aXRjaCIsImluaXRTZWdtZW50Q2hhbmdlIiwiZGVmYXVsdEluaXRQdHMiLCJpbml0U2VnbWVudERhdGEiLCJnZXRFbmNyeXB0aW9uVHlwZSIsImdldERlY3J5cHRlciIsImVtcHR5UmVzdWx0IiwicmVzZXRNdXhlcnMiLCJuZWVkc1Byb2JpbmciLCJjb25maWd1cmVUcmFuc211eGVyIiwicmVzZXRJbml0aWFsVGltZXN0YW1wIiwidHJhbnNtdXgiLCJjdXJyZW50U3RhdGUiLCJ0cmFuc211eFJlc3VsdHMiLCJkZW11eFJlc3VsdE9yUHJvbWlzZSIsImlzUHJvbWlzZSIsImZsdXNoUmVtdXgiLCJyZW11eFJlc3VsdCIsInRyYW5zbXV4U2FtcGxlQWVzIiwidHJhbnNtdXhVbmVuY3J5cHRlZCIsIm11eCIsIl9tdXhDb25maWckaSRkZW11eCIsIlJlbXV4ZXIiLCJEZW11eGVyIiwiZW5jcnlwdGlvblR5cGUiLCJwIiwiRnVuY3Rpb24iLCJUcmFuc211eENvbmZpZyIsIlRyYW5zbXV4U3RhdGUiLCJldmVudGVtaXR0ZXIzIiwicHJlZml4IiwiX19wcm90b19fIiwiRUUiLCJmbiIsIm9uY2UiLCJhZGRMaXN0ZW5lciIsImVtaXR0ZXIiLCJsaXN0ZW5lciIsImV2dCIsIl9ldmVudHMiLCJfZXZlbnRzQ291bnQiLCJjbGVhckV2ZW50IiwiRXZlbnRFbWl0dGVyIiwiZXZlbnROYW1lcyIsIm5hbWVzIiwiZXZlbnRzIiwibGlzdGVuZXJzIiwiaGFuZGxlcnMiLCJsIiwiZWUiLCJsaXN0ZW5lckNvdW50IiwiYTEiLCJhMiIsImEzIiwiYTQiLCJhNSIsImFyZ3MiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsInByZWZpeGVkIiwiZXZlbnRlbWl0dGVyM0V4cG9ydHMiLCJUcmFuc211eGVySW50ZXJmYWNlIiwib25UcmFuc211eENvbXBsZXRlIiwib25GbHVzaCIsInVzZVdvcmtlciIsIndvcmtlckNvbnRleHQiLCJvbndtc2ciLCJlbmFibGVXb3JrZXIiLCJmb3J3YXJkTWVzc2FnZSIsImV2IiwibTJ0c1R5cGVTdXBwb3J0ZWQiLCJjYW5DcmVhdGVXb3JrZXIiLCJ3b3JrZXJQYXRoIiwib25Xb3JrZXJNZXNzYWdlIiwib25lcnJvciIsImZpbGVuYW1lIiwibGluZW5vIiwicG9zdE1lc3NhZ2UiLCJjbWQiLCJyZXNldFdvcmtlciIsInJldm9rZU9iamVjdFVSTCIsInRlcm1pbmF0ZSIsIl9mcmFnJGluaXRTZWdtZW50IiwiX2xhc3RGcmFnJGluaXRTZWdtZW50Iiwic25EaWZmIiwicGFydERpZmYiLCJ0cmFuc211eFJlc3VsdCIsImhhbmRsZVRyYW5zbXV4Q29tcGxldGUiLCJ0cmFuc211eGVyRXJyb3IiLCJhc3luY0ZsdXNoIiwiaGFuZGxlRmx1c2hSZXN1bHQiLCJfdGhpcyR3b3JrZXJDb250ZXh0IiwibG9nVHlwZSIsInN1YnRpdGxlT3B0aW9uc0lkZW50aWNhbCIsInRyYWNrTGlzdDEiLCJ0cmFja0xpc3QyIiwibWVkaWFBdHRyaWJ1dGVzSWRlbnRpY2FsIiwiYXR0cnMxIiwiYXR0cnMyIiwiY3VzdG9tQXR0cmlidXRlcyIsInN0YWJsZVJlbmRpdGlvbklkIiwic3VidGl0bGVBdHRyaWJ1dGUiLCJzdWJ0aXRsZVRyYWNrTWF0Y2hlc1RleHRUcmFjayIsInN1YnRpdGxlVHJhY2siLCJsYW5ndWFnZSIsIlRJQ0tfSU5URVJWQUwkMiIsIkF1ZGlvU3RyZWFtQ29udHJvbGxlciIsInZpZGVvQnVmZmVyIiwidmlkZW9UcmFja0NDIiwid2FpdGluZ1ZpZGVvQ0MiLCJidWZmZXJlZFRyYWNrIiwic3dpdGNoaW5nVHJhY2siLCJ3YWl0aW5nRGF0YSIsIm1haW5EZXRhaWxzIiwiZmx1c2hpbmciLCJidWZmZXJGbHVzaGVkIiwiY2FjaGVkVHJhY2tMb2FkZWREYXRhIiwiQVVESU9fVFJBQ0tTX1VQREFURUQiLCJvbkF1ZGlvVHJhY2tzVXBkYXRlZCIsIkFVRElPX1RSQUNLX1NXSVRDSElORyIsIm9uQXVkaW9UcmFja1N3aXRjaGluZyIsIm9uQXVkaW9UcmFja0xvYWRlZCIsIkJVRkZFUl9SRVNFVCIsIm9uQnVmZmVyUmVzZXQiLCJCVUZGRVJfQ1JFQVRFRCIsIm9uQnVmZmVyQ3JlYXRlZCIsIkJVRkZFUl9GTFVTSEVEIiwib25CdWZmZXJGbHVzaGVkIiwiSU5JVF9QVFNfRk9VTkQiLCJvbkluaXRQdHNGb3VuZCIsImRvVGlja0lkbGUiLCJfbGV2ZWxzJHRyYWNrSWQiLCJfdGhpcyRtZWRpYSIsInNlZWtpbmciLCJjYWNoZSIsImNsZWFyV2FpdGluZ0ZyYWdtZW50Iiwid2FpdGluZ0ZyYWdtZW50QXRQb3NpdGlvbiIsInN0YXJ0RnJhZ1ByZWZldGNoIiwidHJhY2tEZXRhaWxzIiwiQlVGRkVSX0VPUyIsIm1haW5CdWZmZXJJbmZvIiwiYXRHYXAiLCJhdEJ1ZmZlclN5bmNMaW1pdCIsIm1haW5GcmFnIiwibWFpbkJ1ZmZlckxlbmd0aCIsIm1heENvbmZpZ0J1ZmZlciIsIm1lZGlhUGxheWxpc3QiLCJhbHRBdWRpbyIsImZsdXNoQXVkaW9JZk5lZWRlZCIsIl90cmFjayRkZXRhaWxzIiwiZGVmYXVsdEF1ZGlvQ29kZWMiLCJfaGFuZGxlVHJhbnNtdXhDb21wbGV0ZSIsIkFVRElPX1RSQUNLX1NXSVRDSEVEIiwiX2lkMyRzYW1wbGVzIiwiY29tcGxldGVBdWRpb1N3aXRjaCIsIm1hcEZyYWdtZW50IiwiX2J1ZmZlckluaXRTZWdtZW50IiwiRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCIsImVtaXR0ZWRJRDMiLCJlbWl0dGVkVGV4dCIsIkZSQUdfUEFSU0lOR19VU0VSREFUQSIsInZhcmlhbnRBdWRpb0NvZGVjcyIsIkJVRkZFUl9DT0RFQ1MiLCJfdHJhY2skZGV0YWlsczIiLCJidWZmZXJlZEF0dHJpYnV0ZXMiLCJzd2l0Y2hBdHRyaWJ1dGVzIiwiQXVkaW9UcmFja0NvbnRyb2xsZXIiLCJncm91cElkcyIsInRyYWNrc0luR3JvdXAiLCJjdXJyZW50VHJhY2siLCJzZWxlY3REZWZhdWx0VHJhY2siLCJNQU5JRkVTVF9QQVJTRUQiLCJvbk1hbmlmZXN0UGFyc2VkIiwidHJhY2tJbkFjdGl2ZUdyb3VwIiwiY3VycmVudEdyb3VwcyIsImdyb3VwSW5kZXgiLCJhbGxJbmRleCIsImZpbmRUcmFja0lkIiwiYXVkaW9UcmFja3NVcGRhdGVkIiwic2VsZWN0ZWRUcmFja0lkIiwic2V0QXVkaW9UcmFjayIsIl90aGlzJGdyb3VwSWRzIiwibmV3SWQiLCJzZXRBdWRpb09wdGlvbiIsImF1ZGlvT3B0aW9uIiwic3dpdGNoSW5kZXgiLCJ3aXRob3V0Q29kZWNBbmRDaGFubmVsc01hdGNoIiwibGFzdFRyYWNrIiwidHJhY2tMb2FkZWQiLCJUSUNLX0lOVEVSVkFMJDEiLCJTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIiLCJjdXJyZW50VHJhY2tJZCIsInRyYWNrc0J1ZmZlcmVkIiwiU1VCVElUTEVfVFJBQ0tTX1VQREFURUQiLCJvblN1YnRpdGxlVHJhY2tzVXBkYXRlZCIsIlNVQlRJVExFX1RSQUNLX1NXSVRDSCIsIm9uU3VidGl0bGVUcmFja1N3aXRjaCIsIm9uU3VidGl0bGVUcmFja0xvYWRlZCIsIlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VEIiwib25TdWJ0aXRsZUZyYWdQcm9jZXNzZWQiLCJzdWNjZXNzIiwiZnJhZ1N0YXJ0IiwiZnJhZ0VuZCIsImVuZE9mZnNldFN1YnRpdGxlcyIsIm1lZGlhQnVmZmVyVGltZVJhbmdlcyIsIm1haW5TbGlkaW5nU3RhcnRGcmFnbWVudCIsImZvdW5kRnJhZyIsIkJ1ZmZlcmFibGVJbnN0YW5jZSIsInRpbWVyYW5nZXMiLCJnZXRSYW5nZSIsIkRPTUV4Y2VwdGlvbiIsIlN1YnRpdGxlVHJhY2tDb250cm9sbGVyIiwicXVldWVkRGVmYXVsdFRyYWNrIiwiYXN5bmNQb2xsVHJhY2tDaGFuZ2UiLCJwb2xsVHJhY2tDaGFuZ2UiLCJ1c2VUZXh0VHJhY2tQb2xsaW5nIiwic3VidGl0bGVQb2xsaW5nSW50ZXJ2YWwiLCJfc3VidGl0bGVEaXNwbGF5Iiwib25UZXh0VHJhY2tzQ2hhbmdlZCIsInJlbmRlclRleHRUcmFja3NOYXRpdmVseSIsImZpbmRUcmFja0ZvclRleHRUcmFjayIsInNldFN1YnRpdGxlVHJhY2siLCJzdWJ0aXRsZURpc3BsYXkiLCJ0b2dnbGVUcmFja01vZGVzIiwic3VidGl0bGVQcmVmZXJlbmNlIiwic3VidGl0bGVUcmFja3NVcGRhdGVkIiwic2VsZWN0RGVmYXVsdCIsImFsbFN1YnRpdGxlVHJhY2tzIiwic2V0U3VidGl0bGVPcHRpb24iLCJzdWJ0aXRsZU9wdGlvbiIsIm5leHRUcmFjayIsIkJ1ZmZlck9wZXJhdGlvblF1ZXVlIiwic291cmNlQnVmZmVyUmVmZXJlbmNlIiwiYnVmZmVycyIsInF1ZXVlcyIsImFwcGVuZCIsIm9wZXJhdGlvbiIsInBlbmRpbmciLCJxdWV1ZSIsImV4ZWN1dGVOZXh0IiwiaW5zZXJ0QWJvcnQiLCJhcHBlbmRCbG9ja2VyIiwiZXhlY3V0ZSIsInByb21pc2UiLCJvblN0YXJ0Iiwib25Db21wbGV0ZSIsInNiIiwidXBkYXRpbmciLCJzaGlmdEFuZEV4ZWN1dGVOZXh0IiwiY3VycmVudCIsIlZJREVPX0NPREVDX1BST0ZJTEVfUkVQTEFDRSIsIkJ1ZmZlckNvbnRyb2xsZXIiLCJfb2JqZWN0VXJsIiwib3BlcmF0aW9uUXVldWUiLCJidWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkIiwiX2J1ZmZlckNvZGVjRXZlbnRzVG90YWwiLCJtZWRpYVNvdXJjZSIsImxhc3RNcGVnQXVkaW9DaHVuayIsImFwcGVuZFNvdXJjZSIsImFwcGVuZEVycm9ycyIsInBlbmRpbmdUcmFja3MiLCJzb3VyY2VCdWZmZXIiLCJfb25FbmRTdHJlYW1pbmciLCJwYXVzZUJ1ZmZlcmluZyIsIl9vblN0YXJ0U3RyZWFtaW5nIiwicmVzdW1lQnVmZmVyaW5nIiwiX29uTWVkaWFTb3VyY2VPcGVuIiwiX29uTWVkaWFFbXB0aWVkIiwidXBkYXRlTWVkaWFFbGVtZW50RHVyYXRpb24iLCJjaGVja1BlbmRpbmdUcmFja3MiLCJfb25NZWRpYVNvdXJjZUNsb3NlIiwiX29uTWVkaWFTb3VyY2VFbmRlZCIsIm1lZGlhU3JjIiwiX2luaXRTb3VyY2VCdWZmZXIiLCJoYXNTb3VyY2VUeXBlcyIsImdldFNvdXJjZUJ1ZmZlclR5cGVzIiwiTUVESUFfQVRUQUNISU5HIiwib25NZWRpYUF0dGFjaGluZyIsIm9uQnVmZmVyQXBwZW5kaW5nIiwib25CdWZmZXJDb2RlY3MiLCJvbkJ1ZmZlckVvcyIsIm9uRnJhZ1BhcnNlZCIsIkZSQUdfQ0hBTkdFRCIsIm9uRnJhZ0NoYW5nZWQiLCJjb2RlY0V2ZW50cyIsIl9tcyRjb25zdHJ1Y3RvciIsIm1zIiwib2JqZWN0VXJsIiwicmVtb3ZlQXR0cmlidXRlIiwiTU1TIiwiZGlzYWJsZVJlbW90ZVBsYXliYWNrIiwicmVtb3ZlU291cmNlQ2hpbGRyZW4iLCJhZGRTb3VyY2UiLCJzcmMiLCJlbmRPZlN0cmVhbSIsIk1FRElBX0RFVEFDSEVEIiwicmVzZXRCdWZmZXIiLCJfdGhpcyRtZWRpYVNvdXJjZSIsInJlbW92ZUJ1ZmZlckxpc3RlbmVycyIsInNvdXJjZUJ1ZmZlcnMiLCJyZW1vdmVTb3VyY2VCdWZmZXIiLCJzb3VyY2VCdWZmZXJDb3VudCIsInRyYWNrTmFtZXMiLCJ0cmFja05hbWUiLCJjaGFuZ2VUeXBlIiwiX3RyYWNrQ29kZWMiLCJjdXJyZW50Q29kZWNGdWxsIiwiY3VycmVudENvZGVjIiwidHJhY2tDb2RlYyIsIm5leHRDb2RlYyIsIm1pbWVUeXBlIiwiYXBwZW5kQ2hhbmdlVHlwZSIsImV2ZW50RGF0YSIsImNodW5rU3RhdHMiLCJidWZmZXJBcHBlbmRpbmdTdGFydCIsImZyYWdCdWZmZXJpbmciLCJwYXJ0QnVmZmVyaW5nIiwiY2hlY2tUaW1lc3RhbXBPZmZzZXQiLCJ0aW1lc3RhbXBPZmZzZXQiLCJhcHBlbmRFeGVjdXRvciIsIlFVT1RBX0VYQ0VFREVEX0VSUiIsImFwcGVuZEVycm9yQ291bnQiLCJhcHBlbmRFcnJvck1heFJldHJ5IiwiZmx1c2hPcGVyYXRpb24iLCJyZW1vdmVFeGVjdXRvciIsImJ1ZmZlcnNBcHBlbmRlZFRvIiwib25VbmJsb2NrZWQiLCJibG9ja0J1ZmZlcnMiLCJ0cmltQnVmZmVycyIsImVuZGluZyIsInNvdXJjZUJ1ZmZlclR5cGVzIiwiYmFja0J1ZmZlckxlbmd0aCIsImxpdmVCYWNrQnVmZmVyTGVuZ3RoIiwibWF4QmFja0J1ZmZlckxlbmd0aCIsInRhcmdldEJhY2tCdWZmZXJQb3NpdGlvbiIsImZsdXNoQmFja0J1ZmZlciIsImZyb250QnVmZmVyRmx1c2hUaHJlc2hvbGQiLCJmcm9udEJ1ZmZlckxlbmd0aCIsIm1heEZyb250QnVmZmVyTGVuZ3RoIiwidGFyZ2V0RnJvbnRCdWZmZXJQb3NpdGlvbiIsImZsdXNoRnJvbnRCdWZmZXIiLCJCQUNLX0JVRkZFUl9SRUFDSEVEIiwiTElWRV9CQUNLX0JVRkZFUl9SRUFDSEVEIiwibnVtQnVmZmVyZWRSYW5nZXMiLCJsZXZlbER1cmF0aW9uIiwibWVkaWFEdXJhdGlvbiIsIm1zRHVyYXRpb24iLCJsaXZlRHVyYXRpb25JbmZpbml0eSIsInVwZGF0ZVNlZWthYmxlUmFuZ2UiLCJzZXRMaXZlU2Vla2FibGVSYW5nZSIsInBlbmRpbmdUcmFja3NDb3VudCIsImNyZWF0ZVNvdXJjZUJ1ZmZlcnMiLCJCVUZGRVJfSU5DT01QQVRJQkxFX0NPREVDU19FUlJPUiIsImFkZFNvdXJjZUJ1ZmZlciIsInNiTmFtZSIsImFkZEJ1ZmZlckxpc3RlbmVyIiwiX29uU0JVcGRhdGVTdGFydCIsIl9vblNCVXBkYXRlRW5kIiwiX29uU0JVcGRhdGVFcnJvciIsInJlbW92ZWRSYW5nZXMiLCJmaXJzdENoaWxkIiwiX3RoaXMkbWVkaWFTb3VyY2UyIiwiX3RoaXMkbWVkaWFTb3VyY2UzIiwicmVtb3ZlU3RhcnQiLCJyZW1vdmVFbmQiLCJyZW1vdmUiLCJhcHBlbmRCdWZmZXIiLCJibG9ja2luZ09wZXJhdGlvbnMiLCJub2RlIiwic291cmNlQ2hpbGRyZW4iLCJxdWVyeVNlbGVjdG9yQWxsIiwicmVtb3ZlQ2hpbGQiLCJjcmVhdGVFbGVtZW50IiwiYXBwZW5kQ2hpbGQiLCJzcGVjaWFsQ2VhNjA4Q2hhcnNDb2RlcyIsImdldENoYXJGb3JCeXRlIiwiY2hhckNvZGUiLCJOUl9ST1dTIiwiTlJfQ09MUyIsInJvd3NMb3dDaDEiLCJyb3dzSGlnaENoMSIsInJvd3NMb3dDaDIiLCJyb3dzSGlnaENoMiIsImJhY2tncm91bmRDb2xvcnMiLCJDYXB0aW9uc0xvZ2dlciIsInZlcmJvc2VMZXZlbCIsInNldmVyaXR5IiwibnVtQXJyYXlUb0hleEFycmF5IiwibnVtQXJyYXkiLCJoZXhBcnJheSIsIlBlblN0YXRlIiwiZm9yZWdyb3VuZCIsInVuZGVybGluZSIsIml0YWxpY3MiLCJiYWNrZ3JvdW5kIiwiZmxhc2giLCJzZXRTdHlsZXMiLCJzdHlsZXMiLCJhdHRyaWJzIiwic3R5bGUiLCJlcXVhbHMiLCJvdGhlciIsImNvcHkiLCJuZXdQZW5TdGF0ZSIsIlN0eWxlZFVuaWNvZGVDaGFyIiwidWNoYXIiLCJwZW5TdGF0ZSIsInNldENoYXIiLCJzZXRQZW5TdGF0ZSIsIm5ld0NoYXIiLCJpc0VtcHR5IiwiUm93IiwiY2hhcnMiLCJjdXJyUGVuU3RhdGUiLCJjdWVTdGFydFRpbWUiLCJlbXB0eSIsInNldEN1cnNvciIsImFic1BvcyIsIm1vdmVDdXJzb3IiLCJyZWxQb3MiLCJuZXdQb3MiLCJiYWNrU3BhY2UiLCJpbnNlcnRDaGFyIiwiY2hhciIsImNsZWFyRnJvbVBvcyIsInN0YXJ0UG9zIiwiY2xlYXIiLCJjbGVhclRvRW5kT2ZSb3ciLCJnZXRUZXh0U3RyaW5nIiwic2V0UGVuU3R5bGVzIiwiY3VyckNoYXIiLCJDYXB0aW9uU2NyZWVuIiwicm93cyIsImN1cnJSb3ciLCJuclJvbGxVcFJvd3MiLCJsYXN0T3V0cHV0U2NyZWVuIiwiZXF1YWwiLCJyb3ciLCJzZXRQZW4iLCJzZXRQQUMiLCJwYWNEYXRhIiwibmV3Um93IiwidG9wUm93SW5kZXgiLCJwcmV2TGluZVRpbWUiLCJpbmRlbnQiLCJwcmV2UG9zIiwiY29sb3IiLCJzZXRCa2dEYXRhIiwiYmtnRGF0YSIsInNldFJvbGxVcFJvd3MiLCJuclJvd3MiLCJyb2xsVXAiLCJnZXREaXNwbGF5VGV4dCIsInRvcFJvdyIsImFzT25lUm93IiwiZGlzcGxheVRleHQiLCJyb3dOciIsInJvd1RleHQiLCJnZXRUZXh0QW5kRm9ybWF0IiwiQ2VhNjA4Q2hhbm5lbCIsImNoYW5uZWxOdW1iZXIiLCJvdXRwdXRGaWx0ZXIiLCJjaE5yIiwidmVyYm9zZSIsImRpc3BsYXllZE1lbW9yeSIsIm5vbkRpc3BsYXllZE1lbW9yeSIsImN1cnJSb2xsVXBSb3ciLCJ3cml0ZVNjcmVlbiIsImdldEhhbmRsZXIiLCJzZXRIYW5kbGVyIiwibmV3SGFuZGxlciIsInNldE1vZGUiLCJuZXdNb2RlIiwiaW5zZXJ0Q2hhcnMiLCJzY3JlZW4iLCJvdXRwdXREYXRhVXBkYXRlIiwiY2NSQ0wiLCJjY0JTIiwiY2NBT0YiLCJjY0FPTiIsImNjREVSIiwiY2NSVSIsImNjRk9OIiwiY2NSREMiLCJjY1RSIiwiY2NSVEQiLCJjY0VETSIsImNjQ1IiLCJjY0VOTSIsImNjRU9DIiwidG1wIiwiY2NUTyIsIm5yQ29scyIsImNjTUlEUk9XIiwic2Vjb25kQnl0ZSIsImNvbG9ySW5kZXgiLCJjb2xvcnMiLCJkaXNwYXRjaCIsIm5ld0N1ZSIsImRpc3BhdGNoQ3VlIiwiY3VlU3BsaXRBdFRpbWUiLCJDZWE2MDhQYXJzZXIiLCJmaWVsZCIsIm91dDEiLCJvdXQyIiwiY3VycmVudENoYW5uZWwiLCJjbWRIaXN0b3J5IiwiY3JlYXRlQ21kSGlzdG9yeSIsImNoYW5uZWwiLCJhZGREYXRhIiwiYnl0ZUxpc3QiLCJjbWRGb3VuZCIsImNoYXJzRm91bmQiLCJwYXJzZUNtZCIsInBhcnNlTWlkcm93IiwicGFyc2VQQUMiLCJwYXJzZUJhY2tncm91bmRBdHRyaWJ1dGVzIiwicGFyc2VDaGFycyIsImN1cnJDaE5yIiwiY29uZDEiLCJjb25kMiIsImhhc0NtZFJlcGVhdGVkIiwic2V0TGFzdENtZCIsImNhc2UxIiwiY2FzZTIiLCJpbnRlcnByZXRQQUMiLCJwYWNJbmRleCIsImNoYW5uZWxOciIsImNoYXJDb2RlcyIsImNoYXJDb2RlMSIsIm9uZUNvZGUiLCJoZXhDb2RlcyIsIk91dHB1dEZpbHRlciIsInRpbWVsaW5lQ29udHJvbGxlciIsImN1ZVJhbmdlcyIsImFkZEN1ZXMiLCJjcmVhdGVDYXB0aW9uc1RyYWNrIiwiQWxsb3dlZERpcmVjdGlvbnMiLCJBbGxvd2VkQWxpZ25tZW50cyIsImlzQWxsb3dlZFZhbHVlIiwiYWxsb3dlZCIsImxjVmFsdWUiLCJmaW5kRGlyZWN0aW9uU2V0dGluZyIsImZpbmRBbGlnblNldHRpbmciLCJleHRlbmQiLCJyZXN0IiwiY29iaiIsImJhc2VPYmoiLCJoYXNCZWVuUmVzZXQiLCJfaWQiLCJfcGF1c2VPbkV4aXQiLCJfc3RhcnRUaW1lIiwiX2VuZFRpbWUiLCJfdGV4dCIsIl9yZWdpb24iLCJfdmVydGljYWwiLCJfc25hcFRvTGluZXMiLCJfbGluZSIsIl9saW5lQWxpZ24iLCJfcG9zaXRpb24iLCJfcG9zaXRpb25BbGlnbiIsIl9zaXplIiwiX2FsaWduIiwic2V0dGluZyIsIlN5bnRheEVycm9yIiwiZGlzcGxheVN0YXRlIiwiZ2V0Q3VlQXNIVE1MIiwiV2ViVlRUIiwiY29udmVydEN1ZVRvRE9NVHJlZSIsIlN0cmluZ0RlY29kZXIiLCJvcHRpb25zIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwicGFyc2VUaW1lU3RhbXAiLCJjb21wdXRlU2Vjb25kcyIsImYiLCJTZXR0aW5ncyIsInZhbHVlcyIsInYiLCJkZmx0IiwiZGVmYXVsdEtleSIsImFsdCIsIm4iLCJpbnRlZ2VyIiwicGVyY2VudCIsInBhcnNlT3B0aW9ucyIsImtleVZhbHVlRGVsaW0iLCJncm91cERlbGltIiwia3YiLCJkZWZhdWx0cyIsImNlbnRlciIsImFsaWduIiwicGFyc2VDdWUiLCJyZWdpb25MaXN0Iiwib0lucHV0IiwiY29uc3VtZVRpbWVTdGFtcCIsInRzIiwiY29uc3VtZUN1ZVNldHRpbmdzIiwic2V0dGluZ3MiLCJ2YWxzIiwicmVnaW9uIiwidmVydGljYWwiLCJsaW5lIiwibGluZUFsaWduIiwic25hcFRvTGluZXMiLCJza2lwV2hpdGVzcGFjZSIsImZpeExpbmVCcmVha3MiLCJWVFRQYXJzZXIiLCJvbmN1ZSIsIm9ucGFyc2luZ2Vycm9yIiwib25mbHVzaCIsIl90aGlzIiwiY29sbGVjdE5leHRMaW5lIiwiYWxyZWFkeUNvbGxlY3RlZExpbmUiLCJoYXNTdWJzdHJpbmciLCJMSU5FQlJFQUtTIiwiaW5wdXRTdHJpbmciLCJzZWFyY2hTdHJpbmciLCJjdWVTdHJpbmcybWlsbGlzIiwidGltZVN0cmluZyIsInNlY3MiLCJtaW5zIiwiaG91cnMiLCJoYXNoIiwiX2hhc2giLCJnZW5lcmF0ZUN1ZUlkIiwiY2FsY3VsYXRlT2Zmc2V0IiwidnR0Q0NzIiwiY3VyckNDIiwicHJldkNDIiwibmV3IiwicHJlc2VudGF0aW9uT2Zmc2V0IiwiX3ByZXZDQyIsInBhcnNlV2ViVlRUIiwidnR0Qnl0ZUFycmF5IiwiY2FsbEJhY2siLCJlcnJvckNhbGxCYWNrIiwidnR0TGluZXMiLCJjdWVUaW1lIiwidGltZXN0YW1wTWFwTVBFR1RTIiwidGltZXN0YW1wTWFwTE9DQUwiLCJwYXJzaW5nRXJyb3IiLCJpbkhlYWRlciIsImN1ZU9mZnNldCIsIndlYlZ0dE1wZWdUc01hcE9mZnNldCIsIklNU0MxX0NPREVDIiwiSE1TRl9SRUdFWCIsIlRJTUVfVU5JVF9SRUdFWCIsInRleHRBbGlnblRvTGluZUFsaWduIiwicGFyc2VJTVNDMSIsInR0bWxMaXN0Iiwic3luY1RpbWUiLCJ0dG1sIiwicGFyc2VUVE1MIiwidHQiLCJkZWZhdWx0UmF0ZUluZm8iLCJzdWJGcmFtZVJhdGUiLCJmcmFtZVJhdGVNdWx0aXBsaWVyIiwidGlja1JhdGUiLCJyYXRlSW5mbyIsInN0eWxlRWxlbWVudHMiLCJjb2xsZWN0aW9uVG9EaWN0aW9uYXJ5IiwiZ2V0RWxlbWVudENvbGxlY3Rpb24iLCJyZWdpb25FbGVtZW50cyIsImN1ZUVsZW1lbnRzIiwiY3VlRWxlbWVudCIsImN1ZVRleHQiLCJnZXRUZXh0Q29udGVudCIsImhhc0F0dHJpYnV0ZSIsInBhcnNlVHRtbFRpbWUiLCJ0aW1lc3RhbXBQYXJzaW5nRXJyb3IiLCJnZXRUdG1sU3R5bGVzIiwidGV4dEFsaWduIiwiZnJvbUVsZW1lbnQiLCJwYXJlbnROYW1lIiwiY2hpbGROYW1lIiwiZWxlbWVudHNXaXRoSWQiLCJkaWN0IiwiZWxlbWVudCIsIl9ub2RlJGNoaWxkTm9kZXMiLCJub2RlTmFtZSIsInRleHRDb250ZW50IiwidHRzTnMiLCJyZWdpb25TdHlsZSIsInN0eWxlQXR0cmlidXRlcyIsInJlZ2lvblN0eWxlTmFtZSIsImdldEF0dHJpYnV0ZU5TIiwibnMiLCJoYXNBdHRyaWJ1dGVOUyIsInRpbWVBdHRyaWJ1dGVWYWx1ZSIsInBhcnNlSG91cnNNaW51dGVzU2Vjb25kc0ZyYW1lcyIsInBhcnNlVGltZVVuaXRzIiwiVGltZWxpbmVDb250cm9sbGVyIiwiQ3VlcyIsInVucGFyc2VkVnR0RnJhZ3MiLCJjYXB0aW9uc1RyYWNrcyIsIm5vbk5hdGl2ZUNhcHRpb25zVHJhY2tzIiwiY2VhNjA4UGFyc2VyMSIsImNlYTYwOFBhcnNlcjIiLCJsYXN0Q2MiLCJuZXdWVFRDQ3MiLCJjYXB0aW9uc1Byb3BlcnRpZXMiLCJjdWVIYW5kbGVyIiwidGV4dFRyYWNrMSIsImNhcHRpb25zVGV4dFRyYWNrMUxhYmVsIiwibGFuZ3VhZ2VDb2RlIiwiY2FwdGlvbnNUZXh0VHJhY2sxTGFuZ3VhZ2VDb2RlIiwidGV4dFRyYWNrMiIsImNhcHRpb25zVGV4dFRyYWNrMkxhYmVsIiwiY2FwdGlvbnNUZXh0VHJhY2syTGFuZ3VhZ2VDb2RlIiwidGV4dFRyYWNrMyIsImNhcHRpb25zVGV4dFRyYWNrM0xhYmVsIiwiY2FwdGlvbnNUZXh0VHJhY2szTGFuZ3VhZ2VDb2RlIiwidGV4dFRyYWNrNCIsImNhcHRpb25zVGV4dFRyYWNrNExhYmVsIiwiY2FwdGlvbnNUZXh0VHJhY2s0TGFuZ3VhZ2VDb2RlIiwib25GcmFnUGFyc2luZ1VzZXJkYXRhIiwib25GcmFnRGVjcnlwdGVkIiwiU1VCVElUTEVfVFJBQ0tTX0NMRUFSRUQiLCJvblN1YnRpdGxlVHJhY2tzQ2xlYXJlZCIsImluaXRDZWE2MDhQYXJzZXJzIiwiZW5hYmxlQ0VBNzA4Q2FwdGlvbnMiLCJjaGFubmVsMSIsImNoYW5uZWwyIiwiY2hhbm5lbDMiLCJjaGFubmVsNCIsIm1lcmdlZCIsImN1ZVJhbmdlIiwib3ZlcmxhcCIsImludGVyc2VjdGlvbiIsIkNVRVNfUEFSU0VEIiwiZ2V0RXhpc3RpbmdUcmFjayIsImNhblJldXNlVnR0VGV4dFRyYWNrIiwiY3JlYXRlTmF0aXZlVHJhY2siLCJjcmVhdGVOb25OYXRpdmVUcmFjayIsImV4aXN0aW5nVHJhY2siLCJjcmVhdGVUZXh0VHJhY2siLCJ0cmFja1Byb3BlcnRpZXMiLCJjbG9zZWRDYXB0aW9ucyIsIk5PTl9OQVRJVkVfVEVYVF9UUkFDS1NfRk9VTkQiLCJfY2xlYW5UcmFja3MiLCJoYXNJTVNDMSIsImVuYWJsZVdlYlZUVCIsImVuYWJsZUlNU0MxIiwibGlzdElzSWRlbnRpY2FsIiwiaW5Vc2VUcmFja3MiLCJpblVzZVRyYWNrIiwidGV4dFRyYWNrS2luZCIsImNhcHRpb25zT3JTdWJ0aXRsZXNGcm9tQ2hhcmFjdGVyaXN0aWNzIiwidW51c2VkVGV4dFRyYWNrcyIsInRyYWNrc0xpc3QiLCJjYXB0aW9uc1RyYWNrIiwiaW5zdHJlYW1JZE1hdGNoIiwiY2xvc2VkQ2FwdGlvbnNGb3JMZXZlbCIsIl9kYXRhJHBhcnQkaW5kZXgiLCJkZWNyeXB0ZWQiLCJ0cmFja1BsYXlsaXN0TWVkaWEiLCJfcGFyc2VJTVNDMSIsIl9wYXJzZVZUVHMiLCJfYXBwZW5kQ3VlcyIsIm1heEF2Q0MiLCJwYXlsb2FkV2ViVlRUIiwibWlzc2luZ0luaXRQVFMiLCJfZmFsbGJhY2tUb0lNU0MxIiwiZnJhZ0xldmVsIiwiY2NCeXRlcyIsImNjZGF0YXMiLCJleHRyYWN0Q2VhNjA4RGF0YSIsImFjdHVhbENDQnl0ZXMiLCJ0bXBCeXRlIiwiY2NieXRlMSIsImNjYnl0ZTIiLCJjY1ZhbGlkIiwiY2NUeXBlIiwibWFuaWZlc3RUcmFjayIsIngxIiwieTEiLCJ5MiIsIkNhcExldmVsQ29udHJvbGxlciIsImF1dG9MZXZlbENhcHBpbmciLCJyZXN0cmljdGVkTGV2ZWxzIiwiY2xpZW50UmVjdCIsInN0cmVhbUNvbnRyb2xsZXIiLCJzZXRTdHJlYW1Db250cm9sbGVyIiwidW5yZWdpc3Rlckxpc3RlbmVyIiwic3RvcENhcHBpbmciLCJGUFNfRFJPUF9MRVZFTF9DQVBQSU5HIiwib25GcHNEcm9wTGV2ZWxDYXBwaW5nIiwiZHJvcHBlZExldmVsIiwiaXNMZXZlbEFsbG93ZWQiLCJIVE1MVmlkZW9FbGVtZW50IiwiZGV0ZWN0UGxheWVyU2l6ZSIsImNhcExldmVsVG9QbGF5ZXJTaXplIiwic3RhcnRDYXBwaW5nIiwibWVkaWFIZWlnaHQiLCJtZWRpYVdpZHRoIiwibWF4TGV2ZWwiLCJnZXRNYXhMZXZlbCIsIm5leHRMZXZlbFN3aXRjaCIsImNhcExldmVsSW5kZXgiLCJ2YWxpZExldmVscyIsImdldE1heExldmVsQnlNZWRpYVNpemUiLCJnZXREaW1lbnNpb25zIiwiYm91bmRzUmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImJvdHRvbSIsInRvcCIsImNvbnRlbnRTY2FsZUZhY3RvciIsImlnbm9yZURldmljZVBpeGVsUmF0aW8iLCJkZXZpY2VQaXhlbFJhdGlvIiwicmVzdHJpY3RlZExldmVsIiwiYXRHcmVhdGVzdEJhbmR3aWR0aCIsImN1ckxldmVsIiwibWF4TGV2ZWxJbmRleCIsInNxdWFyZVNpemUiLCJGUFNDb250cm9sbGVyIiwiaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSIsImxhc3RUaW1lIiwibGFzdERyb3BwZWRGcmFtZXMiLCJsYXN0RGVjb2RlZEZyYW1lcyIsImNhcExldmVsT25GUFNEcm9wIiwiZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkiLCJjaGVja0ZQU0ludGVydmFsIiwiZnBzRHJvcHBlZE1vbml0b3JpbmdQZXJpb2QiLCJjaGVja0ZQUyIsImRlY29kZWRGcmFtZXMiLCJkcm9wcGVkRnJhbWVzIiwiY3VycmVudFBlcmlvZCIsImN1cnJlbnREcm9wcGVkIiwiY3VycmVudERlY29kZWQiLCJkcm9wcGVkRlBTIiwiRlBTX0RST1AiLCJ0b3RhbERyb3BwZWRGcmFtZXMiLCJmcHNEcm9wcGVkTW9uaXRvcmluZ1RocmVzaG9sZCIsInZpZGVvUGxheWJhY2tRdWFsaXR5IiwidG90YWxWaWRlb0ZyYW1lcyIsImRyb3BwZWRWaWRlb0ZyYW1lcyIsIndlYmtpdERlY29kZWRGcmFtZUNvdW50Iiwid2Via2l0RHJvcHBlZEZyYW1lQ291bnQiLCJMT0dHRVJfUFJFRklYIiwiRU1FQ29udHJvbGxlciIsImtleUZvcm1hdFByb21pc2UiLCJrZXlTeXN0ZW1BY2Nlc3NQcm9taXNlcyIsIl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCIsIm1lZGlhS2V5U2Vzc2lvbnMiLCJrZXlJZFRvS2V5U2Vzc2lvblByb21pc2UiLCJzZXRNZWRpYUtleXNRdWV1ZSIsIkNETUNsZWFudXBQcm9taXNlIiwib25NZWRpYUVuY3J5cHRlZCIsIl9vbk1lZGlhRW5jcnlwdGVkIiwib25XYWl0aW5nRm9yS2V5IiwiX29uV2FpdGluZ0ZvcktleSIsIm9uTWVkaWFEZXRhY2hlZCIsInJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc0Z1bmMiLCJsaWNlbnNlWGhyU2V0dXAiLCJsaWNlbnNlUmVzcG9uc2VDYWxsYmFjayIsImdldExpY2Vuc2VTZXJ2ZXJVcmwiLCJrZXlTeXN0ZW1Db25maWd1cmF0aW9uIiwibGljZW5zZVVybCIsImdldFNlcnZlckNlcnRpZmljYXRlVXJsIiwic2VydmVyQ2VydGlmaWNhdGVVcmwiLCJhdHRlbXB0S2V5U3lzdGVtQWNjZXNzIiwidW5pcXVlQ29kZWMiLCJhdHRlbXB0Iiwia2V5U3lzdGVtcyIsImdldE1lZGlhS2V5c1Byb21pc2UiLCJtZWRpYUtleXMiLCJFTUVLZXlFcnJvciIsIktFWV9TWVNURU1fTk9fQUNDRVNTIiwic3VwcG9ydGVkQ29uZmlndXJhdGlvbnMiLCJlcnJNZXNzYWdlIiwicHJvdG9jb2wiLCJtZWRpYUtleVN5c3RlbUNvbmZpZ3MiLCJrZXlTeXN0ZW1BY2Nlc3MiLCJfa2V5U3lzdGVtQWNjZXNzUHJvbWlzZXMiLCJtZWRpYUtleVN5c3RlbUFjY2VzcyIsImNlcnRpZmljYXRlUmVxdWVzdCIsImZldGNoU2VydmVyQ2VydGlmaWNhdGUiLCJjcmVhdGVNZWRpYUtleXMiLCJjZXJ0aWZpY2F0ZSIsInNldE1lZGlhS2V5c1NlcnZlckNlcnRpZmljYXRlIiwiY3JlYXRlTWVkaWFLZXlTZXNzaW9uQ29udGV4dCIsIm1lZGlhS2V5c1Nlc3Npb24iLCJjcmVhdGVTZXNzaW9uIiwibWVkaWFLZXlTZXNzaW9uQ29udGV4dCIsImtleVN0YXR1cyIsInJlbmV3S2V5U2Vzc2lvbiIsImtleVNlc3Npb25Db250ZXh0IiwiZ2V0S2V5SWRTdHJpbmciLCJnZW5lcmF0ZVJlcXVlc3RXaXRoUHJlZmVycmVkS2V5U2Vzc2lvbiIsInJlbW92ZVNlc3Npb24iLCJ1cGRhdGVLZXlTZXNzaW9uIiwiX21lZGlhS2V5U2Vzc2lvbkNvbnRlIiwia2V5U2Vzc2lvbiIsInNlc3Npb25JZCIsInNlbGVjdEtleVN5c3RlbUZvcm1hdCIsImdldEtleUZvcm1hdFByb21pc2UiLCJrZXlTeXN0ZW1zSW5Db25maWciLCJnZXRLZXlTeXN0ZW1TZWxlY3Rpb25Qcm9taXNlIiwia2V5U3lzdGVtRm9ybWF0IiwibG9hZEtleSIsImtleUluZm8iLCJrZXlEZXRhaWxzIiwia2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlIiwiZ2V0S2V5U3lzdGVtRm9yS2V5UHJvbWlzZSIsInRocm93SWZEZXN0cm95ZWQiLCJhdHRlbXB0U2V0TWVkaWFLZXlzIiwiaGFuZGxlRXJyb3IiLCJLRVlfU1lTVEVNX05PX0tFWVMiLCJLRVlfU1lTVEVNX05PX0NPTkZJR1VSRURfTElDRU5TRSIsImluaXREYXRhVHlwZSIsImtleVN5c3RlbURvbWFpbiIsImpzb24iLCJwc3NoSW5mbyIsImtleUlkSGV4Iiwia2V5Q29udGV4dCIsIm9sZEtleUlkSGV4IiwiX2tleVN5c3RlbVRvS2V5U3lzdGVtIiwic2V0TWVkaWFLZXlzUHJvbWlzZSIsInNldE1lZGlhS2V5cyIsIl90aGlzJGNvbmZpZyRkcm1TeXN0ZSIsIl90aGlzJGNvbmZpZyRkcm1TeXN0ZTIiLCJnZW5lcmF0ZVJlcXVlc3RGaWx0ZXIiLCJnZW5lcmF0ZVJlcXVlc3QiLCJtYXBwZWRJbml0RGF0YSIsIl90aGlzJGhscyIsImxpY2Vuc2VTdGF0dXMiLCJvbm1lc3NhZ2UiLCJfb25tZXNzYWdlIiwibWVzc2FnZVR5cGUiLCJyZW5ld0xpY2Vuc2UiLCJvbmtleXN0YXR1c2VzY2hhbmdlIiwiX29ua2V5c3RhdHVzZXNjaGFuZ2UiLCJvbktleVN0YXR1c0NoYW5nZSIsImtleVVzYWJsZVByb21pc2UiLCJLRVlfU1lTVEVNX1NUQVRVU19JTlRFUk5BTF9FUlJPUiIsIl9jb250ZXh0JG1lZGlhS2V5c1NlcyIsIktFWV9TWVNURU1fTk9fU0VTU0lPTiIsImtleVN0YXR1c2VzIiwic3RhdHVzIiwiY2VydExvYWRlciIsImNlcnRMb2FkUG9saWN5IiwiY29udGV4IiwiS0VZX1NZU1RFTV9TRVJWRVJfQ0VSVElGSUNBVEVfUkVRVUVTVF9GQUlMRUQiLCJjZXJ0Iiwic2V0U2VydmVyQ2VydGlmaWNhdGUiLCJLRVlfU1lTVEVNX1NFUlZFUl9DRVJUSUZJQ0FURV9VUERBVEVfRkFJTEVEIiwia2V5TWVzc2FnZSIsInJlcXVlc3RMaWNlbnNlIiwiS0VZX1NZU1RFTV9TRVNTSU9OX1VQREFURV9GQUlMRUQiLCJ1bnBhY2tQbGF5UmVhZHlLZXlNZXNzYWdlIiwieGhyIiwibGljZW5zZUNoYWxsZW5nZSIsInhtbFN0cmluZyIsInNldFJlcXVlc3RIZWFkZXIiLCJrZXlNZXNzYWdlWG1sIiwiX2hlYWRlciRxdWVyeVNlbGVjdG9yIiwiX2hlYWRlciRxdWVyeVNlbGVjdG9yMiIsInF1ZXJ5U2VsZWN0b3IiLCJjaGFsbGVuZ2VFbGVtZW50IiwiY2hhbGxlbmdlVGV4dCIsInNldHVwTGljZW5zZVhIUiIsImtleXNMaXN0SXRlbSIsIm9wZW4iLCJsaWNlbnNlWGhyU2V0dXBSZXN1bHQiLCJmaW5hbExpY2Vuc2VDaGFsbGVuZ2UiLCJYTUxIdHRwUmVxdWVzdCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsIktFWV9TWVNURU1fTElDRU5TRV9SRVFVRVNUX0ZBSUxFRCIsInN0YXR1c1RleHQiLCJhdHRlbXB0c0xlZnQiLCJsaWNlbnNlWGhyIiwiRE9ORSIsInNlbmQiLCJlbWVFbmFibGVkIiwibWVkaWFLZXlzTGlzdCIsImtleVNlc3Npb25Db3VudCIsImZvcm1hdHMiLCJjbG9zZSIsIkNtT2JqZWN0VHlwZSIsIkNtU3RyZWFtaW5nRm9ybWF0IiwiQ21jZEhlYWRlckZpZWxkIiwiQ21jZEhlYWRlck1hcCIsIk9CSkVDVCIsIlJFUVVFU1QiLCJTRVNTSU9OIiwiU1RBVFVTIiwiU2ZJdGVtIiwiU2ZUb2tlbiIsIkRJQ1QiLCJNYXAiLCJTZXQiLCJ0aHJvd0Vycm9yIiwiY2F1c2UiLCJCQVJFX0lURU0iLCJCT09MRUFOIiwiQllURVMiLCJERUNJTUFMIiwiSU5URUdFUiIsImlzSW52YWxpZEludCIsIlNUUklOR19SRUdFWCIsIlRPS0VOIiwiS0VZIiwic2VyaWFsaXplRXJyb3IiLCJzZXJpYWxpemVCb29sZWFuIiwiYmFzZTY0ZW5jb2RlIiwiYmluYXJ5IiwiYnRvYSIsInNlcmlhbGl6ZUJ5dGVTZXF1ZW5jZSIsImlzVmlldyIsInNlcmlhbGl6ZUludGVnZXIiLCJzZXJpYWxpemVEYXRlIiwicm91bmRUb0V2ZW4iLCJwcmVjaXNpb24iLCJkZWNpbWFsU2hpZnQiLCJpc0VxdWlkaXN0YW50IiwiRVBTSUxPTiIsImZsb29yZWRWYWx1ZSIsInNlcmlhbGl6ZURlY2ltYWwiLCJyb3VuZGVkVmFsdWUiLCJTVFJJTkciLCJzZXJpYWxpemVTdHJpbmciLCJzeW1ib2xUb1N0ciIsInN5bWJvbCIsInNlcmlhbGl6ZVRva2VuIiwidG9rZW4iLCJzZXJpYWxpemVCYXJlSXRlbSIsImlzSW50ZWdlciIsInNlcmlhbGl6ZUtleSIsInNlcmlhbGl6ZVBhcmFtcyIsImVudHJpZXMiLCJzZXJpYWxpemVJdGVtIiwic2VyaWFsaXplSW5uZXJMaXN0Iiwic2VyaWFsaXplRGljdCIsIndoaXRlc3BhY2UiLCJvcHRpb25hbFdoaXRlU3BhY2UiLCJpdGVtIiwib3V0cHV0IiwiZW5jb2RlU2ZEaWN0IiwiaXNUb2tlbkZpZWxkIiwidXJsVG9SZWxhdGl2ZVBhdGgiLCJiYXNlIiwib3JpZ2luIiwidG9QYXRoIiwicGF0aG5hbWUiLCJmcm9tUGF0aCIsInJhbmRvbVVVSUQiLCJkdCIsInJhbmRvbSIsInRvUm91bmRlZCIsInRvVXJsU2FmZSIsInRvSHVuZHJlZCIsIkNtY2RGb3JtYXR0ZXJzIiwiYnIiLCJibCIsImRsIiwibXRwIiwibm9yIiwicnRwIiwidGIiLCJwcm9jZXNzQ21jZCIsImZvcm1hdHRlcnMiLCJmb3JtYXR0ZXIiLCJlbmNvZGVDbWNkIiwiY21jZCIsInRvQ21jZEhlYWRlcnMiLCJoZWFkZXJNYXAiLCJjdXN0b21IZWFkZXJNYXAiLCJzaGFyZHMiLCJlbnRyeSIsIl9oZWFkZXJNYXAkZmluZCIsIl9hY2MkZmllbGQiLCJmaW5kIiwiYXBwZW5kQ21jZEhlYWRlcnMiLCJDTUNEX1BBUkFNIiwidG9DbWNkUXVlcnkiLCJSRUdFWCIsImFwcGVuZENtY2RRdWVyeSIsInNlcGFyYXRvciIsIkNNQ0RDb250cm9sbGVyIiwic2lkIiwiY2lkIiwidXNlSGVhZGVycyIsImluY2x1ZGVLZXlzIiwiaW5pdGlhbGl6ZWQiLCJzdGFydmVkIiwiYXVkaW9CdWZmZXIiLCJvbldhaXRpbmciLCJvblBsYXlpbmciLCJhcHBseVBsYXlsaXN0RGF0YSIsIm90Iiwic3UiLCJhcHBseUZyYWdtZW50RGF0YSIsImdldE9iamVjdFR5cGUiLCJNVVhFRCIsImdldFRvcEJhbmR3aWR0aCIsImdldEJ1ZmZlckxlbmd0aCIsImNyZWF0ZVBsYXlsaXN0TG9hZGVyIiwiY3JlYXRlRnJhZ21lbnRMb2FkZXIiLCJjb250ZW50SWQiLCJfZGF0YSR0cmFja3MkYXVkaW8iLCJfZGF0YSR0cmFja3MkdmlkZW8iLCJjcmVhdGVEYXRhIiwic2YiLCJITFMiLCJwciIsImJhbmR3aWR0aEVzdGltYXRlIiwiaXNWaWRlbyIsIklOSVQiLCJicyIsIlRJTUVEX1RFWFQiLCJDdG9yIiwiQ21jZFBsYXlsaXN0TG9hZGVyIiwiY2FsbGJhY2tzIiwiQ21jZEZyYWdtZW50TG9hZGVyIiwiUEFUSFdBWV9QRU5BTFRZX0RVUkFUSU9OX01TIiwiQ29udGVudFN0ZWVyaW5nQ29udHJvbGxlciIsInBhdGh3YXlQcmlvcml0eSIsInRpbWVUb0xvYWQiLCJyZWxvYWRUaW1lciIsInN0YXJ0ZWQiLCJwZW5hbGl6ZWRQYXRod2F5cyIsInR0bCIsInNjaGVkdWxlUmVmcmVzaCIsImxvYWRTdGVlcmluZ01hbmlmZXN0IiwibGV2ZWxUb1JlbW92ZSIsImVycm9yUGF0aHdheSIsImdldFBhdGh3YXlGb3JHcm91cElkIiwicGF0aHdheXMiLCJ1cGRhdGVQYXRod2F5UHJpb3JpdHkiLCJmaWx0ZXJQYXJzZWRMZXZlbHMiLCJwYXRod2F5TGV2ZWxzIiwiZ2V0TGV2ZWxzRm9yUGF0aHdheSIsInNlbGVjdGVkSW5kZXgiLCJzZWxlY3RlZExldmVsIiwibGV2ZWxBZnRlckNoYW5nZSIsImRlZmF1bHRQYXRod2F5IiwiY2xvbmVQYXRod2F5cyIsInBhdGh3YXlDbG9uZXMiLCJhdWRpb0dyb3VwQ2xvbmVNYXAiLCJzdWJ0aXRsZUdyb3VwQ2xvbmVNYXAiLCJwYXRod2F5Q2xvbmUiLCJjbG9uZUlkIiwiYmFzZUlkIiwidXJpUmVwbGFjZW1lbnQiLCJjbG9uZWRWYXJpYW50cyIsImJhc2VMZXZlbCIsImNsb25lZEF1ZGlvR3JvdXBJZCIsImNsb25lZFN1YnRpdGxlR3JvdXBJZCIsInBlcmZvcm1VcmlSZXBsYWNlbWVudCIsImNsb25lZExldmVsIiwiY2xvbmVSZW5kaXRpb25Hcm91cHMiLCJ0aHJvdWdocHV0Iiwic3RlZXJpbmdNYW5pZmVzdExvYWRQb2xpY3kiLCJzdGVlcmluZ0RhdGEiLCJWRVJTSU9OIiwiVFRMIiwicmVsb2FkVXJpIiwibG9hZGVkU3RlZXJpbmdEYXRhIiwic3RlZXJpbmdNYW5pZmVzdCIsIlNURUVSSU5HX01BTklGRVNUX0xPQURFRCIsImdldFJlc3BvbnNlSGVhZGVyIiwicmV0cnlBZnRlciIsInR0bE1zIiwiZ3JvdXBDbG9uZU1hcCIsImNsb25lZFRyYWNrcyIsImNsb25lZFRyYWNrIiwic3RhYmxlSWQiLCJwZXJPcHRpb25LZXkiLCJIT1NUIiwiaG9zdCIsIlBBUkFNUyIsInBlck9wdGlvblVyaXMiLCJwZXJWYXJpYW50VXJpIiwiQUdFX0hFQURFUl9MSU5FX1JFR0VYIiwiWGhyTG9hZGVyIiwieGhyU2V0dXAiLCJyZXF1ZXN0VGltZW91dCIsInJldHJ5VGltZW91dCIsImFib3J0SW50ZXJuYWwiLCJvbnByb2dyZXNzIiwiX3RoaXMkY2FsbGJhY2tzIiwibG9hZEludGVybmFsIiwib3BlbkFuZFNlbmRYaHIiLCJyZWFkeXN0YXRlY2hhbmdlIiwibG9hZHByb2dyZXNzIiwibG9hZHRpbWVvdXQiLCJ1c2VSZXNwb25zZSIsInJlc3BvbnNlVGV4dCIsInJlc3BvbnNlVVJMIiwiX3RoaXMkY29uZmlnIiwiX3RoaXMkY29udGV4dCIsImxlbmd0aENvbXB1dGFibGUiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJmZXRjaFN1cHBvcnRlZCIsImZldGNoIiwiQWJvcnRDb250cm9sbGVyIiwiUmVhZGFibGVTdHJlYW0iLCJSZXF1ZXN0IiwiRmV0Y2hMb2FkZXIiLCJmZXRjaFNldHVwIiwicmVxdWVzdCIsImNvbnRyb2xsZXIiLCJnZXRSZXF1ZXN0IiwiaW5pdFBhcmFtcyIsImdldFJlcXVlc3RQYXJhbWV0ZXJzIiwic2lnbmFsIiwiaXNBcnJheUJ1ZmZlciIsIkxFTkdUSCIsIm9rIiwiRmV0Y2hFcnJvciIsImdldENvbnRlbnRMZW5ndGgiLCJsb2FkUHJvZ3Jlc3NpdmVseSIsInJlc3BvbnNlRGF0YSIsImNodW5rQ2FjaGUiLCJyZWFkZXIiLCJnZXRSZWFkZXIiLCJwdW1wIiwicmVhZCIsImRvbmUiLCJjcmVkZW50aWFscyIsIkhlYWRlcnMiLCJnZXRCeXRlUmFuZ2VMZW5ndGgiLCJieXRlUmFuZ2VIZWFkZXIiLCJjb250ZW50UmFuZ2UiLCJieXRlUmFuZ2VMZW5ndGgiLCJjb250ZW50TGVuZ3RoIiwiV0hJVEVTUEFDRV9DSEFSIiwiY2FwdGlvblNjcmVlbiIsImluZGVudGluZyIsIl90cmFjayRjdWVzIiwiY3VlQSIsImN1ZUIiLCJkZWZhdWx0TG9hZFBvbGljeSIsImhsc0RlZmF1bHRDb25maWciLCJoaWdoQnVmZmVyV2F0Y2hkb2dQZXJpb2QiLCJudWRnZU9mZnNldCIsIm51ZGdlTWF4UmV0cnkiLCJzdGFydExldmVsIiwiYWJyQ29udHJvbGxlciIsImJ1ZmZlckNvbnRyb2xsZXIiLCJjYXBMZXZlbENvbnRyb2xsZXIiLCJlcnJvckNvbnRyb2xsZXIiLCJmcHNDb250cm9sbGVyIiwiYWJyRXdtYURlZmF1bHRFc3RpbWF0ZU1heCIsIm1pbkF1dG9CaXRyYXRlIiwidGVzdEJhbmR3aWR0aCIsIm1hbmlmZXN0TG9hZGluZ1RpbWVPdXQiLCJtYW5pZmVzdExvYWRpbmdNYXhSZXRyeSIsIm1hbmlmZXN0TG9hZGluZ1JldHJ5RGVsYXkiLCJtYW5pZmVzdExvYWRpbmdNYXhSZXRyeVRpbWVvdXQiLCJsZXZlbExvYWRpbmdUaW1lT3V0IiwibGV2ZWxMb2FkaW5nTWF4UmV0cnkiLCJsZXZlbExvYWRpbmdSZXRyeURlbGF5IiwibGV2ZWxMb2FkaW5nTWF4UmV0cnlUaW1lb3V0IiwiZnJhZ0xvYWRpbmdUaW1lT3V0IiwiZnJhZ0xvYWRpbmdNYXhSZXRyeSIsImZyYWdMb2FkaW5nUmV0cnlEZWxheSIsImZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0IiwidGltZWxpbmVDb25maWciLCJzdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIiLCJzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciIsImF1ZGlvU3RyZWFtQ29udHJvbGxlciIsImF1ZGlvVHJhY2tDb250cm9sbGVyIiwiZW1lQ29udHJvbGxlciIsImNtY2RDb250cm9sbGVyIiwiY29udGVudFN0ZWVyaW5nQ29udHJvbGxlciIsIm1lcmdlQ29uZmlnIiwiZGVmYXVsdENvbmZpZyIsImRlZmF1bHRzQ29weSIsImRlZXBDcHkiLCJkZXByZWNhdGVkU2V0dGluZ1R5cGVzIiwiZGVwcmVjYXRlZFNldHRpbmdzIiwicG9saWN5TmFtZSIsInBvbGljeU5vdFNldCIsInJlcG9ydCIsImRlcHJlY2F0ZWRTZXR0aW5nIiwiZW5hYmxlU3RyZWFtaW5nTW9kZSIsImN1cnJlbnRMb2FkZXIiLCJjYW5TdHJlYW1Qcm9ncmVzc2l2ZWx5IiwiY2hyb21lT3JGaXJlZm94IiwiTGV2ZWxDb250cm9sbGVyIiwiX2xldmVscyIsIl9maXJzdExldmVsIiwiX21heEF1dG9MZXZlbCIsIl9zdGFydExldmVsIiwiY3VycmVudExldmVsSW5kZXgiLCJtYW51YWxMZXZlbEluZGV4Iiwic3RlZXJpbmciLCJvblBhcnNlZENvbXBsZXRlIiwicmVzZXRMZXZlbHMiLCJyZWR1bmRhbnRTZXQiLCJnZW5lcmF0ZVBhdGh3YXlTZXQiLCJyZXNvbHV0aW9uRm91bmQiLCJ2aWRlb0NvZGVjRm91bmQiLCJhdWRpb0NvZGVjRm91bmQiLCJsZXZlbFBhcnNlZCIsIl9hdWRpb0NvZGVjIiwiX3ZpZGVvQ29kZWMiLCJGUkFNRVJBVEUiLCJIRENQIiwiUEFUSFdBWSIsIlJFU09MVVRJT04iLCJWSURFT19SQU5HRSIsImNvbnRlbnRTdGVlcmluZ1ByZWZpeCIsInBhdGh3YXlDb3VudCIsImZpbHRlckFuZFNvcnRNZWRpYU9wdGlvbnMiLCJmaWx0ZXJlZExldmVscyIsIk1BTklGRVNUX0lOQ09NUEFUSUJMRV9DT0RFQ1NfRVJST1IiLCJhc3NpZ25UcmFja0lkc0J5R3JvdXAiLCJ1bnNvcnRlZExldmVscyIsInZhbHVlQSIsInZhbHVlQiIsImZpcnN0TGV2ZWxJblBsYXlsaXN0IiwiX3RoaXMkaGxzJHVzZXJDb25maWciLCJmaXJzdExldmVsQml0cmF0ZSIsInN0YXJ0aW5nQndFc3RpbWF0ZSIsImF1ZGlvT25seSIsImVkYXRhIiwiZm9yY2VTdGFydExvYWQiLCJuZXdMZXZlbCIsImxhc3RMZXZlbEluZGV4IiwibGFzdExldmVsIiwibGFzdFBhdGh3YXlJZCIsImxldmVsU3dpdGNoaW5nRGF0YSIsIm1hbnVhbExldmVsIiwiY29uZmlnU3RhcnRMZXZlbCIsIl9kYXRhJGRlbGl2ZXJ5RGlyZWN0aTIiLCJfZGF0YSRkZWxpdmVyeURpcmVjdGkiLCJfdGhpcyRjdXJyZW50TGV2ZWwiLCJjaGVja01heEF1dG9VcGRhdGVkIiwiS2V5TG9hZGVyIiwia2V5VXJpVG9LZXlJbmZvIiwiX2xvYWRlciRjb250ZXh0IiwiY3JlYXRlS2V5TG9hZEVycm9yIiwibG9hZGluZ0ZyYWciLCJfa2V5SW5mbyIsIl9rZXlJbmZvMiIsImtleUxvYWRQcm9taXNlIiwiX2tleUluZm8kbWVkaWFLZXlTZXNzIiwibG9hZEtleUhUVFAiLCJsb2FkS2V5RU1FIiwiZ2V0U291cmNlQnVmZmVyIiwiU291cmNlQnVmZmVyIiwiV2ViS2l0U291cmNlQnVmZmVyIiwiaXNNU0VTdXBwb3J0ZWQiLCJjb2RlY3NGb3JWaWRlb0NvbnRhaW5lciIsImNvZGVjRm9yQXVkaW9Db250YWluZXIiLCJjaGFuZ2VUeXBlU3VwcG9ydGVkIiwiX3NvdXJjZUJ1ZmZlciRwcm90b3R5IiwiU1RBTExfTUlOSU1VTV9EVVJBVElPTl9NUyIsIk1BWF9TVEFSVF9HQVBfSlVNUCIsIlNLSVBfQlVGRkVSX0hPTEVfU1RFUF9TRUNPTkRTIiwiU0tJUF9CVUZGRVJfUkFOR0VfU1RBUlQiLCJHYXBDb250cm9sbGVyIiwibnVkZ2VSZXRyeSIsInN0YWxsUmVwb3J0ZWQiLCJzdGFsbGVkIiwibW92ZWQiLCJwb2xsIiwiYWN0aXZlRnJhZyIsInNlZWtlZCIsImJlZ2luU2VlayIsIl9zdGFsbGVkRHVyYXRpb24iLCJoYXNFbm91Z2hCdWZmZXIiLCJub0J1ZmZlckdhcCIsInN0YXJ0SnVtcCIsImlzTGl2ZSIsIm1heFN0YXJ0R2FwSnVtcCIsInBhcnRpYWxPckdhcCIsIl90cnlTa2lwQnVmZmVySG9sZSIsInRub3ciLCJzdGFsbGVkRHVyYXRpb24iLCJfcmVwb3J0U3RhbGwiLCJidWZmZXJlZFdpdGhIb2xlcyIsIl90cnlGaXhCdWZmZXJTdGFsbCIsInN0YWxsZWREdXJhdGlvbk1zIiwidGFyZ2V0VGltZSIsIl90cnlOdWRnZUJ1ZmZlciIsImJ1ZmZlclN0YXJ2ZWQiLCJ3YWl0aW5nIiwiZ2FwTGVuZ3RoIiwic3RhcnRHYXAiLCJzdGFydEZyYWciLCJzdGFydFByb3Zpc2lvbmVkIiwibW9yZVRvTG9hZCIsInByb3Zpc2lvbmVkIiwiVElDS19JTlRFUlZBTCIsIlN0cmVhbUNvbnRyb2xsZXIiLCJhdWRpb0NvZGVjU3dhcCIsImdhcENvbnRyb2xsZXIiLCJfZm9yY2VTdGFydExvYWQiLCJmcmFnUGxheWluZyIsIm9udnBsYXlpbmciLCJvbnZzZWVrZWQiLCJmcmFnTGFzdEticHMiLCJjb3VsZEJhY2t0cmFjayIsImJhY2t0cmFja0ZyYWdtZW50IiwiYXVkaW9Db2RlY1N3aXRjaCIsIm9uRnJhZ0xvYWRFbWVyZ2VuY3lBYm9ydGVkIiwib25BdWRpb1RyYWNrU3dpdGNoZWQiLCJjaGVja0J1ZmZlciIsImNoZWNrRnJhZ21lbnRDaGFuZ2VkIiwiZ2V0TWFpbkZ3ZEJ1ZmZlckluZm8iLCJsYXN0RGV0YWlscyIsIl90aGlzJGJhY2t0cmFja0ZyYWdtZSIsImJhY2t0cmFja1NuIiwiYmFja3RyYWNrRnJhZyIsIl9sb2FkQml0cmF0ZVRlc3RGcmFnIiwiZm9sbG93aW5nQnVmZmVyZWRGcmFnIiwiaW1tZWRpYXRlTGV2ZWxTd2l0Y2giLCJhYm9ydEN1cnJlbnRGcmFnIiwiZmV0Y2hkZWxheSIsImZyYWdQbGF5aW5nQ3VycmVudCIsIm5leHRMZXZlbElkIiwiYnVmZmVyZWRGcmFnIiwibmV4dEJ1ZmZlcmVkRnJhZyIsIm1heFN0YXJ0Iiwic3RhcnRQdHMiLCJvbk1lZGlhUGxheWluZyIsIm9uTWVkaWFTZWVrZWQiLCJhYWMiLCJoZWFhYyIsIl9jdXJMZXZlbCRkZXRhaWxzIiwibmV3TGV2ZWxJZCIsIl9nZXRBdWRpb0NvZGVjIiwiZnJvbUFsdEF1ZGlvIiwibWVkaWFUcmFjayIsImFsdGVybmF0ZSIsInN3YXBBdWRpb0NvZGVjIiwiaXNGaXJzdEZyYWdtZW50IiwiaXNGaXJzdEluRGlzY29udGludWl0eSIsImJhY2t0cmFjayIsInVhIiwiZnJhZ0N1cnJlbnRMZXZlbCIsIkxFVkVMX1NXSVRDSEVEIiwiY3VycmVudEZyYWciLCJjdXJyZW50UHJvZ3JhbURhdGVUaW1lIiwiZXBvY01zIiwiSGxzIiwiRGVmYXVsdENvbmZpZyIsImNvcmVDb21wb25lbnRzIiwibmV0d29ya0NvbnRyb2xsZXJzIiwiX2VtaXR0ZXIiLCJfYXV0b0xldmVsQ2FwcGluZyIsIl9tYXhIZGNwTGV2ZWwiLCJsYXRlbmN5Q29udHJvbGxlciIsImxldmVsQ29udHJvbGxlciIsIl9tZWRpYSIsInRyaWdnZXJpbmdFeGNlcHRpb24iLCJDb25maWdBYnJDb250cm9sbGVyIiwiQ29uZmlnQnVmZmVyQ29udHJvbGxlciIsIkNvbmZpZ0NhcExldmVsQ29udHJvbGxlciIsIkNvbmZpZ0Vycm9yQ29udHJvbGxlciIsIkNvbmZpZ0Zwc0NvbnRyb2xsZXIiLCJwbGF5TGlzdExvYWRlciIsImlkM1RyYWNrQ29udHJvbGxlciIsIkNvbmZpZ0NvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXIiLCJjcmVhdGVDb250cm9sbGVyIiwiQXVkaW9TdHJlYW1Db250cm9sbGVyQ2xhc3MiLCJTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXJDbGFzcyIsIkNvbnRyb2xsZXJDbGFzcyIsImNvbXBvbmVudHMiLCJjb250cm9sbGVySW5zdGFuY2UiLCJldmVudE9iamVjdCIsIkRFU1RST1lJTkciLCJkZXRhY2hNZWRpYSIsImNvbXBvbmVudCIsImF0dGFjaE1lZGlhIiwibG9hZFNvdXJjZSIsImxvYWRlZFNvdXJjZSIsImxvYWRpbmdTb3VyY2UiLCJzaG91bGRTdGFydENhcHBpbmciLCJuZXdDYXBMZXZlbFRvUGxheWVyU2l6ZSIsInBsYXlpbmdEYXRlIiwiX3RoaXMkYXVkaW9UcmFja0NvbnRyIiwiX3RoaXMkc3VidGl0bGVUcmFja0NvIiwiYXVkaW9UcmFja0lkIiwic3VidGl0bGVUcmFja0lkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/hls.js/dist/hls.mjs\n");

/***/ })

};
;